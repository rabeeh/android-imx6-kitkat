From bf1da1a5f535dcdd749400475d0f037ec076db42 Mon Sep 17 00:00:00 2001
From: Nitin Garg <nitin.garg@freescale.com>
Date: Sun, 5 Feb 2012 12:17:28 -0600
Subject: [PATCH 231/486] ENGR00173825: Add hwcomposer, gralloc and camera for
 mx53 smd ICS

Add hwcomposer, gralloc and camera for mx53 smd ICS.

Signed-off-by: Nitin Garg <nitin.garg@freescale.com>
---
 mx5x/hwcomposer/Android.mk                |    2 +-
 mx5x/hwcomposer/BG_device.cpp             |   26 +-
 mx5x/hwcomposer/FG_device.cpp             |   36 +-
 mx5x/hwcomposer/blit_ipu.cpp              |  361 +++-----
 mx5x/hwcomposer/blit_ipu.h                |   34 +-
 mx5x/hwcomposer/hwc_common.cpp            |   28 +-
 mx5x/hwcomposer/hwc_common.h              |   18 +-
 mx5x/hwcomposer/hwcomposer.cpp            |  359 +++++---
 mx5x/libcamera/Android.mk                 |   38 +-
 mx5x/libcamera/CameraHal.cpp              | 1326 +++++++++++++++++++----------
 mx5x/libcamera/CameraHal.h                |  141 ++-
 mx5x/libcamera/CameraModule.cpp           |  711 ++++++++++++++++
 mx5x/libcamera/Camera_utils.h             |    8 +-
 mx5x/libcamera/CaptureDeviceInterface.cpp |    4 +-
 mx5x/libcamera/CaptureDeviceInterface.h   |   11 +-
 mx5x/libcamera/V4l2CapDeviceBase.cpp      |   43 +-
 mx5x/libcamera/V4l2CapDeviceBase.h        |    4 +-
 mx5x/libcamera/V4l2CsiDevice.cpp          |   70 +-
 mx5x/libcamera/V4l2CsiDevice.h            |    5 +-
 mx5x/libcamera/V4l2UVCDevice.h            |    4 +-
 mx5x/libcamera/messageQueue.cpp           |  167 ++++
 mx5x/libcamera/messageQueue.h             |  104 +++
 mx5x/libgralloc/framebuffer.cpp           |  218 +++--
 mx5x/libgralloc/gralloc.cpp               |   25 +-
 mx5x/libgralloc/gralloc_priv.h            |    3 +-
 mx5x/libgralloc/mapper.cpp                |   35 +-
 26 files changed, 2647 insertions(+), 1134 deletions(-)
 create mode 100644 mx5x/libcamera/CameraModule.cpp
 create mode 100644 mx5x/libcamera/messageQueue.cpp
 create mode 100644 mx5x/libcamera/messageQueue.h

diff --git a/mx5x/hwcomposer/Android.mk b/mx5x/hwcomposer/Android.mk
index 4939d3e..8c3211f 100755
--- a/mx5x/hwcomposer/Android.mk
+++ b/mx5x/hwcomposer/Android.mk
@@ -20,7 +20,7 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 LOCAL_PRELINK_MODULE := false
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libEGL libipu libcutils libutils libui
+LOCAL_SHARED_LIBRARIES := liblog libEGL libipu libcutils libutils libui libhardware
 LOCAL_SRC_FILES := hwcomposer.cpp BG_device.cpp FG_device.cpp hwc_common.cpp blit_gpu.cpp blit_ipu.cpp output_device.cpp
 LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
 LOCAL_C_INCLUDES += hardware/imx/mx5x/libgralloc
diff --git a/mx5x/hwcomposer/BG_device.cpp b/mx5x/hwcomposer/BG_device.cpp
index 7f1be64..a920e23 100755
--- a/mx5x/hwcomposer/BG_device.cpp
+++ b/mx5x/hwcomposer/BG_device.cpp
@@ -12,13 +12,13 @@
  * limitations under the License.
  */
 
-/* Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #include <sys/mman.h>
 #include <sys/ioctl.h>
 #include <hardware/hardware.h>
 //#include <hardware/overlay.h>
-#include <cutils/properties.h>
+
 #include <fcntl.h>
 #include <errno.h>
 
@@ -83,10 +83,20 @@ int BG_device::init()
   	
   	info.bits_per_pixel = fmt_to_bpp(m_format);
   	info.nonstd = m_format;
-
+  	info.red.offset = 0;
+  	info.red.length = 0;
+  	info.green.offset = 0;
+  	info.green.length = 0;
+  	info.blue.offset = 0;
+  	info.blue.length = 0;
+  	info.transp.offset = 0;
+  	info.transp.length = 0;	 
+  	
+  	info.xres = m_width;
+  	info.yres = m_height;
   	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
   	info.xres_virtual = ALIGN_PIXEL(info.xres);
-
+  	
     if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
     	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO setting failed!");
     	  return -1;    	  
@@ -151,18 +161,12 @@ int BG_device::uninit()
 {
 	  //int status = -EINVAL;    
     int blank = 1;
-    char value[10];
     HWCOMPOSER_LOG_RUNTIME("---------------BG_device::uninit()------------");
 
     if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
 	    HWCOMPOSER_LOG_ERR("Error!BG_device::uninit BLANK FB2 failed!\n");
         //return -1;
-    }
-    property_get("media.VIDEO_PLAYING", value, "0");
-    if (strcmp(value, "0") == 0) {
-        blank = 0;
-        ioctl(m_dev, FBIOBLANK, blank);
-    }
+    }	  
     munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
     close(m_dev);
 
diff --git a/mx5x/hwcomposer/FG_device.cpp b/mx5x/hwcomposer/FG_device.cpp
index 4e2ed49..4d07459 100755
--- a/mx5x/hwcomposer/FG_device.cpp
+++ b/mx5x/hwcomposer/FG_device.cpp
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-/* Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #include <hardware/hardware.h>
 
@@ -158,7 +158,7 @@ int FG_device::init()
     int status = -EINVAL;
     int fbSize = 0;
     void *vaddr = NULL;
-HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
+    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
     if(m_dev <= 0) {
         HWCOMPOSER_LOG_ERR("Error! FG_device::FG_init() invalid parameter!");
         return -1;
@@ -167,33 +167,26 @@ HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
     //fist open fb0 device that it is binded to.
     //it may be modified in mx6x
     int fd_def = -1;
-    int fd_fb1 = -1;
     if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
+            HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
 	    fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
 	    if(fd_def < 0) {
 	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
 	    	  return -1;
 	    }
-			fd_fb1 = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_fb1 < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
-	    	  return -1;
-	    }
-
-  	}
-    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-	    fd_def = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+    }
+    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) {
+            HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb2-------------");
+	    fd_def = open(FB2_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
 	    if(fd_def < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB2_DEV_NAME);
 	    	  return -1;
 	    }
-			fd_fb1 = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_fb1 < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
-	    	  return -1;
-	    }
-  	}
+    }
+    else {
+         HWCOMPOSER_LOG_ERR("Error! %s does not support usage=0x%x!", __FUNCTION__, m_usage);
+         return -1;
+    }
   	//it may be modified in mx6x
 
 //    status = overlay_switch(fd_def, fd_fb1, m_dev, m_usage);
@@ -222,8 +215,6 @@ HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------")
     	  return -1;
     }
 
-   // m_left = 0;
-   // m_top = 0;
     m_width = def_info.xres;//info.xres;
     m_height = def_info.yres;//info.yres;
     m_format = fourcc('U', 'Y', 'V', 'Y');
@@ -287,7 +278,6 @@ HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------")
   	//do it after switch fb2 to fb1 or fb0
   	//status = switch_set(fd_def, fd_fb1, m_usage);
   	close(fd_def);
-  	close(fd_fb1);
 
   	mbuffer_count = DEFAULT_BUFFERS;
   	mbuffer_cur = 0;
diff --git a/mx5x/hwcomposer/blit_ipu.cpp b/mx5x/hwcomposer/blit_ipu.cpp
index 8bb8795..34afcc2 100755
--- a/mx5x/hwcomposer/blit_ipu.cpp
+++ b/mx5x/hwcomposer/blit_ipu.cpp
@@ -12,16 +12,13 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 
 #include <hardware/hardware.h>
 
 #include <fcntl.h>
 #include <errno.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
 
 #include <cutils/log.h>
 #include <cutils/atomic.h>
@@ -29,17 +26,10 @@
 
 #include <hardware/hwcomposer.h>
 
-#include <linux/android_pmem.h>
-
 #include <EGL/egl.h>
 #include "gralloc_priv.h"
 #include "hwc_common.h"
 #include "blit_ipu.h"
-extern "C" {
-#include "mxc_ipu_hl_lib.h"
-}
-
-#define PMEMDEV    "/dev/pmem_adsp"
 
 /*****************************************************************************/
 using namespace android;
@@ -56,33 +46,34 @@ int blit_device::isGPUDevice(const char *dev_name)
 
 blit_ipu::blit_ipu()
 {
-		init();
+    memset(&mTask, 0, sizeof(mTask));
+	init();
 }
 
 blit_ipu::~blit_ipu()
 {
-		uninit();
+	uninit();
 }
 
 int blit_ipu::init()//, hwc_layer_t *layer, struct output_device *output
 {
-		//int status = -EINVAL;
+	int status = -EINVAL;
+    mIpuFd = open("/dev/mxc_ipu", O_RDWR, 0);
+    if(mIpuFd < 0) {
+        HWCOMPOSER_LOG_ERR("%s:%d,open ipu dev failed", __FUNCTION__, __LINE__);
+        return status;
+    }
 
     return 0;
 }
 
 int blit_ipu::uninit()
 {
-	  //int status = -EINVAL;
-    //Free the phy rotation buffer 
-    if(mRotPhyBuffer != 0){
-       returnPmemBuffer(mRotVirBuffer, mRotSize);
-       mRotSize = 0;
-       mRotVirBuffer = NULL;
-       mRotPhyBuffer = 0;
-    }
+	//int status = -EINVAL;
+    if(mIpuFd)
+        close(mIpuFd);
 
-    return 0;
+	return 0;
 }
 
 static void fill_buffer(char *pbuf, int len)
@@ -109,127 +100,125 @@ static void fill_buffer(char *pbuf, int len)
 
     k = (k+1)%3;
 }
-//#define FSL_CAMERAHAL_DUMP
-static void blit_dump(char *pBufs, int len)
+
+static void dump_ipu_task(struct ipu_task *t)
 {
-#ifdef FSL_CAMERAHAL_DUMP
-            //for test code
-            char value[10] = {0};
-            static int vflg = 0;
-            property_get("rw.blit.test", value, "");
-            if(strcmp(value, "1") == 0) {
-                vflg = 1;
-                property_set("rw.blit.test", "0");
-            }
-            if(vflg){
-                HWCOMPOSER_LOG_ERR("-----------dump-----------");
-                FILE *pf = NULL;
-                pf = fopen("/sdcard/blit_dump.data", "wb");
-                if(pf == NULL) {
-                    HWCOMPOSER_LOG_ERR("open /sdcard/camera_tst.data failed");
-                }
-                else {
-                    fwrite(pBufs, len, 1, pf);
-                    fclose(pf);
-                }
-                vflg = 0;
-            }
-#endif
+    HWCOMPOSER_LOG_ERR("======ipu task=====");
+    HWCOMPOSER_LOG_ERR("input:");
+    HWCOMPOSER_LOG_ERR("\tbuffer: %d", t->input.paddr);
+    HWCOMPOSER_LOG_ERR("\twidth: %d", t->input.width);
+    HWCOMPOSER_LOG_ERR("\theight: %d", t->input.height);
+    HWCOMPOSER_LOG_ERR("\tcrop.w =%d", t->input.crop.w);
+    HWCOMPOSER_LOG_ERR("\tcrop.h =%d", t->input.crop.h);
+    HWCOMPOSER_LOG_ERR("\tcrop.pos.x =%d", t->input.crop.pos.x);
+    HWCOMPOSER_LOG_ERR("\tcrop.pos.y =%d", t->input.crop.pos.y);
+    HWCOMPOSER_LOG_ERR("output:");
+    HWCOMPOSER_LOG_ERR("\twidth: %d", t->output.width);
+    HWCOMPOSER_LOG_ERR("\theight: %d", t->output.height);
+    HWCOMPOSER_LOG_ERR("\tcrop.w =%d", t->output.crop.w);
+    HWCOMPOSER_LOG_ERR("\tcrop.h =%d", t->output.crop.h);
+    HWCOMPOSER_LOG_ERR("\tcrop.pos.x =%d", t->output.crop.pos.x);
+    HWCOMPOSER_LOG_ERR("\tcrop.pos.y =%d", t->output.crop.pos.y);
 }
 
 int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
 {
 	  int status = -EINVAL;
-	  if(layer == NULL || out_buf == NULL){
+          char value[10];
+          int hdmi_full_screen = 0;
+	  if(mIpuFd < 0 || layer == NULL || out_buf == NULL){
 	  	  HWCOMPOSER_LOG_ERR("Error!invalid parameters!");
 	  	  return status;
 	  }
 	  //struct blit_ipu *ipu = (struct blit_ipu *)dev;
 
-      HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^^^^^^^^^^^^^^^^^^^^^");
+      HWCOMPOSER_LOG_RUNTIME("%s start", __FUNCTION__);
 	  hwc_rect_t *src_crop = &(layer->sourceCrop);
 	  hwc_rect_t *disp_frame = &(layer->displayFrame);
 	  private_handle_t *handle = (private_handle_t *)(layer->handle);
 
     //fill_buffer((char *)(handle->base), handle->size);
 
-	mIPUInputParam.width = handle->width;//src_crop->right - src_crop->left;
-	mIPUInputParam.height = handle->height;//src_crop->bottom - src_crop->top;
-	mIPUInputParam.input_crop_win.pos.x = src_crop->left;
-    mIPUInputParam.input_crop_win.pos.y = src_crop->top;
-    mIPUInputParam.input_crop_win.win_w = src_crop->right - src_crop->left;
-    mIPUInputParam.input_crop_win.win_h = src_crop->bottom - src_crop->top;
+    mTask.input.width = handle->width;//src_crop->right - src_crop->left;
+    mTask.input.height = handle->height;//src_crop->bottom - src_crop->top;
+    mTask.input.crop.pos.x = src_crop->left;
+    mTask.input.crop.pos.y = src_crop->top;
+    mTask.input.crop.w = src_crop->right - src_crop->left;
+    mTask.input.crop.h = src_crop->bottom - src_crop->top;
 
     if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_SP) {
-        HWCOMPOSER_LOG_RUNTIME("handle->format= NV12");
-        mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
+        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= NV12", __FUNCTION__);
+        mTask.input.format = v4l2_fourcc('N', 'V', '1', '2');
     }
     else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_420_I) {
-        HWCOMPOSER_LOG_RUNTIME("handle->format= I420");
-        mIPUInputParam.fmt = v4l2_fourcc('I', '4', '2', '0');
+        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= I420", __FUNCTION__);
+        mTask.input.format = v4l2_fourcc('I', '4', '2', '0');
     }
     else if(handle->format == HAL_PIXEL_FORMAT_YCbCr_422_I) {
-        HWCOMPOSER_LOG_RUNTIME("handle->format= 422P");
-        mIPUInputParam.fmt = v4l2_fourcc('4', '2', '2','P');
+        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= 422P", __FUNCTION__);
+        mTask.input.format = v4l2_fourcc('4', '2', '2','P');
     } else if (handle->format == HAL_PIXEL_FORMAT_YV12) {
-        HWCOMPOSER_LOG_RUNTIME("handle->format= 422P");
-        mIPUInputParam.fmt = v4l2_fourcc('Y', 'V', '1','2');
+        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= 422P", __FUNCTION__);
+        mTask.input.format = v4l2_fourcc('Y', 'V', '1','2');
     }
     else if((handle->format == HAL_PIXEL_FORMAT_RGB_565) || (handle->format == BLIT_PIXEL_FORMAT_RGB_565)) {
-        HWCOMPOSER_LOG_RUNTIME("handle->format= RGBP");
-        mIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
+        HWCOMPOSER_LOG_RUNTIME("%s, handle->format= RGBP", __FUNCTION__);
+        mTask.input.format = v4l2_fourcc('R', 'G', 'B', 'P');
         //mIPUInputParam.fmt = v4l2_fourcc('N', 'V', '1', '2');
     }else{
-        HWCOMPOSER_LOG_ERR("Error!Not supported input format %d",handle->format);
+        HWCOMPOSER_LOG_ERR("%s, Error!Not supported input format %d", __FUNCTION__, handle->format);
         return status;
     }
-#if 0
-    if(handle->base != 0) {
-       int *pVal = (int *)handle->base;
-       HWCOMPOSER_LOG_RUNTIME("=========buff[%d]=%x, buff[%d]=%x, phy=%x", 0, pVal[0], 1, pVal[1], handle->phys);
-    }
-#endif
-    mIPUInputParam.user_def_paddr[0] = handle->phys;
+
+    mTask.input.paddr = handle->phys;
     //out_buf should has width and height to be checked with the display_frame.
-//HWCOMPOSER_LOG_ERR("^^^^^^^^in^^paddr=%x^^^^^^left=%d, top=%d, right=%d, bottom=%d", handle->phys, src_crop->left, src_crop->top, src_crop->right, src_crop->bottom);
-    mIPUOutputParam.fmt = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
-    mIPUOutputParam.show_to_fb = 0;
-//HWCOMPOSER_LOG_RUNTIME("^^^^^^^^out_buf->format= %x, out->phy_addr=%x, in->phys=%x", out_buf->format, out_buf->phy_addr, handle->phys);
-    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK) {
-	    mIPUOutputParam.width = out_buf->width;
-	    mIPUOutputParam.height = out_buf->height;
-		mIPUOutputParam.output_win.pos.x = 0;
-		mIPUOutputParam.output_win.pos.y = 0;
-		mIPUOutputParam.output_win.win_w = out_buf->width;
-		mIPUOutputParam.output_win.win_h = out_buf->height;
+    mTask.output.format = out_buf->format;//v4l2_fourcc('U', 'Y', 'V', 'Y');
+
+    property_get("sys.HDMI_FULL_SCREEN", value, "");
+    if(strcmp(value, "1") == 0) {
+        hdmi_full_screen = 1;
+    }
+    else {
+        hdmi_full_screen = 0;
     }
-    else if((out_buf->usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) && (out_buf->width != m_def_disp_w || out_buf->height!= m_def_disp_h)){
+
+    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK || (hdmi_full_screen && 
+                        (out_buf->usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2))) { 
+	    mTask.output.width = out_buf->width;
+	    mTask.output.height = out_buf->height;
+	    mTask.output.crop.pos.x = 0;
+	    mTask.output.crop.pos.y = 0;
+	    mTask.output.crop.w = out_buf->width;
+	    mTask.output.crop.h = out_buf->height;
+    }
+    else if((out_buf->usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) && 
+               (out_buf->width != m_def_disp_w || out_buf->height!= m_def_disp_h)){
             int def_w,def_h;
             int dst_w = out_buf->width;
             int dst_h = out_buf->height;
 
-            mIPUOutputParam.width = out_buf->width;//disp_frame->right - disp_frame->left;
-            mIPUOutputParam.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
+            mTask.output.width = out_buf->width;//disp_frame->right - disp_frame->left;
+            mTask.output.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
 
             if(layer->transform == 0 || layer->transform == 3)
             {
                  def_w = m_def_disp_w;
                  def_h = m_def_disp_h;
 
-                 mIPUOutputParam.output_win.pos.x = (disp_frame->left >> 3) << 3;
-                 mIPUOutputParam.output_win.pos.y = (disp_frame->top >> 3) << 3;
-                 mIPUOutputParam.output_win.win_w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-                 mIPUOutputParam.output_win.win_h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
+                 mTask.output.crop.pos.x = (disp_frame->left >> 3) << 3;
+                 mTask.output.crop.pos.y = (disp_frame->top >> 3) << 3;
+                 mTask.output.crop.w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
+                 mTask.output.crop.h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
             }
             else
             {
                  def_w = m_def_disp_h;
                  def_h = m_def_disp_w;
 
-                 mIPUOutputParam.output_win.pos.y = (disp_frame->left >> 3) << 3;
-                 mIPUOutputParam.output_win.pos.x = (disp_frame->top >> 3) << 3;
-                 mIPUOutputParam.output_win.win_h = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-                 mIPUOutputParam.output_win.win_w = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
+                 mTask.output.crop.pos.y = (disp_frame->left >> 3) << 3;
+                 mTask.output.crop.pos.x = (disp_frame->top >> 3) << 3;
+                 mTask.output.crop.h = ((disp_frame->right - disp_frame->left) >> 3) << 3;
+                 mTask.output.crop.w = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
              }
              if(dst_w >= dst_h*def_w/def_h){
                  dst_w = dst_h*def_w/def_h;
@@ -238,138 +227,68 @@ int blit_ipu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
                  dst_h = dst_w*def_h/def_w;
              }
 
-            mIPUOutputParam.output_win.pos.x = mIPUOutputParam.output_win.pos.x * dst_w / def_w;
-            mIPUOutputParam.output_win.pos.y = mIPUOutputParam.output_win.pos.y * dst_h / def_h;
-            mIPUOutputParam.output_win.win_w = mIPUOutputParam.output_win.win_w * dst_w / def_w;
-            mIPUOutputParam.output_win.win_h = mIPUOutputParam.output_win.win_h * dst_h / def_h;
-            mIPUOutputParam.output_win.pos.x += (out_buf->width - dst_w) >> 1;
-            mIPUOutputParam.output_win.pos.y += (out_buf->height - dst_h) >> 1;
-
-            mIPUOutputParam.output_win.pos.x = (mIPUOutputParam.output_win.pos.x >> 3) << 3;
-            mIPUOutputParam.output_win.pos.y = (mIPUOutputParam.output_win.pos.y >> 3) << 3;
-            mIPUOutputParam.output_win.win_w = (mIPUOutputParam.output_win.win_w >> 3) << 3;
-            mIPUOutputParam.output_win.win_h = (mIPUOutputParam.output_win.win_h >> 3) << 3;
+            mTask.output.crop.pos.x = mTask.output.crop.pos.x * dst_w / def_w;
+            mTask.output.crop.pos.y = mTask.output.crop.pos.y * dst_h / def_h;
+            mTask.output.crop.w = mTask.output.crop.w * dst_w / def_w;
+            mTask.output.crop.h = mTask.output.crop.h * dst_h / def_h;
+            mTask.output.crop.pos.x += (out_buf->width - dst_w) >> 1;
+            mTask.output.crop.pos.y += (out_buf->height - dst_h) >> 1;
+
+            mTask.output.crop.pos.x = (mTask.output.crop.pos.x >> 3) << 3;
+            mTask.output.crop.pos.y = (mTask.output.crop.pos.y >> 3) << 3;
+            mTask.output.crop.w = (mTask.output.crop.w >> 3) << 3;
+            mTask.output.crop.h = (mTask.output.crop.h >> 3) << 3;
+            mTask.output.rotate = layer->transform;
     }
     else {
-	    mIPUOutputParam.width = out_buf->width;//disp_frame->right - disp_frame->left;
-	    mIPUOutputParam.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
-	    mIPUOutputParam.output_win.pos.x = (disp_frame->left >> 3) << 3;
-	    mIPUOutputParam.output_win.pos.y = (disp_frame->top >> 3) << 3;
-	    mIPUOutputParam.output_win.win_w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
-	    mIPUOutputParam.output_win.win_h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
-  	}
-
-//HWCOMPOSER_LOG_ERR("^^^^^^^^out^^paddr=%x^^^^^^left=%d, top=%d, right=%d, bottom=%d", out_buf->phy_addr, disp_frame->left, disp_frame->top, disp_frame->right, disp_frame->bottom);
-    mIPUOutputParam.rot = layer->transform;
-    if(out_buf->usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) mIPUOutputParam.rot = 0;
-
-    //If there is a rotation need, we need allocate a rotation buffer for ipu usage
-    //IPU lib support internal allocation for this buffer
-    //to avoid the usage of dma buffer, we allocate externally
-    if(mIPUOutputParam.rot != 0){
-        int rotPhySize = mIPUOutputParam.width*mIPUOutputParam.height*fmt_to_bpp(mIPUOutputParam.fmt)/8;
-        rotPhySize = (rotPhySize + getpagesize()-1) & ~(getpagesize()-1);
-        if(rotPhySize != mRotSize){
-            //Free the phy buffer firstly
-            if(mRotPhyBuffer != 0){
-                returnPmemBuffer(mRotVirBuffer, mRotSize);
-                mRotSize = 0;
-                mRotVirBuffer = NULL;
-                mRotPhyBuffer = 0;
-
-            }
-
-            if(getPmemBuffer(rotPhySize, &mRotVirBuffer, &mRotPhyBuffer) >= 0){
-                HWCOMPOSER_LOG_INFO("getPmemBuffer: 0x%p, 0x%x", mRotVirBuffer, mRotPhyBuffer);
-                mRotSize = rotPhySize;
-            }
-            else{
-                mRotSize = 0;
-                mRotVirBuffer = NULL;
-                mRotPhyBuffer = 0;
-            }
-        }
-
-        //set the buffer to ipu handle
-        if((mRotSize != 0)&&(mRotPhyBuffer != 0)){
-           mIPUHandle.rotbuf_phy_start[0] = (void *)mRotPhyBuffer; 
-           mIPUHandle.rotfr_size = mRotSize;
+	    mTask.output.width = out_buf->width;//disp_frame->right - disp_frame->left;
+	    mTask.output.height = out_buf->height;//disp_frame->bottom - disp_frame->top;
+	    mTask.output.crop.pos.x = (disp_frame->left >> 3) << 3;
+	    mTask.output.crop.pos.y = (disp_frame->top >> 3) << 3;
+	    mTask.output.crop.w = ((disp_frame->right - disp_frame->left) >> 3) << 3;
+	    mTask.output.crop.h = ((disp_frame->bottom - disp_frame->top) >> 3) << 3;
+            mTask.output.rotate = layer->transform;
+    }
+    //mTask.output.rotate = layer->transform;
+    mTask.output.paddr = out_buf->phy_addr;
+    int ret = IPU_CHECK_ERR_INPUT_CROP; 
+    
+    while(ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN) {
+        ret = ioctl(mIpuFd, IPU_CHECK_TASK, &mTask);
+        HWCOMPOSER_LOG_RUNTIME("%s:%d, IPU_CHECK_TASK ret=%d", __FUNCTION__, __LINE__, ret);
+        //dump_ipu_task(&mTask);
+        switch(ret) {
+            case IPU_CHECK_OK:
+                break;
+            case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
+                mTask.input.crop.w -= 8;
+                break;
+            case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
+                mTask.input.crop.h -= 8;
+                break;
+            case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
+                mTask.output.crop.w -= 8;
+                break;
+            case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
+                mTask.output.crop.h -= 8;;
+                break;
+            default:
+                //dump_ipu_task(&mTask);
+                HWCOMPOSER_LOG_ERR("%s:%d, IPU_CHECK_TASK ret=%d", __FUNCTION__, __LINE__, ret);
+                return status;
         }
     }
 
-    mIPUOutputParam.user_def_paddr[0] = out_buf->phy_addr;
-    blit_dump((char *)(handle->base), handle->size);
-HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_init-----in blit_ipu::blit()------\n");
-    if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
-        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
-    else
-        status = mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
-	  if(status < 0) {
-	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_init failed %d",status);
-	  		return status;
-	  }
-HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_buf_update-----in blit_ipu::blit()------\n");
-	  status = mxc_ipu_lib_task_buf_update(&mIPUHandle, handle->phys, out_buf->phy_addr, NULL,NULL,NULL);
+    //if(out_buf->usage & GRALLOC_USAGE_DISPLAY_MASK)
+        //status = mxc_ipu_lib_task_init(&mTask.input,NULL,&mTask.output,OP_NORMAL_MODE|TASK_PP_MODE,&mIPUHandle);
+    //else
+        //status = mxc_ipu_lib_task_init(&mTask.input,NULL,&mTask.output,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+      status = ioctl(mIpuFd, IPU_QUEUE_TASK, &mTask);
 	  if(status < 0) {
-	  		HWCOMPOSER_LOG_ERR("Error!mxc_ipu_lib_task_buf_update failed %d",status);
+	  		HWCOMPOSER_LOG_ERR("%s:%d, IPU_QUEUE_TASK failed %d", __FUNCTION__, __LINE__ ,status);
 	  		return status;
 	  }
-HWCOMPOSER_LOG_RUNTIME("------mxc_ipu_lib_task_uninit-----in blit_ipu::blit()------\n");
-		mxc_ipu_lib_task_uninit(&mIPUHandle);
-		status = 0;
-        HWCOMPOSER_LOG_RUNTIME("^^^^^^^^^^^^^^^blit_ipu::blit()^^end^^^^^^^^^^^^^^^^^^^^");
+	  status = 0;
+      HWCOMPOSER_LOG_RUNTIME("%s end", __FUNCTION__);
 	  return status;
 }
-
-int blit_ipu::getPmemBuffer(int size, void **ppVirBuffer, unsigned int *phyBuffer)
-{
-    int ret;
-    int fd_pmem = 0;
-    struct pmem_region region;
-
-    fd_pmem = open(PMEMDEV, O_RDWR, 0);
-    if(fd_pmem < 0) {
-        HWCOMPOSER_LOG_ERR("Error!Cannot open pmem fd for getPmemBuffer");
-        return -1;
-    }
-    
-    ret = ioctl(fd_pmem, PMEM_GET_TOTAL_SIZE, &region);
-    if (ret < 0) {
-        HWCOMPOSER_LOG_ERR("Cannot get PMEM total size!");
-        close(fd_pmem);
-        return -1;
-    }
-
-    if (region.len <= 0) {
-        HWCOMPOSER_LOG_ERR("PMEM total size smaller than zero!");
-        close(fd_pmem);
-        return -1;
-    }
-
-    *ppVirBuffer = mmap(0, size,
-            PROT_READ|PROT_WRITE, MAP_SHARED, fd_pmem, 0);
-
-    if (*ppVirBuffer == MAP_FAILED) {
-        HWCOMPOSER_LOG_ERR("Error!cannot map the pmem buffer");
-        close(fd_pmem);
-        return -1;
-    }
-
-    memset(&region, 0, sizeof(region));
-    if (ioctl(fd_pmem, PMEM_GET_PHYS, &region) == -1) {
-        munmap(*ppVirBuffer, size);
-        HWCOMPOSER_LOG_ERR("Error!cannot map the pmem buffer"); 
-        close(fd_pmem);
-        return -1;
-    }
-    *phyBuffer = (unsigned long)region.offset;
-    close(fd_pmem); 
-    return 0;
-}
-
-int blit_ipu::returnPmemBuffer(void *pVirBuffer, unsigned int size)
-{
-    munmap(pVirBuffer, size); 
-    return 0;
-}
-
diff --git a/mx5x/hwcomposer/blit_ipu.h b/mx5x/hwcomposer/blit_ipu.h
index e870d7b..8eae6b0 100755
--- a/mx5x/hwcomposer/blit_ipu.h
+++ b/mx5x/hwcomposer/blit_ipu.h
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved. */
 
 #ifndef _BLIT_IPU_H_
 #define _BLIT_IPU_H_
@@ -30,9 +30,10 @@
 #include <EGL/egl.h>
 #include "gralloc_priv.h"
 #include "hwc_common.h"
-extern "C" {
-#include "mxc_ipu_hl_lib.h"
-}
+#include <linux/ipu.h>
+//extern "C" {
+//#include "mxc_ipu_hl_lib.h"
+//}
 /*****************************************************************************/
 
 #define BLIT_PIXEL_FORMAT_RGB_565  209
@@ -42,25 +43,22 @@ class blit_ipu : public blit_device
 public:
     virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
 
-		blit_ipu();
-		virtual ~blit_ipu();
+	blit_ipu();
+	virtual ~blit_ipu();
 
 private:
-		ipu_lib_input_param_t  mIPUInputParam;
-    ipu_lib_output_param_t mIPUOutputParam;
-    ipu_lib_handle_t       mIPUHandle;
-    unsigned int mRotSize;
-    unsigned int mRotPhyBuffer;
-    void *mRotVirBuffer;
-
+    struct ipu_task mTask;
+    int mIpuFd;
+	//ipu_lib_input_param_t  mIPUInputParam;
+    //ipu_lib_output_param_t mIPUOutputParam;
+    //ipu_lib_handle_t       mIPUHandle;
 //    int                    mIPURet;
 private:
-		int init();
+	int init();
     int uninit();
-    int getPmemBuffer(int size, void **ppVirBuffer, unsigned int *phyBuffer);
-    int returnPmemBuffer(void *pVirBuffer, unsigned int size); 
-		blit_ipu& operator = (blit_ipu& out);
-		blit_ipu(const blit_ipu& out);
+
+	blit_ipu& operator = (blit_ipu& out);
+	blit_ipu(const blit_ipu& out);
 };
 
 
diff --git a/mx5x/hwcomposer/hwc_common.cpp b/mx5x/hwcomposer/hwc_common.cpp
index 66b5d81..ed93a3d 100755
--- a/mx5x/hwcomposer/hwc_common.cpp
+++ b/mx5x/hwcomposer/hwc_common.cpp
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 
 #include <hardware/hardware.h>
@@ -30,9 +30,10 @@
 #include "hwc_common.h"
 #include "blit_gpu.h"
 #include "blit_ipu.h"
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-}
+#include <linux/ipu.h>
+//extern "C" {
+//#include "mxc_ipu_hl_lib.h" 
+//}
 /*****************************************************************************/
 using namespace android;
 //int hwc_check_property(hwc_context_t *dev)
@@ -232,28 +233,29 @@ int output_dev_close(output_device *dev)
 
 blit_device::blit_device()
 {
-	int fd_def;
+        int fd_def;
 
         m_def_disp_w = 0;
         m_def_disp_h = 0;
 
-	fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+        fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
 
-	if(fd_def < 0) {
+        if(fd_def < 0) {
           HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
           return;
         }
 
-	struct fb_var_screeninfo def_info;
+        struct fb_var_screeninfo def_info;
         if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
-	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
+          HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
           return;
         }
 
-	m_def_disp_w = def_info.xres;
-	m_def_disp_h = def_info.yres;
+        m_def_disp_w = def_info.xres;
+        m_def_disp_h = def_info.yres;
 
-	close(fd_def);
+        close(fd_def);
 
-	return;
+        return;
 }
+
diff --git a/mx5x/hwcomposer/hwc_common.h b/mx5x/hwcomposer/hwc_common.h
index 4edb8af..572768e 100755
--- a/mx5x/hwcomposer/hwc_common.h
+++ b/mx5x/hwcomposer/hwc_common.h
@@ -12,7 +12,7 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #ifndef _HWC_FSL_H_
 #define _HWC_FSL_H_
@@ -38,7 +38,7 @@
 #define LOG_TAG "FslHwcomposer"
 #include <utils/Log.h>
 
-//#define HWCOMPOSER__DEBUG_LOG
+//#define HWCOMPOSER_DEBUG_LOG
 
 #ifdef HWCOMPOSER_DEBUG_LOG
 #define HWCOMPOSER_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
@@ -56,6 +56,7 @@
 #define DEFAULT_FB_DEV_NAME "/dev/graphics/fb0"
 #define FB1_DEV_NAME "/dev/graphics/fb1"
 #define FB2_DEV_NAME "/dev/graphics/fb2"
+#define FB3_DEV_NAME "/dev/graphics/fb3"
 #define V4L_DEV_NAME "/dev/video16"
 #define MAX_OUTPUT_DISPLAY  10
 
@@ -112,6 +113,13 @@ typedef enum {
 #define GRALLOC_USAGE_DISPLAY_MASK    0x07000000
 #define GRALLOC_USAGE_OVERLAY_DISPLAY_MASK 0x07F00000
 
+#define LAYER_RECORD_NUM      8
+typedef struct {
+    void* handle;
+    hwc_rect_t outRect;
+    int outDev;
+}layer_record;
+
 typedef struct{
     void *virt_addr;
     unsigned long phy_addr;
@@ -213,12 +221,12 @@ class blit_device{
 public:
 		static int isIPUDevice(const char *dev_name);
 		static int isGPUDevice(const char *dev_name);
-    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
+    		virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
 		blit_device();
-                virtual ~blit_device(){}
+		virtual ~blit_device(){}
 
                 int m_def_disp_w;
-	        int m_def_disp_h;
+                int m_def_disp_h;
 };
 
 //int FG_init(struct output_device *dev);
diff --git a/mx5x/hwcomposer/hwcomposer.cpp b/mx5x/hwcomposer/hwcomposer.cpp
index 8cb6444..9293642 100755
--- a/mx5x/hwcomposer/hwcomposer.cpp
+++ b/mx5x/hwcomposer/hwcomposer.cpp
@@ -12,10 +12,9 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #include <hardware/hardware.h>
-//#include <hardware/overlay.h>
 
 #include <fcntl.h>
 #include <errno.h>
@@ -45,6 +44,9 @@ struct hwc_context_t {
     int display_mode;
     char ui_refresh;
     char vd_refresh;
+    int second_display;
+
+    layer_record records[LAYER_RECORD_NUM];
 };
 
 static int hwc_device_open(const struct hw_module_t* module, const char* name,
@@ -60,9 +62,12 @@ hwc_module_t HAL_MODULE_INFO_SYM = {
         version_major: 1,
         version_minor: 0,
         id: HWC_HARDWARE_MODULE_ID,
-        name: "Sample hwcomposer module",
-        author: "The Android Open Source Project",
+        name: "Freescale iMX53 HW Composer module",
+        author: "Freescale",
         methods: &hwc_module_methods,
+        dso: NULL,
+        reserved: {0},
+
     }
 };
 
@@ -80,7 +85,73 @@ static void dump_layer(hwc_layer_t const* l) {
             l->displayFrame.right,
             l->displayFrame.bottom);
 }
-static int releaseAllOutput(struct hwc_context_t *ctx);
+
+/***********************************************************************/
+static void addRecord(hwc_context_t *dev, hwc_layer_list_t* list)
+{
+    int rec_index = 0;
+    if (list && dev) {
+        for(int n=0; n<LAYER_RECORD_NUM; n++) {
+            dev->records[n].handle = NULL;
+            memset(&(dev->records[n].outRect), 0, sizeof(dev->records[n].outRect));
+            dev->records[n].outDev = 0;
+        }
+
+        for (size_t i=0 ; i<list->numHwLayers ; i++) {
+            //dump_layer(&list->hwLayers[i]);
+            //list->hwLayers[i].compositionType = HWC_FRAMEBUFFER;
+            hwc_layer_t *layer = &list->hwLayers[i];
+            /*
+             *the private_handle_t should expand to have usage and format member.
+            */
+            if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
+                continue;//skip NULL pointer and other magic handler
+            }
+            if (private_handle_t::validate(layer->handle) < 0) {
+                //HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
+                continue;
+            }
+            //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
+            //HWCOMPOSER_LOG_ERR("-------hwc_prepare----layer[%d]-----displayID = %d", i, layer->displayId);
+            private_handle_t *handle = (private_handle_t *)(layer->handle);
+            if(!(handle->usage & GRALLOC_USAGE_HWC_OVERLAY)) {
+                //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---usage=%x>>phy=%x>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
+                continue;
+            }
+
+            if(rec_index >= LAYER_RECORD_NUM) {
+                HWCOMPOSER_LOG_ERR("******************Error:%s, too many video layers");
+                return;
+            }
+            dev->records[rec_index].handle = (void*)(layer->handle);
+            dev->records[rec_index].outRect = layer->displayFrame;
+            dev->records[rec_index].outDev = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
+            rec_index ++;
+        }// end for
+    }//end if
+}
+
+static int isRectEqual(hwc_rect_t* hs, hwc_rect_t* hd)
+{
+    return ((hs->left == hd->left) && (hs->top == hd->top)
+            && (hs->right == hd->right) && (hs->bottom == hd->bottom));
+}
+
+static int isInRecord(hwc_context_t *dev, hwc_layer_t *layer)
+{
+    if(dev && layer) {
+        private_handle_t *handle = (private_handle_t *)(layer->handle);
+        for(int i=0; i<LAYER_RECORD_NUM; i++) {
+            if(((int)(dev->records[i].handle) == (int)(layer->handle))
+                      && isRectEqual(&(dev->records[i].outRect), &(layer->displayFrame))
+                      && (dev->records[i].outDev == (handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK))) {
+                return 1;
+            }
+        }
+    }
+    return 0;
+}
+
 static int hwc_check_property(hwc_context_t *dev)
 {
     //bool bValue = false;
@@ -91,29 +162,26 @@ static int hwc_check_property(hwc_context_t *dev)
         property_set("sys.VIDEO_OVERLAY_DISPLAY", "0");
         property_set("sys.VIDEO_DISPLAY", "1");
     }
-    else
+    else if (strcmp(value, "0") == 0)
     {
        property_set("sys.VIDEO_OVERLAY_DISPLAY", "1");
        property_set("sys.VIDEO_DISPLAY", "0");
     }
+
     property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
     if (strcmp(value, "1") == 0) {
-       property_get("ro.secfb.disable-overlay", value, "0");
-       if (strcmp(value, "1") == 0){
-           property_set("sys.VIDEO_OVERLAY_DISPLAY", "0");
-           property_set("sys.VIDEO_DISPLAY", "1");
-
-           property_get("media.VIDEO_PLAYING", value, "0");
-           if (strcmp(value, "0") == 0) {
-               releaseAllOutput(dev);
-           }
-       }
-       else{
-           property_set("sys.VIDEO_OVERLAY_DISPLAY", "2");
-           property_set("sys.VIDEO_DISPLAY", "0");
-       }
-    } else
+       property_set("sys.VIDEO_OVERLAY_DISPLAY", "2");
+       property_set("sys.VIDEO_DISPLAY", "0");
+       dev->display_mode &= ~(DISPLAY_MODE_OVERLAY_DISP0 | DISPLAY_MODE_OVERLAY_DISP1 |
+                              DISPLAY_MODE_OVERLAY_DISP2 | DISPLAY_MODE_OVERLAY_DISP3);
+       dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP0;
+       dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP2;
+       dev->second_display = 1;
+       return 0;
+    } 
+    else if (strcmp(value, "0") == 0)
     {
+       dev->second_display = 0;
        property_set("sys.VIDEO_OVERLAY_DISPLAY", "1");
        property_set("sys.VIDEO_DISPLAY", "0");
     }
@@ -133,7 +201,7 @@ static int hwc_check_property(hwc_context_t *dev)
         dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP1;
     }
 
-		if (strcmp(value, "3") == 0){
+    if (strcmp(value, "3") == 0){
         dev->display_mode |= DISPLAY_MODE_OVERLAY_DISP2;
     }
     else if (strcmp(value, "4") == 0){
@@ -152,6 +220,7 @@ static int hwc_check_property(hwc_context_t *dev)
     if (strcmp(value, "2") == 0){
         dev->display_mode |= DISPLAY_MODE_DISP2;
     }
+    //HWCOMPOSER_LOG_ERR("************dev->display_mode=%x", dev->display_mode);
 	return 0;
 }
 
@@ -161,8 +230,8 @@ static int hwc_modify_property(hwc_context_t *dev, private_handle_t *handle)
 
     if(dev->display_mode & DISPLAY_MODE_DISP1){
             handle->usage |= GRALLOC_USAGE_HWC_DISP1;
-            //dev->display_mode &= ~DISPLAY_MODE_DISP1;
-			return 0;
+            dev->display_mode &= ~DISPLAY_MODE_DISP1;
+	    //return 0;
     }
 
     if(dev->display_mode & DISPLAY_MODE_DISP2)
@@ -170,7 +239,7 @@ static int hwc_modify_property(hwc_context_t *dev, private_handle_t *handle)
 
 	if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP0){
 			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP0;
-			dev->display_mode &= ~DISPLAY_MODE_OVERLAY_DISP0;
+			//dev->display_mode &= ~DISPLAY_MODE_OVERLAY_DISP0;
 	}
 	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP1)
 			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP1;
@@ -180,7 +249,7 @@ static int hwc_modify_property(hwc_context_t *dev, private_handle_t *handle)
 	else if(dev->display_mode & DISPLAY_MODE_OVERLAY_DISP3)
 			handle->usage |= GRALLOC_USAGE_HWC_OVERLAY_DISP3;
 
-//HWCOMPOSER_LOG_ERR("************handle->usage=%x", handle->usage);
+    //HWCOMPOSER_LOG_ERR("************handle->usage=%x", handle->usage);
 	return 0;
 }
 
@@ -232,7 +301,7 @@ static int findOutputDevice(struct hwc_context_t *ctx, int *index, int usage, in
 		}
 	}
 	if(ufg != NULL)
-		*ufg |= uFlag;
+		*ufg = uFlag;
 
 	return (*ufg) ^ usage;
 }
@@ -261,21 +330,37 @@ static void deleteEmtpyIndex(struct hwc_context_t *ctx)
 	}
 }
 
-static char* getDeviceName(int usage, int *pUse)
+static char* getDeviceName(hwc_context_t *dev, int usage, int *pUse)
 {
+    if(dev->second_display) {
+        if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+            *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP0;
+            return (char *)FB1_DEV_NAME;
+        }
+        if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) {
+            *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP2;
+            return (char *)FB3_DEV_NAME;
+        }
+    }
+
     if(usage & GRALLOC_USAGE_HWC_DISP1){
     		*pUse = GRALLOC_USAGE_HWC_DISP1;
-    		return (char *)FB1_DEV_NAME;
+    		return (char *)FB2_DEV_NAME;
     }
     if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
     		*pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP0;
-    		return (char *)FB2_DEV_NAME;
+    		return (char *)FB1_DEV_NAME;
     }
     if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
         *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP1;
-        return (char *)FB2_DEV_NAME;
+        return (char *)FB1_DEV_NAME;
     }//end else if
 
+    if(usage & GRALLOC_USAGE_HWC_OVERLAY_DISP2) {
+            *pUse = GRALLOC_USAGE_HWC_OVERLAY_DISP2;
+            return (char *)FB3_DEV_NAME;
+    }
+
     return NULL;
 }
 
@@ -344,19 +429,10 @@ static int open_outputDevice(struct hwc_context_t *ctx, const char *dev_name, ou
 }
 
 static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
-//#if 1
-		//HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---1>>>>>>>>>>>>>>>>>\n");
-		char out_using[MAX_OUTPUT_DISPLAY] = {0};
-//		for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-//				out_using[i] = m_using[i];
-//		}
-
-		struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
-#if 1
-		if(ctx) {
-			hwc_check_property(ctx);
-		}
-#endif
+    char out_using[MAX_OUTPUT_DISPLAY] = {0};
+
+    struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
+
     if (list && dev) {
         for (size_t i=0 ; i<list->numHwLayers ; i++) {
             //dump_layer(&list->hwLayers[i]);
@@ -365,27 +441,25 @@ static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
             /*
              *the private_handle_t should expand to have usage and format member.
             */
-              if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
-                  continue;//skip NULL pointer and other magic handler
-               }
-		    if (private_handle_t::validate(layer->handle) < 0) {
-	    		//HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
-	    		continue;
-		    }
-		    //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
+            if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
+                continue;//skip NULL pointer and other magic handler
+            }
+	    if (private_handle_t::validate(layer->handle) < 0) {
+		//HWCOMPOSER_LOG_ERR("it is not a valide buffer handle\n");
+		continue;
+	    }
+	    //HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---2>>>>>>>>>>>>>>>>>\n");
             private_handle_t *handle = (private_handle_t *)(layer->handle);
             if(!(handle->usage & GRALLOC_USAGE_HWC_OVERLAY)) {
                 //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---usage=%x>>phy=%x>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
             	continue;
             }
             HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---3>usage=%x, phy=%x>>>>>>>>>>>>>>>>\n", handle->usage, handle->phys);
-#if 1
-        	layer->compositionType = HWC_OVERLAY;
-    		//if(handle->usage & GRALLOC_USAGE_HWC_DISP1)
-    		//handle the display frame position for tv out.
-#endif
-#if 1
-        	hwc_modify_property(ctx, handle);
+            hwc_check_property(ctx);
+	    layer->compositionType = HWC_OVERLAY;
+	    //if(handle->usage & GRALLOC_USAGE_HWC_DISP1)
+	    //handle the display frame position for tv out.
+	    hwc_modify_property(ctx, handle);
 
             if(!validate_displayFrame(layer)) {
                 HWCOMPOSER_LOG_INFO("<<<<<<<<<<<<<<<hwc_prepare---3-2>>>>>>>>>>>>>>>>\n");
@@ -400,16 +474,16 @@ static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
             //HWCOMPOSER_LOG_ERR("<<<<<<<<<<<<<<<hwc_prepare---3-3>>>>>usage=%x>>>i_usage=%x>>>>>>>>\n", handle->usage, i_usage);
             retv = checkOutputDevice(ctx, out_using, i_usage, &m_usage);
             while(retv && m_usage) {
-		        int ruse = 0;
-		        char *dev_name = NULL;
-				dev_name = getDeviceName(m_usage, &ruse);
+		    int ruse = 0;
+		    char *dev_name = NULL;
+		    dev_name = getDeviceName(ctx, m_usage, &ruse);
 	            m_usage &= ~ruse;
 	            HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_prepare---4>>>>>>>>>>>>>>>>>\n");
 	            if(dev_name == NULL) {
-					HWCOMPOSER_LOG_INFO("****Warnning: layer buffer usage(%x) does not support!", handle->usage);
-					HWCOMPOSER_LOG_INFO("****Warnning:  the layer buffer will be handled in surfaceflinger");
-					layer->compositionType = HWC_FRAMEBUFFER;
-					continue;
+			HWCOMPOSER_LOG_INFO("****Warnning: layer buffer usage(%x) does not support!", handle->usage);
+			HWCOMPOSER_LOG_INFO("****Warnning:  the layer buffer will be handled in surfaceflinger");
+			layer->compositionType = HWC_FRAMEBUFFER;
+			continue;
 	            }//end else
 
 	            index = findEmpytIndex(ctx);
@@ -418,31 +492,27 @@ static int hwc_prepare(hwc_composer_device_t *dev, hwc_layer_list_t* list) {
             		return HWC_EGL_ERROR;
 	            }
 	            if(ctx->m_out[index])
-	            		deleteEmtpyIndex(ctx);
+			deleteEmtpyIndex(ctx);
 
 		        status = open_outputDevice(ctx, dev_name, &(ctx->m_out[index]), ruse);//output_dev_open(dev_name, &(ctx->m_out[index]), ruse);
 		        if(status < 0){
-		        	  HWCOMPOSER_LOG_ERR("Error! open output device failed!");
-		        	  continue;
+		            HWCOMPOSER_LOG_ERR("Error! open output device failed!");
+		            continue;
 		        }//end if
 		        out_using[index] = 1;
 		        ctx->m_using[index] = 1;
 		        //setLayerFrame(layer, ctx->m_out[index], ruse);
             }//end while
             checkDisplayFrame(ctx, layer, i_usage);
-#endif
         }//end for
-#if 1
-	    for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-			if(!out_using[i] && ctx->m_using[i]) {
-				ctx->m_using[i] = 0;
-				deleteEmtpyIndex(ctx);
-			}
-			//ctx->m_using[i] = out_using[i];
+        for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
+		if(!out_using[i] && ctx->m_using[i]) {
+			ctx->m_using[i] = 0;
+			deleteEmtpyIndex(ctx);
 		}
-#endif
+		//ctx->m_using[i] = out_using[i];
+	}
     }//end if
-//#endif
     return 0;
 }
 
@@ -485,103 +555,109 @@ static int hwc_set(hwc_composer_device_t *dev,
         hwc_surface_t sur,
         hwc_layer_list_t* list)
 {
-		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=1==============\n");
     struct hwc_context_t *ctx = (struct hwc_context_t *)dev;
     //for (size_t i=0 ; i<list->numHwLayers ; i++) {
     //    dump_layer(&list->hwLayers[i]);
     //}
     //hwc_buffer *outBuff[MAX_OUTPUT_DISPLAY];
     //when displayhardware do releas function, it will come here.
-#if 1
     if(ctx && (dpy == NULL) && (sur == NULL) && (list == NULL)) {
-		//close the output device.
-		releaseAllOutput(ctx);
-		//ctx->display_mode_changed = 1;
+	//close the output device.
+	releaseAllOutput(ctx);
+	//ctx->display_mode_changed = 1;
 
-		return 0;
+	return 0;
     }
-#endif
-		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=2==============\n");
-#if 1 
-    if((ctx == NULL) || (ctx && (ctx->ui_refresh || (!ctx->ui_refresh && !ctx->vd_refresh )))) {
-        EGLBoolean sucess = eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur);
-        if (!sucess) {
+    ctx->ui_refresh = 1;
+    ctx->vd_refresh = 1;
+    if((ctx == NULL) || (ctx && ctx->ui_refresh)) {
+        EGLBoolean success;
+        success = eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur);
+        if (!success) {
             return HWC_EGL_ERROR;
         }
     }
-#endif
     if(list == NULL || dev == NULL || !ctx->vd_refresh) {
     	return 0;
     }
- 		//HWCOMPOSER_LOG_RUNTIME("==============hwc_set=3==============\n");
     if(getActiveOuputDevice(ctx) == 0) {return 0;}//eglSwapBuffers((EGLDisplay)dpy, (EGLSurface)sur); return 0;}
+    HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
 
     int status = -EINVAL;
-	HWCOMPOSER_LOG_RUNTIME("==============hwc_set=4==============\n");
-	hwc_buffer out_buffer[MAX_OUTPUT_DISPLAY];
+    hwc_buffer out_buffer[MAX_OUTPUT_DISPLAY];
     char bufs_state[MAX_OUTPUT_DISPLAY];
     memset(bufs_state, 0, sizeof(bufs_state));
-	memset(out_buffer, 0, sizeof(out_buffer));
-#if 0    
-	for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-		if(ctx->m_using[i] && ctx->m_out[i])
-			status = ctx->m_out[i]->fetch(&out_buffer[i]);
-    }
-#endif
+    memset(out_buffer, 0, sizeof(out_buffer));
     blit_device *bltdev = ctx->blit;
     for (size_t i=0 ; i<list->numHwLayers ; i++){
-		hwc_layer_t *layer = &list->hwLayers[i];
-	    if (private_handle_t::validate(layer->handle) < 0) {
-    		//HWCOMPOSER_LOG_INFO("2--it is not a valide buffer handle\n");
-    		continue;
-	    }
+	hwc_layer_t *layer = &list->hwLayers[i];
+        if(!layer->handle || ((private_handle_t *)layer->handle)->magic != private_handle_t::sMagic) {
+    	    HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
+            continue;
+        }
+	if (private_handle_t::validate(layer->handle) < 0) {
+    	    HWCOMPOSER_LOG_RUNTIME("%s,%d, not a valide buffer handle", __FUNCTION__, __LINE__);
+    	    continue;
+	}
 
         if(!validate_displayFrame(layer)) {
+    	    HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
             continue;
         }
+        HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
 
-		private_handle_t *handle = (private_handle_t *)(layer->handle);
-		if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY){
+        //when GM do seek, it always queue the same buffer.
+        //so, we can not judge the reduplicated buffer by buffer handle now. 
+        if(isInRecord(ctx, layer)) {
+            HWCOMPOSER_LOG_RUNTIME("%s,%d, lost frames", __FUNCTION__, __LINE__);
+            //continue;
+        }
+
+	private_handle_t *handle = (private_handle_t *)(layer->handle);
+	if(handle->usage & GRALLOC_USAGE_HWC_OVERLAY){
             int retv = 0;
             int m_usage = 0;
             int i_usage = handle->usage & GRALLOC_USAGE_OVERLAY_DISPLAY_MASK;
-    	    HWCOMPOSER_LOG_RUNTIME("==============hwc_set=5==============\n");
             if(!i_usage) continue;
             do {
-    			output_device *outdev = NULL;
-    			int index = 0;
-        		retv = findOutputDevice(ctx, &index, i_usage, &m_usage);
+    		output_device *outdev = NULL;
+    		int index = 0;
+        	retv = findOutputDevice(ctx, &index, i_usage, &m_usage);
+                i_usage &= ~m_usage;
                 if((index >= 0) && (index < MAX_OUTPUT_DISPLAY)) {
-                	outdev = ctx->m_out[index];
+                    outdev = ctx->m_out[index];
                 }else {
                     break;
                 }
                 
-    			if(outdev != NULL) {
-                    if(!bufs_state[index] && ctx->m_using[index]) {
-                        outdev->fetch(&out_buffer[index]);
-                        bufs_state[index] = 1;
-                    }
-    				status = bltdev->blit(layer, &(out_buffer[index]));
-    				if(status < 0){
-    					HWCOMPOSER_LOG_ERR("Error! bltdev->blit() failed!");
-    					continue;
-    				}
-    			}//end if(outdev != NULL)
+    		if(outdev != NULL) {
+			if(!bufs_state[index] && ctx->m_using[index]) {
+				outdev->fetch(&out_buffer[index]);
+				bufs_state[index] = 1;
+			}
+			if(!bufs_state[index])
+				continue;
+			status = bltdev->blit(layer, &(out_buffer[index]));
+			if(status < 0){
+				HWCOMPOSER_LOG_ERR("Error! bltdev->blit() failed!");
+				continue;
+			}
+    		}//end if(outdev != NULL)
             }while(retv);
 
 		}//end if
     }//end for
-
     for(int i = 0; i < MAX_OUTPUT_DISPLAY; i++) {
-				if(ctx->m_using[i] && bufs_state[i]) {
-						status = ctx->m_out[i]->post(&out_buffer[i]);
-						if(status < 0){
-								HWCOMPOSER_LOG_ERR("Error! output device post buffer failed!");
-								continue;
-						}
-				}
+	if(ctx->m_using[i] && bufs_state[i]) {
+		status = ctx->m_out[i]->post(&out_buffer[i]);
+		if(status < 0){
+			HWCOMPOSER_LOG_ERR("Error! output device post buffer failed!");
+			continue;
 		}
+	}
+    }
+    addRecord(ctx, list);
+
     return 0;
 }
 
@@ -592,6 +668,7 @@ static int hwc_device_close(struct hw_device_t *dev)
     		if(ctx->blit)
     				blit_dev_close(ctx->blit);
         releaseAllOutput(ctx);
+
         free(ctx);
     }
     return 0;
@@ -628,15 +705,17 @@ static int hwc_device_open(const struct hw_module_t* module, const char* name,
         	  HWCOMPOSER_LOG_ERR("Error! blit_dev_open failed!");
         	  goto err_exit;
         }
-HWCOMPOSER_LOG_RUNTIME("<<<<<<<<<<<<<<<hwc_device_open>>>>>>>>>>>>>>>>>\n");
+
+nor_exit:
+	HWCOMPOSER_LOG_RUNTIME("%s,%d", __FUNCTION__, __LINE__);
         return 0;
 err_exit:
-				if(dev){
-						if(dev->blit) {
-								blit_dev_close(dev->blit);
-						}
-					  free(dev);
-				}
+	if(dev){
+		if(dev->blit) {
+			blit_dev_close(dev->blit);
+		}
+		free(dev);
+	}
 				//status = -EINVAL;
         /****************************************/
     }
diff --git a/mx5x/libcamera/Android.mk b/mx5x/libcamera/Android.mk
index 23c86ff..eb939ec 100755
--- a/mx5x/libcamera/Android.mk
+++ b/mx5x/libcamera/Android.mk
@@ -11,22 +11,24 @@
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-ifeq (true, false)
+
 ifeq ($(BOARD_SOC_CLASS),IMX5X)
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=    \
-	CameraHal.cpp    \
+    CameraHal.cpp    \
+    CameraModule.cpp \
     Camera_pmem.cpp  \
-	CaptureDeviceInterface.cpp \
-	V4l2CsiDevice.cpp \
-	V4l2CapDeviceBase.cpp  \
-	PostProcessDeviceInterface.cpp \
-	PP_ipulib.cpp    \
-	JpegEncoderInterface.cpp \
-    JpegEncoderSoftware.cpp
+    CaptureDeviceInterface.cpp \
+    V4l2CsiDevice.cpp \
+    V4l2CapDeviceBase.cpp  \
+    PostProcessDeviceInterface.cpp \
+    PP_ipulib.cpp    \
+    JpegEncoderInterface.cpp \
+    JpegEncoderSoftware.cpp \
+    messageQueue.cpp
 
 LOCAL_CPPFLAGS +=
 
@@ -40,28 +42,29 @@ LOCAL_SHARED_LIBRARIES:= \
     libhardware_legacy \
     libdl \
     libc \
-	libipu
+    libipu
 
 LOCAL_C_INCLUDES += \
-	frameworks/base/include/binder \
-	frameworks/base/include/ui \
-	frameworks/base/camera/libcameraservice \
-	external/linux-lib/ipu \
+    frameworks/base/include/binder \
+    frameworks/base/include/ui \
+    frameworks/base/camera/libcameraservice \
+    external/linux-lib/ipu \
     hardware/imx/mx5x/libgralloc
 
 ifeq ($(HAVE_FSL_IMX_CODEC),true)
     LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
     LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
     LOCAL_C_INCLUDES +=	\
-					device/fsl/proprietary/codec/ghdr
+         device/fsl/proprietary/codec/ghdr
 endif
 ifeq ($(BOARD_CAMERA_NV12),true)
     LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
 else
     LOCAL_CPPFLAGS += -DRECORDING_FORMAT_YUV420
 endif
-	
-LOCAL_MODULE:= libcamera
+
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw	
+LOCAL_MODULE:= camera.$(TARGET_BOARD_PLATFORM)
 
 LOCAL_CFLAGS += -fno-short-enums
 LOCAL_PRELINK_MODULE := false
@@ -69,4 +72,3 @@ LOCAL_MODULE_TAGS := eng
 
 include $(BUILD_SHARED_LIBRARY)
 endif
-endif
diff --git a/mx5x/libcamera/CameraHal.cpp b/mx5x/libcamera/CameraHal.cpp
index 4c37c8f..8ed50d5 100755
--- a/mx5x/libcamera/CameraHal.cpp
+++ b/mx5x/libcamera/CameraHal.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 
@@ -32,7 +32,7 @@
 
 namespace android {
 
-    CameraHal::CameraHal()
+    CameraHal::CameraHal(int cameraid)
         : mParameters(),
         mCallbackCookie(NULL),
         mNotifyCb(NULL),
@@ -45,17 +45,19 @@ namespace android {
         mAutoFocusThread(NULL),
         mTakePicThread(NULL),
         mLock(),
-        supportedPictureSizes(NULL),
-        supportedPreviewSizes(NULL),
-        supportedFPS(NULL),
-        supprotedThumbnailSizes(NULL),
+        mSupportedPictureSizes(NULL),
+        mSupportedPreviewSizes(NULL),
+        mSupportedFPS(NULL),
+        mSupprotedThumbnailSizes(NULL),
+        mSupportPreviewFormat(NULL),
         mNativeWindow(NULL),
         mMsgEnabled(0),
-        mPreviewHeap(0),
+        mPreviewMemory(NULL),
+        mVideoMemory(NULL),
         mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
         mPPbufNum(0),
-        mPreviewRunning(0),
-        mPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
+        mPreviewRunning(0), mCaptureRunning(0),
+        mDefaultPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
         mPreviewFrameSize(0),
         mTakePicFlag(false),
         mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
@@ -72,10 +74,13 @@ namespace android {
         mCameraReady(false),
         mCaptureDeviceOpen(false),
         mPPDeviceNeed(false),
-		bDerectInput(false),
+	bDerectInput(false),
+        mCameraid(cameraid),
         mPPDeviceNeedForPic(false),
         mPowerLock(false),
-        mPreviewRotate(CAMERA_PREVIEW_BACK_REF)
+        mPreviewRotate(CAMERA_PREVIEW_BACK_REF),
+        mExitCaptureThread(false), mExitPreviewThread(false), 
+        mExitPostProcessThread(false), mExitEncodeThread(false), mTakePictureInProcess(false)
     {
         CAMERA_HAL_LOG_FUNC;
         preInit();
@@ -104,7 +109,6 @@ namespace android {
     void CameraHal :: preInit()
     {
         CAMERA_HAL_LOG_FUNC;
-
     }
     void CameraHal :: postDestroy()
     {
@@ -150,6 +154,16 @@ namespace android {
         CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
         mCameraReady == true;
 
+        CAMERA_TYPE cType;
+        mCaptureDevice->GetDevType(&cType);
+        if(cType == CAMERA_TYPE_UVC) {
+            mPPDeviceNeed = true;
+            CAMERA_HAL_LOG_INFO("-----%s: it is uvc device", __FUNCTION__);
+        }else {
+            mPPDeviceNeed = false;
+            CAMERA_HAL_LOG_INFO("-----%s: it is csi device", __FUNCTION__);
+        }
+
         if ((ret = AolLocForInterBuf())<0)
             return ret;
         if ((ret = InitCameraHalParam()) < 0)
@@ -173,15 +187,17 @@ namespace android {
         CAMERA_HAL_LOG_FUNC;
         CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
 
-        supportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        supportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        supportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        supprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-
-        if (supportedPictureSizes == NULL ||
-                supportedPreviewSizes == NULL ||
-                supportedFPS          == NULL ||
-                supprotedThumbnailSizes == NULL)
+        mSupportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupportPreviewFormat = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+
+        if (mSupportedPictureSizes == NULL ||
+                mSupportedPreviewSizes == NULL ||
+                mSupportedFPS          == NULL ||
+                mSupprotedThumbnailSizes == NULL ||
+                mSupportPreviewFormat == NULL)
             ret = CAMERA_HAL_ERR_ALLOC_BUF;
 
         return ret;
@@ -189,14 +205,14 @@ namespace android {
     void  CameraHal :: FreeInterBuf()
     {
         CAMERA_HAL_LOG_FUNC;
-        if (supportedPictureSizes)
-            free(supportedPictureSizes);
-        if (supportedPreviewSizes)
-            free(supportedPreviewSizes);
-        if (supportedFPS)
-            free(supportedFPS);
-        if (supprotedThumbnailSizes)
-            free(supprotedThumbnailSizes);
+        if (mSupportedPictureSizes)
+            free(mSupportedPictureSizes);
+        if (mSupportedPreviewSizes)
+            free(mSupportedPreviewSizes);
+        if (mSupportedFPS)
+            free(mSupportedFPS);
+        if (mSupprotedThumbnailSizes)
+            free(mSupprotedThumbnailSizes);
     }
 
     CAMERA_HAL_ERR_RET CameraHal :: InitCameraHalParam()
@@ -204,10 +220,10 @@ namespace android {
         CAMERA_HAL_LOG_FUNC;
         CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
 
-        if ((ret = GetCameraBaseParam(&mParameters)) < 0)
+        if ((ret = InitCameraBaseParam(&mParameters)) < 0)
             return ret;
 
-        if ((ret = GetPictureExifParam(&mParameters)) < 0)
+        if ((ret = InitPictureExifParam(&mParameters)) < 0)
             return ret;
 
         return ret;
@@ -219,18 +235,75 @@ namespace android {
         CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
         pthread_mutex_init(&mPPIOParamMutex, NULL);
         pthread_mutex_init(&mOverlayMutex, NULL);
+
+        mPreviewRunning = false;
+        mCaptureRunning = false;
+        mWaitForTakingPicture = false;
+        sem_init(&mCaptureStoppedCondition, 0, 0);
+        sem_init(&mPreviewStoppedCondition, 0, 0);
+        sem_init(&mEncodeStoppedCondition, 0, 0);
+        sem_init(&mPostProcessStoppedCondition, 0, 0);
+        sem_init(&mTakingPicture, 0, 0);
+        //mPostProcessRunning = false;
+        //mEncodeRunning = false;
+        mCaptureFrameThread = new CaptureFrameThread(this);
+        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
+        mEncodeFrameThread = new EncodeFrameThread(this);
+        mTakePicThread= new TakePicThread(this);
+
+        if(mPPDeviceNeed){
+            mPostProcessThread = new PostProcessThread(this);
+            if (mPostProcessThread == NULL)
+                 return CAMERA_HAL_ERR_INIT;
+        }
+
+        if (mCaptureFrameThread == NULL || mPreviewShowFrameThread == NULL ||
+                mEncodeFrameThread == NULL || mTakePicThread == NULL){
+            return CAMERA_HAL_ERR_INIT;
+        }
         return ret;
     }
     CAMERA_HAL_ERR_RET CameraHal::CameraMiscDeInit()
     {
         CAMERA_HAL_LOG_FUNC;
         CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        mCaptureThreadQueue.postQuitMessage();
         pthread_mutex_destroy(&mPPIOParamMutex);
         pthread_mutex_destroy(&mOverlayMutex);
         return ret;
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: GetCameraBaseParam(CameraParameters *pParam)
+    CAMERA_HAL_ERR_RET CameraHal::InitCameraPreviewFormatToParam(int nFmt)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int i;
+        char fmtStr[40];
+
+        memset(fmtStr, 0, 40);
+        convertPreviewFormatToString(fmtStr, 40, mDefaultPreviewFormat);
+        mParameters.setPreviewFormat(fmtStr);
+        mParameters.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, fmtStr);
+
+        memset(fmtStr, 0, 40);
+        for(i = 0; i < nFmt; i++) {
+            if(mCaptureSupportedFormat[i] == v4l2_fourcc('Y','U','1','2')) {
+                strcat(fmtStr, "yuv420p");
+                strcat(fmtStr, ",");
+            }
+            else if(mCaptureSupportedFormat[i] == v4l2_fourcc('N','V','1','2')) {
+                strcat(fmtStr, "yuv420sp");
+                strcat(fmtStr, ",");
+            }
+            //else if(mCaptureSupportedFormat[i] == v4l2_fourcc('Y','U','Y','V')) {
+            //    strcat(fmtStr, "yuv422i-yuyv");
+            //    strcat(fmtStr, ",");
+            //}
+        }
+        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, fmtStr);
+        return CAMERA_HAL_ERR_NONE;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: InitCameraBaseParam(CameraParameters *pParam)
     {
         CAMERA_HAL_LOG_FUNC;
         char TmpStr[20];
@@ -239,13 +312,6 @@ namespace android {
         int  previewCnt= 0, pictureCnt = 0, i;
         char previewFmt[20] = {0};
 
-        pParam->setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);
-        pParam->set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP);
-        strcpy(previewFmt, CameraParameters::PIXEL_FORMAT_YUV420SP);
-        strcat(previewFmt, ",");
-        strcat(previewFmt, CameraParameters::PIXEL_FORMAT_YUV420P);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, previewFmt);
-
         //the Camera Open here will not be close immediately, for later preview.
         if (OpenCaptureDevice() < 0)
             return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
@@ -259,50 +325,57 @@ namespace android {
         if (i == 0)
             return CAMERA_HAL_ERR_GET_PARAM;
 
+        InitCameraPreviewFormatToParam(i);
+
         if (NegotiateCaptureFmt(false) < 0)
             return CAMERA_HAL_ERR_GET_PARAM;
 
-        CaptureSizeFps.fmt = mPreviewCapturedFormat;
+        CaptureSizeFps.fmt = mCaptureDeviceCfg.fmt;//mPreviewCapturedFormat;
+
+        memset(TmpStr, 0, 20);
+        convertPreviewFormatToString(TmpStr, 20, mCaptureDeviceCfg.fmt);
+        mParameters.setPreviewFormat(TmpStr);
 
-        CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat is %x", mPreviewCapturedFormat);
+        CAMERA_HAL_LOG_INFO("mCaptureDeviceCfg.fmt is %x", mCaptureDeviceCfg.fmt);
 
         for(;;){
             if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
                 CAMERA_HAL_LOG_RUNTIME("get the frame size and time interval error");
                 break;
             }
+            memset(TmpStr, 0, 20);
             sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
             CAMERA_HAL_LOG_INFO("the size is %s , the framerate is %d ", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
             if (previewCnt == 0)
-                strncpy((char*) supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                strncpy((char*) mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
             else{
-                strncat(supportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                strncat(supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                strncat(mSupportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                strncat(mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
             }
             pictureCnt ++;
 
             if (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator > 25){
                 if (previewCnt == 0)
-                    strncpy((char*) supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                    strncpy((char*) mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
                 else{
-                    strncat(supportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                    strncat(supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                    strncat(mSupportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                    strncat(mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
                 }
                 previewCnt ++;
             }
         }
 
         /*hard code here*/
-        strcpy(supportedFPS, "15,30");
-        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", supportedPictureSizes);
-        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", supportedPreviewSizes);
-        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", supportedFPS);
+        strcpy(mSupportedFPS, "15,30");
+        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", mSupportedPictureSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", mSupportedPreviewSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", mSupportedFPS);
 
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, supportedPictureSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, supportedPreviewSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, supportedFPS);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(1000,15000),(5000,30000)");
-        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "5000,30000");
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, mSupportedPictureSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, mSupportedPreviewSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, mSupportedFPS);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(15000,15000),(30000,30000)");
+        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "30000,30000");
 
         pParam->setPreviewSize(640, 480);
         pParam->setPictureSize(640, 480);
@@ -330,7 +403,6 @@ namespace android {
         }
         return ret;
     }
-
     void CameraHal ::CloseCaptureDevice()
     {
         CAMERA_HAL_LOG_FUNC;
@@ -340,7 +412,7 @@ namespace android {
         }
     }
 
-    CAMERA_HAL_ERR_RET CameraHal :: GetPictureExifParam(CameraParameters *pParam)
+    CAMERA_HAL_ERR_RET CameraHal :: InitPictureExifParam(CameraParameters *pParam)
     {
         CAMERA_HAL_LOG_FUNC;
         char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
@@ -350,8 +422,8 @@ namespace android {
         pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
         pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
         pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
-        strcpy(supprotedThumbnailSizes, "0x0,128x128,96x96");
-        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, supprotedThumbnailSizes);
+        strcpy(mSupprotedThumbnailSizes, "0x0,128x128,96x96");
+        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, mSupprotedThumbnailSizes);
         pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
         pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
         pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
@@ -442,7 +514,7 @@ namespace android {
         return NULL;
     }
 
-    status_t CameraHal::dump(int fd, const Vector<String16>& args) const
+    status_t CameraHal::dump(int fd) const
     {
         return NO_ERROR;
     }
@@ -453,15 +525,17 @@ namespace android {
         return BAD_VALUE;
     }
 
-    void CameraHal::setCallbacks(notify_callback notify_cb,
-            data_callback data_cb,
-            data_callback_timestamp data_cb_timestamp,
+    void CameraHal::setCallbacks(camera_notify_callback notify_cb,
+            camera_data_callback data_cb,
+            camera_data_timestamp_callback data_cb_timestamp,
+            camera_request_memory get_memory,
             void* user)
     {
         Mutex::Autolock lock(mLock);
         mNotifyCb = notify_cb;
         mDataCb = data_cb;
         mDataCbTimestamp = data_cb_timestamp;
+        mRequestMemory = get_memory;
         mCallbackCookie = user;
     }
 
@@ -485,12 +559,41 @@ namespace android {
         return (mMsgEnabled & msgType);
     }
 
-    CameraParameters CameraHal::getParameters() const
+    void CameraHal::putParameters(char *params)
+    {
+        free(params);
+    }
+
+    char* CameraHal::getParameters() const
     {
         CAMERA_HAL_LOG_FUNC;
 
         Mutex::Autolock lock(mLock);
-        return mParameters;
+        char* params_string;
+        String8 params_str8;
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        CameraParameters mParams = mParameters;
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+
+        params_str8 = mParams.flatten();
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        params_string = (char*)malloc(sizeof(char) * (params_str8.length() + 1));
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        strcpy(params_string, params_str8.string());
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        return params_string;
+    }
+
+    status_t  CameraHal:: setParameters(const char* params)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CameraParameters parameters;
+        String8 str_params(params);
+
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        parameters.unflatten(str_params);
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        return setParameters(parameters);
     }
 
     status_t  CameraHal:: setParameters(const CameraParameters& params)
@@ -509,8 +612,10 @@ namespace android {
             return BAD_VALUE;
         }
         if (!((strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
-                (strcmp(params.getPreviewFormat(), "yuv420p") == 0))) {
-            CAMERA_HAL_ERR("Only yuv420sp or yuv420p is supported, but input format is %s", params.getPreviewFormat());
+                (strcmp(params.getPreviewFormat(), "yuv420p") == 0)/* || (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0)*/
+                )) {
+            CAMERA_HAL_ERR("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
+            //CAMERA_HAL_ERR("Only yuv420sp,yuv420p or yuv422i-yuyv is supported, but input format is %s", params.getPreviewFormat());
             return BAD_VALUE;
         }
 
@@ -522,7 +627,7 @@ namespace android {
         params.getPreviewSize(&w, &h);
         sprintf(tmp, "%dx%d", w, h);
         CAMERA_HAL_LOG_INFO("##the set preview size is %s ##", tmp);
-        if (strstr(supportedPreviewSizes, tmp) == NULL){
+        if (strstr(mSupportedPreviewSizes, tmp) == NULL){
             CAMERA_HAL_ERR("The preview size w %d, h %d is not corrected", w, h);
             return BAD_VALUE;
         }
@@ -530,7 +635,7 @@ namespace android {
         params.getPictureSize(&w, &h);
         sprintf(tmp, "%dx%d", w, h);
         CAMERA_HAL_LOG_INFO("##the set picture size is %s ##", tmp);
-        if (strstr(supportedPictureSizes, tmp) == NULL){
+        if (strstr(mSupportedPictureSizes, tmp) == NULL){
             CAMERA_HAL_ERR("The picture size w %d, h %d is not corrected", w, h);
             return BAD_VALUE;
         }
@@ -566,24 +671,25 @@ namespace android {
             CAMERA_HAL_ERR("The focus mode is not corrected");
             return BAD_VALUE;
         }
-
         mParameters = params;
+        CAMERA_HAL_LOG_INFO("%s return", __FUNCTION__);
 
         return NO_ERROR;
     }
 
-    status_t CameraHal::setPreviewWindow(const sp<ANativeWindow>& buf)
+    status_t CameraHal::setPreviewWindow(struct preview_stream_ops *window)
     {
         CAMERA_HAL_LOG_FUNC;
-        if(buf == 0) {
+        if(window == NULL) {
             isCaptureBufsAllocated = 0;
             CAMERA_HAL_ERR("the buf is null!");
         }
         else {
             CAMERA_HAL_ERR("the buf is not null!");
         }
-        mNativeWindow = buf;
+        mNativeWindow = window;
         if((mNativeWindow != NULL) && !isCaptureBufsAllocated && mCaptureBufNum) {
+        //if((mNativeWindow != NULL) && !isCaptureBufsAllocated) {
             if(PrepareCaptureBufs() < 0) {
                 CAMERA_HAL_ERR("PrepareCaptureBufs()-2 error");
                 return BAD_VALUE;
@@ -611,17 +717,22 @@ namespace android {
         android_native_buffer_t *buf;
         private_handle_t *handle;
         for(unsigned int i = 0; i < mCaptureBufNum; i++) {
-            if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_QUEUED)
-                continue;
-            mCaptureBuffers[i].buf_state = WINDOW_BUFS_QUEUED;
-            buf = (android_native_buffer_t *)mCaptureBuffers[i].native_buf;
-            if(mCaptureBuffers[i].virt_start != NULL) {
-                handle = (private_handle_t *)buf->handle;
-                mapper.unlock(handle);
-            }
-            if(buf != NULL) {
-                mNativeWindow->cancelBuffer(mNativeWindow.get(), buf);
-            }
+            //if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_DEQUEUED) {    
+                buf = (android_native_buffer_t *)mCaptureBuffers[i].native_buf;
+                if(mCaptureBuffers[i].virt_start != NULL) {
+                    handle = (private_handle_t *)buf->handle;
+                    mapper.unlock(handle);
+                }
+                if(buf != NULL) {
+                    mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                }
+            //}
+            mCaptureBuffers[i].buf_state = WINDOW_BUFS_INVALID;//WINDOW_BUFS_QUEUED;
+            mCaptureBuffers[i].refCount = 0;
+            mCaptureBuffers[i].native_buf = NULL;
+            mCaptureBuffers[i].virt_start = NULL;
+            mCaptureBuffers[i].length = 0;
+            mCaptureBuffers[i].phy_offset = 0;
         }
         mCaptureBufNum = 0;
 
@@ -637,7 +748,7 @@ namespace android {
             CAMERA_HAL_ERR("the native window is null!");
             return NO_ERROR;//BAD_VALUE;
         }
-        status_t err = native_window_set_buffers_geometry(mNativeWindow.get(),
+        status_t err = mNativeWindow->set_buffers_geometry(mNativeWindow,
                 mCaptureDeviceCfg.width, mCaptureDeviceCfg.height, 
                 HAL_PIXEL_FORMAT_YCbCr_420_SP);//mCaptureDeviceCfg.fmt);
         if(err != 0){
@@ -646,7 +757,7 @@ namespace android {
             return err;
         }
 
-        err = native_window_set_usage(mNativeWindow.get(), GRALLOC_USAGE_SW_READ_OFTEN |
+        err = mNativeWindow->set_usage(mNativeWindow, GRALLOC_USAGE_SW_READ_OFTEN |
                 GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HWC_OVERLAY);
         if(err != 0){
             CAMERA_HAL_ERR("native_window_set_usage failed:%s(%d)",
@@ -655,8 +766,8 @@ namespace android {
         }
 
         int minUndequeueBufs = 0;
-        err = mNativeWindow->query(mNativeWindow.get(),
-                NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, &minUndequeueBufs);
+        err = mNativeWindow->get_min_undequeued_buffer_count(mNativeWindow,
+                &minUndequeueBufs);
         if(err != 0) {
             CAMERA_HAL_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
                     strerror(-err), -err);
@@ -668,7 +779,7 @@ namespace android {
             return BAD_VALUE;
         }
 
-        err = native_window_set_buffer_count(mNativeWindow.get(), mCaptureBufNum);
+        err = mNativeWindow->set_buffer_count(mNativeWindow, mCaptureBufNum);
         if(err != 0) {
             CAMERA_HAL_ERR("native_window_set_buffer_count failed:%s(%d)",
                     strerror(-err), -err);
@@ -681,25 +792,29 @@ namespace android {
         GraphicBufferMapper &mapper = GraphicBufferMapper::get();
         for(i = 0; i < mCaptureBufNum; i++) {
             android_native_buffer_t *buf = NULL;
+            buffer_handle_t* buf_h = NULL;
             pVaddr = NULL;
-            err = mNativeWindow->dequeueBuffer(mNativeWindow.get(), &buf);
-            if((err != 0) || (buf == NULL)) {
+            int stride;
+            err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
+            if((err != 0) || (buf_h == NULL)) {
                 CAMERA_HAL_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
-                break;
+                return BAD_VALUE;
             }
+            buf = container_of(buf_h, ANativeWindowBuffer, handle);
             private_handle_t *handle = (private_handle_t *)buf->handle;
             mapper.lock(handle, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &pVaddr);
 
             if((handle->phys == 0) || (handle->base == 0) || (handle->size == 0)) {
                  CAMERA_HAL_ERR("%s: dequeue invalide Buffer, phys=%x, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
-                 mNativeWindow->cancelBuffer(mNativeWindow.get(), buf);
-                 break;
+                 mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                 return BAD_VALUE;
             }
 
             mCaptureBuffers[i].virt_start = (unsigned char *)handle->base;
             mCaptureBuffers[i].phy_offset = handle->phys;
             mCaptureBuffers[i].length = handle->size;
             mCaptureBuffers[i].native_buf = (void *)buf;
+            mCaptureBuffers[i].refCount = 0;
             mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
             CAMERA_HAL_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%x, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
         }
@@ -711,17 +826,48 @@ namespace android {
     {
         CAMERA_HAL_LOG_FUNC;
         status_t ret = NO_ERROR;
+
+        if(mTakePictureInProcess) {
+            mWaitForTakingPicture = true;
+            sem_wait(&mTakingPicture);
+            mWaitForTakingPicture = false;
+	}
         Mutex::Autolock lock(mLock);
         //isPreviewFinsh = 0;
         mEnqueuedBufs = 0;
+
+        mPreviewLock.lock();
         if (mPreviewRunning) {
+            // already running
+            CAMERA_HAL_LOG_RUNTIME("%s : preview thread already running", __func__);
+            mPreviewLock.unlock();
+            return NO_ERROR;//INVALID_OPERATION;
+        }        
+            
+        if ((ret == CameraHALStartPreview())<0) {
+            CAMERA_HAL_LOG_RUNTIME("%s : CameraHALStartPreview error", __func__);
+            mPreviewLock.unlock();
+            return ret;            
+        }
+
+        mPreviewRunning = true;
+        mPreviewLock.unlock();
+        
+        mCaptureLock.lock();
+        if(mCaptureRunning) {
+            CAMERA_HAL_ERR("%s : preview thread already running", __func__);
+            mCaptureLock.unlock();
             return NO_ERROR;
         }
-        if ((ret == CameraHALStartPreview())<0)
-            return ret;
+        mCaptureRunning = true;
+        mCaptureLock.unlock();                  
 
-        if((ret = AllocateRecordVideoBuf())<0)
-            return ret;
+        if(mPPDeviceNeed) {
+            //mPostProcessLock.lock(); 
+            //mPostProcessCondition.signal();
+            //mPostProcessLock.unlock();            
+        }
+    
         LockWakeLock();
         return ret;
     }
@@ -747,81 +893,77 @@ namespace android {
         return mPreviewRunning;
     }
 
-	status_t CameraHal::storeMetaDataInBuffers(bool enable)
-	{
+    status_t CameraHal::storeMetaDataInBuffers(bool enable)
+    {
         CAMERA_HAL_LOG_FUNC;
         unsigned int i;
 
-		bDerectInput = enable;
-		if (bDerectInput == true) {
-			if (!mPPDeviceNeed){
-				for(i = 0 ; i < mCaptureBufNum; i ++) {
-					mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
-					CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mCaptureBuffers[i].phy_offset);
-					mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
-					memcpy(mVideoBuffers[i]->pointer(),
-							(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
-				}
-			}else{
-				for(i = 0 ; i < mPPbufNum; i ++) {
-					mVideoBufferPhy[i].phy_offset = mPPbuf[i].phy_offset;
-					CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mPPbuf[i].phy_offset);
-					mVideoBufferPhy[i].length = mPPbuf[i].length;
-					memcpy(mVideoBuffers[i]->pointer(),
-							(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
-				}
-			}
-		}
-
-		return NO_ERROR;
-	}
-
-	int32_t CameraHal::getNumberOfVideoBuffers() const
-	{
-        CAMERA_HAL_LOG_FUNC;
-
+	bDerectInput = enable;
+	if (bDerectInput == true) {
 		if (!mPPDeviceNeed){
-			return mCaptureBufNum;
+			for(i = 0 ; i < mCaptureBufNum; i ++) {
+				mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
+				CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mCaptureBuffers[i].phy_offset);
+				mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
+				memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
+						(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
+			}
 		}else{
-			return  mPPbufNum;
+			for(i = 0 ; i < mPPbufNum; i ++) {
+				mVideoBufferPhy[i].phy_offset = mPPbuf[i].phy_offset;
+				CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mPPbuf[i].phy_offset);
+				mVideoBufferPhy[i].length = mPPbuf[i].length;
+				memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
+						(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
+			}
 		}
 	}
 
-	sp<IMemory> CameraHal::getVideoBuffer(int32_t index) const
-	{
+	return NO_ERROR;
+    }
+#if 0
+    int32_t CameraHal::getNumberOfVideoBuffers() const
+    {
         CAMERA_HAL_LOG_FUNC;
 
-		return mVideoBuffers[index];
+	if (!mPPDeviceNeed){
+		return mCaptureBufNum;
+	}else{
+		return  mPPbufNum;
 	}
+    }
 
+    sp<IMemory> CameraHal::getVideoBuffer(int32_t index) const
+    {
+        CAMERA_HAL_LOG_FUNC;
+        //this may be done in cameraHardwareInterface
+        //CameraHardwareInterface::CameraHeapMemory* mem;
+        //mem = (CameraHardwareInterface::CameraHeapMemory*)(mVideoMemory->handle);
+	//return mem->mBuffers[index];
+        return mVideoMemory;
+    }
+#endif
     status_t CameraHal::startRecording()
     {
         CAMERA_HAL_LOG_FUNC;
         status_t ret = NO_ERROR;
         unsigned int i;
 
+        mEncodeLock.lock();
         if (mRecordRunning == true ) {
-            CAMERA_HAL_LOG_INFO("Recording is already existed\n");
+            CAMERA_HAL_LOG_INFO("%s: Recording is already existed\n", __FUNCTION__);
+            mEncodeLock.unlock();
             return ret;
         }
-
-        mRecordRunning = true;
-
-		if (bDerectInput == true) {
-			if (!mPPDeviceNeed){
-				for(i = 0 ; i < mCaptureBufNum; i ++) {
-					sem_post(&avab_enc_frame_finish);
-				}
-			}else{
-				for(i = 0 ; i < mPPbufNum; i ++) {
-					sem_post(&avab_enc_frame_finish);
-				}
-			}
-
-			for(i = 0; i < mVideoBufNume; i++) {
-				mVideoBufferUsing[i] = 0;
-			}
+        
+           
+	if (bDerectInput == true) {
+		for(i = 0; i < mVideoBufNume; i++) {
+			mVideoBufferUsing[i] = 0;
 		}
+	}
+	mEncodeLock.unlock();
+        mRecordRunning = true;
 
         return NO_ERROR;
     }
@@ -829,26 +971,36 @@ namespace android {
     void CameraHal::stopRecording()
     {
         CAMERA_HAL_LOG_FUNC;
-        mRecordRunning = false;
-		if (bDerectInput == true) 
-			//bDerectInput = false;
-			sem_post(&avab_enc_frame_finish);
-		}
+        
+        mEncodeLock.lock();        
+
+        if(mRecordRunning) {
+            mRecordRunning = false;
+            mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_STOP, 0));
+            sem_wait(&mEncodeStoppedCondition);
+            CAMERA_HAL_LOG_RUNTIME("---%s, after wait--", __FUNCTION__);
+        }
+		//if(bDerectInput == true) 
+		//	bDerectInput = false;		                
+        mEncodeLock.unlock();
+	}
 
-    void CameraHal::releaseRecordingFrame(const sp<IMemory>& mem)
+    void CameraHal::releaseRecordingFrame(const void* mem)
     {
-        ssize_t offset;
-        size_t  size;
+        //CAMERA_HAL_LOG_FUNC;
         int index;
 
-        offset = mem->offset();
-        size   = mem->size();
-        index = offset / size;
-
+        index = ((size_t)mem - (size_t)mVideoMemory->data) / mPreviewFrameSize;
         mVideoBufferUsing[index] = 0;
 
-		if (bDerectInput == true)
-			sem_post(&avab_enc_frame_finish);
+	if (bDerectInput == true) {
+            if(mCaptureBuffers[index].refCount == 0) {
+                CAMERA_HAL_ERR("warning:%s about to release mCaptureBuffers[%d].refcount=%d-", __FUNCTION__, index, mCaptureBuffers[index].refCount);
+                return;
+            }
+	putBufferCount(&mCaptureBuffers[index]);
+        }
+
     }
 
     bool CameraHal::recordingEnabled()
@@ -884,18 +1036,25 @@ namespace android {
         CAMERA_HAL_LOG_FUNC;
         Mutex::Autolock lock(mLock);
 
-        if (mTakePicThread != NULL)
-            mTakePicThread.clear();
+        //CameraHALStopPreview();
+        if(mTakePictureInProcess) {
+            CAMERA_HAL_ERR("%s: takePicture already in process", __FUNCTION__);
+            return INVALID_OPERATION;
+        }
+
+        if(mTakePicThread->run("takepicThread", PRIORITY_URGENT_DISPLAY) != NO_ERROR) {
+            CAMERA_HAL_ERR("%s: could't run take picture thread", __FUNCTION__);
+            return INVALID_OPERATION;
+        }
+        mTakePictureInProcess = true;
 
-        mTakePicThread= new TakePicThread(this);
-        if (mTakePicThread == NULL)
-            return UNKNOWN_ERROR;
         return NO_ERROR;
     }
 
     status_t CameraHal::cancelPicture()
     {
         CAMERA_HAL_LOG_FUNC;
+        mTakePicThread->requestExitAndWait();
 
         return NO_ERROR;
     }
@@ -920,6 +1079,7 @@ namespace android {
         /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
         CameraHALStopPreview();
         cameraHALTakePicture();
+        mTakePictureInProcess = false;
 
         return UNKNOWN_ERROR;
     }
@@ -930,9 +1090,10 @@ namespace android {
         int ret = NO_ERROR;
         unsigned int DeQueBufIdx = 0;
         struct jpeg_encoding_conf JpegEncConf;
-        DMA_BUFFER Buf_input, Buf_output;
-        sp<MemoryBase> JpegMemBase = NULL;
-        sp<MemoryHeapBase> JpegImageHeap = NULL;
+        DMA_BUFFER *Buf_input, Buf_output;
+        //sp<MemoryBase> JpegMemBase = NULL;
+        //sp<MemoryHeapBase> JpegImageHeap = NULL;
+        camera_memory_t* JpegMemBase = NULL;
         int  max_fps, min_fps;
 
         if (mJpegEncoder == NULL){
@@ -1003,11 +1164,12 @@ namespace android {
             }
         }
 
-        JpegImageHeap= new MemoryHeapBase(mCaptureFrameSize);
-        if (JpegImageHeap == NULL){
+        JpegMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
+        if (JpegMemBase == NULL || JpegMemBase->data == NULL){
             ret = NO_MEMORY;
             goto Pic_out;
         }
+
         // do the csc if necessary
         if (mPPDeviceNeedForPic){
             mPPInputParam.user_def_paddr = mCaptureBuffers[DeQueBufIdx].phy_offset;
@@ -1015,12 +1177,12 @@ namespace android {
             mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
             mPPDevice->DoPorcess(&(mCaptureBuffers[DeQueBufIdx]), &(mPPbuf[0]));
             mPPDevice->PPDeviceDeInit();
-            Buf_input = mPPbuf[0];
+            Buf_input = &mPPbuf[0];
         }else{
-            Buf_input = mCaptureBuffers[DeQueBufIdx];
+            Buf_input = &mCaptureBuffers[DeQueBufIdx];
         }
 
-        Buf_output.virt_start = (unsigned char *)(JpegImageHeap->getBase());
+        Buf_output.virt_start = (unsigned char *)(JpegMemBase->data);
         CAMERA_HAL_LOG_INFO("Generated a picture");
 
         if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
@@ -1028,25 +1190,30 @@ namespace android {
             mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
         }
 
-        if (mJpegEncoder->DoEncode(&Buf_input,&Buf_output,&JpegEncConf) < 0){
+        if (mJpegEncoder->DoEncode(Buf_input,&Buf_output,&JpegEncConf) < 0){
             ret = UNKNOWN_ERROR;
             goto Pic_out;
         }
 
-        JpegMemBase = new MemoryBase(JpegImageHeap, 0, JpegEncConf.output_jpeg_size);
-
 Pic_out:
-        mCaptureDevice->DevStop();
-        //mCaptureDevice->DevDeAllocate();
         freeBuffersToNativeWindow();
-        CloseCaptureDevice();
-
-        if ((JpegMemBase != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
+        //JpegMemBase = new MemoryBase(JpegImageHeap, 0, JpegEncConf.output_jpeg_size);
+        if ((JpegMemBase != NULL) &&(JpegMemBase->data != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
             CAMERA_HAL_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
-            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, mCallbackCookie);
+            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, 0, NULL, mCallbackCookie);
         }
 
+        mCaptureDevice->DevStop();
+        //mCaptureDevice->DevDeAllocate();
+        //freeBuffersToNativeWindow();
+        //CloseCaptureDevice();
 
+        if(JpegMemBase) {
+            JpegMemBase->release(JpegMemBase);
+        }
+        if(mWaitForTakingPicture) {
+            sem_post(&mTakingPicture);
+        }
         return ret;
 
     }
@@ -1106,38 +1273,41 @@ Pic_out:
                 mCaptureDeviceCfg.fmt = mPictureEncodeFormat;
             }
         }else{
-            CAMERA_HAL_LOG_INFO("mPreviewFormat :%c%c%c%c\n",
-                    mPreviewFormat & 0xFF, (mPreviewFormat >> 8) & 0xFF,
-                    (mPreviewFormat >> 16) & 0xFF, (mPreviewFormat >> 24) & 0xFF);
+            CAMERA_HAL_LOG_INFO("mDefaultPreviewFormat :%c%c%c%c\n",
+                    mDefaultPreviewFormat & 0xFF, (mDefaultPreviewFormat >> 8) & 0xFF,
+                    (mDefaultPreviewFormat >> 16) & 0xFF, (mDefaultPreviewFormat >> 24) & 0xFF);
             CAMERA_HAL_LOG_INFO("mUvcSpecialCaptureFormat :%c%c%c%c\n",
                     mUvcSpecialCaptureFormat & 0xFF, (mUvcSpecialCaptureFormat >> 8) & 0xFF,
                     (mUvcSpecialCaptureFormat >> 16) & 0xFF, (mUvcSpecialCaptureFormat >> 24) & 0xFF);
 
-            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
-                if (mCaptureSupportedFormat[i] == mPreviewFormat){
-                    CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
-                    mPPDeviceNeed = false;
-                    mPreviewCapturedFormat = mPreviewFormat;
-                    break;
+            if(mPPDeviceNeed == false) {
+                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                    CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
+                    if (mCaptureSupportedFormat[i] == mDefaultPreviewFormat){
+                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                        //mPPDeviceNeed = false;
+                        //mPreviewCapturedFormat = mPreviewFormat;
+                        mCaptureDeviceCfg.fmt = mDefaultPreviewFormat;
+                        break;
+                    }
                 }
             }
-
-            if (i == MAX_QUERY_FMT_TIMES){
+            else {
                 for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
                     //since for CSI, the CSI can convert to any YUV format if necessary, so specailly is just for UVC
                     if (mCaptureSupportedFormat[i] == mUvcSpecialCaptureFormat){
                         CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
-                        mPPDeviceNeed = true;
-                        mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
+                        //mPPDeviceNeed = true;
+                        //mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
+                        mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat;
                         break;
                     }
                 }
             }
 
-            CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat :%c%c%c%c\n",
-                    mPreviewCapturedFormat & 0xFF, (mPreviewCapturedFormat >> 8) & 0xFF,
-                    (mPreviewCapturedFormat >> 16) & 0xFF, (mPreviewCapturedFormat >> 24) & 0xFF);
+            CAMERA_HAL_LOG_INFO("mCaptureDeviceCfg.fmt :%c%c%c%c\n",
+                    mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
+                    (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
 
             if ((i == MAX_QUERY_FMT_TIMES)){
                 CAMERA_HAL_ERR("Negotiate for the preview format error");
@@ -1342,7 +1512,30 @@ Pic_out:
         return ret;
     }
 
-    status_t CameraHal::convertPreviewFormat(unsigned int *pFormat)
+    status_t CameraHal::convertPreviewFormatToString(char *pStr, int length, unsigned int format)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(pStr == NULL || length < 10) {
+            CAMERA_HAL_ERR("%s: invalide parameters", __FUNCTION__);
+            return BAD_VALUE;
+        }
+        if(format == v4l2_fourcc('Y','U','1','2')) {
+            strcpy(pStr, "yuv420p");
+        }
+        else if(format == v4l2_fourcc('N','V','1','2')) {
+            strcpy(pStr, "yuv420sp");
+        }
+        //else if(format == v4l2_fourcc('Y','U','Y','V')) {
+        //    strcpy(pStr, "yuv422i-yuyv");
+        //}
+        else {
+            CAMERA_HAL_ERR("%s: Only YU12 or NV12 is supported", __FUNCTION__);
+            return BAD_VALUE;
+        }
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::convertStringToPreviewFormat(unsigned int *pFormat)
     {
         CAMERA_HAL_LOG_FUNC;
         if(!strcmp(mParameters.getPreviewFormat(), "yuv420p")) {
@@ -1351,6 +1544,9 @@ Pic_out:
         else if(!strcmp(mParameters.getPreviewFormat(), "yuv420sp")) {
             *pFormat = v4l2_fourcc('N','V','1','2');
         }
+        //else if(!strcmp(mParameters.getPreviewFormat(), "yuv422i-yuyv")) {
+        //    *pFormat = v4l2_fourcc('Y','U','Y','V');
+        //}
         else {
             CAMERA_HAL_ERR("Only yuv420sp or yuv420p is supported");
             return BAD_VALUE;
@@ -1366,11 +1562,13 @@ Pic_out:
 
         mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
 
-        if ((ret = convertPreviewFormat(&mPreviewCapturedFormat)) != 0) {
+        if ((ret = convertStringToPreviewFormat(&mPreviewCapturedFormat)) != 0) {
+            CAMERA_HAL_ERR("%s: convertStringToPreviewFormat error", __FUNCTION__);
             return ret;
         }
 
         mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
+        CAMERA_HAL_LOG_RUNTIME("*********%s,mCaptureDeviceCfg.fmt=%x************", __FUNCTION__, mCaptureDeviceCfg.fmt);
         mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
         mCaptureDeviceCfg.tv.numerator = 1;
         mCaptureDevice->GetDevName(mCameraSensorName);
@@ -1417,7 +1615,7 @@ Pic_out:
                 return ret;
             }
         }
-        mPreviewRunning = true;
+        //mPreviewRunning = true;
         return ret;
     }
     void CameraHal::CameraHALStopPreview()
@@ -1426,51 +1624,58 @@ Pic_out:
         if (mPreviewRunning != 0)	{
             CameraHALStopThreads();
             CameraHALStopMisc();
+            mCaptureBufNum = 0;
             CAMERA_HAL_LOG_INFO("camera hal stop preview done");
         }else{
             CAMERA_HAL_LOG_INFO("Camera hal already stop preview");
         }
-        mCaptureBufNum = 0;
+        //mCaptureBufNum = 0;
         return ;
     }
 
     void CameraHal :: CameraHALStopThreads()
     {
         CAMERA_HAL_LOG_FUNC;
-        mPreviewRunning = 0;
-        if (mCaptureFrameThread!= 0){
-            mCaptureFrameThread->requestExitAndWait();
-            mCaptureFrameThread.clear();
-        }
-        if (mPPDeviceNeed){
-            if (mPostProcessThread!= 0){
-                mPostProcessThread->requestExitAndWait();
-                mPostProcessThread.clear();
-            }
+        
+        mCaptureLock.lock();
+        if(mCaptureRunning) {
+            CAMERA_HAL_LOG_INFO("%s :capture run", __FUNCTION__);
+            mCaptureThreadQueue.postStopMessage();
+            mCaptureRunning = false;
+            sem_wait(&mCaptureStoppedCondition);
+        }else {
+            CAMERA_HAL_LOG_INFO("%s :capture not run", __FUNCTION__);
         }
-        if (mPreviewShowFrameThread!= 0){
-            mPreviewShowFrameThread->requestExitAndWait();
-            mPreviewShowFrameThread.clear();
+        mCaptureLock.unlock();
+        CAMERA_HAL_LOG_INFO("%s :---------", __FUNCTION__);
+
+        mPostProcessLock.lock(); 
+        if(mPPDeviceNeed && mPreviewRunning) {
+            CAMERA_HAL_LOG_INFO("%s :postprocess run", __FUNCTION__);
+            mPostProcessThreadQueue.postStopMessage();
+            sem_wait(&mPostProcessStoppedCondition);
         }
+        mPostProcessLock.unlock(); 
 
-        if (mEncodeFrameThread!= 0){
-            mEncodeFrameThread->requestExitAndWait();
-            mEncodeFrameThread.clear();
+        mPreviewLock.lock();
+        if(mPreviewRunning) {
+            CAMERA_HAL_LOG_INFO("%s :preview run", __FUNCTION__);
+            mPreviewThreadQueue.postStopMessage();
+            mPreviewRunning = false;
+            sem_wait(&mPreviewStoppedCondition);
+        }else {
+            CAMERA_HAL_LOG_INFO("%s :preview not run", __FUNCTION__);
         }
+        mPreviewLock.unlock();
+        CAMERA_HAL_LOG_INFO("%s :exit", __FUNCTION__);
+        
         return ;
     }
 
     void CameraHal :: CameraHALStopMisc()
     {
         CAMERA_HAL_LOG_FUNC;
-        sem_destroy(&avab_dequeue_frame);
-        sem_destroy(&avab_show_frame);
-        sem_destroy(&avab_enc_frame);
-        sem_destroy(&avab_enc_frame_finish);
-        if(mPPDeviceNeed){
-            sem_destroy(&avab_pp_in_frame);
-            sem_destroy(&avab_pp_out_frame);
-        }
+
         if(mPPDeviceNeed){
             for (unsigned int i = 0; i < mPPbufNum; i++){
                 mPmemAllocator->deAllocate(&mPPbuf[i]);
@@ -1480,14 +1685,17 @@ Pic_out:
         mCaptureDevice->DevStop();
         //mCaptureDevice->DevDeAllocate();
         freeBuffersToNativeWindow();
-        CloseCaptureDevice();
-
+        //CloseCaptureDevice();
+        //mCaptureBufNum = 0;
     }
 
     status_t CameraHal :: PrepareCaptureBufs()
     {
         CAMERA_HAL_LOG_FUNC;
         //status_t ret = NO_ERROR;
+        //if(mCaptureBufNum == 0) {
+        //    mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
+        //}
         unsigned int CaptureBufNum = mCaptureBufNum;
         
         if(allocateBuffersFromNativeWindow() < 0) {
@@ -1512,6 +1720,11 @@ Pic_out:
         nCameraBuffersQueued = mCaptureBufNum;
         isCaptureBufsAllocated = 1;
 
+        if((AllocateRecordVideoBuf())<0) {
+            CAMERA_HAL_LOG_INFO("%s: AllocateRecordVideoBuf error\n", __FUNCTION__);
+            return BAD_VALUE;
+        }
+ 
         return NO_ERROR;
     }
 
@@ -1550,7 +1763,7 @@ Pic_out:
         if (mTakePicFlag)
             targetFmt = mPictureEncodeFormat;
         else
-            targetFmt = mPreviewFormat;
+            targetFmt = mDefaultPreviewFormat;
 
         pthread_mutex_lock(&mPPIOParamMutex);
         mPPInputParam.width = mCaptureDeviceCfg.width;
@@ -1586,15 +1799,24 @@ Pic_out:
             else 
                 mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
 
-            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
-            mPreviewHeap.clear();
-            for (i = 0; i< mPreviewHeapBufNum; i++)
-                mPreviewBuffers[i].clear();
-            mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
-            if (mPreviewHeap == NULL)
+            if(mPreviewMemory != NULL) {
+                mPreviewMemory->release(mPreviewMemory);
+            }
+
+            mPreviewMemory = mRequestMemory(-1, mPreviewFrameSize, mPreviewHeapBufNum, NULL);
+            if(mPreviewMemory == NULL) {
+                CAMERA_HAL_ERR("%s, allocate memory failed", __FUNCTION__);
                 return NO_MEMORY;
-            for (i = 0; i < mPreviewHeapBufNum; i++)
-                mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
+            }
+            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
+            //mPreviewHeap.clear();
+            //for (i = 0; i< mPreviewHeapBufNum; i++)
+            //    mPreviewBuffers[i].clear();
+            //mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
+            //if (mPreviewHeap == NULL)
+            //    return NO_MEMORY;
+            //for (i = 0; i < mPreviewHeapBufNum; i++)
+            //    mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
         }
         /*allocate the buffer for IPU process*/
         if (mPPDeviceNeed || mPPDeviceNeedForPic){
@@ -1626,10 +1848,13 @@ Pic_out:
         is_first_buffer = 1;
         last_display_index = 0;
 
-        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
-        sem_init(&avab_show_frame, 0, 0);
-        sem_init(&avab_enc_frame, 0, 0);
-		sem_init(&avab_enc_frame_finish, 0, 0);
+        //for(unsigned int i=0; i < mCaptureBufNum; i++) {
+        //    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
+        //}
+//        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
+//        sem_init(&avab_show_frame, 0, 0);
+//        sem_init(&avab_enc_frame, 0, 0);
+//		sem_init(&avab_enc_frame_finish, 0, 0);
 		if(mPPDeviceNeed){
             sem_init(&avab_pp_in_frame, 0, 0);
             sem_init(&avab_pp_out_frame, 0, mPPbufNum);
@@ -1643,109 +1868,226 @@ Pic_out:
         status_t ret = NO_ERROR;
         if (mCaptureDevice->DevStart()<0)
             return INVALID_OPERATION;
-
-        mCaptureFrameThread = new CaptureFrameThread(this);
-        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
-        mEncodeFrameThread = new EncodeFrameThread(this);
-        if(mPPDeviceNeed){
-            mPostProcessThread = new PostProcessThread(this);
-            if (mPostProcessThread == NULL)
-                return UNKNOWN_ERROR;
+        
+        isCaptureBufsAllocated = 1;
+        for(unsigned int i=0; i < mCaptureBufNum; i++) {
+            mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
+        }
+        return ret;
+    }
+    
+    status_t CameraHal::putBufferCount(DMA_BUFFER *pBuf)
+    {
+        if(pBuf == NULL)
+            return INVALID_OPERATION;
+            
+        Mutex::Autolock _l(pBuf->mBufferLock);
+        pBuf->refCount --;
+        if(pBuf->refCount == 0) {
+            if(!mPPDeviceNeed && mNativeWindow != 0 && mCaptureRunning) {
+                unsigned int buf_index = -1;    
+                //queue the v4l2 buf back
+                android_native_buffer_t *buf = NULL;
+                buffer_handle_t *buf_h = NULL;
+                int stride;
+                int err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
+                if((err != 0) || buf_h == NULL) {
+                    CAMERA_HAL_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
+                    return INVALID_OPERATION;
+                }
+                buf = container_of(buf_h, ANativeWindowBuffer, handle);
+                //mNativeWindow->lockBuffer(mNativeWindow.get(), buf);
+                SearchBuffer((void *)buf, &buf_index);
+                if(buf_index < mCaptureBufNum) {
+                    if(mCaptureDevice->DevQueue(buf_index) <0){
+                        CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
+                        mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                        return INVALID_OPERATION;
+                    }
+                    mCaptureBuffers[buf_index].buf_state = WINDOW_BUFS_DEQUEUED;
+                    mCaptureBuffers[buf_index].refCount = 0;
+                    nCameraBuffersQueued++;
+                    mEnqueuedBufs --;
+                    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, buf_index));
+                }else {
+                    mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                    CAMERA_HAL_ERR("dequeue invalide buffer!!!!");
+                    return INVALID_OPERATION;
+                }                  
+            }else if(mPPDeviceNeed){
+                mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, 0));
+            }//end elseif            
         }
+        return NO_ERROR;
+    }
+    
+    void CameraHal ::getBufferCount(DMA_BUFFER *pBuf)
+    {
+        if(pBuf == NULL)
+            return;
+        Mutex::Autolock _l(pBuf->mBufferLock);
+        pBuf->refCount ++;        
+    }
 
-        if (mCaptureFrameThread == NULL ||
-                mPreviewShowFrameThread == NULL ||
-                mEncodeFrameThread == NULL){
-            return UNKNOWN_ERROR;
+    int CameraHal ::captureframeThreadWrapper() 
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        while(1) {
+            if(mExitCaptureThread) {
+                CAMERA_HAL_LOG_INFO("%s: exiting normally", __FUNCTION__);
+                return 0;
+            }
+            ret = captureframeThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s: capture thread exit with exception", __FUNCTION__);
+                return ret;
+            }
         }
-        //mPreviewRunning = true;
-        isCaptureBufsAllocated = 1;
         return ret;
     }
 
-
     int CameraHal ::captureframeThread()
     {
-        CAMERA_HAL_LOG_FUNC;
-
-        unsigned int DeqBufIdx = 0;
-        struct timespec ts;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_dequeue_frame, &ts) != 0) );
-
-        if(!mPreviewRunning || error_status)
-            return UNKNOWN_ERROR;
-
-        mCaptureDevice->DevDequeue(&DeqBufIdx);
-
-        nCameraBuffersQueued--;
+        //CAMERA_HAL_LOG_FUNC;
+        
+        unsigned int bufIndex = -1;
+        status_t ret = NO_ERROR;
+        sp<CMessage> msg = mCaptureThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;            
+        }
+                
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                ret = mCaptureDevice->DevDequeue(&bufIndex);
+                //handle the error return.
+                if(ret < 0) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer", __FUNCTION__);
+                    mCaptureThreadQueue.postQuitMessage();
+                    return NO_ERROR;
+                }
+                //handle the normal return.
+                if(!mPPDeviceNeed) {
+                    getBufferCount(&mCaptureBuffers[bufIndex]);
+                    mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                    
+                    if(mRecordRunning) {
+                        getBufferCount(&mCaptureBuffers[bufIndex]);
+                        //CAMERA_HAL_LOG_INFO("%s: post encode message %d", __FUNCTION__, bufIndex);
+                        mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                    }
+                }else {
+                    getBufferCount(&mCaptureBuffers[bufIndex]);
+                    mPostProcessThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                }
+                break;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: capture thread stop", __FUNCTION__);
+                mCaptureThreadQueue.clearMessage();
+                sem_post(&mCaptureStoppedCondition);
+                CAMERA_HAL_LOG_INFO("%s: capture thread stop finish", __FUNCTION__);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitCaptureThread = 1;
+                if(!mPPDeviceNeed) {
+                    mPreviewThreadQueue.postQuitMessage();
+                    if(mRecordRunning)
+                        mEncodeThreadQueue.postQuitMessage();
+                }else {
+                    mPostProcessThreadQueue.postQuitMessage();
+                }
+                break;
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;
+        }//end switch
+        
+        return ret;
+    }
 
-        buffer_index_maps[dequeue_head]=DeqBufIdx;
-        dequeue_head ++;
-        dequeue_head %= mCaptureBufNum;
+    int CameraHal::postprocessThreadWrapper()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
 
-        if(!mPPDeviceNeed){
-            sem_post(&avab_show_frame);
-            sem_post(&avab_enc_frame);
-        }else{
-            sem_post(&avab_pp_in_frame);
+        while(1) {
+            if(mExitPostProcessThread) {
+                CAMERA_HAL_LOG_INFO("%s, postprocessThread exit normally", __FUNCTION__);
+                return ret;
+            }
+            ret = postprocessThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s, postprocessThread exit with exception", __FUNCTION__);
+                return ret;
+            }
         }
-
-        return NO_ERROR;
+        return ret;
     }
 
     int CameraHal::postprocessThread()
     {
-        CAMERA_HAL_LOG_FUNC;
         int PPInIdx = 0, PPoutIdx = 0;
-        DMA_BUFFER PPInBuf, PPoutBuf;
-        struct timespec ts;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_in_frame, &ts) != 0) );
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_out_frame, &ts) != 0) );
-
-
-        if(!mPreviewRunning || error_status)
-            return UNKNOWN_ERROR;
-        PPInIdx = buffer_index_maps[pp_in_head];
-        PPInBuf = mCaptureBuffers[PPInIdx];
-        pp_in_head ++;
-        pp_in_head %= mCaptureBufNum;
-
-        PPoutIdx = pp_out_head;
-        PPoutBuf = mPPbuf[PPoutIdx];
-        pp_out_head ++;
-        pp_out_head %= mPPbufNum;
-
-        pthread_mutex_lock(&mPPIOParamMutex);
-        mPPInputParam.user_def_paddr = PPInBuf.phy_offset;
-        mPPOutputParam.user_def_paddr = PPoutBuf.phy_offset;
-        mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
-        mPPDevice->DoPorcess(&PPInBuf, &PPoutBuf);
-        mPPDevice->PPDeviceDeInit();
-        pthread_mutex_unlock(&mPPIOParamMutex);
-
-        sem_post(&avab_show_frame);
-        sem_post(&avab_enc_frame);
-
-        if (mCaptureDevice->DevQueue(PPInIdx) < 0){
-            CAMERA_HAL_ERR("queue buf back error");
-            return INVALID_OPERATION;
+        DMA_BUFFER *PPInBuf, *PPoutBuf;
+        status_t ret = NO_ERROR;
+        
+        sp<CMessage> msg = mPostProcessThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;
         }
-        nCameraBuffersQueued ++;
-        sem_post(&avab_dequeue_frame);
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                PPInIdx = msg->arg0;
+                if(PPInIdx < 0 || (unsigned int)PPInIdx >= mCaptureBufNum) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    return BAD_VALUE;  
+                }
+                PPInBuf = &mCaptureBuffers[PPInIdx];
+                PPoutIdx = pp_out_head;
+                PPoutBuf = &mPPbuf[PPoutIdx];
+                pp_out_head ++;
+                pp_out_head %= mPPbufNum;
+
+                pthread_mutex_lock(&mPPIOParamMutex);
+                mPPInputParam.user_def_paddr = PPInBuf->phy_offset;
+                mPPOutputParam.user_def_paddr = PPoutBuf->phy_offset;
+                mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
+                mPPDevice->DoPorcess(PPInBuf, PPoutBuf);
+                mPPDevice->PPDeviceDeInit();
+                pthread_mutex_unlock(&mPPIOParamMutex);
+
+                getBufferCount(&mPPbuf[PPoutIdx]);
+                mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, PPoutIdx));
+                
+                if(mRecordRunning) {
+                    getBufferCount(&mPPbuf[PPoutIdx]);
+                    //CAMERA_HAL_LOG_INFO("%s: post encode message %d", __FUNCTION__, PPoutIdx);
+                    mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, PPoutIdx));
+                }
 
-        return NO_ERROR;
+                ret = putBufferCount(PPInBuf);                       
+                break;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: postprocess thread stop", __FUNCTION__);
+                mPostProcessThreadQueue.clearMessage();
+                sem_post(&mPostProcessStoppedCondition);
+                CAMERA_HAL_LOG_INFO("%s: postprocess thread stop finish", __FUNCTION__);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitPostProcessThread = 1;
+                mPreviewThreadQueue.postQuitMessage();
+                if(mRecordRunning)
+                    mEncodeThreadQueue.postQuitMessage();
+                break;
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;
+        }
+        return ret;
     }
 
     void CameraHal::SearchBuffer(void *pNativeBuf, unsigned int *pIndex)
@@ -1761,51 +2103,27 @@ Pic_out:
         *pIndex = -1;
         return;
     }
-
-    int CameraHal ::previewshowFrameThread()
+    
+    int CameraHal ::previewshowFrameThreadWrapper()
     {
         CAMERA_HAL_LOG_FUNC;
-        struct timespec ts;
-        int display_index = 0;
-        //DMA_BUFFER InBuf;
-        DMA_BUFFER *pInBuf = NULL;
-        unsigned int queue_back_index = 0;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (!error_status && mPreviewRunning &&(sem_timedwait(&avab_show_frame, &ts) != 0) );
-
-        if ((mPreviewRunning == 0) || error_status)
-            return UNKNOWN_ERROR;
-
-        if (!mPPDeviceNeed){
-            display_index = buffer_index_maps[display_head];
-            //InBuf = mCaptureBuffers[display_index];
-            pInBuf = &mCaptureBuffers[display_index];
-            display_head ++;
-            display_head %= mCaptureBufNum;
-        }else{
-            display_index = display_head;
-            //InBuf = mPPbuf[display_index];
-            pInBuf = &mCaptureBuffers[display_index];
-            display_head ++;
-            display_head %= mPPbufNum;
-        }
-
-        if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-            convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
-                    (uint8_t*)(mPreviewBuffers[preview_heap_buf_head]->pointer()),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
-            mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewBuffers[preview_heap_buf_head], mCallbackCookie);
-            preview_heap_buf_head ++;
-            preview_heap_buf_head %= mPreviewHeapBufNum;
+        status_t ret = NO_ERROR;
+        while(1) {
+            if(mExitPreviewThread) {
+                CAMERA_HAL_LOG_INFO("%s: exiting", __FUNCTION__);
+                return 0;
+            }
+            ret = previewshowFrameThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s: capture thread exit with exception", __FUNCTION__);
+                return ret;
+            }            
         }
+        return ret;
+    }
 
-        if (mNativeWindow != 0) {
-            if (mNativeWindow->queueBuffer(mNativeWindow.get(), (android_native_buffer_t * )pInBuf->native_buf) < 0){
-                CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
-            }
-            pInBuf->buf_state = WINDOW_BUFS_QUEUED;
+    static void bufferDump(DMA_BUFFER *pBufs)
+    {
 #ifdef FSL_CAMERAHAL_DUMP
             //for test code
             char value[10] = {0};
@@ -1825,126 +2143,188 @@ Pic_out:
                 }
                 vflg = 0;
             }
-#endif            
-            mEnqueuedBufs ++;
+#endif                    
+    }
+    
+    int CameraHal ::previewshowFrameThread()
+    {
+        //CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int display_index;
+        DMA_BUFFER *pInBuf = NULL;
+        
+        sp<CMessage> msg = mPreviewThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;            
+        }
+                
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                display_index = msg->arg0;
+                if(display_index < 0 || (unsigned int)display_index >= mCaptureBufNum) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    return BAD_VALUE;  
+                }
+                                
+                if(!mPPDeviceNeed) {
+                    pInBuf = &mCaptureBuffers[display_index];
+                }else {
+                    pInBuf = &mPPbuf[display_index];
+                }
+                
+                if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
+                    //CAMERA_HAL_ERR("*******CAMERA_MSG_PREVIEW_FRAME*******");
+                    convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
+                            (uint8_t*)((unsigned char*)mPreviewMemory->data + preview_heap_buf_head*mPreviewFrameSize),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
+                    mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, preview_heap_buf_head, NULL, mCallbackCookie);
+                    preview_heap_buf_head ++;
+                    preview_heap_buf_head %= mPreviewHeapBufNum;
+                }                
+
+                if (mNativeWindow != 0) {
+                    if (mNativeWindow->enqueue_buffer(mNativeWindow, &((android_native_buffer_t * )pInBuf->native_buf)->handle) < 0){
+                        CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
+                        return BAD_VALUE;
+                    }
+                    pInBuf->buf_state = WINDOW_BUFS_QUEUED;
 
-            if (mEnqueuedBufs <= 2) {
-                return NO_ERROR;
-            }
+                    mEnqueuedBufs ++;
+                    bufferDump(pInBuf);
+                    if (mEnqueuedBufs <= 2) {
+                        return NO_ERROR;
+                    }
+                } 
+                
+                ret = putBufferCount(pInBuf);                       
+                break;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: preview thread stop", __FUNCTION__);
+                mPreviewThreadQueue.clearMessage();
+                sem_post(&mPreviewStoppedCondition);
+                CAMERA_HAL_LOG_INFO("%s: preview thread stop finish", __FUNCTION__);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitPreviewThread = 1;
+                break;
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;   
         }
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=200000; // 100ms
-        } while ((sem_timedwait(&avab_enc_frame_finish, &ts) != 0)&&!error_status && mPreviewRunning );
-
-        if (!mPPDeviceNeed && mNativeWindow != 0){
-            //queue the v4l2 buf back
-            android_native_buffer_t *buf = NULL;
-            int err = mNativeWindow->dequeueBuffer(mNativeWindow.get(), &buf);
-            if((err != 0) || buf == NULL) {
-                CAMERA_HAL_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
-                return INVALID_OPERATION;
+        
+        return ret;
+    }
+    
+    int CameraHal::encodeframeThreadWrapper()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        while(1) {
+            if(mExitEncodeThread) {
+                CAMERA_HAL_ERR("%s: encode thread exit normally", __FUNCTION__);
+                return 0;
             }
-
-            SearchBuffer((void *)buf, &queue_back_index);
-            if(queue_back_index < mCaptureBufNum) {
-                if(mCaptureDevice->DevQueue(queue_back_index) <0){
-                    CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
-                    mNativeWindow->cancelBuffer(mNativeWindow.get(), buf);
-                    return INVALID_OPERATION;
-                }
-                mCaptureBuffers[queue_back_index].buf_state = WINDOW_BUFS_DEQUEUED;
-                nCameraBuffersQueued++;
-                mEnqueuedBufs --;
-                sem_post(&avab_dequeue_frame);
-            }else {
-                mNativeWindow->cancelBuffer(mNativeWindow.get(), buf);
-                CAMERA_HAL_ERR("dequeue invalide buffer!!!!");
-                return INVALID_OPERATION;
+            ret = encodeframeThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s: encode thread exit with exception", __FUNCTION__);
+                return ret;
             }
-        }else{
-            sem_post(&avab_pp_out_frame);
         }
-
-        return NO_ERROR;
+        return ret;
     }
-
-    int CameraHal :: encodeframeThread()
+    
+    int CameraHal::encodeframeThread()
     {
-        CAMERA_HAL_LOG_FUNC;
-        struct timespec ts;
-        unsigned int enc_index = 0, i = 0;
-        DMA_BUFFER EncBuf;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while ((sem_timedwait(&avab_enc_frame, &ts) != 0) && !error_status &&  mPreviewRunning );
+        //CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int enc_index;
+        sp<CMessage> msg = mEncodeThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;            
+        }
+            
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                enc_index = msg->arg0;
+                unsigned int i;
+                if(enc_index < 0 || (unsigned int)enc_index >= mCaptureBufNum) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    return BAD_VALUE;  
+                }
+                
+                struct timespec ts;
+                DMA_BUFFER *EncBuf;
+                if (!mPPDeviceNeed){
+                    EncBuf = &mCaptureBuffers[enc_index];
+                }else{
+                    EncBuf = &mPPbuf[enc_index];
+                }
 
-        if ((mPreviewRunning == 0) || error_status)
-            return UNKNOWN_ERROR;
+                if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
+                    nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
+                    if (bDerectInput == true) {
+	                memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
+			          (void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
+                    } else {
+	                memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
+			          (void*)EncBuf->virt_start, mPreviewFrameSize);
+	                ret = putBufferCount(EncBuf);
+                    }
 
-        if (!mPPDeviceNeed){
-            enc_index = buffer_index_maps[enc_head];
-            EncBuf = mCaptureBuffers[enc_index];
-            enc_head ++;
-            enc_head %= mCaptureBufNum;
-        }else{
-            enc_index = enc_head;
-            EncBuf = mPPbuf[enc_index];
-            enc_head ++;
-            enc_head %= mPPbufNum;
-        }
-
-        if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
-            nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
-            for(i = 0 ; i < mVideoBufNume; i ++) {
-				if(mVideoBufferUsing[i] == 0) {
-					if (bDerectInput == true) {
-						memcpy(mVideoBuffers[i]->pointer(),
-								(void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
-					} else {
-						memcpy(mVideoBuffers[i]->pointer(),
-								(void*)EncBuf.virt_start, mPreviewFrameSize);
-					}
-
-                    mVideoBufferUsing[i] = 1;
-                    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoBuffers[i], mCallbackCookie);
-                    break;
+		    mVideoBufferUsing[enc_index] = 1;
+		    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoMemory, enc_index, mCallbackCookie);
+		    break;
+                }else {
+                    ret = putBufferCount(EncBuf);
                 }
-            }
-            if (i == mVideoBufNume)
-                CAMERA_HAL_LOG_INFO("no Buffer can be used for record\n");
-        }
-
-		if (!(bDerectInput == true && mRecordRunning == true))
-			sem_post(&avab_enc_frame_finish);
+                break;
 
-        return NO_ERROR;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: encode thread stop", __FUNCTION__);
+                //mEncodeThreadQueue.clearMessage();
+                sem_post(&mEncodeStoppedCondition);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitEncodeThread = 1;
+                break;                
 
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;                   
+        }
+        
+        return ret;
     }
 
-
     status_t CameraHal :: AllocateRecordVideoBuf()
     {
         status_t ret = NO_ERROR;
         unsigned int i = 0;
-        mVideoHeap.clear();
-        for(i = 0; i < mVideoBufNume; i++) {
-            mVideoBuffers[i].clear();
-            mVideoBufferUsing[i] = 0;
+        //mVideoHeap.clear();
+        if(mVideoMemory != NULL) {
+            mVideoMemory->release(mVideoMemory);
         }
+        //for(i = 0; i < mVideoBufNume; i++) {
+        //    mVideoBuffers[i].clear();
+        //    mVideoBufferUsing[i] = 0;
+        //}
 
         CAMERA_HAL_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
-        mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
-        if (mVideoHeap == NULL)
+        //mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
+        mVideoMemory = mRequestMemory(-1, mPreviewFrameSize, mVideoBufNume, NULL);
+        //if (mVideoHeap == NULL)
+        if(mVideoMemory == NULL) {
+            CAMERA_HAL_ERR("%s, request video buffer failed", __FUNCTION__);
             return NO_MEMORY;
-        for(i = 0; i < mVideoBufNume; i++) {
-            CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
-            mVideoBuffers[i] = new MemoryBase(mVideoHeap,
-                    mPreviewFrameSize * i, mPreviewFrameSize);
         }
+        //for(i = 0; i < mVideoBufNume; i++) {
+        //    CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
+        //    mVideoBuffers[i] = new MemoryBase(mVideoHeap,
+        //            mPreviewFrameSize * i, mPreviewFrameSize);
+        //}
 
         return ret;
     }
@@ -2034,7 +2414,7 @@ Pic_out:
 
     }
 
-
+#if 0
 #define FACE_BACK_CAMERA_NAME "back_camera_name"
 #define FACE_FRONT_CAMERA_NAME "front_camera_name"
 #define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
@@ -2149,7 +2529,7 @@ Pic_out:
         return hardware;
     }
 
+#endif
 };
 
 
-
diff --git a/mx5x/libcamera/CameraHal.h b/mx5x/libcamera/CameraHal.h
index 4095295..1de9749 100755
--- a/mx5x/libcamera/CameraHal.h
+++ b/mx5x/libcamera/CameraHal.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 
@@ -36,14 +36,15 @@
 #include <utils/threads.h>
 #include <binder/MemoryBase.h>
 #include <binder/MemoryHeapBase.h>
-#include <camera/CameraHardwareInterface.h>
-//#include <ui/Overlay.h>
+#include <camera/CameraParameters.h>
+#include <hardware/camera.h>
 #include <semaphore.h>
 
 #include "Camera_pmem.h"
 #include "CaptureDeviceInterface.h"
 #include "PostProcessDeviceInterface.h"
 #include "JpegEncoderInterface.h"
+#include "messageQueue.h"
 
 
 #define EXIF_MAKENOTE "fsl_makernote"
@@ -84,15 +85,22 @@ namespace android {
         CAMERA_PREVIEW_ROATE_LAST = 3
 	}CAMERA_PREVIEW_ROTATE;
 
-    class CameraHal : public CameraHardwareInterface {
+#ifndef container_of
+#define container_of(ptr, type, member) ({                      \
+        const typeof(((type *) 0)->member) *__mptr = (ptr);     \
+        (type *) ((char *) __mptr - (char *)(&((type *)0)->member)); })
+#endif
+
+    class CameraHal {
     public:
         //virtual sp<IMemoryHeap> getPreviewHeap() const;
         virtual sp<IMemoryHeap> getRawHeap() const;
 
-        virtual status_t setPreviewWindow(const sp<ANativeWindow>& buf);
-        virtual void        setCallbacks(notify_callback notify_cb,
-                data_callback data_cb,
-                data_callback_timestamp data_cb_timestamp,
+        virtual status_t setPreviewWindow(struct preview_stream_ops *window);
+        virtual void        setCallbacks(camera_notify_callback notify_cb,
+                camera_data_callback data_cb,
+                camera_data_timestamp_callback data_cb_timestamp,
+                camera_request_memory get_memory,
                 void* user);
 
         virtual void        enableMsgType(int32_t msgType);
@@ -104,21 +112,23 @@ namespace android {
         virtual bool        previewEnabled();
 
 		virtual status_t  storeMetaDataInBuffers(bool enable);
-		virtual int32_t getNumberOfVideoBuffers() const;
-		virtual sp<IMemory> getVideoBuffer(int32_t index) const;
+		//virtual int32_t getNumberOfVideoBuffers() const;
+		//virtual sp<IMemory> getVideoBuffer(int32_t index) const;
 
         virtual status_t    startRecording();
         virtual void        stopRecording();
         virtual bool        recordingEnabled();
-        virtual void        releaseRecordingFrame(const sp<IMemory>& mem);
+        virtual void        releaseRecordingFrame(const void*  mem);
 
         virtual status_t    autoFocus();
         virtual status_t    cancelAutoFocus();
         virtual status_t    takePicture();
         virtual status_t    cancelPicture();
-        virtual status_t    dump(int fd, const Vector<String16>& args) const;
+        virtual status_t    dump(int fd) const;
         virtual status_t    setParameters(const CameraParameters& params);
-        virtual CameraParameters  getParameters() const;
+        virtual status_t    setParameters(const char* params);
+        virtual char*  getParameters() const;
+        void putParameters(char *);
         virtual status_t    sendCommand(int32_t command, int32_t arg1,
                 int32_t arg2);
         virtual void release();
@@ -129,7 +139,7 @@ namespace android {
         CAMERA_HAL_ERR_RET  Init();
         void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
 
-        CameraHal();
+        CameraHal(int cameraid);
         virtual             ~CameraHal();
 
     private:
@@ -143,8 +153,8 @@ namespace android {
                 run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
             }
             virtual bool threadLoop() {
-                mHardware->captureframeThread();
-                return true;
+                mHardware->captureframeThreadWrapper();
+                return false;
             }
         };
 
@@ -157,8 +167,8 @@ namespace android {
                 run("PostProcessThread", PRIORITY_URGENT_DISPLAY);
             }
             virtual bool threadLoop() {
-                mHardware->postprocessThread();
-                return true;
+                mHardware->postprocessThreadWrapper();
+                return false;
             }
         };
 
@@ -172,8 +182,8 @@ namespace android {
                 run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
             }
             virtual bool threadLoop() {
-                mHardware->previewshowFrameThread();
-                return true;
+                mHardware->previewshowFrameThreadWrapper();
+                return false;
             }
         };
 
@@ -186,7 +196,7 @@ namespace android {
                 run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
             }
             virtual bool threadLoop() {
-                mHardware->encodeframeThread();
+                mHardware->encodeframeThreadWrapper();
                 return true;
             }
         };
@@ -213,14 +223,14 @@ namespace android {
         public:
             TakePicThread(CameraHal* hw)
                 : Thread(false), mHardware(hw) { }
+#if 0
             virtual void onFirstRef() {
                 run("TakePicThread", PRIORITY_URGENT_DISPLAY);
             }
+#endif  
             virtual bool threadLoop() {
-                if (mHardware->takepicThread()>=0)
-                    return true;
-                else
-                    return false;
+                mHardware->takepicThread();
+                return false;
             }
         };
 
@@ -233,8 +243,8 @@ namespace android {
         CAMERA_HAL_ERR_RET AolLocForInterBuf();
         void  FreeInterBuf();
         CAMERA_HAL_ERR_RET InitCameraHalParam();
-        CAMERA_HAL_ERR_RET GetCameraBaseParam(CameraParameters *pParam);
-        CAMERA_HAL_ERR_RET GetPictureExifParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET InitCameraBaseParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET InitPictureExifParam(CameraParameters *pParam);
         CAMERA_HAL_ERR_RET CameraMiscInit();
         CAMERA_HAL_ERR_RET CameraMiscDeInit();
         status_t CameraHALPreviewStart();
@@ -242,6 +252,10 @@ namespace android {
         int postprocessThread();
         int previewshowFrameThread();
         int encodeframeThread();
+        int captureframeThreadWrapper();
+        int postprocessThreadWrapper();
+        int previewshowFrameThreadWrapper();
+        int encodeframeThreadWrapper();
         status_t AllocateRecordVideoBuf();
 
         status_t CameraHALStartPreview();
@@ -275,13 +289,50 @@ namespace android {
         status_t PrepareCaptureBufs();
         volatile bool isCaptureBufsAllocated;
         //volatile bool isPreviewFinsh;
-        status_t convertPreviewFormat(unsigned int *pFormat);
+        status_t convertStringToPreviewFormat(unsigned int *pFormat);
+        status_t convertPreviewFormatToString(char *pStr, int length, unsigned int format);
+        status_t putBufferCount(DMA_BUFFER *pBuf);
+        void getBufferCount(DMA_BUFFER *pBuf);
+        CAMERA_HAL_ERR_RET InitCameraPreviewFormatToParam(int nFmt);
+
+        CMessageQueue mCaptureThreadQueue;
+        CMessageQueue mPreviewThreadQueue;
+        CMessageQueue mPostProcessThreadQueue;
+        CMessageQueue mEncodeThreadQueue;
+
+        mutable Mutex mCaptureLock;
+        mutable Condition mCaptureCondition;
+        //mutable Condition mCaptureStoppedCondition;
+        mutable sem_t mCaptureStoppedCondition;
+        bool mCaptureRunning;
+        bool mExitCaptureThread;
+        mutable Mutex mPreviewLock;
+        mutable Condition mPreviewCondition;
+        //mutable Condition mPreviewStoppedCondition;
+        mutable sem_t mPreviewStoppedCondition;
+        bool mPreviewRunning;
+        bool mExitPreviewThread;
+        mutable Mutex mPostProcessLock;
+        //mutable Condition mPostProcessCondition;
+        mutable sem_t mPostProcessStoppedCondition;
+        //bool mPostProcessRunning;
+        bool mExitPostProcessThread;
+        mutable Mutex mEncodeLock;
+        mutable Condition mEncodeCondition;
+        //mutable Condition mEncodeStoppedCondition;
+        mutable sem_t mEncodeStoppedCondition;
+        //bool mEncodeRunning;
+        bool mExitEncodeThread;
+        mutable sem_t mTakingPicture;
+        bool mWaitForTakingPicture;
+        bool mTakePictureInProcess;
 
         CameraParameters    mParameters;
         void               *mCallbackCookie;
-        notify_callback    mNotifyCb;
-        data_callback      mDataCb;
-        data_callback_timestamp mDataCbTimestamp;
+        camera_notify_callback    mNotifyCb;
+        camera_data_callback      mDataCb;
+        camera_data_timestamp_callback mDataCbTimestamp;
+        camera_request_memory mRequestMemory;
 
         sp<CaptureDeviceInterface> mCaptureDevice;
         sp<PostProcessDeviceInterface> mPPDevice;
@@ -297,24 +348,27 @@ namespace android {
 
         mutable Mutex       mLock;
 
-        char *supportedPictureSizes;
-        char *supportedPreviewSizes;
-        char *supportedFPS;
-        char *supprotedThumbnailSizes;
+        char *mSupportedPictureSizes;
+        char *mSupportedPreviewSizes;
+        char *mSupportedFPS;
+        char *mSupprotedThumbnailSizes;
+        char *mSupportPreviewFormat;
 
-        sp<ANativeWindow>   mNativeWindow;
+        preview_stream_ops_t*   mNativeWindow;
         unsigned int        mMsgEnabled;
 
         struct capture_config_t mCaptureDeviceCfg;
         DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
 
-        sp<MemoryHeapBase>  mPreviewHeap;
-        sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
+        //sp<MemoryHeapBase>  mPreviewHeap;
+        camera_memory_t* mPreviewMemory;
+        //sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
 
         /* the buffer for recorder */
         unsigned int        mVideoBufNume;
-        sp<MemoryHeapBase>  mVideoHeap;
-        sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
+        camera_memory_t* mVideoMemory;
+        //sp<MemoryHeapBase>  mVideoHeap;
+        //sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
         volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
 		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
 
@@ -324,8 +378,8 @@ namespace android {
         pp_input_param_t    mPPInputParam;
         pp_output_param_t   mPPOutputParam;
 
-        volatile bool       mPreviewRunning;
-        unsigned int        mPreviewFormat;
+        //volatile bool       mPreviewRunning;
+        unsigned int        mDefaultPreviewFormat;
         unsigned int 		mPreviewFrameSize;
         unsigned int        mPreviewCapturedFormat;
 
@@ -356,7 +410,8 @@ namespace android {
         bool mPreviewStopped;
         bool mRecordStopped;
         bool mPowerLock;
-		bool bDerectInput;
+	bool bDerectInput;
+        int mCameraid;
 
         int error_status;
         unsigned int preview_heap_buf_head;
diff --git a/mx5x/libcamera/CameraModule.cpp b/mx5x/libcamera/CameraModule.cpp
new file mode 100644
index 0000000..20470b9
--- /dev/null
+++ b/mx5x/libcamera/CameraModule.cpp
@@ -0,0 +1,711 @@
+/*
+ * Copyright (C) Freescale - http://www.Freescale.com/
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+* @file CameraHal.cpp
+*
+* This file maps the Camera Hardware Interface to V4L2.
+*
+*/
+
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#define LOG_TAG "CameraHAL"
+
+#include <utils/threads.h>
+#include <cutils/properties.h>
+#include "CameraHal.h"
+#include "Camera_utils.h"
+
+#define MAX_CAMERAS_SUPPORTED 2
+//static android::CameraProperties gCameraProperties;
+static android::CameraHal* gCameraHals[MAX_CAMERAS_SUPPORTED];
+static unsigned int gCamerasOpen = 0;
+static android::Mutex gCameraHalDeviceLock;
+
+static int camera_device_open(const hw_module_t* module, const char* name,
+                hw_device_t** device);
+static int camera_device_close(hw_device_t* device);
+static int camera_get_number_of_cameras(void);
+static int camera_get_camera_info(int camera_id, struct camera_info *info);
+
+static struct hw_module_methods_t camera_module_methods = {
+        open: camera_device_open
+};
+
+camera_module_t HAL_MODULE_INFO_SYM = {
+    common: {
+         tag: HARDWARE_MODULE_TAG,
+         version_major: 1,
+         version_minor: 0,
+         id: CAMERA_HARDWARE_MODULE_ID,
+         name: "Freescale CameraHal Module",
+         author: "Freescale",
+         methods: &camera_module_methods,
+         dso: NULL, /* remove compilation warnings */
+         reserved: {0}, /* remove compilation warnings */
+    },
+    get_number_of_cameras: camera_get_number_of_cameras,
+    get_camera_info: camera_get_camera_info,
+};
+
+typedef struct fsl_camera_device {
+    camera_device_t base;
+    /* TI specific "private" data can go here (base.priv) */
+    int cameraid;
+} fsl_camera_device_t;
+
+
+/*******************************************************************
+ * implementation of camera_device_ops functions
+ *******************************************************************/
+
+int camera_set_preview_window(struct camera_device * device,
+        struct preview_stream_ops *window)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->setPreviewWindow(window);
+
+    return rv;
+}
+
+void camera_set_callbacks(struct camera_device * device,
+        camera_notify_callback notify_cb,
+        camera_data_callback data_cb,
+        camera_data_timestamp_callback data_cb_timestamp,
+        camera_request_memory get_memory,
+        void *user)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->setCallbacks(notify_cb, data_cb, data_cb_timestamp, get_memory, user);
+}
+
+void camera_enable_msg_type(struct camera_device * device, int32_t msg_type)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->enableMsgType(msg_type);
+}
+
+void camera_disable_msg_type(struct camera_device * device, int32_t msg_type)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->disableMsgType(msg_type);
+}
+
+int camera_msg_type_enabled(struct camera_device * device, int32_t msg_type)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return 0;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    return gCameraHals[fsl_dev->cameraid]->msgTypeEnabled(msg_type);
+}
+
+int camera_start_preview(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->startPreview();
+
+    return rv;
+}
+
+void camera_stop_preview(struct camera_device * device)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->stopPreview();
+}
+
+int camera_preview_enabled(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->previewEnabled();
+    return rv;
+}
+
+int camera_store_meta_data_in_buffers(struct camera_device * device, int enable)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    //  TODO: meta data buffer not current supported
+    rv = gCameraHals[fsl_dev->cameraid]->storeMetaDataInBuffers(enable);
+    return rv;
+    //return enable ? android::INVALID_OPERATION: android::OK;
+}
+
+int camera_start_recording(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->startRecording();
+    return rv;
+}
+
+void camera_stop_recording(struct camera_device * device)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->stopRecording();
+}
+
+int camera_recording_enabled(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->recordingEnabled();
+    return rv;
+}
+
+void camera_release_recording_frame(struct camera_device * device,
+                const void *opaque)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->releaseRecordingFrame(opaque);
+}
+
+int camera_auto_focus(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->autoFocus();
+    return rv;
+}
+
+int camera_cancel_auto_focus(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->cancelAutoFocus();
+    return rv;
+}
+
+int camera_take_picture(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->takePicture();
+    return rv;
+}
+
+int camera_cancel_picture(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->cancelPicture();
+    return rv;
+}
+
+int camera_set_parameters(struct camera_device * device, const char *params)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->setParameters(params);
+    return rv;
+}
+
+char* camera_get_parameters(struct camera_device * device)
+{
+    char* param = NULL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return NULL;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    param = gCameraHals[fsl_dev->cameraid]->getParameters();
+
+    return param;
+}
+
+static void camera_put_parameters(struct camera_device *device, char *parms)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->putParameters(parms);
+}
+
+int camera_send_command(struct camera_device * device,
+            int32_t cmd, int32_t arg1, int32_t arg2)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->sendCommand(cmd, arg1, arg2);
+    return rv;
+}
+
+void camera_release(struct camera_device * device)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->release();
+}
+
+int camera_dump(struct camera_device * device, int fd)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->dump(fd);
+    return rv;
+}
+
+extern "C" void heaptracker_free_leaked_memory(void);
+
+int camera_device_close(hw_device_t* device)
+{
+    int ret = 0;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    android::Mutex::Autolock lock(gCameraHalDeviceLock);
+
+    if (!device) {
+        ret = -EINVAL;
+        goto done;
+    }
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    if (fsl_dev) {
+        if (gCameraHals[fsl_dev->cameraid]) {
+            delete gCameraHals[fsl_dev->cameraid];
+            gCameraHals[fsl_dev->cameraid] = NULL;
+            gCamerasOpen--;
+        }
+
+        if (fsl_dev->base.ops) {
+            free(fsl_dev->base.ops);
+        }
+        free(fsl_dev);
+    }
+done:
+#ifdef HEAPTRACKER
+    heaptracker_free_leaked_memory();
+#endif
+    return ret;
+}
+
+#define FACE_BACK_CAMERA_NAME "back_camera_name"
+#define FACE_FRONT_CAMERA_NAME "front_camera_name"
+#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
+#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
+#define DEFAULT_ERROR_NAME '#'
+#define DEFAULT_ERROR_NAME_str "#"
+#define UVC_NAME "uvc"
+static struct camera_info sCameraInfo[2];
+static char Camera_name[2][MAX_SENSOR_NAME];
+/*******************************************************************
+ * implementation of camera_module functions
+ *******************************************************************/
+
+/* open device handle to one of the cameras
+ *
+ * assume camera service will keep singleton of each camera
+ * so this function will always only be called once per camera instance
+ */
+
+int camera_device_open(const hw_module_t* module, const char* name,
+                hw_device_t** device)
+{
+    int rv = 0;
+    int num_cameras = 0;
+    int cameraid;
+    fsl_camera_device_t* camera_device = NULL;
+    camera_device_ops_t* camera_ops = NULL;
+    android::CameraHal* camera = NULL;
+    char *SelectedCameraName;
+    android::sp<android::CaptureDeviceInterface> pCaptureDevice = NULL;
+    android::sp<android::PostProcessDeviceInterface> pPPDevice = NULL;
+    android::sp<android::JpegEncoderInterface>pJpegEncoder = NULL;
+    //android::CameraProperties::Properties* properties = NULL;
+
+    android::Mutex::Autolock lock(gCameraHalDeviceLock);
+
+    LOGI("camera_device open");
+
+    if (name != NULL) {
+        cameraid = atoi(name);
+        num_cameras = camera_get_number_of_cameras();//gCameraProperties.camerasSupported();
+
+        if(cameraid > num_cameras)
+        {
+            LOGE("camera service provided cameraid out of bounds, "
+                    "cameraid = %d, num supported = %d",
+                    cameraid, num_cameras);
+            rv = -EINVAL;
+            goto fail;
+        }
+#if 0
+        if(gCamerasOpen >= MAX_SIMUL_CAMERAS_SUPPORTED)
+        {
+            LOGE("maximum number of cameras already open");
+            rv = -ENOMEM;
+            goto fail;
+        }
+#endif
+        camera_device = (fsl_camera_device_t*)malloc(sizeof(*camera_device));
+        if(!camera_device)
+        {
+            LOGE("camera_device allocation fail");
+            rv = -ENOMEM;
+            goto fail;
+        }
+
+        camera_ops = (camera_device_ops_t*)malloc(sizeof(*camera_ops));
+        if(!camera_ops)
+        {
+            LOGE("camera_ops allocation fail");
+            rv = -ENOMEM;
+            goto fail;
+        }
+
+        memset(camera_device, 0, sizeof(*camera_device));
+        memset(camera_ops, 0, sizeof(*camera_ops));
+
+        camera_device->base.common.tag = HARDWARE_DEVICE_TAG;
+        camera_device->base.common.version = 0;
+        camera_device->base.common.module = (hw_module_t *)(module);
+        camera_device->base.common.close = camera_device_close;
+        camera_device->base.ops = camera_ops;
+
+        camera_ops->set_preview_window = camera_set_preview_window;
+        camera_ops->set_callbacks = camera_set_callbacks;
+        camera_ops->enable_msg_type = camera_enable_msg_type;
+        camera_ops->disable_msg_type = camera_disable_msg_type;
+        camera_ops->msg_type_enabled = camera_msg_type_enabled;
+        camera_ops->start_preview = camera_start_preview;
+        camera_ops->stop_preview = camera_stop_preview;
+        camera_ops->preview_enabled = camera_preview_enabled;
+        camera_ops->store_meta_data_in_buffers = camera_store_meta_data_in_buffers;
+        camera_ops->start_recording = camera_start_recording;
+        camera_ops->stop_recording = camera_stop_recording;
+        camera_ops->recording_enabled = camera_recording_enabled;
+        camera_ops->release_recording_frame = camera_release_recording_frame;
+        camera_ops->auto_focus = camera_auto_focus;
+        camera_ops->cancel_auto_focus = camera_cancel_auto_focus;
+        camera_ops->take_picture = camera_take_picture;
+        camera_ops->cancel_picture = camera_cancel_picture;
+        camera_ops->set_parameters = camera_set_parameters;
+        camera_ops->get_parameters = camera_get_parameters;
+        camera_ops->put_parameters = camera_put_parameters;
+        camera_ops->send_command = camera_send_command;
+        camera_ops->release = camera_release;
+        camera_ops->dump = camera_dump;
+
+        *device = &camera_device->base.common;
+
+        // -------- TI specific stuff --------
+
+        camera_device->cameraid = cameraid;
+#if 0
+        if(gCameraProperties.getProperties(cameraid, &properties) < 0)
+        {
+            LOGE("Couldn't get camera properties");
+            rv = -ENOMEM;
+            goto fail;
+        }
+#endif
+        SelectedCameraName = Camera_name[sCameraInfo[cameraid].facing];
+
+        pCaptureDevice = android::createCaptureDevice(SelectedCameraName);
+        pPPDevice = android::createPPDevice();
+        pJpegEncoder = android::createJpegEncoder(android::SOFTWARE_JPEG_ENC);
+
+        camera = new android::CameraHal(cameraid);
+
+        if(!camera)
+        {
+            LOGE("Couldn't create instance of CameraHal class");
+            rv = -ENOMEM;
+            goto fail;
+        }
+#if 0
+        if(properties && (camera->initialize(properties) != android::NO_ERROR))
+        {
+            LOGE("Couldn't initialize camera instance");
+            rv = -ENODEV;
+            goto fail;
+        }
+#endif
+        if (camera->setCaptureDevice(pCaptureDevice) < 0 ||
+                camera->setPostProcessDevice(pPPDevice) < 0 ||
+                camera->setJpegEncoder(pJpegEncoder) < 0)
+            return NULL;
+
+        if (camera->Init() < 0)
+            return NULL;
+
+        //now the board has only one csi camera sensor, so just do mirror for it
+        if(strstr(SelectedCameraName, "ov") != NULL){
+            camera->setPreviewRotate(android::CAMERA_PREVIEW_HORIZ_FLIP);
+        }
+
+        gCameraHals[cameraid] = camera;
+        gCamerasOpen++;
+    }
+
+    return rv;
+
+fail:
+    if(camera_device) {
+        free(camera_device);
+        camera_device = NULL;
+    }
+    if(camera_ops) {
+        free(camera_ops);
+        camera_ops = NULL;
+    }
+    if(camera) {
+        delete camera;
+        camera = NULL;
+    }
+    *device = NULL;
+    return rv;
+}
+
+static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
+{
+    char orientStr[10];
+
+    property_get (FACE_BACK_CAMERA_NAME, pFaceBackCameraName, DEFAULT_ERROR_NAME_str );
+    property_get (FACE_BACK_CAMERA_ORIENT, orientStr, DEFAULT_ERROR_NAME_str );
+
+    if (orientStr[0] == DEFAULT_ERROR_NAME )
+        *pFaceBackOrient = 0;
+    else 
+        *pFaceBackOrient = atoi(orientStr);
+
+    LOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
+
+    property_get(FACE_FRONT_CAMERA_NAME, pFaceFrontCameraName, DEFAULT_ERROR_NAME_str );
+
+    property_get(FACE_FRONT_CAMERA_ORIENT, orientStr, DEFAULT_ERROR_NAME_str );
+
+
+    if (orientStr[0] == DEFAULT_ERROR_NAME )
+        *pFaceFrontOrient = 0;
+    else 
+        *pFaceFrontOrient = atoi(orientStr);
+
+    LOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
+
+}
+
+int camera_get_number_of_cameras()
+{
+    int back_orient =0,  front_orient = 0;
+    int back_camera_num = 0, front_camera_num = 0;
+    GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
+    if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
+        sCameraInfo[0].facing = CAMERA_FACING_BACK;
+        sCameraInfo[0].orientation = back_orient;
+        back_camera_num++;
+    }
+    if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
+        if(back_camera_num > 0){
+            sCameraInfo[1].facing = CAMERA_FACING_FRONT;
+            sCameraInfo[1].orientation = front_orient;
+        }else{
+	    sCameraInfo[0].facing = CAMERA_FACING_FRONT;
+	    sCameraInfo[0].orientation = front_orient;
+        }
+        front_camera_num ++;
+    }
+    return (back_camera_num + front_camera_num);					
+
+}
+
+int camera_get_camera_info(int cameraId, struct camera_info* cameraInfo)
+{
+    memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(camera_info));
+    return 0;
+}
+
diff --git a/mx5x/libcamera/Camera_utils.h b/mx5x/libcamera/Camera_utils.h
index 89c6729..dfca274 100755
--- a/mx5x/libcamera/Camera_utils.h
+++ b/mx5x/libcamera/Camera_utils.h
@@ -16,7 +16,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #ifndef CAMERA_UTILS_H
@@ -25,8 +25,9 @@
 #undef LOG_TAG
 #define LOG_TAG "FslCameraHAL"
 #include <utils/Log.h>
+#include <utils/threads.h>
 
-//#define CAMERA_HAL_DEBUG_LOG
+#define CAMERA_HAL_DEBUG_LOG
 
 #ifdef CAMERA_HAL_DEBUG_LOG
 #define CAMERA_HAL_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
@@ -49,6 +50,7 @@ namespace android {
     }DMA_ALLOCATE_ERR_RET;
 
     typedef enum{
+        WINDOW_BUFS_INVALID = 0,
         WINDOW_BUFS_DEQUEUED = 1,
         WINDOW_BUFS_QUEUED = 2,
     }WINDOW_BUFS_STATE;
@@ -58,6 +60,8 @@ namespace android {
         size_t phy_offset;
         unsigned int length;
         void *native_buf;
+        Mutex mBufferLock;
+        unsigned int refCount;
         WINDOW_BUFS_STATE buf_state;
     }DMA_BUFFER;
 
diff --git a/mx5x/libcamera/CaptureDeviceInterface.cpp b/mx5x/libcamera/CaptureDeviceInterface.cpp
index 8adc966..791308c 100755
--- a/mx5x/libcamera/CaptureDeviceInterface.cpp
+++ b/mx5x/libcamera/CaptureDeviceInterface.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include "V4l2UVCDevice.h"
 #include "V4l2CsiDevice.h"
@@ -23,7 +23,7 @@ namespace android{
     extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName)
     {
         if(strstr(deviceName, UVC_NAME_STRING)){
-            CAMERA_HAL_LOG_INFO("It is the UVC device");
+            CAMERA_HAL_LOG_INFO("It is the UVC device, name:%s", deviceName);
 
             sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
             device->SetDevName(deviceName);
diff --git a/mx5x/libcamera/CaptureDeviceInterface.h b/mx5x/libcamera/CaptureDeviceInterface.h
index bbba44c..d63b4fa 100755
--- a/mx5x/libcamera/CaptureDeviceInterface.h
+++ b/mx5x/libcamera/CaptureDeviceInterface.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #ifndef CAPTURE_DEVICE_INTERFACE_H
@@ -46,6 +46,11 @@ namespace android {
         MOTION_MODE = 0,
         HIGH_QUALITY_MODE = 1
     }CAPTURE_MODE;
+    
+    typedef enum{
+        CAMERA_TYPE_CSI = 0,
+        CAMERA_TYPE_UVC = 1,
+    }CAMERA_TYPE;
 
     typedef enum{
         OUTPU_FMT = 0,
@@ -57,7 +62,8 @@ namespace android {
         SENSOR_PREVIEW_VERT_FLIP = 1,
         SENSOR_PREVIEW_HORIZ_FLIP = 2,
         SENSOR_PREVIEW_ROATE_180 = 3,
-        SENSOR_PREVIEW_ROATE_LAST = 3
+        SENSOR_PREVIEW_ROATE_LAST = 3,
+        SENSOR_PREVIEW_ROATE_INVALID =4
 	}SENSOR_PREVIEW_ROTATE;
 
     struct timeval_fract{
@@ -93,6 +99,7 @@ namespace android {
         virtual CAPTURE_DEVICE_ERR_RET DevStop()=0;
         virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate()=0;
         virtual CAPTURE_DEVICE_ERR_RET DevClose()=0;
+        virtual CAPTURE_DEVICE_ERR_RET GetDevType(CAMERA_TYPE *pType)=0;
 
         virtual ~ CaptureDeviceInterface(){}
     };
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.cpp b/mx5x/libcamera/V4l2CapDeviceBase.cpp
index 3202591..1fac34f 100755
--- a/mx5x/libcamera/V4l2CapDeviceBase.cpp
+++ b/mx5x/libcamera/V4l2CapDeviceBase.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <string.h>
 #include <unistd.h>
@@ -50,6 +50,7 @@ namespace android{
 
     {
         mCaptureDeviceName[0] = '#';
+        memset((void*)&mCapCfg, 0, sizeof(mCapCfg));
     }
 
     V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
@@ -80,6 +81,15 @@ namespace android{
         return V4l2Open(); 
     } 
 
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevType(CAMERA_TYPE *pType)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(pType == NULL)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        *pType = mCameraType;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
     CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
         CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
         CAMERA_HAL_LOG_FUNC;
@@ -98,8 +108,30 @@ namespace android{
             return CAPTURE_DEVICE_ERR_BAD_PARAM;
         }
 
-        mCapCfg = *pCapcfg;
-        return V4l2SetConfig(pCapcfg);
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if(mCapCfg.fmt != pCapcfg->fmt || mCapCfg.width != pCapcfg->width || mCapCfg.height != pCapcfg->height
+                || mCapCfg.tv.denominator/mCapCfg.tv.numerator != pCapcfg->tv.denominator/pCapcfg->tv.numerator) {
+            mCapCfg.fmt = pCapcfg->fmt;
+            mCapCfg.width = pCapcfg->width;
+            mCapCfg.height = pCapcfg->height;
+            mCapCfg.tv.denominator = pCapcfg->tv.denominator;
+            mCapCfg.tv.numerator = pCapcfg->tv.numerator;
+            CAMERA_HAL_LOG_RUNTIME("V4l2SetConfig=width=%d,height=%d", mCapCfg.width, mCapCfg.height);
+            ret = V4l2SetConfig(pCapcfg);
+            if(ret < 0) {
+                return ret;
+            }
+            mCapCfg.rotate = SENSOR_PREVIEW_ROATE_INVALID;
+        }
+
+        if(mCapCfg.rotate != pCapcfg->rotate) {
+            mCapCfg.rotate = pCapcfg->rotate;
+            CAMERA_HAL_LOG_RUNTIME("V4l2SetRot=rotate=%d", mCapCfg.rotate);
+            if(V4l2SetRot(pCapcfg) < 0)
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        return ret;
 
     }
 
@@ -224,6 +256,7 @@ namespace android{
                     CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
                     if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
                         close(fd);
+                        fd = 0;
                         continue;
                     } else if ((strstr((char *)v4l2_cap.driver, mInitalDeviceName) != 0) &&
                             (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
@@ -231,8 +264,10 @@ namespace android{
                         strcpy(mCaptureDeviceName, dev_node);
                         CAMERA_HAL_LOG_RUNTIME("device name is %s", mCaptureDeviceName);
                         break;
-                    } else
+                    } else {
                         close(fd);
+                        fd = 0;
+                    }
                 }
             }
             if (fd > 0)
diff --git a/mx5x/libcamera/V4l2CapDeviceBase.h b/mx5x/libcamera/V4l2CapDeviceBase.h
index 0408fcb..c23a23a 100755
--- a/mx5x/libcamera/V4l2CapDeviceBase.h
+++ b/mx5x/libcamera/V4l2CapDeviceBase.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #ifndef V4L2_CAP_DEVICE_BASE_H
 #define V4L2_CAP_DEVICE_BASE_H
@@ -34,6 +34,7 @@ namespace android{
 
         virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName);
         virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_ERR_RET GetDevType(CAMERA_TYPE *pType);
         virtual CAPTURE_DEVICE_ERR_RET DevOpen();
         virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam);
         virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg);
@@ -79,6 +80,7 @@ namespace android{
         int          mQueuedBufNum;
         DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
         struct   capture_config_t mCapCfg;
+        CAMERA_TYPE  mCameraType;
 
     };
 };
diff --git a/mx5x/libcamera/V4l2CsiDevice.cpp b/mx5x/libcamera/V4l2CsiDevice.cpp
index af3c119..ba9e472 100755
--- a/mx5x/libcamera/V4l2CsiDevice.cpp
+++ b/mx5x/libcamera/V4l2CsiDevice.cpp
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <string.h>
 #include <unistd.h>
@@ -42,7 +42,7 @@ namespace android{
         mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
         mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
         mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
-
+        mCameraType = CAMERA_TYPE_CSI;
     }
     V4l2CsiDevice :: ~V4l2CsiDevice()
     {
@@ -84,6 +84,7 @@ namespace android{
                     CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
                     if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
                         close(fd);
+                        fd = 0;
                         continue;
                     } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
                         is_found = 1;
@@ -192,6 +193,8 @@ namespace android{
         struct v4l2_control ctrl;
         struct v4l2_streamparm parm;
 
+        memset(&parm, 0, sizeof(struct v4l2_streamparm));
+        memset(&fmt, 0, sizeof(struct v4l2_format));
         V4l2ConfigInput(pCapcfg);
 
         parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
@@ -202,11 +205,12 @@ namespace android{
         }
         CAMERA_HAL_LOG_RUNTIME("the fps is %d", pCapcfg->tv.denominator);
 
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
         parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
         parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode), 
+                &(parm.parm.capture.timeperframe));
+        if (ret != CAPTURE_DEVICE_ERR_NONE)
+            return ret;
 
         if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
             parm.parm.capture.timeperframe.numerator = 1;
@@ -241,11 +245,8 @@ namespace android{
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }
 
-        if(V4l2SetRot(pCapcfg) < 0)
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-
         fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
+        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &fmt) < 0) {
             CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
             return CAPTURE_DEVICE_ERR_SYS_CALL;
         }else{
@@ -260,7 +261,8 @@ namespace android{
         return CAPTURE_DEVICE_ERR_NONE;
     }
 
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, 
+            unsigned int *pMode, struct v4l2_fract *pTimeFrame){
 
         CAMERA_HAL_LOG_FUNC;
         if (mCameraDevice <= 0 || pCapcfg == NULL){
@@ -273,29 +275,48 @@ namespace android{
         unsigned int pic_waite_buf_num = 0;
         if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
                 (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
-            pic_waite_buf_num = 10;
-            if (capturewidth == 640 && captureheight == 480)
+            pic_waite_buf_num = 6;
+            if (capturewidth == 640 && captureheight == 480) {
                 capturemode = 0;	/* VGA mode */
-            else if (capturewidth == 320 && captureheight == 240)
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 320 && captureheight == 240) {
                 capturemode = 1;	/* QVGA mode */
-            else if (capturewidth == 720 && captureheight == 480)
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 720 && captureheight == 480) {
                 capturemode = 2;	/* PAL mode */
-            else if (capturewidth == 720 && captureheight == 576)
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 720 && captureheight == 576) {
                 capturemode = 3;	/* PAL mode */
-            else if (capturewidth == 1280 && captureheight == 720)
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 1280 && captureheight == 720) {
                 capturemode = 4;	/* 720P mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
             else if (capturewidth == 1920 && captureheight == 1080){
-                pic_waite_buf_num = 5;
+                pic_waite_buf_num = 3;
                 capturemode = 5;	/* 1080P mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 15;
             }
             else if (capturewidth == 2592 && captureheight == 1944) {
-                pic_waite_buf_num = 3;
+                pic_waite_buf_num =1;
                 capturemode = 6;	/* 2592x1944 mode */
-                pCapcfg->tv.denominator = 15;
-                pCapcfg->tv.numerator = 1;
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 15;
             }
             else if (capturewidth == 176 && captureheight == 144) {
                 capturemode = 7;       /* QCIF mode */
+                //pTimeFrame->numerator = 1;
+                //pTimeFrame->denominator = 30;
             }
             else{
                 CAMERA_HAL_ERR("The camera mode is not supported!!!!");
@@ -322,6 +343,7 @@ namespace android{
                 return CAPTURE_DEVICE_ERR_BAD_PARAM;
             }
         }else{
+            CAMERA_HAL_ERR("The camera sensor %s not configure!!!!", mInitalDeviceName);
             capturemode = 0;
             pic_waite_buf_num = 0;
         }
@@ -346,13 +368,13 @@ namespace android{
         // Set rotation
         ctrl.id = V4L2_CID_MXC_ROT;
         if (pCapcfg->rotate == SENSOR_PREVIEW_BACK_REF)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_NONE;
+            ctrl.value = V4L2_MXC_ROTATE_NONE;
         else if (pCapcfg->rotate == SENSOR_PREVIEW_VERT_FLIP)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_VERT_FLIP;
+            ctrl.value = V4L2_MXC_ROTATE_VERT_FLIP;
         else if (pCapcfg->rotate == SENSOR_PREVIEW_HORIZ_FLIP)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_HORIZ_FLIP;
+            ctrl.value = V4L2_MXC_ROTATE_HORIZ_FLIP;
         else if (pCapcfg->rotate == SENSOR_PREVIEW_ROATE_180)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_180;
+            ctrl.value = V4L2_MXC_ROTATE_180;
         else
             ctrl.value = V4L2_MXC_ROTATE_NONE;
 
diff --git a/mx5x/libcamera/V4l2CsiDevice.h b/mx5x/libcamera/V4l2CsiDevice.h
index 5247eae..54108e1 100755
--- a/mx5x/libcamera/V4l2CsiDevice.h
+++ b/mx5x/libcamera/V4l2CsiDevice.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #ifndef V4L2_CSI_DEVICE_H
 #define V4L2_CSI_DEVICE_H
@@ -41,7 +41,8 @@ class V4l2CsiDevice : public V4l2CapDeviceBase{
 		CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
 		CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
         CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
+        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, 
+                unsigned int *pMode, struct v4l2_fract *pTimeFrame); 
         CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
 
 		unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
diff --git a/mx5x/libcamera/V4l2UVCDevice.h b/mx5x/libcamera/V4l2UVCDevice.h
index f3af040..47e0c20 100755
--- a/mx5x/libcamera/V4l2UVCDevice.h
+++ b/mx5x/libcamera/V4l2UVCDevice.h
@@ -15,7 +15,7 @@
  */
 
 /*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #ifndef V4L2_UVC_DEVICE_H
 #define V4L2_UVC_DEVICE_H
@@ -31,7 +31,7 @@ namespace android{
 
     class V4l2UVCDevice : public V4l2CapDeviceBase{
     public:
-        V4l2UVCDevice(){}
+        V4l2UVCDevice(){mCameraType = CAMERA_TYPE_UVC;}
         ~V4l2UVCDevice(){}
 
     };
diff --git a/mx5x/libcamera/messageQueue.cpp b/mx5x/libcamera/messageQueue.cpp
new file mode 100644
index 0000000..0a53b42
--- /dev/null
+++ b/mx5x/libcamera/messageQueue.cpp
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/types.h>
+
+#include <utils/threads.h>
+#include <utils/Timers.h>
+#include <utils/Log.h>
+#include <binder/IPCThreadState.h>
+
+#include "messageQueue.h"
+#include "Camera_utils.h"
+
+namespace android {
+
+void CMessageList::insert(const sp<CMessage>& node)
+{
+    mList.push_back(node);
+};
+
+void CMessageList::remove(CMessageList::LIST::iterator pos)
+{
+    mList.erase(pos);
+}
+
+void CMessageList::clear()
+{
+    mList.clear();
+}
+
+CMessageQueue::CMessageQueue()
+    :mQuit(false), mStop(false)
+{
+    mQuitMessage = new CMessage(CMESSAGE_TYPE_QUITE);
+    mStopMessage = new CMessage(CMESSAGE_TYPE_STOP);
+}
+
+CMessageQueue::~CMessageQueue()
+{
+        Mutex::Autolock _l(mLock);
+    LIST::iterator curr(mMessages.begin());
+    //sp<CMessage> tmp;
+
+    while(curr != mMessages.end()) {
+        //tmp = *cur;
+        //tmp.clear();
+        mMessages.remove(curr);
+        //tmp.clear();
+        curr ++;
+    }
+}
+
+void CMessageQueue::clearMessage()
+{
+    CAMERA_HAL_ERR("-------CMessageQueue::clearMessage--------");
+        Mutex::Autolock _l(mLock);
+        mMessages.clear();
+#if 0
+    LIST::iterator icur(mMessages.begin());
+    LIST::iterator iend(mMessages.end());
+    //sp<CMessage> tmp;
+
+    while(icur != iend) {
+    CAMERA_HAL_ERR("*********CMessageQueue::clearMessage********");
+        //tmp = *cur;
+        //tmp.clear();
+        mMessages.remove(icur);
+        //tmp.clear();i
+        icur ++;
+    }
+#endif 
+    mStop = false;
+}
+
+sp<CMessage> CMessageQueue::waitMessage(nsecs_t timeout)
+{
+    sp<CMessage> result;
+    nsecs_t timeoutTime = systemTime() + timeout;
+    
+    while(true) {
+        Mutex::Autolock _l(mLock);
+        nsecs_t now = systemTime();
+        LIST::iterator cur(mMessages.begin());
+
+        if(mQuit) {
+            result = mQuitMessage;
+            return result;
+        }
+        if(mStop) {
+            result = mStopMessage;
+            return result;
+        }
+
+        if(cur != mMessages.end()) {
+            result = *cur;
+        }
+
+        if(result != 0) {
+            mMessages.remove(cur);
+            break;
+        }
+
+        if(timeout >= 0) {
+            if(timeoutTime < now) {
+                result = 0;
+                break;
+            }
+            nsecs_t relTime = timeoutTime - systemTime();
+            mCondition.waitRelative(mLock, relTime);
+        }else {
+            mCondition.wait(mLock);
+        }
+    }
+    return result;
+}
+
+status_t CMessageQueue::postMessage(const sp<CMessage>& message, int32_t flags) 
+{
+    return queueMessage(message, flags);
+}
+
+status_t CMessageQueue::postQuitMessage()
+{
+    Mutex::Autolock _l(mLock);
+    mQuit = true;
+    mCondition.signal();
+    return NO_ERROR;
+}
+
+status_t CMessageQueue::postStopMessage()
+{
+    Mutex::Autolock _l(mLock);
+    mStop = true;
+    //mMessages.insert(new CMessage(CMESSAGE_TYPE_STOP, 0));
+    mCondition.signal();
+    return NO_ERROR;
+}
+
+status_t CMessageQueue::queueMessage(const sp<CMessage>& message, int32_t flags)
+{
+    Mutex::Autolock _l(mLock);
+    mMessages.insert(message);
+    mCondition.signal();
+    return NO_ERROR;
+}
+};
+
diff --git a/mx5x/libcamera/messageQueue.h b/mx5x/libcamera/messageQueue.h
new file mode 100644
index 0000000..8054cfe
--- /dev/null
+++ b/mx5x/libcamera/messageQueue.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#ifndef CAMERA_HAL_MESSAGE_QUEUE_H
+#define CAMERA_HAL_MESSAGE_QUEUE_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <utils/threads.h>
+#include <utils/Timers.h>
+#include <utils/List.h>
+
+//#include "Barrier.h"
+
+namespace android {
+
+typedef enum{
+    CMESSAGE_TYPE_NORMAL = 0,
+    CMESSAGE_TYPE_STOP = -1,
+    CMESSAGE_TYPE_QUITE = -2,
+}CMESSAGE_TYPE;
+
+class CMessage;
+
+class CMessageList
+{
+    List< sp<CMessage> > mList;
+    typedef List< sp<CMessage> > LIST;
+public:
+    inline LIST::iterator begin() {return mList.begin();}
+    inline LIST::const_iterator begin() const {return mList.begin();}
+    inline LIST::iterator end() {return mList.end();}
+    inline LIST::const_iterator end() const {return mList.end();}
+    inline bool isEmpty() const {return mList.empty();}
+    void insert(const sp<CMessage> &node);
+    void remove(LIST::iterator pos);
+    void clear();
+};
+
+class CMessage : public LightRefBase<CMessage>
+{
+public:
+    CMESSAGE_TYPE what;
+    int32_t arg0;
+
+    //CMessage(): what(0), arg0(0) {}
+    CMessage(CMESSAGE_TYPE what, int32_t arg0=0)
+        : what(what), arg0(arg0) {}
+
+//protected:
+    virtual ~CMessage() {}
+
+private:
+    friend class LightRefBase<CMessage>;
+};
+
+class CMessageQueue
+{
+    typedef List< sp<CMessage> > LIST;
+public:
+    CMessageQueue();
+    ~CMessageQueue();
+
+    sp<CMessage> waitMessage(nsecs_t timeout=-1);
+    status_t postMessage(const sp<CMessage>& message, int32_t flags=0);
+    status_t postQuitMessage();
+    status_t postStopMessage();
+    void clearMessage();
+
+private:
+    status_t queueMessage(const sp<CMessage>& message, int32_t flags);
+
+    Mutex mLock;
+    Condition mCondition;
+    CMessageList mMessages;
+    bool mQuit;
+    bool mStop;
+    sp<CMessage> mQuitMessage;
+    sp<CMessage> mStopMessage;
+};
+
+
+};
+
+#endif
diff --git a/mx5x/libgralloc/framebuffer.cpp b/mx5x/libgralloc/framebuffer.cpp
index 03eeffb..42c53ad 100755
--- a/mx5x/libgralloc/framebuffer.cpp
+++ b/mx5x/libgralloc/framebuffer.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/* Copyright 2010-2011 Freescale Semiconductor Inc. */
+/* Copyright 2010-2012 Freescale Semiconductor Inc. */
 
 #include <sys/mman.h>
 
@@ -42,13 +42,10 @@
 #include <linux/videodev.h>
 #include <sys/mman.h>
 
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
+#include <linux/ipu.h>
 
 #endif
 #include <GLES/gl.h>
-#include <c2d_api.h>
 #include <pthread.h>
 #include <semaphore.h>
 
@@ -93,10 +90,12 @@ struct fb_context_t {
     sem_t sec_display_begin;
     sem_t sec_display_end;
     pthread_t thread_id;
-    C2D_CONTEXT c2dctx;
+  //  C2D_CONTEXT c2dctx;
     int sec_rotation;
     int cleancount;
     int mRotate;
+    struct ipu_task mTask;
+    int mIpuFd;
 #endif
 };
 
@@ -368,13 +367,13 @@ static int fb_setSecRotation(struct framebuffer_device_t* dev,int secRotation)
 
 static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
 {
-    if (private_handle_t::validate(buffer) < 0)
+    if (!buffer)
         return -EINVAL;
 
     fb_context_t* ctx = (fb_context_t*)dev;
 
     private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(buffer);
-    private_module_t* m = reinterpret_cast<private_module_t*>(
+	private_module_t* m = reinterpret_cast<private_module_t*>(
             dev->common.module);
     if (m->currentBuffer) {
         m->base.unlock(&m->base, m->currentBuffer);
@@ -383,9 +382,10 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
 
     if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
 
+        void *vaddr = NULL;
         m->base.lock(&m->base, buffer, 
                 private_module_t::PRIV_USAGE_LOCKED_FOR_POST, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), NULL);
+                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), &vaddr);
 
         const size_t offset = hnd->base - m->framebuffer->base;
         m->info.activate = FB_ACTIVATE_VBL;
@@ -402,7 +402,11 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
                 if(mapSecFrameBuffer(ctx)== 0)
                 {    
                     ctx->sec_display_inited = true;
-                    c2dCreateContext(&ctx->c2dctx); 
+               //     c2dCreateContext(&ctx->c2dctx);
+                    ctx->mIpuFd = open("/dev/mxc_ipu", O_RDWR, 0);
+                    if(ctx->mIpuFd < 0) {
+                        LOGE("%s:%d,open ipu dev failed", __FUNCTION__, __LINE__);
+                    }
 
                     sem_init(&ctx->sec_display_begin, 0, 0);
                     sem_init(&ctx->sec_display_end, 0, 0);
@@ -433,7 +437,8 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
                 sem_destroy(&ctx->sec_display_begin);
                 sem_destroy(&ctx->sec_display_end);
                 
-                if (ctx->c2dctx != NULL)c2dDestroyContext(ctx->c2dctx);
+            //    if (ctx->c2dctx != NULL)c2dDestroyContext(ctx->c2dctx);
+                if(ctx->mIpuFd >= 0)close(ctx->mIpuFd);
                 
                 //Set the prop rw.SECOND_DISPLAY_ENABLED to 0
                 LOGI("Switch back to display 0");
@@ -445,12 +450,12 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
                 ctx->sec_disp_base = 0;
                 //DeInit the second display
                 if(ctx->sec_fp) {
-                    int fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0); 
+                    int fp_property = open("/sys/class/graphics/fb2/fsl_disp_property",O_RDWR, 0); 
                     if(fp_property >= 0) {
                         char overlayStr[32];
                         int blank;
                         int fb2_fp;
-			struct fb_var_screeninfo fb0_var;
+                        struct fb_var_screeninfo fb0_var;
 
                         blank = 1;
 
@@ -466,7 +471,7 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
                         }
 
                     	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
-                    		LOGI("Error!BLANK FB1 failed!\n");
+                            LOGI("Error!BLANK FB2 failed!\n");
                     	}
                     
                         if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
@@ -475,13 +480,13 @@ static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
 
                         memset(overlayStr, 0 ,32);
                         strcpy(overlayStr, "1-layer-fb\n");
-                        LOGI("WRITE 1-layer-fb to fb1/fsl_disp_property");
+                        LOGI("WRITE 1-layer-fb to fb2/fsl_disp_property");
                         write(fp_property, overlayStr, strlen(overlayStr)+1);
                         close(fp_property);
 
                         blank = FB_BLANK_POWERDOWN;
                     	if(ioctl(ctx->sec_fp, FBIOBLANK, blank) < 0) {
-                    		LOGI("Error!BLANK FB1 failed!\n");
+                            LOGI("Error!BLANK FB2 failed!\n");
                     	}
                         blank = FB_BLANK_UNBLANK;
                     	if(ioctl(m->framebuffer->fd, FBIOBLANK, blank) < 0) {
@@ -836,10 +841,10 @@ static int set_graphics_fb_mode(int fb, int dual_disp)
     if(strncmp(fb_mode, disp_mode, strlen(disp_mode)+1))
     {
         size = write(fp_mode, disp_mode, strlen(disp_mode)+1);
-		if(size <= 0)
-	    {
-	        LOGI("Error! Cannot write %s", temp_name);
-	    }
+        if(size <= 0)
+        {
+           LOGI("Error! Cannot write %s", temp_name);
+        }
     }
 
     close(fp_mode); fp_mode = 0;
@@ -1139,9 +1144,9 @@ static int mapSecFrameBuffer(fb_context_t* ctx)
 
     set_graphics_fb_mode(1,1);
 
-    sec_fp = open("/dev/graphics/fb1",O_RDWR, 0);
+    sec_fp = open("/dev/graphics/fb2",O_RDWR, 0);
     if (sec_fp < 0){
-        LOGE("Error!Cannot open the /dev/graphics/fb1 for second display");
+        LOGE("Error!Cannot open the /dev/graphics/fb2 for second display");
         goto disp_init_error;
     }
 
@@ -1161,7 +1166,7 @@ static int mapSecFrameBuffer(fb_context_t* ctx)
     close(fb2_fp);
 
 	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
-		LOGI("Error!BLANK FB1 failed!\n");
+		LOGI("Error!BLANK FB2 failed!\n");
         goto disp_init_error;
 	}
 
@@ -1185,7 +1190,7 @@ static int mapSecFrameBuffer(fb_context_t* ctx)
 
     blank = FB_BLANK_UNBLANK;
 	if(ioctl(sec_fp, FBIOBLANK, blank) < 0) {
-		LOGI("Error!UNBLANK FB1 failed!\n");
+		LOGI("Error!UNBLANK FB2 failed!\n");
         goto disp_init_error;
 	}
 
@@ -1336,106 +1341,90 @@ static int mapSecFrameBuffer(fb_context_t* ctx)
 
 static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx)
 {
-    ipu_lib_input_param_t sIPUInputParam;   
-    ipu_lib_output_param_t sIPUOutputParam; 
-    ipu_lib_handle_t            sIPUHandle;
-    int iIPURet = 0;
-    memset(&sIPUInputParam,0,sizeof(sIPUInputParam));
-    memset(&sIPUOutputParam,0,sizeof(sIPUOutputParam));
-    memset(&sIPUHandle,0,sizeof(sIPUHandle));
-
-    //Setting input format
-    sIPUInputParam.width = ctx->device.width;
-    sIPUInputParam.height = ctx->device.height;
-
-    sIPUInputParam.input_crop_win.pos.x = 0;
-    sIPUInputParam.input_crop_win.pos.y = 0;  
-    sIPUInputParam.input_crop_win.win_w = ctx->device.width;
-    sIPUInputParam.input_crop_win.win_h = ctx->device.height;
-    sIPUInputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-    sIPUInputParam.user_def_paddr[0] = phys;
-        
-    //Setting output format
-    //Should align with v4l
-    sIPUOutputParam.fmt = v4l2_fourcc('R', 'G', 'B', 'P');
-    sIPUOutputParam.width = ctx->sec_disp_w;
-    sIPUOutputParam.height = ctx->sec_disp_h;   
-    sIPUOutputParam.show_to_fb = 0;
-    //Output param should be same as input, since no resize,crop
-    sIPUOutputParam.output_win.pos.x = 0;
-    sIPUOutputParam.output_win.pos.y = 0;
-    sIPUOutputParam.output_win.win_w = ctx->sec_disp_w;
-    sIPUOutputParam.output_win.win_h = ctx->sec_disp_h;
+    private_module_t* m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
+
+    if(ctx->mIpuFd < 0){
+        LOGE("%s:%d, invalid ipu device !!!!", __FUNCTION__, __LINE__);
+        return -EINVAL;
+    }
+
+    if(m->info.bits_per_pixel == 32){
+        ctx->mTask.input.format = v4l2_fourcc('B', 'G', 'R', '4');
+    }
+    else {
+        ctx->mTask.input.format = v4l2_fourcc('R', 'G', 'B', 'P');
+    }
+    ctx->mTask.input.width = ctx->device.width;
+    ctx->mTask.input.height = ctx->device.height;
+    ctx->mTask.input.crop.pos.x = 0;
+    ctx->mTask.input.crop.pos.y = 0;
+    ctx->mTask.input.crop.w = ctx->device.width;
+    ctx->mTask.input.crop.h = ctx->device.height;
+    ctx->mTask.input.paddr = phys;
+
+    ctx->mTask.output.format = v4l2_fourcc('R', 'G', 'B', 'P');
+    ctx->mTask.output.width = ctx->sec_disp_w;
+    ctx->mTask.output.height = ctx->sec_disp_h;
+    ctx->mTask.output.crop.w = ctx->sec_disp_w;
+    ctx->mTask.output.crop.h = ctx->sec_disp_h;
     
-    int output_w = 0;
-    int output_h = 0;
-    //Make sure the output w/h proportion is align with the primary display
-    if((ctx->sec_rotation == 0x0)||(ctx->sec_rotation == 0x3))
+    if((ctx->mRotate == 0)||(ctx->mRotate == 180))
     {
-        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.width/ctx->device.height){
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
+        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.width/ctx->device.height){
+            ctx->mTask.output.crop.w = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
         }
         else{
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
+            ctx->mTask.output.crop.h = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
         }
     }
     else{
-        if(ctx->sec_disp_w/ctx->sec_disp_h >= ctx->device.height/ctx->device.width){
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_h > MAX_SEC_DISP_HEIGHT?MAX_SEC_DISP_HEIGHT:ctx->sec_disp_h;
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
+        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.height/ctx->device.width){
+            ctx->mTask.output.crop.w = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
         }
         else{
-            sIPUOutputParam.output_win.win_w = ctx->sec_disp_w > MAX_SEC_DISP_WIDTH?MAX_SEC_DISP_WIDTH:ctx->sec_disp_w;
-            sIPUOutputParam.output_win.win_h = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
+            ctx->mTask.output.crop.h = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
         }
     }
-    sIPUOutputParam.output_win.pos.x = (ctx->sec_disp_w - sIPUOutputParam.output_win.win_w)/2;
-    sIPUOutputParam.output_win.pos.y = (ctx->sec_disp_h - sIPUOutputParam.output_win.win_h)/2;
-
-
-    //sIPUOutputParam.rot = 0;
-    sIPUOutputParam.rot = ctx->sec_rotation;
-    //LOGI("Sec Rotation %d",ctx->sec_rotation);
-
-    sIPUOutputParam.user_def_paddr[0] = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    //LOGI("Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-    //sIPUOutputParam.width,
-    //sIPUOutputParam.height,
-    //sIPUOutputParam.output_win.pos.x,
-    //sIPUOutputParam.output_win.pos.y,
-    //sIPUOutputParam.output_win.win_w,
-    //sIPUOutputParam.output_win.win_h,
-    //sIPUOutputParam.rot);
-                                         
-    //LOGI("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-    //sIPUInputParam.width,
-    //sIPUInputParam.height,
-    //sIPUInputParam.fmt,
-    //sIPUInputParam.input_crop_win.pos.x,
-    //sIPUInputParam.input_crop_win.pos.y,
-    //sIPUInputParam.input_crop_win.win_w,
-    //sIPUInputParam.input_crop_win.win_h);     
-        
-    iIPURet =  mxc_ipu_lib_task_init(&sIPUInputParam,NULL,&sIPUOutputParam,OP_NORMAL_MODE|TASK_VF_MODE,&sIPUHandle);
-    if (iIPURet < 0) {
-        LOGE("Error!mxc_ipu_lib_task_init failed mIPURet %d!",iIPURet);
-        return -1;
-    }  
-    //LOGI("mxc_ipu_lib_task_init success");
-    iIPURet = mxc_ipu_lib_task_buf_update(&sIPUHandle,phys,sIPUOutputParam.user_def_paddr[0],NULL,NULL,NULL);
-    if (iIPURet < 0) {
-        LOGE("Error!mxc_ipu_lib_task_buf_update failed mIPURet %d!",iIPURet);
-        mxc_ipu_lib_task_uninit(&sIPUHandle);
-        return -1;
+
+    ctx->mTask.output.crop.pos.x = (ctx->sec_disp_w - ctx->mTask.output.crop.w)/2;
+    ctx->mTask.output.crop.pos.y = (ctx->sec_disp_h - ctx->mTask.output.crop.h)/2;
+
+    ctx->mTask.output.rotate = ctx->sec_rotation;
+    ctx->mTask.output.paddr = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
+
+    int status = -EINVAL;
+    int ret = IPU_CHECK_ERR_INPUT_CROP;
+
+    while(ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN) {
+        ret = ioctl(ctx->mIpuFd, IPU_CHECK_TASK, &ctx->mTask);
+        switch(ret) {
+            case IPU_CHECK_OK:
+                break;
+            case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
+                ctx->mTask.input.crop.w -= 8;
+                break;
+            case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
+                ctx->mTask.input.crop.h -= 8;
+                break;
+            case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
+                ctx->mTask.output.crop.w -= 8;
+                break;
+            case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
+                ctx->mTask.output.crop.h -= 8;;
+                break;
+            default:
+                return status;
+        }
+    }
+    status = ioctl(ctx->mIpuFd, IPU_QUEUE_TASK, &ctx->mTask);
+    if(status < 0) {
+        LOGE("%s:%d, IPU_QUEUE_TASK failed %d", __FUNCTION__, __LINE__ ,status);
     }
-    //LOGI("mxc_ipu_lib_task_buf_update success");
-    mxc_ipu_lib_task_uninit(&sIPUHandle);
 
-    return 0;
+    return status;
 }
 
+#if 0
 /** convert HAL_PIXEL_FORMAT to C2D format */
 static C2D_COLORFORMAT get_format(int format) {
     switch (format) {
@@ -1541,7 +1530,7 @@ static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx)
 
     return 0;
 }
-
+#endif
 void * secDispShowFrames(void * arg)
 {
     private_module_t* m = NULL;
@@ -1585,7 +1574,7 @@ void * secDispShowFrames(void * arg)
         {
             hnd = reinterpret_cast<private_handle_t const*>(ctx->buffer);
             m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
-
+#if 0
             if(ctx->c2dctx != NULL)
             {
                 resizeToSecFrameBuffer_c2d(hnd->base,
@@ -1593,6 +1582,7 @@ void * secDispShowFrames(void * arg)
                            ctx);
             }
             else
+#endif
             {
                 resizeToSecFrameBuffer(hnd->base,
                                    m->framebuffer->phys + hnd->base - m->framebuffer->base,
@@ -1689,11 +1679,7 @@ int fb_device_open(hw_module_t const* module, const char* name,
             *device = &dev->device.common;
             fbdev = (framebuffer_device_t*) *device;
             fbdev->reserved[0] = nr_framebuffers;
-        }
-
-	/* initialize the IPU lib IPC */
-        if (!no_ipu)
-            mxc_ipu_lib_ipc_init();
+      }
 
     fslwatermark_sem_open();
 
diff --git a/mx5x/libgralloc/gralloc.cpp b/mx5x/libgralloc/gralloc.cpp
index cd16f28..64fbc78 100755
--- a/mx5x/libgralloc/gralloc.cpp
+++ b/mx5x/libgralloc/gralloc.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved. */
 
 #include <limits.h>
 #include <unistd.h>
@@ -214,7 +214,7 @@ static int init_pmem_area_locked(private_module_t* m)
                 LOGE("PMEM_GET_PHYS failed (%s)", strerror(-errno));
             } else {
                 m->master_phys = (unsigned long)region.offset;
-				LOGI("PMEM GPU enabled, size:%d, phys base:%x",size,m->master_phys);
+				LOGI("PMEM GPU enabled, size:%d, phys base:%lx",size,m->master_phys);
             }
         }
         m->pmem_master = master_fd;
@@ -368,9 +368,9 @@ static int gralloc_alloc(alloc_device_t* dev,
         return -EINVAL;
 
     size_t size, alignedw, alignedh;
-    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || format == HAL_PIXEL_FORMAT_YCbCr_422_I || 
+    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || format == HAL_PIXEL_FORMAT_YCbCr_422_I ||
             format == HAL_PIXEL_FORMAT_YCbCr_422_SP || format == HAL_PIXEL_FORMAT_YCbCr_420_I ||
-	format == HAL_PIXEL_FORMAT_YV12)
+            format == HAL_PIXEL_FORMAT_YV12)
     {
         // FIXME: there is no way to return the alignedh
         alignedw = ALIGN_PIXEL_16(w);
@@ -423,9 +423,9 @@ static int gralloc_alloc(alloc_device_t* dev,
         return err;
     }
 
-	private_handle_t* hnd = (private_handle_t*)(*pHandle);
-	hnd->usage = usage;
-	hnd->format = format;
+    private_handle_t* hnd = (private_handle_t*)(*pHandle);
+    hnd->usage = usage;
+    hnd->format = format;
     hnd->width = alignedw;
     hnd->height = alignedh;
 
@@ -454,7 +454,7 @@ static int gralloc_free(alloc_device_t* dev,
                 struct pmem_region sub = { hnd->offset, hnd->size };
                 int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
                 LOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
-                        "fd=%d, sub.offset=%lu, sub.size=%lu",
+                        "fd=%d, sub.offset=%d, sub.size=%d",
                         strerror(errno), hnd->fd, hnd->offset, hnd->size);
                 if (err == 0) {
                     // we can't deallocate the memory in case of UNMAP failure
@@ -493,6 +493,9 @@ int gralloc_device_open(const hw_module_t* module, const char* name,
         hw_device_t** device)
 {
     int status = -EINVAL;
+    hw_module_t *hw = const_cast<hw_module_t *>(module);
+    private_module_t* m = reinterpret_cast<private_module_t*>(hw);
+
     if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
         gralloc_context_t *dev;
         dev = (gralloc_context_t*)malloc(sizeof(*dev));
@@ -512,6 +515,12 @@ int gralloc_device_open(const hw_module_t* module, const char* name,
         *device = &dev->device.common;
         status = 0;
     } else {
+
+        m->flags = 0;
+        m->pmem_master = -1;
+        m->pmem_master_base=0;
+        m->master_phys = 0;
+
         status = fb_device_open(module, name, device);
     }
     return status;
diff --git a/mx5x/libgralloc/gralloc_priv.h b/mx5x/libgralloc/gralloc_priv.h
index 638e5d8..08a77d2 100755
--- a/mx5x/libgralloc/gralloc_priv.h
+++ b/mx5x/libgralloc/gralloc_priv.h
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #ifndef GRALLOC_PRIV_H_
 #define GRALLOC_PRIV_H_
@@ -78,6 +78,7 @@ struct private_handle_t {
     enum {
         PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
         PRIV_FLAGS_USES_PMEM   = 0x00000002,
+        PRIV_FLAGS_NEEDS_FLUSH    = 0x00000008,
     };
 
     enum {
diff --git a/mx5x/libgralloc/mapper.cpp b/mx5x/libgralloc/mapper.cpp
index 139ad43..f75bcc1 100755
--- a/mx5x/libgralloc/mapper.cpp
+++ b/mx5x/libgralloc/mapper.cpp
@@ -14,17 +14,19 @@
  * limitations under the License.
  */
 
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
+/*Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
 
 #include <limits.h>
 #include <errno.h>
 #include <pthread.h>
 #include <unistd.h>
 #include <string.h>
+#include <stdarg.h>
 
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
 
 #include <cutils/log.h>
 #include <cutils/atomic.h>
@@ -32,6 +34,8 @@
 #include <hardware/hardware.h>
 #include <hardware/gralloc.h>
 
+#include <linux/android_pmem.h>
+
 #include "gralloc_priv.h"
 
 
@@ -61,7 +65,9 @@ static int gralloc_map(gralloc_module_t const* module,
         void* mappedAddress = mmap(0, size,
                 PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
         if (mappedAddress == MAP_FAILED) {
-            LOGE("Could not mmap %s", strerror(errno));
+            LOGE("Could not mmap handle %p, fd=%d (%s)",
+                    handle, hnd->fd, strerror(errno));
+            hnd->base = 0;
             return -errno;
         }
         hnd->base = intptr_t(mappedAddress) + hnd->offset;
@@ -226,7 +232,16 @@ int gralloc_lock(gralloc_module_t const* module,
 
     if (new_value & private_handle_t::LOCK_STATE_WRITE) {
         // locking for write, store the tid
-        hnd->writeOwner = getpid();
+        hnd->writeOwner = gettid();
+    }
+
+    // if requesting sw write for non-framebuffer handles, flag for
+    // flushing at unlock
+
+    if ((usage & GRALLOC_USAGE_SW_WRITE_MASK) &&
+            (hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) &&
+            !(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
+        hnd->flags |= private_handle_t::PRIV_FLAGS_NEEDS_FLUSH;
     }
 
     if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
@@ -258,13 +273,25 @@ int gralloc_unlock(gralloc_module_t const* module,
     private_handle_t* hnd = (private_handle_t*)handle;
     int32_t current_value, new_value;
 
+    if (hnd->flags & private_handle_t::PRIV_FLAGS_NEEDS_FLUSH) {
+        struct pmem_region region;
+        int err;
+
+        region.offset = hnd->offset;
+        region.len = hnd->size;
+        err = ioctl(hnd->fd, PMEM_CACHE_FLUSH, &region);
+        LOGE_IF(err < 0, "cannot flush handle %p (offs=%x len=%x)\n",
+                hnd, hnd->offset, hnd->size);
+        hnd->flags &= ~private_handle_t::PRIV_FLAGS_NEEDS_FLUSH;
+    }
+
     do {
         current_value = hnd->lockState;
         new_value = current_value;
 
         if (current_value & private_handle_t::LOCK_STATE_WRITE) {
             // locked for write
-            if (hnd->writeOwner == getpid()) {
+            if (hnd->writeOwner == gettid()) {
                 hnd->writeOwner = 0;
                 new_value &= ~private_handle_t::LOCK_STATE_WRITE;
             }
-- 
1.8.0

