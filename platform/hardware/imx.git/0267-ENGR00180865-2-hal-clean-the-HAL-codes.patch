From 316e80db71a9b7ac433295f22f04d7aef2066cf9 Mon Sep 17 00:00:00 2001
From: Xinyu Chen <xinyu.chen@freescale.com>
Date: Thu, 26 Apr 2012 11:20:52 +0800
Subject: [PATCH 267/498] ENGR00180865-2 hal: clean the HAL codes

Remove the unused libcamera dir
Remove the unused mx6/libgralloc dir
Remove the pmem allocator in mx6 camera HAL
Remove the PMEM codes from mx6/

Signed-off-by: Xinyu Chen <xinyu.chen@freescale.com>
---
 libcamera/CameraHal.cpp                  | 1836 ------------------------------
 libcamera/CameraHal.h                    |  377 ------
 libcamera/Camera_pmem.cpp                |  163 ---
 libcamera/Camera_pmem.h                  |   53 -
 libcamera/Camera_utils.h                 |   60 -
 libcamera/CaptureDeviceInterface.cpp     |   40 -
 libcamera/CaptureDeviceInterface.h       |  102 --
 libcamera/JpegEncoderInterface.cpp       |   34 -
 libcamera/JpegEncoderInterface.h         |  173 ---
 libcamera/JpegEncoderSoftware.cpp        |  661 -----------
 libcamera/JpegEncoderSoftware.h          |   84 --
 libcamera/PP_ipulib.cpp                  |  138 ---
 libcamera/PP_ipulib.h                    |   47 -
 libcamera/PostProcessDeviceInterface.cpp |   26 -
 libcamera/PostProcessDeviceInterface.h   |   78 --
 libcamera/V4l2CapDeviceBase.cpp          |  612 ----------
 libcamera/V4l2CapDeviceBase.h            |   84 --
 libcamera/V4l2CsiDevice.cpp              |  362 ------
 libcamera/V4l2CsiDevice.h                |   53 -
 libcamera/V4l2UVCDevice.h                |   41 -
 mx6/hwcomposer/Android.mk                |    2 +-
 mx6/libcamera/Android.mk                 |    3 +-
 mx6/libcamera/CameraHal.cpp              |   14 -
 mx6/libcamera/CameraHal.h                |    8 +-
 mx6/libcamera/Camera_pmem.cpp            |  163 ---
 mx6/libcamera/Camera_pmem.h              |   53 -
 mx6/libgralloc/Android.mk                |   53 -
 mx6/libgralloc/allocator.cpp             |  172 ---
 mx6/libgralloc/allocator.h               |  130 ---
 mx6/libgralloc/framebuffer.cpp           | 1532 -------------------------
 mx6/libgralloc/gr.h                      |   65 --
 mx6/libgralloc/gralloc.cpp               |  560 ---------
 mx6/libgralloc/gralloc_priv.h            |  151 ---
 mx6/libgralloc/mapper.cpp                |  327 ------
 mx6/libgralloc_wrapper/framebuffer.cpp   |    6 +-
 mx6/libgralloc_wrapper/gralloc.cpp       |    6 -
 mx6/libgralloc_wrapper/gralloc_priv.h    |   13 +-
 mx6/libgralloc_wrapper/mapper.cpp        |    3 -
 38 files changed, 11 insertions(+), 8274 deletions(-)
 delete mode 100755 libcamera/CameraHal.cpp
 delete mode 100755 libcamera/CameraHal.h
 delete mode 100755 libcamera/Camera_pmem.cpp
 delete mode 100755 libcamera/Camera_pmem.h
 delete mode 100755 libcamera/Camera_utils.h
 delete mode 100755 libcamera/CaptureDeviceInterface.cpp
 delete mode 100755 libcamera/CaptureDeviceInterface.h
 delete mode 100755 libcamera/JpegEncoderInterface.cpp
 delete mode 100755 libcamera/JpegEncoderInterface.h
 delete mode 100755 libcamera/JpegEncoderSoftware.cpp
 delete mode 100755 libcamera/JpegEncoderSoftware.h
 delete mode 100755 libcamera/PP_ipulib.cpp
 delete mode 100755 libcamera/PP_ipulib.h
 delete mode 100755 libcamera/PostProcessDeviceInterface.cpp
 delete mode 100755 libcamera/PostProcessDeviceInterface.h
 delete mode 100755 libcamera/V4l2CapDeviceBase.cpp
 delete mode 100755 libcamera/V4l2CapDeviceBase.h
 delete mode 100755 libcamera/V4l2CsiDevice.cpp
 delete mode 100755 libcamera/V4l2CsiDevice.h
 delete mode 100755 libcamera/V4l2UVCDevice.h
 delete mode 100755 mx6/libcamera/Camera_pmem.cpp
 delete mode 100755 mx6/libcamera/Camera_pmem.h
 delete mode 100755 mx6/libgralloc/Android.mk
 delete mode 100755 mx6/libgralloc/allocator.cpp
 delete mode 100755 mx6/libgralloc/allocator.h
 delete mode 100755 mx6/libgralloc/framebuffer.cpp
 delete mode 100755 mx6/libgralloc/gr.h
 delete mode 100755 mx6/libgralloc/gralloc.cpp
 delete mode 100755 mx6/libgralloc/gralloc_priv.h
 delete mode 100755 mx6/libgralloc/mapper.cpp

diff --git a/libcamera/CameraHal.cpp b/libcamera/CameraHal.cpp
deleted file mode 100755
index 8a446af..0000000
--- a/libcamera/CameraHal.cpp
+++ /dev/null
@@ -1,1836 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-
-#include <cutils/properties.h>
-#include "CameraHal.h"
-#include <time.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dlfcn.h>
-#include <hardware_legacy/power.h>
-
-namespace android {
-
-    CameraHal::CameraHal()
-        : mParameters(),
-        mCallbackCookie(NULL),
-        mNotifyCb(NULL),
-        mDataCb(NULL),
-        mDataCbTimestamp(NULL),
-        mCaptureFrameThread(NULL),
-        mPostProcessThread(NULL),
-        mPreviewShowFrameThread(NULL),
-        mEncodeFrameThread(NULL),
-        mAutoFocusThread(NULL),
-        mTakePicThread(NULL),
-        mLock(),
-        supportedPictureSizes(NULL),
-        supportedPreviewSizes(NULL),
-        supportedFPS(NULL),
-        supprotedThumbnailSizes(NULL),
-        mOverlay(NULL),
-        mMsgEnabled(0),
-        mPreviewHeap(0),
-        mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
-        mPPbufNum(0),
-        mPreviewRunning(0),
-        mPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
-        mPreviewFrameSize(0),
-        mTakePicFlag(false),
-        mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
-        mCaptureFrameSize(0),
-        mCaptureBufNum(0),
-        mRecordRunning(0),
-        mCurrentRecordFrame(0),
-        nCameraBuffersQueued(0),
-        mPreviewHeapBufNum(PREVIEW_HEAP_BUF_NUM),
-        mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
-        mCameraReady(false),
-        mCaptureDeviceOpen(false),
-        mPPDeviceNeed(false),
-        mPPDeviceNeedForPic(false),
-        mPowerLock(false),
-        mPreviewRotate(CAMERA_PREVIEW_BACK_REF)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        preInit();
-    }
-
-    CameraHal :: ~CameraHal()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CameraMiscDeInit();
-        CloseCaptureDevice();
-        FreeInterBuf();
-        postDestroy();
-    }
-
-    void CameraHal :: release()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        Mutex::Autolock lock(mLock);
-
-        mCameraReady = false;
-        CameraHALStopPreview();
-        UnLockWakeLock();
-        return;
-    }
-
-    void CameraHal :: preInit()
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-    }
-    void CameraHal :: postDestroy()
-    {
-        CAMERA_HAL_LOG_FUNC;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mCaptureDevice = capturedevice;
-        else
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mPPDevice = postprocessdevice;
-        else 
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        if (mCameraReady == false)
-            mJpegEncoder = jpegencoder;
-        else
-            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
-        return ret;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal::Init()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        mCameraReady == true;
-
-        if ((ret = AolLocForInterBuf())<0)
-            return ret;
-        if ((ret = InitCameraHalParam()) < 0)
-            return ret;
-        if (mPPDeviceNeed == true && mPPDevice == NULL)
-            return CAMERA_HAL_ERR_PP_NULL;
-        if ((ret = CameraMiscInit()) < 0)
-            return ret;
-
-        return ret;
-    }
-    void  CameraHal::setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        mPreviewRotate = previewRotate;
-        return ;
-    }
-
-    CAMERA_HAL_ERR_RET  CameraHal :: AolLocForInterBuf()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-
-        supportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        supportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        supportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-        supprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
-
-        if (supportedPictureSizes == NULL ||
-                supportedPreviewSizes == NULL ||
-                supportedFPS          == NULL ||
-                supprotedThumbnailSizes == NULL)
-            ret = CAMERA_HAL_ERR_ALLOC_BUF;
-
-        return ret;
-    }
-    void  CameraHal :: FreeInterBuf()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        if (supportedPictureSizes)
-            free(supportedPictureSizes);
-        if (supportedPreviewSizes)
-            free(supportedPreviewSizes);
-        if (supportedFPS)
-            free(supportedFPS);
-        if (supprotedThumbnailSizes)
-            free(supprotedThumbnailSizes);
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: InitCameraHalParam()
-    {	
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-
-        if ((ret = GetCameraBaseParam(&mParameters)) < 0)
-            return ret;
-
-        if ((ret = GetPictureExifParam(&mParameters)) < 0)
-            return ret;
-
-        return ret;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal::CameraMiscInit()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        pthread_mutex_init(&mPPIOParamMutex, NULL);
-        pthread_mutex_init(&mOverlayMutex, NULL);
-        return ret;
-    }
-    CAMERA_HAL_ERR_RET CameraHal::CameraMiscDeInit()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
-        pthread_mutex_destroy(&mPPIOParamMutex);
-        pthread_mutex_destroy(&mOverlayMutex);
-        return ret;
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: GetCameraBaseParam(CameraParameters *pParam)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        char TmpStr[20];
-        unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
-        struct capture_config_t CaptureSizeFps;
-        int  previewCnt= 0, pictureCnt = 0, i;
-
-        pParam->setPreviewFormat(CameraParameters::PIXEL_FORMAT_YUV420SP);
-        pParam->set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, CameraParameters::PIXEL_FORMAT_YUV420SP);
-
-        //the Camera Open here will not be close immediately, for later preview.
-        if (OpenCaptureDevice() < 0)
-            return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
-
-        memset(mCaptureSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
-
-        for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mCaptureSupportedFormat[i])) < 0)
-                break;
-        }
-        if (i == 0)
-            return CAMERA_HAL_ERR_GET_PARAM;
-
-        if (NegotiateCaptureFmt(false) < 0)
-            return CAMERA_HAL_ERR_GET_PARAM;
-
-        CaptureSizeFps.fmt = mPreviewCapturedFormat;
-
-        CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat is %x", mPreviewCapturedFormat);
-
-        for(;;){
-            if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
-                CAMERA_HAL_LOG_RUNTIME("get the frame size and time interval error");
-                break;
-            }
-            sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
-            CAMERA_HAL_LOG_INFO("the size is %s , the framerate is %d ", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
-            if (previewCnt == 0)
-                strncpy((char*) supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-            else{
-                strncat(supportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                strncat(supportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-            }
-            pictureCnt ++;
-
-            if (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator > 25){
-                if (previewCnt == 0)
-                    strncpy((char*) supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-                else{
-                    strncat(supportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-                    strncat(supportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
-                }
-                previewCnt ++;
-            }
-        }
-
-        /*hard code here*/
-        strcpy(supportedFPS, "15,30");
-        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", supportedPictureSizes);
-        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", supportedPreviewSizes);
-        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", supportedFPS);
-
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, supportedPictureSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, supportedPreviewSizes);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, supportedFPS);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(1000,15000),(5000,30000)");
-        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "5000,30000");
-
-        pParam->setPreviewSize(640, 480);
-        pParam->setPictureSize(640, 480);
-        pParam->setPreviewFrameRate(5);
-
-        return CAMERA_HAL_ERR_NONE;
-
-    }
-
-    status_t CameraHal :: OpenCaptureDevice()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        if (mCaptureDeviceOpen){
-            CAMERA_HAL_LOG_INFO("The capture device already open");
-            return NO_ERROR;
-        }
-        else if (mCaptureDevice != NULL){
-            if ( mCaptureDevice->DevOpen()<0 )
-                return INVALID_OPERATION;
-            mCaptureDeviceOpen = true;
-        }else{
-            CAMERA_HAL_ERR("no capture device assigned");
-            return INVALID_OPERATION;
-        }
-        return ret;
-    }
-    void CameraHal ::CloseCaptureDevice()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        if (mCaptureDeviceOpen && mCaptureDevice != NULL){
-            mCaptureDevice->DevClose();
-            mCaptureDeviceOpen = false;
-        }
-    }
-
-    CAMERA_HAL_ERR_RET CameraHal :: GetPictureExifParam(CameraParameters *pParam)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
-
-        /*hard code here*/
-        pParam->set(CameraParameters::KEY_FOCUS_DISTANCES, "24.0,50.0,2147483648.0");
-        pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
-        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
-        pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
-        strcpy(supprotedThumbnailSizes, "0x0,128x128,96x96");
-        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, supprotedThumbnailSizes);
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
-        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
-        pParam->set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
-        pParam->set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
-        pParam->set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
-
-        pParam->set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, CameraParameters::FOCUS_MODE_AUTO);
-        pParam->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
-
-        pParam->set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
-        pParam->set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
-        pParam->set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
-        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
-        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
-        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
-        pParam->set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
-
-        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
-        strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
-        pParam->set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
-        pParam->set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
-        pParam->set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
-        pParam->set(CameraParameters::KEY_MAX_ZOOM, "1");
-        // default zoom should be 0 as CTS defined
-        pParam->set(CameraParameters::KEY_ZOOM, "0");
-        //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
-        //returned as 320. The number of elements is {@link
-        //#getMaxZoom} + 1. The list is sorted from small to large. The
-        //first element is always 100. The last element is the zoom
-        //ratio of the maximum zoom value.
-        pParam->set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
-
-        return CAMERA_HAL_ERR_NONE;
-    }
-
-    sp<IMemoryHeap> CameraHal::getPreviewHeap() const
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        return mPreviewHeap;
-    }
-
-    sp<IMemoryHeap> CameraHal::getRawHeap() const
-    {
-        return NULL;
-    }
-
-    status_t CameraHal::dump(int fd, const Vector<String16>& args) const
-    {
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
-            int32_t arg2)
-    {
-        return BAD_VALUE;
-    }
-
-    void CameraHal::setCallbacks(notify_callback notify_cb,
-            data_callback data_cb,
-            data_callback_timestamp data_cb_timestamp,
-            void* user)
-    {
-        Mutex::Autolock lock(mLock);
-        mNotifyCb = notify_cb;
-        mDataCb = data_cb;
-        mDataCbTimestamp = data_cb_timestamp;
-        mCallbackCookie = user;
-    }
-
-    void CameraHal::enableMsgType(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_HAL_LOG_INFO("###the mesg enabled is %x###", msgType);
-        mMsgEnabled |= msgType;
-    }
-
-    void CameraHal::disableMsgType(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_HAL_LOG_INFO("###the mesg disabled is %x###", msgType);
-        mMsgEnabled &= ~msgType;
-    }
-    bool CameraHal::msgTypeEnabled(int32_t msgType)
-    {
-        Mutex::Autolock lock(mLock);
-        CAMERA_HAL_LOG_INFO("###the mesg check is %x###", msgType);
-        return (mMsgEnabled & msgType);
-    }
-
-    CameraParameters CameraHal::getParameters() const
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        Mutex::Autolock lock(mLock);
-        return mParameters;
-    }
-
-    status_t  CameraHal:: setParameters(const CameraParameters& params)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int w, h;
-        int framerate;
-        int max_zoom,zoom, max_fps, min_fps;
-        char tmp[128];
-        Mutex::Autolock lock(mLock);
-
-        max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
-        zoom = params.getInt(CameraParameters::KEY_ZOOM);
-        if(zoom > max_zoom){
-            CAMERA_HAL_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
-            return BAD_VALUE;
-        }
-        if (!(strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
-                (strcmp(params.getPreviewFormat(), "yuv422i") == 0)) {
-            CAMERA_HAL_ERR("Only yuv420 or yuv420i is supported");
-            return BAD_VALUE;
-        }
-
-        if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
-            CAMERA_HAL_ERR("Only jpeg still pictures are supported");
-            return BAD_VALUE;
-        }
-
-        params.getPreviewSize(&w, &h);
-        sprintf(tmp, "%dx%d", w, h);
-        CAMERA_HAL_LOG_INFO("##the set preview size is %s ##", tmp);
-        if (strstr(supportedPreviewSizes, tmp) == NULL){
-            CAMERA_HAL_ERR("The preview size w %d, h %d is not corrected", w, h);
-            return BAD_VALUE;
-        }
-
-        params.getPictureSize(&w, &h);
-        sprintf(tmp, "%dx%d", w, h);
-        CAMERA_HAL_LOG_INFO("##the set picture size is %s ##", tmp);
-        if (strstr(supportedPictureSizes, tmp) == NULL){
-            CAMERA_HAL_ERR("The picture size w %d, h %d is not corrected", w, h);
-            return BAD_VALUE;
-        }
-
-        framerate = params.getPreviewFrameRate();
-        CAMERA_HAL_LOG_INFO("##the set frame rate is %d ##", framerate);
-        if (framerate >30 || framerate<0 ){
-            CAMERA_HAL_ERR("The framerate is not corrected");
-            return BAD_VALUE;
-        }
-
-        params.getPreviewFpsRange(&min_fps, &max_fps);
-        CAMERA_HAL_LOG_INFO("###the fps is %d###", max_fps);
-        if (max_fps < 1000 || min_fps < 1000 || max_fps > 30000 || min_fps > 30000){
-            CAMERA_HAL_ERR("The fps range from %d to %d is error", min_fps, max_fps);
-            return BAD_VALUE;
-        }
-
-        mParameters = params;
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::setOverlay(const sp<Overlay> &overlay)
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        Mutex::Autolock lock(mLock);
-        if (overlay == NULL){
-            CAMERA_HAL_LOG_INFO("Trying to set overlay, but overlay is null!");
-        }
-        else{
-            CAMERA_HAL_LOG_INFO("Get the overlay to display");
-            overlay->setParameter(OVERLAY_MODE, OVERLAY_PUSH_MODE);
-        }
-        pthread_mutex_lock(&mOverlayMutex);
-        mOverlay = overlay;
-        pthread_mutex_unlock(&mOverlayMutex);
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::startPreview()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-
-        Mutex::Autolock lock(mLock);
-        if (mPreviewRunning) {
-            return NO_ERROR;
-        }
-        if ((ret == CameraHALStartPreview())<0)
-            return ret;
-
-        LockWakeLock();
-        return ret;
-    }
-
-    void CameraHal::stopPreview()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        struct timeval af_time, be_time;
-        Mutex::Autolock lock(mLock);
-        /* Cannot stop preview in recording */
-        //   if(mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)
-        //       return;
-
-        CameraHALStopPreview();
-        UnLockWakeLock();
-
-    }
-
-    bool CameraHal::previewEnabled()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        return mPreviewRunning;
-    }
-
-    status_t CameraHal::startRecording()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-
-        if (mRecordRunning == true ) {
-            CAMERA_HAL_LOG_INFO("Recording is already existed\n");
-            return ret;
-        }
-        if((ret = AllocateRecordVideoBuf())<0)
-            return ret;
-
-        mRecordRunning = true;
-
-        return NO_ERROR;
-    }
-
-    void CameraHal::stopRecording()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        mRecordRunning = false;
-    }
-
-    void CameraHal::releaseRecordingFrame(const sp<IMemory>& mem)
-    {
-        ssize_t offset;
-        size_t  size;
-        int index;
-
-        offset = mem->offset();
-        size   = mem->size();
-        index = offset / size;
-
-        mVideoBufferUsing[index] = 0;
-    }
-
-    bool CameraHal::recordingEnabled()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        return (mPreviewRunning && mRecordRunning);
-    }
-
-    status_t CameraHal::autoFocus()
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        Mutex::Autolock lock(mLock);
-
-        if (mAutoFocusThread != NULL)
-            mAutoFocusThread.clear();
-
-        mAutoFocusThread = new AutoFocusThread(this);
-        if (mAutoFocusThread == NULL)
-            return UNKNOWN_ERROR;
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::cancelAutoFocus()
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::takePicture()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        Mutex::Autolock lock(mLock);
-
-        if (mTakePicThread != NULL)
-            mTakePicThread.clear();
-
-        mTakePicThread= new TakePicThread(this);
-        if (mTakePicThread == NULL)
-            return UNKNOWN_ERROR;
-        return NO_ERROR;
-    }
-
-    status_t CameraHal::cancelPicture()
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        return NO_ERROR;
-    }
-
-
-    int CameraHal::autoFocusThread()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int FocusFlag = 0;
-
-        if (mMsgEnabled & CAMERA_MSG_FOCUS)
-            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
-
-        return UNKNOWN_ERROR; //exit the thread
-    }
-
-    int CameraHal::takepicThread()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_LOG_INFO("Camera is taking picture!");
-
-        /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
-        CameraHALStopPreview();
-        cameraHALTakePicture();
-
-        return UNKNOWN_ERROR;
-    }
-
-    int CameraHal :: cameraHALTakePicture()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int ret = NO_ERROR;
-        unsigned int DeQueBufIdx = 0;
-        struct jpeg_encoding_conf JpegEncConf;
-        DMA_BUFFER Buf_input, Buf_output;
-        sp<MemoryBase> JpegMemBase = NULL;
-        sp<MemoryHeapBase> JpegImageHeap = NULL;
-        int  max_fps, min_fps;
-
-        if (mJpegEncoder == NULL){
-            CAMERA_HAL_ERR("the jpeg encoder is NULL");
-            return BAD_VALUE;
-        }
-        mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
-        mCaptureDeviceCfg.tv.numerator = 1;
-        mCaptureDevice->GetDevName(mCameraSensorName);
-        if (strstr(mCameraSensorName, "uvc") == NULL){
-        //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-        // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
-        if (mParameters.getPreviewFrameRate() >= 15)
-            mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-        else{
-            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-            CAMERA_HAL_LOG_INFO("###start the preview the fps is %d###", max_fps);
-            mCaptureDeviceCfg.tv.denominator = max_fps/1000;
-        }
-        }else{
-                mCaptureDeviceCfg.tv.denominator = 15;
-        }
-        mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
-        mPPbufNum = 1;
-        mTakePicFlag = true;
-        mPPDeviceNeedForPic = false;
-        if ((ret = GetJpegEncoderParam()) < 0)
-            return ret;
-        if ((ret = NegotiateCaptureFmt(true)) < 0)
-            return ret;
-
-        if (mPPDeviceNeedForPic){
-            if ((ret = PreparePostProssDevice()) < 0){
-                CAMERA_HAL_ERR("PreparePostProssDevice error");
-                return ret;
-            }
-        }
-        if ((ret = PrepareCaptureDevices()) < 0)
-            return ret;
-
-        if (mPPDeviceNeedForPic){
-            if ((ret = PreparePreviwBuf()) < 0){
-                CAMERA_HAL_ERR("PreparePreviwBuf error");
-                return ret;
-            }
-        }
-        if ((ret = PrepareJpegEncoder()) < 0)
-            return ret;
-
-        if (mCaptureDevice->DevStart()<0){
-            CAMERA_HAL_ERR("the capture start up failed !!!!");
-            return INVALID_OPERATION;
-        }
-
-        for (unsigned int i =0;;){
-            if (mCaptureDevice->DevDequeue(&DeQueBufIdx) < 0){
-                LOGE("VIDIOC_DQBUF Failed!!!");
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-
-            if (++i == mCaptureDeviceCfg.picture_waite_number)
-                break;
-
-            if (mCaptureDevice->DevQueue(DeQueBufIdx) < 0 ){
-                ret = UNKNOWN_ERROR;
-                goto Pic_out;
-            }
-        }
-
-        JpegImageHeap= new MemoryHeapBase(mCaptureFrameSize);
-        if (JpegImageHeap == NULL){
-            ret = NO_MEMORY;
-            goto Pic_out;
-        }
-        // do the csc if necessary
-        if (mPPDeviceNeedForPic){
-            mPPInputParam.user_def_paddr = mCaptureBuffers[DeQueBufIdx].phy_offset;
-            mPPOutputParam.user_def_paddr = mPPbuf[0].phy_offset;
-            mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
-            mPPDevice->DoPorcess(&(mCaptureBuffers[DeQueBufIdx]), &(mPPbuf[0]));
-            mPPDevice->PPDeviceDeInit();
-            Buf_input = mPPbuf[0];
-        }else{
-            Buf_input = mCaptureBuffers[DeQueBufIdx];
-        }
-
-        Buf_output.virt_start = (unsigned char *)(JpegImageHeap->getBase());
-        CAMERA_HAL_LOG_INFO("Generated a picture");
-
-        if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
-            CAMERA_HAL_LOG_INFO("CAMERA_MSG_SHUTTER");
-            mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
-        }
-
-        if (mJpegEncoder->DoEncode(&Buf_input,&Buf_output,&JpegEncConf) < 0){
-            ret = UNKNOWN_ERROR;
-            goto Pic_out;
-        }
-
-        JpegMemBase = new MemoryBase(JpegImageHeap, 0, JpegEncConf.output_jpeg_size);
-
-Pic_out:
-        mCaptureDevice->DevStop();
-        mCaptureDevice->DevDeAllocate();
-        CloseCaptureDevice();
-
-        if ((JpegMemBase != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
-            CAMERA_HAL_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
-            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, mCallbackCookie);
-        }
-
-
-        return ret;
-
-    }
-
-    int CameraHal :: GetJpegEncoderParam()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int ret = NO_ERROR, i = 0;
-        memset(mEncoderSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
-
-        for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mEncoderSupportedFormat[i])) < 0)
-                break;
-        }
-        if (i == 0){
-            CAMERA_HAL_ERR("Get the parameters error");
-            return UNKNOWN_ERROR;
-        }
-        return ret;
-    }
-    int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int ret = NO_ERROR, i = 0, j = 0;
-
-
-        if(TakePicFlag){
-            mPictureEncodeFormat = 0;
-            for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
-                for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
-                    if (mEncoderSupportedFormat[j] == 0)
-                        break;
-                    if (mCaptureSupportedFormat[i] == mEncoderSupportedFormat[j]){
-                        mPictureEncodeFormat= mCaptureSupportedFormat[i];
-
-                        CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
-                                mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
-                                (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
-                        break;
-                    }
-                }
-                if ((mPictureEncodeFormat != 0) || (mCaptureSupportedFormat[i] == 0))
-                    break;
-            }
-            if (mPictureEncodeFormat == 0){
-                mPictureEncodeFormat = mEncoderSupportedFormat[0];
-                mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat; //For uvc now, IPU only can support yuyv.
-                mPPDeviceNeedForPic = true;
-                CAMERA_HAL_LOG_INFO("Need to do the CSC for Jpeg encoder");
-                CAMERA_HAL_LOG_INFO(" Get the captured format is :%c%c%c%c\n",
-                        mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
-                        (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
-                CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
-                        mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
-                        (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
-            }else{
-                mCaptureDeviceCfg.fmt = mPictureEncodeFormat;
-            }
-        }else{
-            CAMERA_HAL_LOG_INFO("mPreviewFormat :%c%c%c%c\n",
-                    mPreviewFormat & 0xFF, (mPreviewFormat >> 8) & 0xFF,
-                    (mPreviewFormat >> 16) & 0xFF, (mPreviewFormat >> 24) & 0xFF);
-            CAMERA_HAL_LOG_INFO("mUvcSpecialCaptureFormat :%c%c%c%c\n",
-                    mUvcSpecialCaptureFormat & 0xFF, (mUvcSpecialCaptureFormat >> 8) & 0xFF,
-                    (mUvcSpecialCaptureFormat >> 16) & 0xFF, (mUvcSpecialCaptureFormat >> 24) & 0xFF);
-
-            for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
-                if (mCaptureSupportedFormat[i] == mPreviewFormat){
-                    CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
-                    mPPDeviceNeed = false;
-                    mPreviewCapturedFormat = mPreviewFormat;
-                    break;
-                }
-            }
-
-            if (i == MAX_QUERY_FMT_TIMES){
-                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
-                    //since for CSI, the CSI can convert to any YUV format if necessary, so specailly is just for UVC
-                    if (mCaptureSupportedFormat[i] == mUvcSpecialCaptureFormat){
-                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
-                        mPPDeviceNeed = true;
-                        mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
-                        break;
-                    }
-                }
-            }
-
-            CAMERA_HAL_LOG_INFO("mPreviewCapturedFormat :%c%c%c%c\n",
-                    mPreviewCapturedFormat & 0xFF, (mPreviewCapturedFormat >> 8) & 0xFF,
-                    (mPreviewCapturedFormat >> 16) & 0xFF, (mPreviewCapturedFormat >> 24) & 0xFF);
-
-            if ((i == MAX_QUERY_FMT_TIMES)){
-                CAMERA_HAL_ERR("Negotiate for the preview format error");
-                return BAD_VALUE;
-            }
-        }
-
-
-        return ret;
-    }
-
-    int CameraHal :: PrepareJpegEncoder()
-    {
-        int ret = NO_ERROR;
-        struct jpeg_enc_make_info_t make_info;
-        struct jpeg_enc_makernote_info_t makernote_info;
-        struct jpeg_enc_model_info_t model_info;
-        struct jpeg_enc_datetime_info_t datetime_info;
-        struct jpeg_enc_focallength_t focallength_info;
-        struct jpeg_enc_gps_param gps_info;
-        int rotate_angle = 0;
-        JPEG_ENCODER_WHITEBALANCE whitebalance_info;
-        JPEG_ENCODER_FLASH flash_info;
-        const char * pWhiteBalanceStr, *pFlashStr;
-
-        char temp_string[30], gps_datetime_string[11];
-        char format[30] = "%Y:%m:%d %k:%M:%S";
-        time_t clock;
-        struct tm *tm, *temp_tm;
-        char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
-        double dAltitude;
-
-        mJpegEncCfg.BufFmt = mPictureEncodeFormat;
-        mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
-        mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
-        mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
-        CAMERA_HAL_LOG_INFO("the pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
-        CAMERA_HAL_LOG_INFO("the thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
-        //set focallength info
-        focallength_info.numerator=10001;
-        focallength_info.denominator=1000;  // hardcode here for the cts
-        mJpegEncCfg.pFoclLength = &focallength_info;
-
-        //set the make info
-        make_info.make_bytes=strlen(EXIF_MAKENOTE);
-        strcpy((char *)make_info.make, EXIF_MAKENOTE);
-        mJpegEncCfg.pMakeInfo = &make_info;
-
-        //set makernote info
-        makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
-        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
-        mJpegEncCfg.pMakeNote = &makernote_info;
-
-        //set model info
-        model_info.model_bytes=strlen(EXIF_MODEL);
-        strcpy((char *)model_info.model,EXIF_MODEL);
-        mJpegEncCfg.pModelInfo = &model_info;
-
-        //set datetime
-        time(&clock);
-        tm = localtime(&clock);
-        time_t GpsUtcTime;
-        strftime(temp_string, sizeof(temp_string), format, tm);
-        CAMERA_HAL_LOG_INFO("the date time is %s", temp_string);
-        memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
-        mJpegEncCfg.pDatetimeInfo = &datetime_info;
-
-        rotate_angle = mParameters.getInt(CameraParameters::KEY_ROTATION);
-        if (rotate_angle == 0)
-            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL; //the android and the jpeg has the same define
-        else if (rotate_angle == 90)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_90;
-        else if (rotate_angle == 180)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_180;
-        else if (rotate_angle == 270)
-            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_270;
-        else
-            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL;
-        CAMERA_HAL_LOG_INFO("ratate info is %d", rotate_angle);
-
-        pWhiteBalanceStr = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
-        CAMERA_HAL_LOG_INFO("white balance is %s",pWhiteBalanceStr);
-        if (strcmp(pWhiteBalanceStr, CameraParameters::WHITE_BALANCE_AUTO) == 0){
-            whitebalance_info = WHITEBALANCE_AUTO;
-        }else{
-            whitebalance_info = WHITEBALANCE_MANUAL;
-        }
-        mJpegEncCfg.WhiteBalanceInfo = whitebalance_info;
-
-        pFlashStr = mParameters.get(CameraParameters::KEY_FLASH_MODE);
-        CAMERA_HAL_LOG_INFO("flash mode is %s", pFlashStr);
-        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) == 0){
-            flash_info = FLASH_NOT_FIRE;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) == 0){
-            flash_info = FLASH_FIRED_AUTO;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) == 0){
-            flash_info = FLASH_FIRED;
-        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) == 0){
-            flash_info = FLASH_FIRED_RED_EYE_REDUCE;
-        }
-        else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) == 0){
-            flash_info = FLASH_FIRED_COMPULOSORY;
-        }
-        else{
-            flash_info = FLASH_NOT_FIRE;
-        }
-        mJpegEncCfg.FlashInfo = flash_info;
-
-        cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
-        cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
-        cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
-        cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
-
-        if (cLatitude !=NULL && cLatitude!=NULL && cAltitude!=NULL && cTimeStamp!=NULL){
-
-            gps_info.version=0x02020000;
-
-            //latitude: dd/1,mm/1,ss/1
-            gps_info.latitude_degree[1]=1;
-            gps_info.latitude_minute[1]=1;
-            gps_info.latitude_second[1]=1;
-            memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
-
-            if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
-                //the ref is south
-                memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
-            }
-
-            //longtitude: dd/1,mm/1,ss/1
-            gps_info.longtitude_degree[1]=1;
-            gps_info.longtitude_minute[1]=1;
-            gps_info.longtitude_second[1]=1;
-            memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
-
-            if (stringTodegree(cLatitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
-                //the ref is Weston
-                memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
-            }
-
-            //altitude(meters): aa/1
-            gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
-            gps_info.altitude[0]=1000;
-            gps_info.altitude[1]=1;
-            if (cAltitude != NULL){
-                int intValue;
-                gps_info.altitude[1]=1000;	   // the precision is CM
-                dAltitude= atof(cAltitude);
-                CAMERA_HAL_LOG_RUNTIME("the altitude is %s", cAltitude);
-                intValue = (int)(dAltitude * 1000.0);
-                if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
-                gps_info.altitude[0] = (unsigned long) intValue;
-                CAMERA_HAL_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
-            }
-
-            //timestamp: hh/1,mm/1,ss/1
-            gps_info.hour[1]=1;
-            gps_info.minute[1]=1;
-            gps_info.seconds[1]=1;
-            if (cTimeStamp != NULL){
-
-                GpsUtcTime = atol(cTimeStamp);
-                CAMERA_HAL_LOG_INFO("the Timestamp is %s", cTimeStamp);
-                temp_tm = gmtime((const time_t*)&GpsUtcTime);
-                if (temp_tm != NULL)
-                    tm = temp_tm;
-            }
-
-            gps_info.hour[0] = tm->tm_hour;
-            gps_info.minute[0] = tm->tm_min;
-            gps_info.seconds[0] = tm->tm_sec;
-
-            strcpy (format, "%Y:%m:%d ");
-
-
-            strftime((char *)temp_string, strlen(temp_string), format, tm);
-            memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
-
-
-            char * progressMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
-            if (progressMehod == NULL){
-                CAMERA_HAL_LOG_INFO("The progressMethod is NULL, add a fake");
-                progressMehod = (char *)"fsl_fake_method";
-            }
-            CAMERA_HAL_LOG_INFO("the progressMethod is %s", progressMehod);
-
-            memcpy(gps_info.processmethod, progressMehod, strlen(progressMehod));
-
-            gps_info.processmethod_bytes=strlen(progressMehod);
-
-            CAMERA_HAL_LOG_INFO("the method is %s", gps_info.processmethod);
-
-            mJpegEncCfg.pGps_info = &gps_info;
-        }else{
-            mJpegEncCfg.pGps_info = NULL;
-        }
-
-        if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
-            CAMERA_HAL_ERR("Jpeg Encoder Init error !!!");
-            return UNKNOWN_ERROR;
-        }
-
-        return ret;
-    }
-    status_t CameraHal::CameraHALStartPreview()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int  max_fps, min_fps;
-        mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
-        mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
-        mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
-        mCaptureDeviceCfg.tv.numerator = 1;
-        mCaptureDevice->GetDevName(mCameraSensorName);
-        if (strstr(mCameraSensorName, "uvc") == NULL){
-        //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
-        // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
-        if (mParameters.getPreviewFrameRate() >= 15)
-            mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
-        else{
-            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
-            CAMERA_HAL_LOG_INFO("###start the capture the fps is %d###", max_fps);
-            mCaptureDeviceCfg.tv.denominator = max_fps/1000;
-        }
-        }else{
-                mCaptureDeviceCfg.tv.denominator = 15;
-        }
-        mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
-        mPPbufNum = POST_PROCESS_BUFFER_NUM;
-        mTakePicFlag = false;
-
-        if ((ret = PrepareCaptureDevices()) < 0){
-            CAMERA_HAL_ERR("PrepareCaptureDevices error ");
-            return ret;
-        }
-        if (mPPDeviceNeed){
-            if ((ret = PreparePostProssDevice()) < 0){
-                CAMERA_HAL_ERR("PreparePostProssDevice error");
-                return ret;
-            }
-        }
-        if ((ret = PreparePreviwBuf()) < 0){
-            CAMERA_HAL_ERR("PreparePreviwBuf error");
-            return ret;
-        }
-
-        if ((ret = PreparePreviwMisc()) < 0){
-            CAMERA_HAL_ERR("PreparePreviwMisc error");
-            return ret;
-        }
-
-        if ((ret = CameraHALPreviewStart()) < 0){
-            CAMERA_HAL_ERR("CameraHALPreviewStart error");
-            return ret;
-        }
-        return ret;
-    }
-    void CameraHal::CameraHALStopPreview()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        if (mPreviewRunning != 0)	{
-            CameraHALStopThreads();
-            CameraHALStopMisc();
-            CAMERA_HAL_LOG_INFO("camera hal stop preview done");
-        }else{
-            CAMERA_HAL_LOG_INFO("Camera hal already stop preview");
-        }
-        return ;
-    }
-
-    void CameraHal :: CameraHALStopThreads()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        mPreviewRunning = 0;
-        if (mCaptureFrameThread!= 0){
-            mCaptureFrameThread->requestExitAndWait();
-            mCaptureFrameThread.clear();
-        }
-        if (mPPDeviceNeed){
-            if (mPostProcessThread!= 0){
-                mPostProcessThread->requestExitAndWait();
-                mPostProcessThread.clear();
-            }
-        }
-        if (mPreviewShowFrameThread!= 0){
-            mPreviewShowFrameThread->requestExitAndWait();
-            mPreviewShowFrameThread.clear();
-        }
-
-        if (mEncodeFrameThread!= 0){
-            mEncodeFrameThread->requestExitAndWait();
-            mEncodeFrameThread.clear();
-        }
-        return ;
-    }
-
-    void CameraHal :: CameraHALStopMisc()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        sem_destroy(&avab_dequeue_frame);
-        sem_destroy(&avab_show_frame);
-        sem_destroy(&avab_enc_frame);
-        sem_destroy(&avab_enc_frame_finish);
-        if(mPPDeviceNeed){
-            sem_destroy(&avab_pp_in_frame);
-            sem_destroy(&avab_pp_out_frame);
-        }
-        if(mPPDeviceNeed){
-            for (unsigned int i = 0; i < mPPbufNum; i++){
-                mPmemAllocator->deAllocate(&mPPbuf[i]);
-            }
-            mPmemAllocator = NULL;
-        }
-        mCaptureDevice->DevStop();
-        mCaptureDevice->DevDeAllocate();
-        CloseCaptureDevice();
-
-    }
-    status_t CameraHal :: PrepareCaptureDevices()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        int i =0;
-        unsigned int CaptureBufNum = mCaptureBufNum;
-        struct capture_config_t *pCapcfg;
-        if ((ret = OpenCaptureDevice())<0)
-            return ret;
-
-        if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) {//set the config and get the captured framesize
-            CAMERA_HAL_ERR("Dev config failed");
-            return BAD_VALUE;
-        }
-        mCaptureFrameSize = mCaptureDeviceCfg.framesize;
-
-        if (mCaptureDevice->DevAllocateBuf(mCaptureBuffers,&CaptureBufNum)< 0){
-            CAMERA_HAL_ERR("capture device allocat buf error");
-            return BAD_VALUE;
-        }
-        if(mCaptureBufNum != CaptureBufNum){
-            CAMERA_HAL_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
-        }
-
-        mCaptureBufNum = CaptureBufNum;
-
-        if (mCaptureDevice->DevPrepare()< 0){
-            CAMERA_HAL_ERR("capture device prepare error");
-            return BAD_VALUE;
-        }
-        nCameraBuffersQueued = mCaptureBufNum;
-
-        return ret;
-    }
-
-    status_t CameraHal::PreparePostProssDevice()
-    {
-
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int targetFmt;
-        if (mTakePicFlag)
-            targetFmt = mPictureEncodeFormat;
-        else
-            targetFmt = mPreviewFormat;
-
-        pthread_mutex_lock(&mPPIOParamMutex);
-        mPPInputParam.width = mCaptureDeviceCfg.width;
-        mPPInputParam.height= mCaptureDeviceCfg.height;
-        mPPInputParam.fmt   = mCaptureDeviceCfg.fmt;
-        mPPInputParam.input_crop_win.pos.x = 0;
-        mPPInputParam.input_crop_win.pos.y = 0;
-        mPPInputParam.input_crop_win.win_w = mCaptureDeviceCfg.width;
-        mPPInputParam.input_crop_win.win_h = mCaptureDeviceCfg.height;
-
-        mPPOutputParam.width = mCaptureDeviceCfg.width;
-        mPPOutputParam.height= mCaptureDeviceCfg.height;
-        mPPOutputParam.fmt   = targetFmt;
-        mPPOutputParam.rot   = 0;
-        mPPOutputParam.output_win.pos.x = 0;
-        mPPOutputParam.output_win.pos.y = 0;
-        mPPOutputParam.output_win.win_w = mCaptureDeviceCfg.width;
-        mPPOutputParam.output_win.win_h = mCaptureDeviceCfg.height;
-        pthread_mutex_unlock(&mPPIOParamMutex);
-        return ret;
-    }
-
-    status_t CameraHal::PreparePreviwBuf()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        unsigned int i =0;
-
-        //temply hard code here
-        if (mTakePicFlag == 0){
-            if(V4L2_PIX_FMT_NV12)
-                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
-            else 
-                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
-
-            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
-            mPreviewHeap.clear();
-            for (i = 0; i< mPreviewHeapBufNum; i++)
-                mPreviewBuffers[i].clear();
-            mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
-            if (mPreviewHeap == NULL)
-                return NO_MEMORY;
-            for (i = 0; i < mPreviewHeapBufNum; i++)
-                mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
-        }
-        /*allocate the buffer for IPU process*/
-        if (mPPDeviceNeed || mPPDeviceNeedForPic){
-            mPmemAllocator = new PmemAllocator(mPPbufNum, mCaptureFrameSize);
-
-            if(mPmemAllocator == NULL || mPmemAllocator->err_ret < 0){
-                return NO_MEMORY;
-            }
-            for (i = 0; i < mPPbufNum; i++){
-                if(mPmemAllocator->allocate(&(mPPbuf[i]),mCaptureFrameSize) < 0){
-                    return NO_MEMORY;
-                }
-            }
-        }
-        return ret;
-    }
-
-    status_t CameraHal ::PreparePreviwMisc()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        dequeue_head = 0;
-        preview_heap_buf_head = 0;
-        display_head = 0;
-        enc_head     = 0;
-        pp_in_head   = 0;
-        pp_out_head  = 0;
-        error_status = 0;
-        is_first_buffer = 1;
-        last_display_index = 0;
-
-        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
-        sem_init(&avab_show_frame, 0, 0);
-        sem_init(&avab_enc_frame, 0, 0);
-        sem_init(&avab_enc_frame_finish, 0, 0);
-        if(mPPDeviceNeed){
-            sem_init(&avab_pp_in_frame, 0, 0);
-            sem_init(&avab_pp_out_frame, 0, mPPbufNum);
-        }
-        return ret;
-    }
-
-    status_t CameraHal ::CameraHALPreviewStart()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        status_t ret = NO_ERROR;
-        if (mCaptureDevice->DevStart()<0)
-            return INVALID_OPERATION;
-
-        mCaptureFrameThread = new CaptureFrameThread(this);
-        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
-        mEncodeFrameThread = new EncodeFrameThread(this);
-        if(mPPDeviceNeed){
-            mPostProcessThread = new PostProcessThread(this);
-            if (mPostProcessThread == NULL)
-                return UNKNOWN_ERROR;
-        }
-
-        if (mCaptureFrameThread == NULL ||
-                mPreviewShowFrameThread == NULL ||
-                mEncodeFrameThread == NULL){
-            return UNKNOWN_ERROR;
-        }
-
-        mPreviewRunning = true;
-        return ret;
-    }
-
-
-    int CameraHal ::captureframeThread()
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        unsigned int DeqBufIdx = 0;
-        struct timespec ts;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_dequeue_frame, &ts) != 0) );
-
-        if(!mPreviewRunning || error_status)
-            return UNKNOWN_ERROR;
-
-        mCaptureDevice->DevDequeue(&DeqBufIdx);
-
-        nCameraBuffersQueued--;
-
-        buffer_index_maps[dequeue_head]=DeqBufIdx;
-        dequeue_head ++;
-        dequeue_head %= mCaptureBufNum;
-
-        if(!mPPDeviceNeed){
-            sem_post(&avab_show_frame);
-            sem_post(&avab_enc_frame);
-        }else{
-            sem_post(&avab_pp_in_frame);
-        }
-
-        return NO_ERROR;
-    }
-
-    int CameraHal::postprocessThread()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int PPInIdx = 0, PPoutIdx = 0;
-        DMA_BUFFER PPInBuf, PPoutBuf;
-        struct timespec ts;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_in_frame, &ts) != 0) );
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (mPreviewRunning && !error_status &&(sem_timedwait(&avab_pp_out_frame, &ts) != 0) );
-
-
-        if(!mPreviewRunning || error_status)
-            return UNKNOWN_ERROR;
-        PPInIdx = buffer_index_maps[pp_in_head];
-        PPInBuf = mCaptureBuffers[PPInIdx];
-        pp_in_head ++;
-        pp_in_head %= mCaptureBufNum;
-
-        PPoutIdx = pp_out_head;
-        PPoutBuf = mPPbuf[PPoutIdx];
-        pp_out_head ++;
-        pp_out_head %= mPPbufNum;
-
-        pthread_mutex_lock(&mPPIOParamMutex);
-        mPPInputParam.user_def_paddr = PPInBuf.phy_offset;
-        mPPOutputParam.user_def_paddr = PPoutBuf.phy_offset;
-        mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
-        mPPDevice->DoPorcess(&PPInBuf, &PPoutBuf);
-        mPPDevice->PPDeviceDeInit();
-        pthread_mutex_unlock(&mPPIOParamMutex);
-
-        sem_post(&avab_show_frame);
-        sem_post(&avab_enc_frame);
-
-        if (mCaptureDevice->DevQueue(PPInIdx) < 0){
-            CAMERA_HAL_ERR("queue buf back error");
-            return INVALID_OPERATION;
-        }
-        nCameraBuffersQueued ++;
-        sem_post(&avab_dequeue_frame);
-
-        return NO_ERROR;
-    }
-    int CameraHal ::previewshowFrameThread()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        struct timespec ts;
-        int display_index = 0;
-        DMA_BUFFER InBuf;
-        int queue_back_index = 0;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while (!error_status && mPreviewRunning &&(sem_timedwait(&avab_show_frame, &ts) != 0) );
-
-        if ((mPreviewRunning == 0) || error_status)
-            return UNKNOWN_ERROR;
-
-        if (!mPPDeviceNeed){
-            display_index = buffer_index_maps[display_head];
-            InBuf = mCaptureBuffers[display_index];
-            display_head ++;
-            display_head %= mCaptureBufNum;
-        }else{
-            display_index = display_head;
-            InBuf = mPPbuf[display_index];
-            display_head ++;
-            display_head %= mPPbufNum;
-        }
-
-        if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
-            convertNV12toYUV420SP((uint8_t*)(InBuf.virt_start),
-                    (uint8_t*)(mPreviewBuffers[preview_heap_buf_head]->pointer()),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
-            mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewBuffers[preview_heap_buf_head], mCallbackCookie);
-            preview_heap_buf_head ++;
-            preview_heap_buf_head %= mPreviewHeapBufNum;
-        }
-
-        pthread_mutex_lock(&mOverlayMutex);
-
-        if (mOverlay != 0) {
-            if (mOverlay->queueBuffer((overlay_buffer_t)InBuf.phy_offset) < 0){
-                CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
-            }
-
-            if (is_first_buffer) {
-                is_first_buffer = 0;
-                last_display_index = display_index;
-                pthread_mutex_unlock(&mOverlayMutex);
-                goto show_out;
-            }
-        }
-
-        if (!mPPDeviceNeed){
-            if (mOverlay != 0){
-                queue_back_index = last_display_index;
-            }else{
-                queue_back_index = display_index;
-            }
-        }
-        pthread_mutex_unlock(&mOverlayMutex);
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=200000; // 100ms
-        } while ((sem_timedwait(&avab_enc_frame_finish, &ts) != 0)&&!error_status && mPreviewRunning );
-
-        if (!mPPDeviceNeed){
-            //queue the v4l2 buf back
-            if(mCaptureDevice->DevQueue(queue_back_index) <0){
-                CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
-                return INVALID_OPERATION;
-            }
-            last_display_index = display_index;
-            nCameraBuffersQueued++;
-            sem_post(&avab_dequeue_frame);
-        }else{
-            sem_post(&avab_pp_out_frame);
-        }
-
-show_out:
-
-        return NO_ERROR;
-    }
-
-    int CameraHal :: encodeframeThread()
-    {
-        CAMERA_HAL_LOG_FUNC;
-        struct timespec ts;
-        unsigned int enc_index = 0, i = 0;
-        DMA_BUFFER EncBuf;
-
-        do {
-            clock_gettime(CLOCK_REALTIME, &ts);
-            ts.tv_nsec +=100000; // 100ms
-        } while ((sem_timedwait(&avab_enc_frame, &ts) != 0) && !error_status &&  mPreviewRunning );
-
-        if ((mPreviewRunning == 0) || error_status)
-            return UNKNOWN_ERROR;
-
-        if (!mPPDeviceNeed){
-            enc_index = buffer_index_maps[enc_head];
-            EncBuf = mCaptureBuffers[enc_index];
-            enc_head ++;
-            enc_head %= mCaptureBufNum;
-        }else{
-            enc_index = enc_head;
-            EncBuf = mPPbuf[enc_index];
-            enc_head ++;
-            enc_head %= mPPbufNum;
-        }
-
-        if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
-            nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
-            for(i = 0 ; i < mVideoBufNume; i ++) {
-                if(mVideoBufferUsing[i] == 0) {
-                    memcpy(mVideoBuffers[i]->pointer(),
-                            (void*)EncBuf.virt_start, mPreviewFrameSize);
-
-                    mVideoBufferUsing[i] = 1;
-                    mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoBuffers[i], mCallbackCookie);
-                    break;
-                }
-            }
-            if (i == mVideoBufNume)
-                CAMERA_HAL_LOG_INFO("no Buffer can be used for record\n");
-        }
-
-        sem_post(&avab_enc_frame_finish);
-        return NO_ERROR;
-
-    }
-
-
-    status_t CameraHal :: AllocateRecordVideoBuf()
-    {
-        status_t ret = NO_ERROR;
-        unsigned int i = 0;
-        mVideoHeap.clear();
-        for(i = 0; i < mVideoBufNume; i++) {
-            mVideoBuffers[i].clear();
-            mVideoBufferUsing[i] = 0;
-        }
-
-        CAMERA_HAL_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
-        mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
-        if (mVideoHeap == NULL)
-            return NO_MEMORY;
-        for(i = 0; i < mVideoBufNume; i++) {
-            CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
-            mVideoBuffers[i] = new MemoryBase(mVideoHeap,
-                    mPreviewFrameSize * i, mPreviewFrameSize);
-        }
-
-        return ret;
-    }
-
-
-    void CameraHal :: LockWakeLock()
-    {
-        if (!mPowerLock) {
-            acquire_wake_lock (PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
-            mPowerLock = true;
-        }
-    }
-    void CameraHal :: UnLockWakeLock()
-    {
-        if (mPowerLock) {
-            release_wake_lock (V4LSTREAM_WAKE_LOCK);
-            mPowerLock = false;
-        }
-    }
-
-    void CameraHal::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
-    {
-        /* Color space conversion from I420 to YUV420SP */
-        int Ysize = 0, UVsize = 0;
-        uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
-
-        Ysize = width * height;
-        UVsize = width *  height >> 2;
-
-        Yin = inputBuffer;
-        Uin = Yin + Ysize;
-        Vin = Uin + 1;
-
-        Yout = outputBuffer;
-        Vout = Yout + Ysize;
-        Uout = Vout + 1;
-
-        memcpy(Yout, Yin, Ysize);
-
-        for(int k = 0; k < UVsize; k++) {
-            *Uout = *Uin;
-            *Vout = *Vin;
-            Uout += 2;
-            Vout += 2;
-            Uin  += 2;
-            Vin += 2;
-        }
-    }
-
-
-
-    int CameraHal::stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second)
-    {
-        double dAttribtute;
-        long intAttribute;
-        int ret  = 0;
-        if (cAttribute == NULL){
-            return -1;
-        }
-
-        CAMERA_HAL_LOG_RUNTIME("the attribute is %s", cAttribute);
-
-        dAttribtute = atof(cAttribute);
-
-        CAMERA_HAL_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
-        intAttribute  = (long)(dAttribtute*(double)3600.0);
-        if (intAttribute < 0){
-            ret = 1;
-            intAttribute *=-1;
-        }
-
-        second = (unsigned int)(intAttribute%60);
-        minute = (unsigned int)((intAttribute%3600-second)/60);
-        degree = (unsigned int)(intAttribute/3600);
-
-        CAMERA_HAL_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
-
-        return ret;
-
-    }
-
-
-#define FACE_BACK_CAMERA_NAME "back_camera_name"
-#define FACE_FRONT_CAMERA_NAME "front_camera_name"
-#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
-#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
-#define DEFAULT_ERROR_NAME '#'
-#define DEFAULT_ERROR_NAME_str "#"
-#define UVC_NAME "uvc"
-    static CameraInfo sCameraInfo[2];
-    static char Camera_name[2][MAX_SENSOR_NAME];
-
-    static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
-    {
-        char orientStr[10];
-
-        property_get (FACE_BACK_CAMERA_NAME,
-                pFaceBackCameraName,
-                DEFAULT_ERROR_NAME_str );
-        property_get (FACE_BACK_CAMERA_ORIENT,
-                orientStr,
-                DEFAULT_ERROR_NAME_str );
-
-        if (orientStr[0] == DEFAULT_ERROR_NAME )
-            *pFaceBackOrient = 0;
-        else 
-            *pFaceBackOrient = atoi(orientStr);
-
-        LOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
-
-        property_get (FACE_FRONT_CAMERA_NAME,
-                pFaceFrontCameraName,
-                DEFAULT_ERROR_NAME_str );
-
-        property_get (FACE_FRONT_CAMERA_ORIENT,
-                orientStr,
-                DEFAULT_ERROR_NAME_str );
-
-
-        if (orientStr[0] == DEFAULT_ERROR_NAME )
-            *pFaceFrontOrient = 0;
-        else 
-            *pFaceFrontOrient = atoi(orientStr);
-
-        LOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
-
-    }
-
-    int HAL_getNumberOfCameras()
-    {
-        int back_orient =0,  front_orient = 0;
-        int back_camera_num = 0, front_camera_num = 0;
-        GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
-        if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
-            sCameraInfo[0].facing = CAMERA_FACING_BACK;
-            sCameraInfo[0].orientation = back_orient;
-            back_camera_num++;
-        }
-        if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
-            if(back_camera_num > 0){
-                sCameraInfo[1].facing = CAMERA_FACING_FRONT;
-                sCameraInfo[1].orientation = front_orient;
-            }else{
-                sCameraInfo[0].facing = CAMERA_FACING_FRONT;
-                sCameraInfo[0].orientation = front_orient;
-            }
-            front_camera_num ++;
-        }
-        return (back_camera_num + front_camera_num);					
-
-    }
-
-    void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
-    {
-        memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));					
-    }
-
-    sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
-    {
-        char *SelectedCameraName;
-        int back_camera_num = 0, front_camera_num = 0;
-        sp<CaptureDeviceInterface> pCaptureDevice = NULL;
-        sp<PostProcessDeviceInterface> pPPDevice = NULL;
-        sp<JpegEncoderInterface>pJpegEncoder = NULL;
-
-        if (HAL_getNumberOfCameras() ==0 ){
-            CAMERA_HAL_ERR("There is no configure for Cameras");
-            return NULL;
-        }
-
-        SelectedCameraName = Camera_name[sCameraInfo[cameraId].facing];
-
-        pCaptureDevice = createCaptureDevice(SelectedCameraName);
-        pPPDevice = createPPDevice();
-        pJpegEncoder = createJpegEncoder(SOFTWARE_JPEG_ENC);
-
-        CameraHal *pCameraHal = new CameraHal();
-        if (pCameraHal->setCaptureDevice(pCaptureDevice) < 0 ||
-                pCameraHal->setPostProcessDevice(pPPDevice) < 0 ||
-                pCameraHal->setJpegEncoder(pJpegEncoder) < 0)
-            return NULL;
-
-        if (pCameraHal->Init() < 0)
-            return NULL;
-
-        //now the board has only one csi camera sensor, so just do mirror for it
-        if(strstr(SelectedCameraName, "ov") != NULL){
-            pCameraHal->setPreviewRotate(CAMERA_PREVIEW_BACK_REF);
-        }
-
-        sp<CameraHardwareInterface> hardware(pCameraHal);
-        CAMERA_HAL_LOG_INFO("created the fsl Camera hal");
-
-        return hardware;
-    }
-
-};
-
-
-
diff --git a/libcamera/CameraHal.h b/libcamera/CameraHal.h
deleted file mode 100755
index efdea0d..0000000
--- a/libcamera/CameraHal.h
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-
-#ifndef CAMERA_HAL_BASE_H
-#define CAMERA_HAL_BASE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <binder/MemoryBase.h>
-#include <binder/MemoryHeapBase.h>
-#include <camera/CameraHardwareInterface.h>
-#include <ui/Overlay.h>
-#include <semaphore.h>
-
-#include "Camera_pmem.h"
-#include "CaptureDeviceInterface.h"
-#include "PostProcessDeviceInterface.h"
-#include "JpegEncoderInterface.h"
-
-
-#define EXIF_MAKENOTE "fsl_makernote"
-#define EXIF_MODEL    "fsl_model"
-
-#define CAMER_PARAM_BUFFER_SIZE 512
-#define MAX_QUERY_FMT_TIMES 20
-#define PARAMS_DELIMITER ","
-#define V4LSTREAM_WAKE_LOCK "V4LCapture"
-#define MAX_SENSOR_NAME 32
-
-#define PREVIEW_HEAP_BUF_NUM    5
-#define VIDEO_OUTPUT_BUFFER_NUM 5
-#define POST_PROCESS_BUFFER_NUM 5
-#define TAKE_PIC_QUE_BUF_NUM 5
-
-#define PREVIEW_CAPTURE_BUFFER_NUM 5
-#define PICTURE_CAPTURE_BUFFER_NUM 3
-
-namespace android {
-
-    typedef enum{
-        CAMERA_HAL_ERR_NONE = 0,
-        CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE = -1,
-        CAMERA_HAL_ERR_GET_PARAM           = -2,
-        CAMERA_HAL_ERR_BAD_PARAM =-3,
-        CAMERA_HAL_ERR_BAD_ALREADY_RUN = -4,
-        CAMERA_HAL_ERR_INIT = -5,
-        CAMERA_HAL_ERR_ALLOC_BUF =-6,
-        CAMERA_HAL_ERR_PP_NULL = -7
-    }CAMERA_HAL_ERR_RET;
-
-	typedef enum{
-        CAMERA_PREVIEW_BACK_REF = 0,
-        CAMERA_PREVIEW_VERT_FLIP = 1,
-        CAMERA_PREVIEW_HORIZ_FLIP = 2,
-        CAMERA_PREVIEW_ROATE_180 = 3,
-        CAMERA_PREVIEW_ROATE_LAST = 3
-	}CAMERA_PREVIEW_ROTATE;
-
-    class CameraHal : public CameraHardwareInterface {
-    public:
-        virtual sp<IMemoryHeap> getPreviewHeap() const;
-        virtual sp<IMemoryHeap> getRawHeap() const;
-
-        virtual status_t setPreviewWindow(const sp<ANativeWindow>& buf) { return 0;};
-        virtual void        setCallbacks(notify_callback notify_cb,
-                data_callback data_cb,
-                data_callback_timestamp data_cb_timestamp,
-                void* user);
-
-        virtual void        enableMsgType(int32_t msgType);
-        virtual void        disableMsgType(int32_t msgType);
-        virtual bool        msgTypeEnabled(int32_t msgType);
-
-        virtual bool        useOverlay() { return true; }
-        virtual status_t    setOverlay(const sp<Overlay> &overlay);
-
-        virtual status_t    startPreview();
-        virtual void        stopPreview();
-        virtual bool        previewEnabled();
-
-        virtual status_t    startRecording();
-        virtual void        stopRecording();
-        virtual bool        recordingEnabled();
-        virtual void        releaseRecordingFrame(const sp<IMemory>& mem);
-
-        virtual status_t    autoFocus();
-        virtual status_t    cancelAutoFocus();
-        virtual status_t    takePicture();
-        virtual status_t    cancelPicture();
-        virtual status_t    dump(int fd, const Vector<String16>& args) const;
-        virtual status_t    setParameters(const CameraParameters& params);
-        virtual CameraParameters  getParameters() const;
-        virtual status_t    sendCommand(int32_t command, int32_t arg1,
-                int32_t arg2);
-        virtual void release();
-
-        CAMERA_HAL_ERR_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
-        CAMERA_HAL_ERR_RET setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice);
-        CAMERA_HAL_ERR_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
-        CAMERA_HAL_ERR_RET  Init();
-        void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
-
-        CameraHal();
-        virtual             ~CameraHal();
-
-    private:
-
-        class CaptureFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            CaptureFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw) { }
-            virtual void onFirstRef() {
-                run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mHardware->captureframeThread();
-                return true;
-            }
-        };
-
-        class PostProcessThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            PostProcessThread(CameraHal* hw)
-                : Thread(false), mHardware(hw) { }
-            virtual void onFirstRef() {
-                run("PostProcessThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mHardware->postprocessThread();
-                return true;
-            }
-        };
-
-
-        class PreviewShowFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            PreviewShowFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw) { }
-            virtual void onFirstRef() {
-                run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mHardware->previewshowFrameThread();
-                return true;
-            }
-        };
-
-        class EncodeFrameThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            EncodeFrameThread(CameraHal* hw)
-                : Thread(false), mHardware(hw) { }
-            virtual void onFirstRef() {
-                run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                mHardware->encodeframeThread();
-                return true;
-            }
-        };
-
-        class AutoFocusThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            AutoFocusThread(CameraHal* hw)
-                : Thread(false), mHardware(hw) { }
-            virtual void onFirstRef() {
-                run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                if (mHardware->autoFocusThread()>=0)
-                    return true;
-                else
-                    return false;
-            }
-        };
-
-
-        class TakePicThread : public Thread {
-            CameraHal* mHardware;
-        public:
-            TakePicThread(CameraHal* hw)
-                : Thread(false), mHardware(hw) { }
-            virtual void onFirstRef() {
-                run("TakePicThread", PRIORITY_URGENT_DISPLAY);
-            }
-            virtual bool threadLoop() {
-                if (mHardware->takepicThread()>=0)
-                    return true;
-                else
-                    return false;
-            }
-        };
-
-        void preInit();
-        void postDestroy();
-
-        status_t OpenCaptureDevice();
-        void CloseCaptureDevice();
-
-        CAMERA_HAL_ERR_RET AolLocForInterBuf();
-        void  FreeInterBuf();
-        CAMERA_HAL_ERR_RET InitCameraHalParam();
-        CAMERA_HAL_ERR_RET GetCameraBaseParam(CameraParameters *pParam);
-        CAMERA_HAL_ERR_RET GetPictureExifParam(CameraParameters *pParam);
-        CAMERA_HAL_ERR_RET CameraMiscInit();
-        CAMERA_HAL_ERR_RET CameraMiscDeInit();
-        status_t CameraHALPreviewStart();
-        int captureframeThread();
-        int postprocessThread();
-        int previewshowFrameThread();
-        int encodeframeThread();
-        status_t AllocateRecordVideoBuf();
-
-        status_t CameraHALStartPreview();
-        void     CameraHALStopPreview();
-
-        status_t PreparePreviwBuf();
-        status_t PrepareCaptureDevices();
-        status_t PreparePostProssDevice();
-        status_t PreparePreviwMisc();
-
-        void CameraHALStopThreads();
-        void LockWakeLock();
-
-        void UnLockWakeLock();
-
-        int autoFocusThread();
-        int takepicThread();
-
-        int GetJpegEncoderParam();
-        int NegotiateCaptureFmt(bool TakePicFlag);
-        int cameraHALTakePicture();
-        void CameraHALStopMisc();
-        int PrepareJpegEncoder();
-        void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
-
-        int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
-
-        CameraParameters    mParameters;
-        void               *mCallbackCookie;
-        notify_callback    mNotifyCb;
-        data_callback      mDataCb;
-        data_callback_timestamp mDataCbTimestamp;
-
-        sp<CaptureDeviceInterface> mCaptureDevice;
-        sp<PostProcessDeviceInterface> mPPDevice;
-        sp<JpegEncoderInterface> mJpegEncoder;
-
-
-        sp<CaptureFrameThread> mCaptureFrameThread;
-        sp<PostProcessThread>  mPostProcessThread;
-        sp<PreviewShowFrameThread> mPreviewShowFrameThread;
-        sp<EncodeFrameThread> mEncodeFrameThread;
-        sp<AutoFocusThread>mAutoFocusThread;
-        sp<TakePicThread> mTakePicThread;
-
-        mutable Mutex       mLock;
-
-        char *supportedPictureSizes;
-        char *supportedPreviewSizes;
-        char *supportedFPS;
-        char *supprotedThumbnailSizes;
-
-        sp<Overlay>         mOverlay;
-        unsigned int        mMsgEnabled;
-
-        struct capture_config_t mCaptureDeviceCfg;
-        DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
-
-        sp<MemoryHeapBase>  mPreviewHeap;
-        sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
-
-        /* the buffer for recorder */
-        unsigned int        mVideoBufNume;
-        sp<MemoryHeapBase>  mVideoHeap;
-        sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
-        volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
-
-
-        sp<PmemAllocator>   mPmemAllocator;
-        DMA_BUFFER          mPPbuf[POST_PROCESS_BUFFER_NUM];
-        unsigned int        mPPbufNum;
-        pp_input_param_t    mPPInputParam;
-        pp_output_param_t   mPPOutputParam;
-
-        volatile bool       mPreviewRunning;
-        unsigned int        mPreviewFormat;
-        unsigned int 		mPreviewFrameSize;
-        unsigned int        mPreviewCapturedFormat;
-
-        bool                mTakePicFlag;
-        unsigned int        mEncoderSupportedFormat[MAX_QUERY_FMT_TIMES];
-        enc_cfg_param       mJpegEncCfg;
-
-
-        unsigned int        mUvcSpecialCaptureFormat;
-        unsigned int        mCaptureSupportedFormat[MAX_QUERY_FMT_TIMES];
-        unsigned int        mPictureEncodeFormat;
-        unsigned int        mCaptureFrameSize;
-        unsigned int        mCaptureBufNum;
-        bool                mRecordRunning;
-        int                 mCurrentRecordFrame;
-        int 		        nCameraBuffersQueued;
-
-        unsigned int        mPreviewHeapBufNum;
-        unsigned int        mTakePicBufQueNum;
-
-        char                mCameraSensorName[MAX_SENSOR_NAME];
-        bool mCameraReady;
-        bool mCaptureDeviceOpen;
-        bool mPPDeviceNeed;
-        bool mPPDeviceNeedForPic;
-        bool mPreviewStopped;
-        bool mRecordStopped;
-        bool mPowerLock;
-
-        int error_status;
-        unsigned int preview_heap_buf_head;
-        unsigned int display_head;
-        unsigned int enc_head;
-        unsigned int dequeue_head;
-        unsigned int is_first_buffer;
-        unsigned int last_display_index;
-        unsigned int pp_in_head;
-        unsigned int pp_out_head;
-        unsigned int buffer_index_maps[PREVIEW_CAPTURE_BUFFER_NUM];
-
-        sem_t avab_show_frame;
-        sem_t avab_dequeue_frame;
-        sem_t avab_enc_frame;
-        sem_t avab_enc_frame_finish;
-        sem_t avab_pp_in_frame;
-        sem_t avab_pp_out_frame;
-
-        pthread_mutex_t mOverlayMutex;
-        pthread_mutex_t mMsgMutex;
-        pthread_mutex_t mPPIOParamMutex;
-        CAMERA_PREVIEW_ROTATE mPreviewRotate;
-
-    };
-
-}; // namespace android
-
-#endif
-
diff --git a/libcamera/Camera_pmem.cpp b/libcamera/Camera_pmem.cpp
deleted file mode 100755
index 865b352..0000000
--- a/libcamera/Camera_pmem.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <pthread.h>
-#include <semaphore.h>
-#include <linux/time.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <linux/android_pmem.h>
-#include "Camera_pmem.h"
-
-
-/*
- *   input parameter: 
- */
-
-using namespace android;
-
-PmemAllocator::PmemAllocator(int bufCount, int bufSize):
-    err_ret(0), mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
-    mVirBase(NULL),mPhyBase(NULL)
-{
-
-    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
-
-    int err;
-    struct pmem_region region;
-    mFD = open(PMEM_DEV, O_RDWR);
-    if (mFD < 0) {
-        CAMERA_HAL_ERR("Error!PmemAllocator constructor");
-        err_ret = -1;
-        return;
-    }
-
-    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
-    if (err == 0)
-    {
-        CAMERA_HAL_ERR("Info!get pmem total size %d",(int)region.len);
-    }
-    else
-    {
-        CAMERA_HAL_ERR("Error!Cannot get total length in PmemAllocator constructor");
-        err_ret = -1;
-        return;
-    }
-
-    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
-
-    mTotalSize = mBufSize*bufCount;
-    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
-        CAMERA_HAL_ERR("Error!Out of PmemAllocator capability");
-    }
-    else
-    {
-        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
-                PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
-
-        if (virtualbase == MAP_FAILED) {
-            CAMERA_HAL_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
-                    mFD, (unsigned int)mTotalSize, strerror(errno));
-            return;
-        }
-
-        memset(&region, 0, sizeof(region));
-
-        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
-        {
-            CAMERA_HAL_ERR("Error!Failed to get physical address of source!\n");
-            munmap(virtualbase, mTotalSize);
-            return;
-        }
-        mVirBase = (void *)virtualbase;
-        mPhyBase = region.offset;
-        CAMERA_HAL_LOG_RUNTIME("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
-    }
-}
-
-PmemAllocator::~PmemAllocator()
-{
-    CAMERA_HAL_LOG_FUNC;
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(mSlotAllocated[index]) {
-            CAMERA_HAL_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
-        }
-    }
-
-    if(mVirBase) {
-        munmap(mVirBase, mTotalSize);
-    }
-    if(mFD) {
-        close(mFD);
-    }
-
-}
-
-int PmemAllocator::allocate(DMA_BUFFER *pbuf, int size)
-{
-    CAMERA_HAL_LOG_FUNC;
-
-    if((!mVirBase)||(!pbuf)||(size>mBufSize)) {
-        CAMERA_HAL_ERR("Error!No memory for allocator");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(!mSlotAllocated[index]) {
-            CAMERA_HAL_ERR("Free slot %d for allocating mBufSize %d request size %d",
-                    index,mBufSize,size);
-
-            pbuf->virt_start= (unsigned char *)mVirBase+index*mBufSize; 
-            pbuf->phy_offset= mPhyBase+index*mBufSize;
-            pbuf->length= mBufSize;
-            mSlotAllocated[index] = true;
-            return DMA_ALLOCATE_ERR_NONE;
-        }
-    }
-    return DMA_ALLOCATE_ERR_BAD_PARAM;
-}
-
-int PmemAllocator::deAllocate(DMA_BUFFER *pbuf)
-{
-    CAMERA_HAL_LOG_FUNC;
-    if((!mVirBase)||(!pbuf)) {
-        CAMERA_HAL_ERR("Error!No memory for allocator");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-    int nSlot = ((unsigned int)pbuf->virt_start- (unsigned int)mVirBase)/mBufSize;
-    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
-        CAMERA_HAL_ERR("Info!deAllocate for slot %d",nSlot);
-        mSlotAllocated[nSlot] = false;
-        return DMA_ALLOCATE_ERR_NONE;
-    }
-    else{
-        CAMERA_HAL_ERR("Error!Not a valid buffer");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-}
diff --git a/libcamera/Camera_pmem.h b/libcamera/Camera_pmem.h
deleted file mode 100755
index 8b174a4..0000000
--- a/libcamera/Camera_pmem.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef __CAMERA_MEM__H__
-#define __CAMERA_MEM__H__
-
-#include "Camera_utils.h"
-#include <utils/RefBase.h>
-
-
-#define DEFAULT_PMEM_ALIGN (4096)
-#define PMEM_DEV "/dev/pmem_adsp"
-#define MAX_SLOT 64
-
-namespace android {
-
-class PmemAllocator : public virtual RefBase
-{
-public:
-    PmemAllocator(int bufCount,int bufSize);
-    virtual ~PmemAllocator();
-    virtual int allocate(DMA_BUFFER *p_buf, int size);
-    virtual int deAllocate(DMA_BUFFER *p_buf);
-	int err_ret;
-private:
-    int mFD;
-    unsigned long mTotalSize;
-    int mBufCount;
-    int mBufSize;
-    void *mVirBase;
-    unsigned int mPhyBase;
-    bool mSlotAllocated[MAX_SLOT];
-	
-};
-};
-
-#endif
diff --git a/libcamera/Camera_utils.h b/libcamera/Camera_utils.h
deleted file mode 100755
index 6e01da3..0000000
--- a/libcamera/Camera_utils.h
+++ /dev/null
@@ -1,60 +0,0 @@
-
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef CAMERA_UTILS_H
-#define CAMERA_UTILS_H
-
-#undef LOG_TAG
-#define LOG_TAG "FslCameraHAL"
-#include <utils/Log.h>
-
-//#define CAMERA_HAL_DEBUG_LOG
-
-#ifdef CAMERA_HAL_DEBUG_LOG
-#define CAMERA_HAL_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
-#define CAMERA_HAL_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
-#else
-#define CAMERA_HAL_LOG_RUNTIME(format, ...) 
-#define CAMERA_HAL_LOG_FUNC
-#endif
-
-#define CAMERA_HAL_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
-#define CAMERA_HAL_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
-
-#define CAMERA_HAL_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
-namespace android {
-
-    typedef enum{
-        DMA_ALLOCATE_ERR_NONE = 0,
-        DMA_ALLOCATE_ERR_BAD_PARAM = -1,
-
-    }DMA_ALLOCATE_ERR_RET;
-
-    typedef struct {
-        unsigned char *virt_start;
-        size_t phy_offset;
-        unsigned int length;
-    }DMA_BUFFER;
-
-}; //name space android
-
-#endif
-
diff --git a/libcamera/CaptureDeviceInterface.cpp b/libcamera/CaptureDeviceInterface.cpp
deleted file mode 100755
index 8adc966..0000000
--- a/libcamera/CaptureDeviceInterface.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include "V4l2UVCDevice.h"
-#include "V4l2CsiDevice.h"
-namespace android{
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName)
-    {
-        if(strstr(deviceName, UVC_NAME_STRING)){
-            CAMERA_HAL_LOG_INFO("It is the UVC device");
-
-            sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
-            device->SetDevName(deviceName);
-            return device;
-        }else{
-            CAMERA_HAL_LOG_INFO("It is the CSI device");
-            sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
-            device->SetDevName(deviceName);
-            return device;
-        }
-    }
-
-
-}
diff --git a/libcamera/CaptureDeviceInterface.h b/libcamera/CaptureDeviceInterface.h
deleted file mode 100755
index dac77cf..0000000
--- a/libcamera/CaptureDeviceInterface.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef CAPTURE_DEVICE_INTERFACE_H
-#define CAPTURE_DEVICE_INTERFACE_H
-
-#include <utils/RefBase.h>
-#include "Camera_utils.h"
-
-
-namespace android {
-#define UVC_NAME_STRING "uvc"
-
-    typedef enum{
-        CAPTURE_DEVICE_ERR_ALRADY_OPENED  = 3,
-        CAPTURE_DEVICE_ERR_ENUM_CONTINUE  = 2,
-        CAPTURE_DEVICE_ERR_ENUM_PARAM_END = 1,
-        CAPTURE_DEVICE_ERR_NONE = 0,
-        CAPTURE_DEVICE_ERR_OPEN = -1,
-        CAPTURE_DEVICE_ERR_GET_PARAM = -2,
-        CAPTURE_DEVICE_ERR_SET_PARAM = -3,
-        CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
-        CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
-        CAPTURE_DEVICE_ERR_SYS_CALL=-6,
-        CAPTURE_DEVICE_ERR_UNKNOWN = -100
-    }CAPTURE_DEVICE_ERR_RET;
-
-    typedef enum{
-        MOTION_MODE = 0,
-        HIGH_QUALITY_MODE = 1
-    }CAPTURE_MODE;
-
-    typedef enum{
-        OUTPU_FMT = 0,
-        FRAME_SIZE_FPS = 1
-    }DevParamType;
-
-	typedef enum{
-        SENSOR_PREVIEW_BACK_REF = 0,
-        SENSOR_PREVIEW_VERT_FLIP = 1,
-        SENSOR_PREVIEW_HORIZ_FLIP = 2,
-        SENSOR_PREVIEW_ROATE_180 = 3,
-        SENSOR_PREVIEW_ROATE_LAST = 3
-	}SENSOR_PREVIEW_ROTATE;
-
-    struct timeval_fract{
-        unsigned int numerator;
-        unsigned int denominator;
-    };
-
-    struct capture_config_t{
-        unsigned int fmt;
-        unsigned int width;
-        unsigned int height;
-        unsigned int framesize;   //out
-        unsigned int picture_waite_number;//out
-        struct timeval_fract tv;
-		SENSOR_PREVIEW_ROTATE rotate;
-    };
-
-
-    class CaptureDeviceInterface : public virtual RefBase{
-    public:
-
-        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName)=0;
-        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevOpen()=0;
-        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevPrepare()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevStart()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevQueue(unsigned int BufQueIdx)=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevStop()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate()=0;
-        virtual CAPTURE_DEVICE_ERR_RET DevClose()=0;
-
-        virtual ~ CaptureDeviceInterface(){}
-    };
-    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName);
-
-};
-#endif
-
diff --git a/libcamera/JpegEncoderInterface.cpp b/libcamera/JpegEncoderInterface.cpp
deleted file mode 100755
index 30b9d96..0000000
--- a/libcamera/JpegEncoderInterface.cpp
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. 
- */
-#include "JpegEncoderSoftware.h"
-namespace android{
-
-    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
-    {
-        if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
-            CAMERA_HAL_LOG_INFO("Create the software encoder");
-            return JpegEncoderSoftware::createInstance();
-        }
-        else{
-            CAMERA_HAL_ERR("the hardware encoder is not supported");
-            return NULL;
-        }
-    }
-};
diff --git a/libcamera/JpegEncoderInterface.h b/libcamera/JpegEncoderInterface.h
deleted file mode 100755
index b515757..0000000
--- a/libcamera/JpegEncoderInterface.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef JPEG_ENCODER_INTERFACE_H
-#define JPEG_ENCODER_INTERFACE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include "Camera_utils.h"
-#include <utils/RefBase.h>
-
-namespace android{
-
-
-#define MAX_JPEG_MAKE_BYTES 256
-#define MAX_JPEG_MAKERNOTE_BYTES 256
-#define MAX_JPEG_MODEL_BYTES 256
-#define TIME_FMT_LENGTH 20
-#define MAX_GPS_PROCESSING_BYTES	256
-
-    typedef enum{
-    ORIENTATION_UNDEFINED = 0,
-    ORIENTATION_NORMAL = 1,
-    ORIENTATION_FLIP_HORIZONTAL = 2,
-    ORIENTATION_ROTATE_180 = 3,
-    ORIENTATION_FLIP_VERTICAL = 4,
-    ORIENTATION_TRANSPOSE = 5,
-    ORIENTATION_ROTATE_90 = 6,
-    ORIENTATION_TRANSVERSE = 7,
-    ORIENTATION_ROTATE_270 = 8
-    }JPEG_ENCODER_ROTATION;
-
-    typedef enum{
-    WHITEBALANCE_AUTO = 0,
-    WHITEBALANCE_MANUAL = 1
-    }JPEG_ENCODER_WHITEBALANCE;
-
-    typedef enum{
-    FLASH_NOT_FIRE = 0x00,
-    FLASH_FIRED    = 0x01,
-    FLASH_FIRED_AUTO = 0x19,
-    FLASH_FIRED_RED_EYE_REDUCE = 0x41,
-    FLASH_FIRED_COMPULOSORY = 0x09
-    }JPEG_ENCODER_FLASH;
-
-    typedef enum{
-        SOFTWARE_JPEG_ENC = 0,
-        HARDWARE_JPEG_ENC = 1
-    }JPEG_ENCODER_TYPE;
-
-    typedef enum{
-        JPEG_ENC_ERROR_NONE = 0,
-        JPEG_ENC_ERROR_BAD_PARAM = -1,
-        JPEG_ENC_ERROR_ALOC_BUF = -2
-    }JPEG_ENC_ERR_RET;
-
-
-    typedef enum{
-        SUPPORTED_FMT = 0,
-    }JPEEG_QUERY_TYPE;
-
-    struct jpeg_enc_focallength_t
-    {
-        unsigned int numerator;
-        unsigned int denominator;
-    };
-
-    struct jpeg_enc_make_info_t
-    {
-        unsigned char make_bytes;
-        unsigned char make[MAX_JPEG_MAKE_BYTES];
-    };
-    struct jpeg_enc_makernote_info_t
-    {
-        unsigned char makernote_bytes;
-        unsigned char makernote[MAX_JPEG_MAKERNOTE_BYTES];
-    };
-
-    struct jpeg_enc_model_info_t
-    {
-        unsigned char model_bytes;
-        unsigned char model[MAX_JPEG_MODEL_BYTES];	
-    };
-
-    struct jpeg_enc_datetime_info_t
-    {
-        unsigned char datetime[TIME_FMT_LENGTH];	// "YYYY:MM:DD HH:MM:SS" with time shown in 24-hour format
-    };
-
-    struct jpeg_enc_gps_param{
-        unsigned int version;//GPSVersionID
-        char latitude_ref[2];//GPSLatitudeRef: "N " is positive; "S " is negative
-        char longtitude_ref[2];	//GPSLongtitudeRef: "E " is positive; "W " is negative
-        unsigned int latitude_degree[2];//GPSLatitude
-        unsigned int latitude_minute[2];
-        unsigned int latitude_second[2];
-        unsigned int longtitude_degree[2];//GPSLongitude
-        unsigned int longtitude_minute[2];
-        unsigned int longtitude_second[2];
-        char altitude_ref;//GPSAltitudeRef: 0 or 1(negative)
-        unsigned int altitude[2];//GPSAltitude: unit is meters
-        unsigned int hour[2];//GPSTimeStamp
-        unsigned int minute[2];
-        unsigned int seconds[2];
-        char processmethod[MAX_GPS_PROCESSING_BYTES]; //GPSProcessingMethod
-        char processmethod_bytes;
-        char datestamp[11];//GPSDateStamp: "YYYY:MM:DD "
-    };
-
-    typedef struct{
-        unsigned int PicWidth;
-        unsigned int PicHeight;
-        unsigned int ThumbWidth;
-        unsigned int ThumbHeight;
-        unsigned int BufFmt;
-        JPEG_ENCODER_ROTATION RotationInfo;
-        JPEG_ENCODER_WHITEBALANCE WhiteBalanceInfo;
-        JPEG_ENCODER_FLASH FlashInfo;
-        struct jpeg_enc_focallength_t *pFoclLength;
-        struct jpeg_enc_make_info_t *pMakeInfo;
-        struct jpeg_enc_makernote_info_t *pMakeNote;
-        struct jpeg_enc_model_info_t *pModelInfo;
-        struct jpeg_enc_datetime_info_t *pDatetimeInfo;
-        struct jpeg_enc_gps_param *pGps_info;
-    }enc_cfg_param;
-
-    struct jpeg_encoding_conf{
-        unsigned int output_jpeg_size;
-    };
-
-    class JpegEncoderInterface : public virtual RefBase{
-    public:
-        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)=0;
-        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg)=0;
-        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg)=0;
-        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit()=0;
-
-        virtual ~ JpegEncoderInterface(){}
-    }; 
-
-    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type);
-
-};
-
-#endif
diff --git a/libcamera/JpegEncoderSoftware.cpp b/libcamera/JpegEncoderSoftware.cpp
deleted file mode 100755
index 14adb6a..0000000
--- a/libcamera/JpegEncoderSoftware.cpp
+++ /dev/null
@@ -1,661 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "JpegEncoderSoftware.h"
-
-namespace android{
-
-    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataSize = 0;//Total size of g_JpegData
-    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataLen = 0;//Valid data len of g_JpegData
-    JPEG_ENC_UINT8 *JpegEncoderSoftware::g_JpegData = NULL;//Buffer to hold jpeg data
-
-    JpegEncoderSoftware :: JpegEncoderSoftware()
-        :mSupportedTypeIdx(0),
-        pEncCfgLocal(NULL),
-        pEncObj(NULL)
-    {
-        mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
-    }
-
-    JpegEncoderSoftware :: ~JpegEncoderSoftware()
-    {
-
-    }
-
-    JPEG_ENC_ERR_RET  JpegEncoderSoftware :: EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)
-    {
-
-        int * pSupportedType = (int *)pQueryRet;
-        switch(QueryType){	
-            case SUPPORTED_FMT:
-                if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
-                    *pSupportedType = mSupportedType[mSupportedTypeIdx];
-                    mSupportedTypeIdx ++;
-                }else{
-                    mSupportedTypeIdx = 0;
-                    return JPEG_ENC_ERROR_BAD_PARAM;
-                }
-                break;
-            default:
-                return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        return JPEG_ENC_ERROR_NONE;
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
-    {
-        CAMERA_HAL_LOG_FUNC;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-        struct jpeg_enc_focallength_t * pFoclLength = NULL;
-        struct jpeg_enc_make_info_t *pMakeInfo = NULL;
-        struct jpeg_enc_makernote_info_t *pMakeNote = NULL;
-        struct jpeg_enc_model_info_t *pModelInfo = NULL;
-        struct jpeg_enc_datetime_info_t *pDatetimeInfo = NULL;
-        struct jpeg_enc_gps_param *pGpsInfoLocal = NULL;
-
-        if(pEncCfg == NULL){
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
-
-        if (pEncCfgLocal == NULL){
-            CAMERA_HAL_ERR("Allocat buffer for EncCfg failed");
-            return JPEG_ENC_ERROR_ALOC_BUF;
-        }
-
-        memset(pEncCfgLocal, 0, sizeof(enc_cfg_param));
-        memcpy(pEncCfgLocal, pEncCfg, sizeof(enc_cfg_param));
-
-
-        if ((ret = CheckEncParm()) != JPEG_ENC_ERROR_NONE){
-            goto INT_ERR_RET;
-        }
-
-        if (pEncCfg->pFoclLength != NULL){
-            pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
-
-            if (pFoclLength == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pFoclLength failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pFoclLength, 0, sizeof(struct jpeg_enc_focallength_t));
-            memcpy(pFoclLength, pEncCfg->pFoclLength, sizeof(struct jpeg_enc_focallength_t));
-            pEncCfgLocal->pFoclLength = pFoclLength;
-        }
-
-
-        if (pEncCfg->pMakeInfo != NULL){
-            pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
-
-            if (pMakeInfo == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pMakeInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pMakeInfo, 0, sizeof(struct jpeg_enc_make_info_t));
-            memcpy(pMakeInfo, pEncCfg->pMakeInfo, sizeof(struct jpeg_enc_make_info_t));
-            pEncCfgLocal->pMakeInfo = pMakeInfo;
-        }
-
-        if (pEncCfg->pMakeNote != NULL){
-            pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
-
-            if (pMakeNote == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pMakeNote failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pMakeNote, 0, sizeof(struct jpeg_enc_makernote_info_t));
-            memcpy(pMakeNote, pEncCfg->pMakeNote, sizeof(struct jpeg_enc_makernote_info_t));
-            pEncCfgLocal->pMakeNote = pMakeNote;
-        }
-
-        if (pEncCfg->pModelInfo != NULL){
-            pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
-
-            if (pModelInfo == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pModelInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pModelInfo, 0, sizeof(struct jpeg_enc_model_info_t));
-            memcpy(pModelInfo, pEncCfg->pModelInfo, sizeof(struct jpeg_enc_model_info_t));
-            pEncCfgLocal->pModelInfo = pModelInfo;
-        }
-
-        if (pEncCfg->pDatetimeInfo != NULL){
-            pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
-
-            if (pDatetimeInfo == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pDatetimeInfo failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pDatetimeInfo, 0, sizeof(struct jpeg_enc_datetime_info_t));
-            memcpy(pDatetimeInfo, pEncCfg->pDatetimeInfo, sizeof(struct jpeg_enc_datetime_info_t));
-            pEncCfgLocal->pDatetimeInfo = pDatetimeInfo;
-        }
-
-        if (pEncCfg->pGps_info != NULL){
-            pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
-
-            if (pGpsInfoLocal == NULL){
-                CAMERA_HAL_ERR("Allocat buffer for pGpsInfoLocal failed");
-                ret = JPEG_ENC_ERROR_ALOC_BUF;
-                goto INT_ERR_RET;
-            }
-            memset(pGpsInfoLocal, 0, sizeof(struct jpeg_enc_gps_param));
-            memcpy(pGpsInfoLocal, pEncCfg->pGps_info, sizeof(struct jpeg_enc_gps_param));
-            pEncCfgLocal->pGps_info = pGpsInfoLocal;
-        }
-
-        return ret;
-
-INT_ERR_RET:
-        if(pEncCfgLocal)
-            free(pEncCfgLocal);
-        if(pFoclLength)
-            free(pFoclLength);
-        if(pMakeInfo)
-            free(pMakeInfo);
-        if(pMakeNote)
-            free(pMakeNote);
-        if(pModelInfo)
-            free(pModelInfo);
-        if(pDatetimeInfo)
-            free(pDatetimeInfo);
-        if(pGpsInfoLocal)
-            free(pGpsInfoLocal);
-        return ret;
-
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg){
-        if (inBuf == NULL || outBuf == NULL || inBuf->virt_start == NULL || outBuf->virt_start == NULL){
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }else{
-            return encodeImge(inBuf,outBuf, &(pJpegEncCfg->output_jpeg_size));
-        }
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
-        CAMERA_HAL_LOG_FUNC;
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-
-        if (pEncCfgLocal != NULL ){
-            if (pEncCfgLocal->pFoclLength != NULL)
-                free(pEncCfgLocal->pFoclLength);
-            if (pEncCfgLocal->pMakeInfo != NULL)
-                free(pEncCfgLocal->pMakeInfo);
-            if (pEncCfgLocal->pMakeNote != NULL)
-                free(pEncCfgLocal->pMakeNote);
-            if (pEncCfgLocal->pModelInfo != NULL)
-                free(pEncCfgLocal->pModelInfo);
-            if (pEncCfgLocal->pDatetimeInfo != NULL)
-                free(pEncCfgLocal->pDatetimeInfo);
-            if (pEncCfgLocal->pGps_info != NULL)
-                free(pEncCfgLocal->pGps_info);
-            free(pEncCfgLocal);
-        }
-
-        return ret;
-
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
-
-        CAMERA_HAL_LOG_FUNC;
-        int i = 0;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-
-        if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
-            CAMERA_HAL_ERR("The input widht and height is wrong");
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)|| 
-                (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
-                (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
-            CAMERA_HAL_ERR("The input widht and height is wrong");
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        for (i = 0; i< MAX_ENC_SUPPORTED_YUV_TYPE; i++){
-            if(pEncCfgLocal->BufFmt == mSupportedType[i])
-                break;
-        }
-
-        if (i == MAX_ENC_SUPPORTED_YUV_TYPE)
-            ret = JPEG_ENC_ERROR_BAD_PARAM;
-
-        return ret;
-    }
-
-    JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
-
-        CAMERA_HAL_LOG_FUNC;
-
-        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
-        int width, height, size,index;
-        JPEG_ENC_UINT8 * i_buff = NULL;
-        JPEG_ENC_UINT8 * y_buff = NULL;
-        JPEG_ENC_UINT8 * u_buff = NULL;
-        JPEG_ENC_UINT8 * v_buff = NULL;
-        JPEG_ENC_RET_TYPE return_val;
-        jpeg_enc_parameters * params = NULL;
-        jpeg_enc_object * obj_ptr = NULL;
-        JPEG_ENC_UINT8 number_mem_info;
-        jpeg_enc_memory_info * mem_info = NULL;
-        unsigned char *thumbnail_buffer,*temp_buffer=NULL;
-        int thumbnail_width, thumbnail_height;
-        unsigned char *buffer = inBuf->virt_start;
-
-        bool mEncodeThumbnailFlag = true;
-
-        width = pEncCfgLocal->PicWidth;
-        height = pEncCfgLocal->PicHeight;
-
-        thumbnail_width = pEncCfgLocal->ThumbWidth;
-        thumbnail_height = pEncCfgLocal->ThumbHeight;
-
-
-        if (thumbnail_width <= 0 || thumbnail_height<= 0)
-            mEncodeThumbnailFlag = false;
-
-        g_JpegDataSize = 0;//Total size of g_JpegData
-        g_JpegDataLen = 0;//Valid data len of g_JpegData
-        g_JpegData = NULL;//Buffer to hold jpeg data
-        size = width * height * 3 / 2;
-
-        g_JpegData = outBuf->virt_start;
-        g_JpegDataSize = size;
-        if(!g_JpegData)
-        {
-            return JPEG_ENC_ERROR_BAD_PARAM;
-        }
-
-        /* --------------------------------------------
-         * Allocate memory for Encoder Object
-         * -------------------------------------------*/
-        obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
-        if(!obj_ptr)
-        {
-            return JPEG_ENC_ERROR_ALOC_BUF;
-        }
-        memset(obj_ptr, 0, sizeof(jpeg_enc_object));
-
-        /* Assign the function for streaming output */
-        obj_ptr->jpeg_enc_push_output = pushJpegOutput;
-        obj_ptr->context=NULL;   //user can put private variables into it
-        /* --------------------------------------------
-         * Fill up the parameter structure of JPEG Encoder
-         * -------------------------------------------*/
-        params = &(obj_ptr->parameters);
-
-        if(mEncodeThumbnailFlag==true)
-        {
-
-            //need resizing code here!!!
-            thumbnail_buffer = (unsigned char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
-            if(!thumbnail_buffer)
-            {
-                return JPEG_ENC_ERROR_ALOC_BUF;
-            }
-
-            yuv_resize((unsigned char *)thumbnail_buffer, thumbnail_width, thumbnail_height, buffer, width, height);
-
-            width = thumbnail_width;
-            height = thumbnail_height;
-
-            temp_buffer = buffer;
-            buffer = thumbnail_buffer;
-
-            params->mode = JPEG_ENC_THUMB;
-        }
-        else
-        {
-            params->mode = JPEG_ENC_MAIN_ONLY;
-        }
-
-encodeframe:
-
-        params->compression_method = JPEG_ENC_SEQUENTIAL;
-        params->quality = 75;
-        params->restart_markers = 0;
-        if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','1','2')){
-            params->y_width = width;
-            params->y_height = height;
-            params->u_width = params->y_width/2;
-            params->u_height = params->y_height/2;
-            params->v_width = params->y_width/2;
-            params->v_height = params->y_height/2;
-            params->primary_image_height = height;
-            params->primary_image_width = width;
-            params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
-        }else if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','Y','V')){
-            params->y_width = width;
-            params->y_height = height;
-            params->u_width = params->y_width/2;
-            params->u_height = params->y_height;
-            params->v_width = params->y_width/2;
-            params->v_height = params->y_height;
-            params->primary_image_height = height;
-            params->primary_image_width = width;
-            params->yuv_format = JPEG_ENC_YU_YV_422_INTERLEAVED;
-        }
-        params->exif_flag = 1;
-
-        params->y_left = 0;
-        params->y_top = 0;
-        params->y_total_width = 0;
-        params->y_total_height = 0;
-        params->raw_dat_flag= 0;
-
-        if(params->y_total_width==0)
-        {
-            params->y_left=0;
-            params->u_left=0;
-            params->v_left=0;
-            params->y_total_width=params->y_width;  // no cropping
-            params->u_total_width=params->u_width;  // no cropping
-            params->v_total_width=params->v_width;  // no cropping
-        }
-
-        if(params->y_total_height==0)
-        {
-            params->y_top=0;
-            params->u_top=0;
-            params->v_top=0;
-            params->y_total_height=params->y_height; // no cropping
-            params->u_total_height=params->u_height; // no cropping
-            params->v_total_height=params->v_height; // no cropping
-        }
-
-        /* Pixel size is unknown by default */
-        params->jfif_params.density_unit = 0;
-        /* Pixel aspect ratio is square by default */
-        params->jfif_params.X_density = 1;
-        params->jfif_params.Y_density = 1;
-        if (params->yuv_format == JPEG_ENC_YUV_420_NONINTERLEAVED){
-            y_buff = (JPEG_ENC_UINT8 *)buffer;
-            u_buff = y_buff+width*height;
-            v_buff = u_buff+width*height/4;
-            i_buff = NULL;
-        }else if (params->yuv_format == JPEG_ENC_YU_YV_422_INTERLEAVED){
-            y_buff = NULL;
-            u_buff = NULL;
-            v_buff = NULL;
-            i_buff = (JPEG_ENC_UINT8 *)buffer;
-        }
-        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
-
-        /* --------------------------------------------
-         * QUERY MEMORY REQUIREMENTS
-         * -------------------------------------------*/
-        return_val = jpeg_enc_query_mem_req(obj_ptr);
-
-        if(return_val != JPEG_ENC_ERR_NO_ERROR)
-        {
-            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
-            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_query_mem_req success");
-        /* --------------------------------------------
-         * ALLOCATE MEMORY REQUESTED BY CODEC
-         * -------------------------------------------*/
-        number_mem_info = obj_ptr->mem_infos.no_entries;
-        for(index = 0; index < number_mem_info; index++)
-        {
-            /* This example code ignores the 'alignment' and
-             * 'memory_type', but some other applications might want
-             * to allocate memory based on them */
-            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-            mem_info->memptr = (void *) malloc(mem_info->size);
-            if(mem_info->memptr==NULL) {
-                CAMERA_HAL_LOG_RUNTIME("Malloc error after query\n");
-                goto done;
-            }
-        }
-
-        return_val = jpeg_enc_init(obj_ptr);
-        if(return_val != JPEG_ENC_ERR_NO_ERROR)
-        {
-            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
-            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-
-        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_init success");
-        if(params->mode == JPEG_ENC_THUMB)
-            createJpegExifTags(obj_ptr);
-
-        return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
-                y_buff, u_buff, v_buff);
-
-        if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
-        {
-            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
-            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
-            goto done;
-        }
-
-        if(params->mode == JPEG_ENC_THUMB)
-        {
-            JPEG_ENC_UINT8 num_entries;
-            JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
-            JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
-
-            jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
-
-            for(int i = 0; i < num_entries; i++)
-            {
-                *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
-            }
-
-            free(offset_tbl_ptr);
-            free(value_tbl_ptr);
-
-            free(buffer);
-
-            number_mem_info = obj_ptr->mem_infos.no_entries;
-            for(index = 0; index < number_mem_info; index++)
-            {
-                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-                if(mem_info)
-                    free(mem_info->memptr);
-            }
-
-            g_JpegData += g_JpegDataLen;
-            g_JpegDataSize -= g_JpegDataLen;
-
-
-            //recover to build the main jpeg
-            params->mode = JPEG_ENC_MAIN;
-
-            buffer = temp_buffer;
-            width = pEncCfgLocal->PicWidth;
-            height = pEncCfgLocal->PicHeight;
-
-            goto encodeframe;
-        }
-        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_encodeframe success");
-        // Make an IMemory for each frame
-        //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
-        *pEncSize = g_JpegDataLen;
-
-done:
-        /* --------------------------------------------
-         * FREE MEMORY REQUESTED BY CODEC
-         * -------------------------------------------*/
-        if(obj_ptr)
-        {
-            number_mem_info = obj_ptr->mem_infos.no_entries;
-            for(index = 0; index < number_mem_info; index++)
-            {
-                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
-                if(mem_info)
-                    free(mem_info->memptr);
-            }
-            free(obj_ptr);
-        }
-
-        return ret;
-    }
-
-    JPEG_ENC_UINT8 JpegEncoderSoftware::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
-            JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
-    {
-        JPEG_ENC_UINT32 i;
-        if(*out_buf_ptrptr == NULL)
-        {
-            /* This function is called for the 1'st time from the
-             * codec */
-            *out_buf_ptrptr = g_JpegData;
-            *out_buf_len_ptr = g_JpegDataSize;
-        }
-
-        else if(flush == 1)
-        {
-            /* Flush the buffer*/
-            g_JpegDataLen += *out_buf_len_ptr;
-            CAMERA_HAL_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
-
-            *out_buf_ptrptr = NULL;
-            *out_buf_len_ptr = NULL;
-        }
-        else
-        {
-            CAMERA_HAL_LOG_RUNTIME("Not enough buffer for encoding");
-            return 0;
-        }
-
-        return(1); /* Success */
-    }
-
-    void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
-    {
-        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
-
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_ORIENTATION, (unsigned int)(&(pEncCfgLocal->RotationInfo)));
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_WHITEBALANCE, (unsigned int)(&(pEncCfgLocal->WhiteBalanceInfo)));
-        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FLASH, (unsigned int)(&(pEncCfgLocal->FlashInfo)));
-
-        if(pEncCfgLocal->pMakeInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(pEncCfgLocal->pMakeInfo));
-        if(pEncCfgLocal->pMakeNote)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(pEncCfgLocal->pMakeNote));
-        if(pEncCfgLocal->pModelInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(pEncCfgLocal->pModelInfo));
-        if(pEncCfgLocal->pDatetimeInfo)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(pEncCfgLocal->pDatetimeInfo));
-        if(pEncCfgLocal->pFoclLength)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(pEncCfgLocal->pFoclLength));
-
-        if (pEncCfgLocal->pGps_info)
-            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(pEncCfgLocal->pGps_info));
-
-        return;
-    }
-
-    int JpegEncoderSoftware::yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height)
-    {
-        int i,j,s;
-        int h_offset;
-        int v_offset;
-        unsigned char *ptr,cc;
-        int h_scale_ratio;
-        int v_scale_ratio;
-
-        s = 0;
-
-_resize_begin:
-
-        if(!dst_width) return -1;
-        if(!dst_height) return -1;
-
-        h_scale_ratio = src_width / dst_width;
-        if(!h_scale_ratio) return -1;
-
-        v_scale_ratio = src_height / dst_height;
-        if(!v_scale_ratio) return -1;
-
-        h_offset = (src_width - dst_width * h_scale_ratio) / 2;
-        v_offset = (src_height - dst_height * v_scale_ratio) / 2;
-
-        for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
-        {
-            for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
-            {
-                ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
-                cc = ptr[0];
-
-                ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
-                ptr[0] = cc;
-            }
-        }
-
-        src_ptr += src_width*src_height;
-        dst_ptr += dst_width*dst_height;
-
-        if(s < 2)
-        {
-            if(!s++)
-            {
-                src_width >>= 1;
-                src_height >>= 1;
-
-                dst_width >>= 1;
-                dst_height >>= 1;
-            }
-
-            goto _resize_begin;
-        }
-
-        return 0;
-    }
-
-    sp<JpegEncoderInterface> JpegEncoderSoftware::createInstance(){
-        sp<JpegEncoderInterface> hardware(new JpegEncoderSoftware());
-        return hardware;
-    }
-
-
-};
diff --git a/libcamera/JpegEncoderSoftware.h b/libcamera/JpegEncoderSoftware.h
deleted file mode 100755
index 2bcd2d1..0000000
--- a/libcamera/JpegEncoderSoftware.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef JPEG_ENCODER_SOFTWARE_H
-#define JPEG_ENCODER_SOFTWARE_H
-
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-
-#include "JpegEncoderInterface.h"
-#include "jpeg_enc_interface.h"
-
-
-namespace android{
-#define MAX_ENC_SUPPORTED_YUV_TYPE  1
-
-    class JpegEncoderSoftware : public JpegEncoderInterface{
-    public:
-        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet);
-        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg);
-        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg);
-        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit();
-
-        static sp<JpegEncoderInterface>createInstance();
-    private:
-
-        JpegEncoderSoftware();
-        virtual ~JpegEncoderSoftware();
-
-        virtual JPEG_ENC_ERR_RET CheckEncParm();
-        virtual JPEG_ENC_ERR_RET encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize);
-
-
-        static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
-                JPEG_ENC_UINT32 *out_buf_len_ptr,
-                JPEG_ENC_UINT8 flush, 
-                void * context, 
-                JPEG_ENC_MODE enc_mode);
-        void createJpegExifTags(jpeg_enc_object * obj_ptr);
-        int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
-
-
-        unsigned int mSupportedType[MAX_ENC_SUPPORTED_YUV_TYPE];
-        unsigned int mSupportedTypeIdx;
-        enc_cfg_param *pEncCfgLocal;
-        jpeg_enc_object *pEncObj;
-
-
-        static JPEG_ENC_UINT32 g_JpegDataSize ;//Total size of g_JpegData
-        static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
-        static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
-
-    }; 
-};
-
-#endif
diff --git a/libcamera/PP_ipulib.cpp b/libcamera/PP_ipulib.cpp
deleted file mode 100755
index 69d91ee..0000000
--- a/libcamera/PP_ipulib.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include "PP_ipulib.h"
-#include <stdlib.h>
-#include <string.h>
-
-namespace android{
-
-    wp<PostProcessDeviceInterface> PPIpuLib :: singleton;
-
-    PPIpuLib :: PPIpuLib(){
-        return;
-    }
-
-    PPIpuLib :: ~PPIpuLib(){
-
-        singleton.clear();
-    }
-    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
-        CAMERA_HAL_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        int mIPURet;
-
-        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-        //Setting input format
-        mIPUInputParam.width = pp_input->width;
-        mIPUInputParam.height = pp_input->height;
-
-        mIPUInputParam.input_crop_win.pos.x = pp_input->input_crop_win.pos.x;
-        mIPUInputParam.input_crop_win.pos.y = pp_input->input_crop_win.pos.y;  
-        mIPUInputParam.input_crop_win.win_w = pp_input->input_crop_win.win_w;
-        mIPUInputParam.input_crop_win.win_h = pp_input->input_crop_win.win_h;
-        mIPUInputParam.fmt = pp_input->fmt;
-        mIPUInputParam.user_def_paddr[0] = pp_input->user_def_paddr;
-
-        //Setting output format
-        mIPUOutputParam.fmt = pp_output->fmt;
-        mIPUOutputParam.width = pp_output->width;
-        mIPUOutputParam.height = pp_output->height;   
-        mIPUOutputParam.show_to_fb = 0;
-        //Output param should be same as input, since no resize,crop
-        mIPUOutputParam.output_win.pos.x = pp_output->output_win.pos.x;
-        mIPUOutputParam.output_win.pos.y = pp_output->output_win.pos.y;
-        mIPUOutputParam.output_win.win_w = pp_output->output_win.win_w;
-        mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
-        mIPUOutputParam.rot = pp_output->rot;
-        mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
-        CAMERA_HAL_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
-                mIPUOutputParam.width,
-                mIPUOutputParam.height,
-                mIPUOutputParam.output_win.pos.x,
-                mIPUOutputParam.output_win.pos.y,
-                mIPUOutputParam.output_win.win_w,
-                mIPUOutputParam.output_win.win_h,
-                mIPUOutputParam.rot);
-
-        CAMERA_HAL_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
-                mIPUInputParam.width,
-                mIPUInputParam.height,
-                mIPUInputParam.fmt,
-                mIPUInputParam.input_crop_win.pos.x,
-                mIPUInputParam.input_crop_win.pos.y,
-                mIPUInputParam.input_crop_win.win_w,
-                mIPUInputParam.input_crop_win.win_h);	  
-
-        mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
-        if (mIPURet < 0) {
-            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
-            return PPDEVICE_ERROR_INIT;
-        }  
-
-        return ret;
-    }
-
-    PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
-        CAMERA_HAL_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        int mIPURet;
-        mIPUInputParam.user_def_paddr[0] = pp_input_addr->phy_offset;
-
-        mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
-
-        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset,NULL,NULL,NULL);
-        if (mIPURet < 0) {
-            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
-            mxc_ipu_lib_task_uninit(&mIPUHandle);
-            memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-            return PPDEVICE_ERROR_PROCESS;
-        }
-
-        return ret;
-
-    }
-
-    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
-        CAMERA_HAL_LOG_FUNC;
-        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
-
-        mxc_ipu_lib_task_uninit(&mIPUHandle);
-        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
-
-        return ret;
-    }
-
-    sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
-        CAMERA_HAL_LOG_FUNC;
-        if (singleton != 0) {
-            sp<PostProcessDeviceInterface> device = singleton.promote();
-            if (device != 0) {
-                return device;
-            }
-        }
-        sp<PostProcessDeviceInterface> device(new PPIpuLib());
-
-        singleton = device;
-        return device;
-    }
-
-};
diff --git a/libcamera/PP_ipulib.h b/libcamera/PP_ipulib.h
deleted file mode 100755
index 39b0d4c..0000000
--- a/libcamera/PP_ipulib.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef PP_IPU_LIB_H
-#define PP_IPU_LIB_H
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-} 
-
-#include "PostProcessDeviceInterface.h"
-
-namespace android{
-    class PPIpuLib : public PostProcessDeviceInterface
-    {
-    public:
-        virtual PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output);
-        virtual PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr);
-        virtual PPDEVICE_ERR_RET PPDeviceDeInit();
-        static sp<PostProcessDeviceInterface> createInstance();
-    private:
-        PPIpuLib();
-        virtual ~PPIpuLib();
-        static wp<PostProcessDeviceInterface> singleton;
-
-        ipu_lib_input_param_t mIPUInputParam;	
-        ipu_lib_output_param_t mIPUOutputParam; 
-        ipu_lib_handle_t			mIPUHandle;
-    };
-};
-#endif
diff --git a/libcamera/PostProcessDeviceInterface.cpp b/libcamera/PostProcessDeviceInterface.cpp
deleted file mode 100755
index 3d7e752..0000000
--- a/libcamera/PostProcessDeviceInterface.cpp
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include "PP_ipulib.h" 
-namespace android{
-    extern "C" sp<PostProcessDeviceInterface> createPPDevice(){
-        return PPIpuLib :: createInstance();
-    }
-
-};
diff --git a/libcamera/PostProcessDeviceInterface.h b/libcamera/PostProcessDeviceInterface.h
deleted file mode 100755
index 9d730b6..0000000
--- a/libcamera/PostProcessDeviceInterface.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef POSTPROCESS_DEVICE_INTERFACE_H
-#define POSTPROCESS_DEVICE_INTERFACE_H
-
-#include <utils/RefBase.h>
-#include "Camera_utils.h"
-#include <linux/videodev2.h>
-
-namespace android {
-
-    typedef enum{
-        PPDEVICE_ERROR_NONE = 0,
-        PPDEVICE_ERROR_INIT = -1,
-        PPDEVICE_ERROR_PROCESS  = -2,
-        PPDEVICE_ERROR_DEINIT = -3
-    }PPDEVICE_ERR_RET;
-
-    struct pp_fb_pos{
-        unsigned short x;
-        unsigned short y;
-    };
-
-    struct win_t{
-        struct pp_fb_pos pos;
-        unsigned int win_w;
-        unsigned int win_h;
-    } ;
-
-    typedef struct {
-        unsigned int width;
-        unsigned int height;
-        unsigned int fmt;
-        struct win_t input_crop_win;
-        int user_def_paddr;
-    } pp_input_param_t;
-
-    typedef struct {
-        unsigned int width;
-        unsigned int height;
-        unsigned int fmt;
-        unsigned int rot;
-        struct win_t output_win;
-        int user_def_paddr;
-    } pp_output_param_t;
-
-
-    class PostProcessDeviceInterface : public virtual RefBase{
-    public:
-        virtual  PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output)=0;
-        virtual  PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr)=0;
-        virtual  PPDEVICE_ERR_RET PPDeviceDeInit()=0;
-
-        virtual ~PostProcessDeviceInterface(){}
-    }; 
-    extern "C" sp<PostProcessDeviceInterface> createPPDevice();
-
-};
-#endif
-
diff --git a/libcamera/V4l2CapDeviceBase.cpp b/libcamera/V4l2CapDeviceBase.cpp
deleted file mode 100755
index 8976b9e..0000000
--- a/libcamera/V4l2CapDeviceBase.cpp
+++ /dev/null
@@ -1,612 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "V4l2CapDeviceBase.h"
-
-
-
-
-namespace android{
-
-    V4l2CapDeviceBase ::V4l2CapDeviceBase()
-        :mCameraDevice(0),
-        mFmtParamIdx(0),
-        mSizeFPSParamIdx(0),
-        mRequiredFmt(0),
-        mBufQueNum(0),
-        mQueuedBufNum(0)
-
-    {
-        mCaptureDeviceName[0] = '#';
-    }
-
-    V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
-    {
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::SetDevName(char * deviceName){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        if(NULL == deviceName)
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        strcpy(mInitalDeviceName, deviceName);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if(NULL == deviceName)
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        strcpy(deviceName, mInitalDeviceName);
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::DevOpen(){
-        CAMERA_HAL_LOG_FUNC;
-
-        return V4l2Open(); 
-    } 
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        CAMERA_HAL_LOG_FUNC;
-
-        if(mCameraDevice <= 0)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        else
-            return V4l2EnumParam(devParamType,retParam);
-
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        mCapCfg = *pCapcfg;
-        return V4l2SetConfig(pCapcfg);
-
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2AllocateBuf(DevBufQue, pBufQueNum);
-    }
-
-    CAPTURE_DEVICE_ERR_RET  V4l2CapDeviceBase :: DevPrepare(){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2Prepare();
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStart(){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else
-            return V4l2Start();
-    }
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Dequeue(pBufQueIdx);
-        }
-
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Queue(BufQueIdx);
-        }
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStop(){
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Stop();
-        }
-
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDeAllocate(){
-        CAMERA_HAL_LOG_FUNC;
-
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2DeAlloc();
-        }
-    }
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevClose(){
-
-        CAMERA_HAL_LOG_FUNC;
-
-        if (mCameraDevice <= 0){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }else{
-            return V4l2Close();
-        }
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Open(){
-        CAMERA_HAL_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-
-        char   dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_capability v4l2_cap;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-        else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        else{
-            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5)) 
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                        continue;
-                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
-                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
-                        close(fd);
-                        continue;
-                    } else if ((strstr((char *)v4l2_cap.driver, mInitalDeviceName) != 0) &&
-                            (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
-                        is_found = 1;
-                        strcpy(mCaptureDeviceName, dev_node);
-                        CAMERA_HAL_LOG_RUNTIME("device name is %s", mCaptureDeviceName);
-                        break;
-                    } else
-                        close(fd);
-                }
-            }
-            if (fd > 0)
-                mCameraDevice = fd;
-            else{
-                CAMERA_HAL_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        return ret; 
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-
-        CAMERA_HAL_LOG_FUNC;
-        CAMERA_HAL_LOG_RUNTIME("devParamType is %d", devParamType);
-
-        if(mCameraDevice <= 0)
-            return CAPTURE_DEVICE_ERR_OPEN;
-        switch(devParamType){
-            case OUTPU_FMT: 
-                ret = V4l2EnumFmt(retParam);
-                break;
-            case FRAME_SIZE_FPS:
-                {
-                    ret = V4l2EnumSizeFps(retParam);
-                    break;
-                }
-            default:
-                {
-                    ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-                    break;
-                }
-        }
-        return ret;
-
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        struct v4l2_fmtdesc vid_fmtdesc;
-        unsigned int *pParamVal = (unsigned int *)retParam;
-
-        vid_fmtdesc.index = mFmtParamIdx;
-        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
-            mFmtParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-        }else{
-            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
-            *pParamVal = vid_fmtdesc.pixelformat;
-            mFmtParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        struct v4l2_frmsizeenum vid_frmsize;
-        struct v4l2_frmivalenum vid_frmval;
-
-        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-        vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
-            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
-            vid_frmval.pixel_format = pCapCfg->fmt;
-            vid_frmval.width = vid_frmsize.discrete.width;
-            vid_frmval.height= vid_frmsize.discrete.height;
-            if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
-                CAMERA_HAL_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
-                mSizeFPSParamIdx = 0;
-                ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-            }else{
-                pCapCfg->width	= vid_frmsize.discrete.width;
-                pCapCfg->height = vid_frmsize.discrete.height;
-                pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
-                pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
-                mSizeFPSParamIdx ++;
-                ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-            }
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
-
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        //For uvc Camera do nothing here.
-
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        *pMode = 0;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
-
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        //For uvc Camera do nothing here.
-
-        return ret;
-    }
-
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_format fmt;
-        struct v4l2_control ctrl;
-        struct v4l2_streamparm parm;
-
-        V4l2ConfigInput(pCapcfg);
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
-
-        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
-        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
-        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-        else
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_HAL_ERR("set format failed\n");
-            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
-                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
-                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
-        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-            CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
-                    parm.parm.capture.timeperframe.denominator);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-
-
-        if(V4l2SetRot(pCapcfg) < 0)
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }else{
-
-            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-        }
-        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-        pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
-        unsigned int i;
-        struct v4l2_buffer buf;
-        enum v4l2_buf_type type;
-        struct v4l2_requestbuffers req;
-        int BufQueNum;
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        mBufQueNum = *pBufQueNum;
-
-        memset(&req, 0, sizeof (req));
-        req.count = mBufQueNum;
-        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        req.memory = V4L2_MEMORY_MMAP;
-        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
-            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        /*the driver may can't meet the request, and return the buf num it can handle*/
-        *pBufQueNum = mBufQueNum = req.count;
-
-        for (i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (buf));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.index = i;
-            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
-                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } else {
-                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
-            }
-
-            mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
-            mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset = (size_t) buf.m.offset;
-            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
-                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
-            memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
-            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Prepare(){
-        CAMERA_HAL_LOG_FUNC;
-        struct v4l2_buffer buf;
-        mQueuedBufNum = 0;
-        for (unsigned int i = 0; i < mBufQueNum; i++) {
-            memset(&buf, 0, sizeof (struct v4l2_buffer));
-            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-            buf.memory = V4L2_MEMORY_MMAP;
-            buf.index = i;
-            buf.m.offset = mCaptureBuffers[i].phy_offset;
-
-            if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
-                CAMERA_HAL_ERR("VIDIOC_QBUF error\n");
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            } 
-            mQueuedBufNum ++;
-        }
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Start(){
-        enum v4l2_buf_type type;
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else{
-            CAMERA_HAL_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
-        int ret;
-        struct v4l2_buffer cfilledbuffer;
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-        ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
-        if (ret < 0) {
-            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        *pBufQueIdx = cfilledbuffer.index;
-
-        mQueuedBufNum --;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
-        int ret;
-        struct v4l2_buffer cfilledbuffer;
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
-            return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
-        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        cfilledbuffer.memory = V4L2_MEMORY_MMAP;
-        cfilledbuffer.index = BufQueIdx;
-        ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
-        if (ret < 0) {
-            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        mQueuedBufNum ++;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Stop(){
-        enum v4l2_buf_type type;
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        } else
-            CAMERA_HAL_LOG_INFO("VIDIOC_STREAMOFF ok\n");
-
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 ){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        for (unsigned int i = 0; i < mBufQueNum; i++) {
-            if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
-                munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
-                mCaptureBuffers[i].length = 0;
-                CAMERA_HAL_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
-            }
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Close(){
-
-        CAMERA_HAL_LOG_FUNC;
-
-        if (mCameraDevice <= 0 ){
-            CAMERA_HAL_LOG_INFO("the device handle is error");
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-        CAMERA_HAL_LOG_INFO("close the device");
-        close(mCameraDevice);
-        mCameraDevice = -1;
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-};
diff --git a/libcamera/V4l2CapDeviceBase.h b/libcamera/V4l2CapDeviceBase.h
deleted file mode 100755
index 636b062..0000000
--- a/libcamera/V4l2CapDeviceBase.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#ifndef V4L2_CAP_DEVICE_BASE_H
-#define V4L2_CAP_DEVICE_BASE_H
-#include <linux/videodev2.h>
-
-#include "CaptureDeviceInterface.h"
-
-#define CAMAERA_FILENAME_LENGTH     256
-#define MAX_CAPTURE_BUF_QUE_NUM     6
-#define CAMAERA_SENSOR_LENGTH       32
-
-namespace android{
-
-    class V4l2CapDeviceBase : public CaptureDeviceInterface{
-    public:
-
-        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName);
-        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName);
-        virtual CAPTURE_DEVICE_ERR_RET DevOpen();
-        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_ERR_RET DevPrepare();
-        virtual CAPTURE_DEVICE_ERR_RET DevStart();
-        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET DevQueue( unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET DevStop();
-        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate();
-        virtual CAPTURE_DEVICE_ERR_RET DevClose();
-
-    protected:
-
-        V4l2CapDeviceBase();
-        virtual ~V4l2CapDeviceBase();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Open();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Prepare();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Start();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Dequeue(unsigned int *pBufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Queue(unsigned int BufQueIdx);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Stop();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2DeAlloc();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2Close();
-        virtual CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        virtual CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
-        virtual CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-
-        char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
-        char         mInitalDeviceName[CAMAERA_SENSOR_LENGTH];
-        int          mCameraDevice;
-        unsigned int mFmtParamIdx;
-        unsigned int mSizeFPSParamIdx;
-        unsigned int mRequiredFmt;
-        unsigned int mBufQueNum;
-        int          mQueuedBufNum;
-        DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
-        struct   capture_config_t mCapCfg;
-
-    };
-};
-
-#endif
diff --git a/libcamera/V4l2CsiDevice.cpp b/libcamera/V4l2CsiDevice.cpp
deleted file mode 100755
index e67f301..0000000
--- a/libcamera/V4l2CsiDevice.cpp
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#include <string.h>
-#include <unistd.h>
-#include <time.h>
-#include <dlfcn.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <linux/time.h>
-#include <linux/videodev.h>
-#include <linux/videodev2.h>
-#include <linux/mxc_v4l2.h>
-#include <linux/mxcfb.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <utils/threads.h>
-#include <dirent.h>
-
-#include "V4l2CsiDevice.h"
-
-namespace android{
-    V4l2CsiDevice :: V4l2CsiDevice(){
-        mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
-        mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
-        mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
-
-    }
-    V4l2CsiDevice :: ~V4l2CsiDevice()
-    {
-    }
-
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2Open(){
-        CAMERA_HAL_LOG_FUNC;
-        int fd = 0, i, j, is_found = 0;
-        const char *flags[] = {"uncompressed", "compressed"};
-
-        char	dev_node[CAMAERA_FILENAME_LENGTH];
-        DIR *v4l_dir = NULL;
-        struct dirent *dir_entry;
-        struct v4l2_dbg_chip_ident vid_chip;
-        struct v4l2_fmtdesc vid_fmtdesc;
-        struct v4l2_frmsizeenum vid_frmsize;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-
-        if(mCameraDevice > 0)
-            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
-        else if (mCaptureDeviceName[0] != '#'){
-            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
-            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
-            if (mCameraDevice < 0)
-                return CAPTURE_DEVICE_ERR_OPEN;
-        }
-        else{
-            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
-            v4l_dir = opendir("/sys/class/video4linux");
-            if (v4l_dir){
-                while((dir_entry = readdir(v4l_dir))) {
-                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
-                    if(strncmp(dir_entry->d_name, "video", 5)) 
-                        continue;
-                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
-                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
-                        continue;
-                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
-                    if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
-                        close(fd);
-                        continue;
-                    } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
-                        is_found = 1;
-                        strcpy(mCaptureDeviceName, dev_node);
-                        strcpy(mInitalDeviceName, vid_chip.match.name);
-                        CAMERA_HAL_LOG_INFO("device name is %s", mCaptureDeviceName);
-                        CAMERA_HAL_LOG_INFO("sensor name is %s", mInitalDeviceName);
-                        break;
-                    } else{
-                        close(fd);
-                        fd = 0;
-                    }
-                }
-            }
-            if (fd > 0)
-                mCameraDevice = fd;
-            else{
-                CAMERA_HAL_ERR("The device name is not correct or the device is error");
-                return CAPTURE_DEVICE_ERR_OPEN;
-            }
-        }
-        return ret; 
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        unsigned int *pParamVal = (unsigned int *)retParam;
-
-        if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
-            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
-            *pParamVal = mSupportedFmt[mFmtParamIdx];
-            mFmtParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }else{
-            mFmtParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
-        struct v4l2_frmsizeenum vid_frmsize;
-
-        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
-        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
-        vid_frmsize.index = mSizeFPSParamIdx;
-        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
-        vid_frmsize.pixel_format = pCapCfg->fmt;
-        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-            mSizeFPSParamIdx = 0;
-            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-        }else{
-            //hardcode here for ov3640
-            if (strstr(mInitalDeviceName, "3640") != NULL){
-                CAMERA_HAL_LOG_INFO("the sensor  is  mInitalDeviceName");
-                if (vid_frmsize.discrete.width == 1024 && vid_frmsize.discrete.height == 768){
-                    mSizeFPSParamIdx ++;
-                    vid_frmsize.index = mSizeFPSParamIdx;
-                    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
-                        mSizeFPSParamIdx = 0;
-                        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
-                    }
-                }
-            }
-            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
-            pCapCfg->width  = vid_frmsize.discrete.width;
-            pCapCfg->height = vid_frmsize.discrete.height;
-            if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
-                pCapCfg->tv.numerator = 1;
-                pCapCfg->tv.denominator = 15;
-            }else{
-                pCapCfg->tv.numerator = 1;
-                pCapCfg->tv.denominator = 30;
-            }
-            mSizeFPSParamIdx ++;
-            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
-        }
-        return ret;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
-    {
-        CAMERA_HAL_LOG_FUNC;
-        int input = 1;
-        if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
-            CAMERA_HAL_ERR("set input failed");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
-    {
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        struct v4l2_format fmt;
-        struct v4l2_control ctrl;
-        struct v4l2_streamparm parm;
-
-        V4l2ConfigInput(pCapcfg);
-
-        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        //hard code here to do a walk around.
-        if(pCapcfg->tv.denominator != 30 && pCapcfg->tv.denominator != 15){
-            pCapcfg->tv.numerator = 1;
-            pCapcfg->tv.denominator = 30;
-        }
-        CAMERA_HAL_LOG_RUNTIME("the fps is %d", pCapcfg->tv.denominator);
-
-        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
-        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
-        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
-        if (ret != CAPTURE_DEVICE_ERR_NONE)
-            return ret;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
-            parm.parm.capture.timeperframe.numerator = 1;
-            parm.parm.capture.timeperframe.denominator = 15;
-            if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0){
-                CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
-                CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator, 
-                        parm.parm.capture.timeperframe.denominator);
-                return CAPTURE_DEVICE_ERR_SYS_CALL;
-            }
-        }
-
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
-
-        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
-        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
-        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
-        else
-            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
-        fmt.fmt.pix.priv = 0;
-        fmt.fmt.pix.sizeimage = 0;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
-            CAMERA_HAL_ERR("set format failed\n");
-            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
-            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
-                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
-                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        if(V4l2SetRot(pCapcfg) < 0)
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-
-        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
-            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }else{
-
-            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
-            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
-            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
-            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
-        }
-        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
-
-        CAMERA_HAL_LOG_FUNC;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        unsigned int capturemode = 0;
-        unsigned int capturewidth =  pCapcfg->width;
-        unsigned int captureheight = pCapcfg->height;
-        unsigned int pic_waite_buf_num = 0;
-        if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
-                (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
-            pic_waite_buf_num = 10;
-            if (capturewidth == 640 && captureheight == 480)
-                capturemode = 0;	/* VGA mode */
-            else if (capturewidth == 320 && captureheight == 240)
-                capturemode = 1;	/* QVGA mode */
-            else if (capturewidth == 720 && captureheight == 480)
-                capturemode = 2;	/* PAL mode */
-            else if (capturewidth == 720 && captureheight == 576)
-                capturemode = 3;	/* PAL mode */
-            else if (capturewidth == 1280 && captureheight == 720)
-                capturemode = 4;	/* 720P mode */
-            else if (capturewidth == 1920 && captureheight == 1080){
-                pic_waite_buf_num = 5;
-                capturemode = 5;	/* 1080P mode */
-            }
-            else if (capturewidth == 2592 && captureheight == 1944) {
-                pic_waite_buf_num = 5;
-                capturemode = 6;	/* 2592x1944 mode */
-            }
-            else{
-                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
-            pic_waite_buf_num = 10;
-            if (capturewidth == 320 && captureheight == 240)
-                capturemode = 1;	/* QVGA mode */
-            else if (capturewidth == 640 && captureheight == 480)
-                capturemode = 0;	/* VGA mode */
-            else if (capturewidth == 720 && captureheight == 480)
-                capturemode = 4;
-            else if (capturewidth == 720 && captureheight == 576)
-                capturemode = 5;
-            else if (capturewidth == 2048 && captureheight == 1536)
-            {
-                pic_waite_buf_num = 10;
-                capturemode = 3;	/* QXGA mode */
-            }
-            else
-            {
-                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
-                return CAPTURE_DEVICE_ERR_BAD_PARAM;
-            }
-        }else{
-            capturemode = 0;
-            pic_waite_buf_num = 0;
-        }
-
-        CAMERA_HAL_LOG_INFO("the mode is %d", capturemode);
-        *pMode = capturemode;
-        pCapcfg->picture_waite_number = pic_waite_buf_num;
-
-        return CAPTURE_DEVICE_ERR_NONE;
-    }
-
-    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
-
-        CAMERA_HAL_LOG_FUNC;
-        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
-        if (mCameraDevice <= 0 || pCapcfg == NULL){
-            return CAPTURE_DEVICE_ERR_BAD_PARAM;
-        }
-
-        struct v4l2_control ctrl;
-
-        // Set rotation
-        ctrl.id = V4L2_CID_MXC_ROT;
-        if (pCapcfg->rotate == SENSOR_PREVIEW_BACK_REF)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_NONE;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_VERT_FLIP)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_VERT_FLIP;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_HORIZ_FLIP)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_HORIZ_FLIP;
-        else if (pCapcfg->rotate == SENSOR_PREVIEW_ROATE_180)
-            ctrl.value = V4L2_MXC_CAM_ROTATE_180;
-        else
-            ctrl.value = V4L2_MXC_ROTATE_NONE;
-
-        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
-            CAMERA_HAL_ERR("set ctrl failed\n");
-            return CAPTURE_DEVICE_ERR_SYS_CALL;
-        }
-
-        return ret;
-    }
-};
-
diff --git a/libcamera/V4l2CsiDevice.h b/libcamera/V4l2CsiDevice.h
deleted file mode 100755
index 5247eae..0000000
--- a/libcamera/V4l2CsiDevice.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#ifndef V4L2_CSI_DEVICE_H
-#define V4L2_CSI_DEVICE_H
-
-#include <linux/videodev2.h>
-#include "V4l2CapDeviceBase.h"
-#define ENUM_SUPPORTED_FMT     3
-
-#define OV3640_NAME_STR   "ov3640"
-#define OV5640_NAME_STR   "ov5640"
-#define OV5642_NAME_STR   "ov5642"
-namespace android{
-
-class V4l2CsiDevice : public V4l2CapDeviceBase{
-    public:
-        
-        V4l2CsiDevice();
-        virtual ~V4l2CsiDevice();
-    protected:
-		
-		CAPTURE_DEVICE_ERR_RET V4l2Open();
-		CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
-		CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
-		CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
-        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
-        CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
-
-		unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
-   };
-
-};
-#endif
-
-
diff --git a/libcamera/V4l2UVCDevice.h b/libcamera/V4l2UVCDevice.h
deleted file mode 100755
index f3af040..0000000
--- a/libcamera/V4l2UVCDevice.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-#ifndef V4L2_UVC_DEVICE_H
-#define V4L2_UVC_DEVICE_H
-
-#include <linux/videodev2.h>
-
-
-#include "V4l2CapDeviceBase.h"
-
-#define MAX_DEV_NAME_LENGTH 10
-
-namespace android{
-
-    class V4l2UVCDevice : public V4l2CapDeviceBase{
-    public:
-        V4l2UVCDevice(){}
-        ~V4l2UVCDevice(){}
-
-    };
-
-};
-#endif
-
diff --git a/mx6/hwcomposer/Android.mk b/mx6/hwcomposer/Android.mk
index c54650b..2c3d580 100755
--- a/mx6/hwcomposer/Android.mk
+++ b/mx6/hwcomposer/Android.mk
@@ -23,7 +23,7 @@ LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
 LOCAL_SHARED_LIBRARIES := liblog libEGL libipu libcutils libutils libui libhardware
 LOCAL_SRC_FILES := hwcomposer.cpp BG_device.cpp FG_device.cpp hwc_common.cpp blit_gpu.cpp blit_ipu.cpp output_device.cpp
 LOCAL_MODULE := hwcomposer.$(TARGET_BOARD_PLATFORM)
-LOCAL_C_INCLUDES += hardware/imx/mx6/libgralloc
+LOCAL_C_INCLUDES += hardware/imx/mx6/libgralloc_wrapper
 LOCAL_C_INCLUDES += external/linux-lib/ipu
 LOCAL_CFLAGS:= -DLOG_TAG=\"hwcomposer\"
 LOCAL_MODULE_TAGS := eng
diff --git a/mx6/libcamera/Android.mk b/mx6/libcamera/Android.mk
index 725eab5..7d09df1 100755
--- a/mx6/libcamera/Android.mk
+++ b/mx6/libcamera/Android.mk
@@ -20,7 +20,6 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES:=    \
 	CameraHal.cpp    \
 	CameraModule.cpp \
-    Camera_pmem.cpp  \
 	CaptureDeviceInterface.cpp \
 	V4l2CsiDevice.cpp \
 	V4l2CapDeviceBase.cpp  \
@@ -49,7 +48,7 @@ LOCAL_C_INCLUDES += \
 	frameworks/base/include/ui \
 	frameworks/base/camera/libcameraservice \
 	external/linux-lib/ipu \
-    hardware/imx/mx6/libgralloc
+	hardware/imx/mx6/libgralloc_wrapper
 
 ifeq ($(HAVE_FSL_IMX_CODEC),true)
     LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
diff --git a/mx6/libcamera/CameraHal.cpp b/mx6/libcamera/CameraHal.cpp
index fc9825b..4a3560a 100755
--- a/mx6/libcamera/CameraHal.cpp
+++ b/mx6/libcamera/CameraHal.cpp
@@ -1704,10 +1704,6 @@ Pic_out:
         CAMERA_HAL_LOG_FUNC;
 
         if(mPPDeviceNeed){
-            for (unsigned int i = 0; i < mPPbufNum; i++){
-                mPmemAllocator->deAllocate(&mPPbuf[i]);
-            }
-            mPmemAllocator = NULL;
         }
         mCaptureDevice->DevStop();
         //mCaptureDevice->DevDeAllocate();
@@ -1842,16 +1838,6 @@ Pic_out:
         }
         /*allocate the buffer for IPU process*/
         if (mPPDeviceNeed || mPPDeviceNeedForPic){
-            mPmemAllocator = new PmemAllocator(mPPbufNum, mCaptureFrameSize);
-
-            if(mPmemAllocator == NULL || mPmemAllocator->err_ret < 0){
-                return NO_MEMORY;
-            }
-            for (i = 0; i < mPPbufNum; i++){
-                if(mPmemAllocator->allocate(&(mPPbuf[i]),mCaptureFrameSize) < 0){
-                    return NO_MEMORY;
-                }
-            }
         }
         return ret;
     }
diff --git a/mx6/libcamera/CameraHal.h b/mx6/libcamera/CameraHal.h
index bddce07..9d3a226 100755
--- a/mx6/libcamera/CameraHal.h
+++ b/mx6/libcamera/CameraHal.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +15,6 @@
  * limitations under the License.
  */
 
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-
 #ifndef CAMERA_HAL_BASE_H
 #define CAMERA_HAL_BASE_H
 
@@ -40,7 +36,6 @@
 #include <hardware/camera.h>
 #include <semaphore.h>
 
-#include "Camera_pmem.h"
 #include "CaptureDeviceInterface.h"
 #include "PostProcessDeviceInterface.h"
 #include "JpegEncoderInterface.h"
@@ -372,7 +367,6 @@ namespace android {
         volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
 		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
 
-        sp<PmemAllocator>   mPmemAllocator;
         DMA_BUFFER          mPPbuf[POST_PROCESS_BUFFER_NUM];
         unsigned int        mPPbufNum;
         pp_input_param_t    mPPInputParam;
diff --git a/mx6/libcamera/Camera_pmem.cpp b/mx6/libcamera/Camera_pmem.cpp
deleted file mode 100755
index 865b352..0000000
--- a/mx6/libcamera/Camera_pmem.cpp
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <pthread.h>
-#include <semaphore.h>
-#include <linux/time.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <linux/android_pmem.h>
-#include "Camera_pmem.h"
-
-
-/*
- *   input parameter: 
- */
-
-using namespace android;
-
-PmemAllocator::PmemAllocator(int bufCount, int bufSize):
-    err_ret(0), mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
-    mVirBase(NULL),mPhyBase(NULL)
-{
-
-    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
-
-    int err;
-    struct pmem_region region;
-    mFD = open(PMEM_DEV, O_RDWR);
-    if (mFD < 0) {
-        CAMERA_HAL_ERR("Error!PmemAllocator constructor");
-        err_ret = -1;
-        return;
-    }
-
-    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
-    if (err == 0)
-    {
-        CAMERA_HAL_ERR("Info!get pmem total size %d",(int)region.len);
-    }
-    else
-    {
-        CAMERA_HAL_ERR("Error!Cannot get total length in PmemAllocator constructor");
-        err_ret = -1;
-        return;
-    }
-
-    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
-
-    mTotalSize = mBufSize*bufCount;
-    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
-        CAMERA_HAL_ERR("Error!Out of PmemAllocator capability");
-    }
-    else
-    {
-        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
-                PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
-
-        if (virtualbase == MAP_FAILED) {
-            CAMERA_HAL_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
-                    mFD, (unsigned int)mTotalSize, strerror(errno));
-            return;
-        }
-
-        memset(&region, 0, sizeof(region));
-
-        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
-        {
-            CAMERA_HAL_ERR("Error!Failed to get physical address of source!\n");
-            munmap(virtualbase, mTotalSize);
-            return;
-        }
-        mVirBase = (void *)virtualbase;
-        mPhyBase = region.offset;
-        CAMERA_HAL_LOG_RUNTIME("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
-    }
-}
-
-PmemAllocator::~PmemAllocator()
-{
-    CAMERA_HAL_LOG_FUNC;
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(mSlotAllocated[index]) {
-            CAMERA_HAL_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
-        }
-    }
-
-    if(mVirBase) {
-        munmap(mVirBase, mTotalSize);
-    }
-    if(mFD) {
-        close(mFD);
-    }
-
-}
-
-int PmemAllocator::allocate(DMA_BUFFER *pbuf, int size)
-{
-    CAMERA_HAL_LOG_FUNC;
-
-    if((!mVirBase)||(!pbuf)||(size>mBufSize)) {
-        CAMERA_HAL_ERR("Error!No memory for allocator");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-
-    for(int index=0;index < MAX_SLOT;index ++) {
-        if(!mSlotAllocated[index]) {
-            CAMERA_HAL_ERR("Free slot %d for allocating mBufSize %d request size %d",
-                    index,mBufSize,size);
-
-            pbuf->virt_start= (unsigned char *)mVirBase+index*mBufSize; 
-            pbuf->phy_offset= mPhyBase+index*mBufSize;
-            pbuf->length= mBufSize;
-            mSlotAllocated[index] = true;
-            return DMA_ALLOCATE_ERR_NONE;
-        }
-    }
-    return DMA_ALLOCATE_ERR_BAD_PARAM;
-}
-
-int PmemAllocator::deAllocate(DMA_BUFFER *pbuf)
-{
-    CAMERA_HAL_LOG_FUNC;
-    if((!mVirBase)||(!pbuf)) {
-        CAMERA_HAL_ERR("Error!No memory for allocator");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-    int nSlot = ((unsigned int)pbuf->virt_start- (unsigned int)mVirBase)/mBufSize;
-    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
-        CAMERA_HAL_ERR("Info!deAllocate for slot %d",nSlot);
-        mSlotAllocated[nSlot] = false;
-        return DMA_ALLOCATE_ERR_NONE;
-    }
-    else{
-        CAMERA_HAL_ERR("Error!Not a valid buffer");
-        return DMA_ALLOCATE_ERR_BAD_PARAM;
-    }
-}
diff --git a/mx6/libcamera/Camera_pmem.h b/mx6/libcamera/Camera_pmem.h
deleted file mode 100755
index 8b174a4..0000000
--- a/mx6/libcamera/Camera_pmem.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
- * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-#ifndef __CAMERA_MEM__H__
-#define __CAMERA_MEM__H__
-
-#include "Camera_utils.h"
-#include <utils/RefBase.h>
-
-
-#define DEFAULT_PMEM_ALIGN (4096)
-#define PMEM_DEV "/dev/pmem_adsp"
-#define MAX_SLOT 64
-
-namespace android {
-
-class PmemAllocator : public virtual RefBase
-{
-public:
-    PmemAllocator(int bufCount,int bufSize);
-    virtual ~PmemAllocator();
-    virtual int allocate(DMA_BUFFER *p_buf, int size);
-    virtual int deAllocate(DMA_BUFFER *p_buf);
-	int err_ret;
-private:
-    int mFD;
-    unsigned long mTotalSize;
-    int mBufCount;
-    int mBufSize;
-    void *mVirBase;
-    unsigned int mPhyBase;
-    bool mSlotAllocated[MAX_SLOT];
-	
-};
-};
-
-#endif
diff --git a/mx6/libgralloc/Android.mk b/mx6/libgralloc/Android.mk
deleted file mode 100755
index db02da1..0000000
--- a/mx6/libgralloc/Android.mk
+++ /dev/null
@@ -1,53 +0,0 @@
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-ifneq (,$(findstring imx,$(TARGET_BOARD_PLATFORM)))
-LOCAL_PATH := $(call my-dir)
-
-# HAL module implemenation, not prelinked and stored in
-# hw/<OVERLAY_HARDWARE_MODULE_ID>.<ro.product.board>.so
-include $(CLEAR_VARS)
-LOCAL_PRELINK_MODULE := false
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
-LOCAL_SHARED_LIBRARIES := liblog libcutils libGLESv1_CM libipu libhardware
-#ifeq ($(BOARD_SOC_TYPE),IMX50)
-#LOCAL_SHARED_LIBRARIES += libc2d_z160
-#else
-#LOCAL_SHARED_LIBRARIES += libc2d_z430
-#endif
-LOCAL_C_INCLUDES += external/linux-lib/ipu
-LOCAL_C_INCLUDES += hardware/imx/mx5x/libcopybit
-
-LOCAL_SRC_FILES := 	\
-	allocator.cpp 	\
-	gralloc.cpp 	\
-	framebuffer.cpp \
-	mapper.cpp
-	
-LOCAL_MODULE := gralloc.$(TARGET_BOARD_PLATFORM)
-LOCAL_CFLAGS:= -DLOG_TAG=\"$(TARGET_BOARD_PLATFORM).gralloc\" -D_LINUX
-
-
-#ifeq ($(HAVE_FSL_EPDC_FB),true)
-#LOCAL_CFLAGS += -DFSL_EPDC_FB
-#endif
-
-ifeq ($(HAVE_FSL_IMX_IPU),true)
-LOCAL_CFLAGS += -DFSL_IMX_DISPLAY
-endif
-
-LOCAL_MODULE_TAGS := eng
-
-include $(BUILD_SHARED_LIBRARY)
-endif
diff --git a/mx6/libgralloc/allocator.cpp b/mx6/libgralloc/allocator.cpp
deleted file mode 100755
index a05e82f..0000000
--- a/mx6/libgralloc/allocator.cpp
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <cutils/log.h>
-
-#include "allocator.h"
-
-
-// align all the memory blocks on a cache-line boundary
-const int SimpleBestFitAllocator::kMemoryAlign = 32;
-
-SimpleBestFitAllocator::SimpleBestFitAllocator()
-    : mHeapSize(0)
-{
-}
-
-SimpleBestFitAllocator::SimpleBestFitAllocator(size_t size)
-    : mHeapSize(0)
-{
-    setSize(size);
-}
-
-SimpleBestFitAllocator::~SimpleBestFitAllocator()
-{
-    while(!mList.isEmpty()) {
-        delete mList.remove(mList.head());
-    }
-}
-
-ssize_t SimpleBestFitAllocator::setSize(size_t size)
-{
-    Locker::Autolock _l(mLock);
-    if (mHeapSize != 0) return -EINVAL;
-    size_t pagesize = getpagesize();
-    mHeapSize = ((size + pagesize-1) & ~(pagesize-1));
-    chunk_t* node = new chunk_t(0, mHeapSize / kMemoryAlign);
-    mList.insertHead(node);
-    return size;
-}
-    
-    
-size_t SimpleBestFitAllocator::size() const
-{
-    return mHeapSize;
-}
-
-ssize_t SimpleBestFitAllocator::allocate(size_t size, uint32_t flags)
-{
-    Locker::Autolock _l(mLock);
-    if (mHeapSize == 0) return -EINVAL;
-    ssize_t offset = alloc(size, flags);
-    return offset;
-}
-
-ssize_t SimpleBestFitAllocator::deallocate(size_t offset)
-{
-    Locker::Autolock _l(mLock);
-    if (mHeapSize == 0) return -EINVAL;
-    chunk_t const * const freed = dealloc(offset);
-    if (freed) {
-        return 0;
-    }
-    return -ENOENT;
-}
-
-ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
-{
-    if (size == 0) {
-        return 0;
-    }
-    size = (size + kMemoryAlign-1) / kMemoryAlign;
-    chunk_t* free_chunk = 0;
-    chunk_t* cur = mList.head();
-
-    size_t pagesize = getpagesize();
-    while (cur) {
-        int extra = ( -cur->start & ((pagesize/kMemoryAlign)-1) ) ;
-
-        // best fit
-        if (cur->free && (cur->size >= (size+extra))) {
-            if ((!free_chunk) || (cur->size < free_chunk->size)) {
-                free_chunk = cur;
-            }
-            if (cur->size == size) {
-                break;
-            }
-        }
-        cur = cur->next;
-    }
-
-    if (free_chunk) {
-        const size_t free_size = free_chunk->size;
-        free_chunk->free = 0;
-        free_chunk->size = size;
-        if (free_size > size) {
-            int extra = ( -free_chunk->start & ((pagesize/kMemoryAlign)-1) ) ;
-            if (extra) {
-                chunk_t* split = new chunk_t(free_chunk->start, extra);
-                free_chunk->start += extra;
-                mList.insertBefore(free_chunk, split);
-            }
-
-            LOGE_IF(((free_chunk->start*kMemoryAlign)&(pagesize-1)),
-                    "page is not aligned!!!");
-
-            const ssize_t tail_free = free_size - (size+extra);
-            if (tail_free > 0) {
-                chunk_t* split = new chunk_t(
-                        free_chunk->start + free_chunk->size, tail_free);
-                mList.insertAfter(free_chunk, split);
-            }
-        }
-        return (free_chunk->start)*kMemoryAlign;
-    }
-    return -ENOMEM;
-}
-
-SimpleBestFitAllocator::chunk_t* SimpleBestFitAllocator::dealloc(size_t start)
-{
-    start = start / kMemoryAlign;
-    chunk_t* cur = mList.head();
-    while (cur) {
-        if (cur->start == start) {
-            LOG_FATAL_IF(cur->free,
-                "block at offset 0x%08lX of size 0x%08lX already freed",
-                cur->start*kMemoryAlign, cur->size*kMemoryAlign);
-
-            // merge freed blocks together
-            chunk_t* freed = cur;
-            cur->free = 1;
-            do {
-                chunk_t* const p = cur->prev;
-                chunk_t* const n = cur->next;
-                if (p && (p->free || !cur->size)) {
-                    freed = p;
-                    p->size += cur->size;
-                    mList.remove(cur);
-                    delete cur;
-                }
-                cur = n;
-            } while (cur && cur->free);
-
-            #ifndef NDEBUG
-                if (!freed->free) {
-                    dump_l("dealloc (!freed->free)");
-                }
-            #endif
-            LOG_FATAL_IF(!freed->free,
-                "freed block at offset 0x%08lX of size 0x%08lX is not free!",
-                freed->start * kMemoryAlign, freed->size * kMemoryAlign);
-
-            return freed;
-        }
-        cur = cur->next;
-    }
-    return 0;
-}
diff --git a/mx6/libgralloc/allocator.h b/mx6/libgralloc/allocator.h
deleted file mode 100755
index df08de2..0000000
--- a/mx6/libgralloc/allocator.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#ifndef GRALLOC_ALLOCATOR_H_
-#define GRALLOC_ALLOCATOR_H_
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "gr.h"
-
-// ----------------------------------------------------------------------------
-
-/*
- * A simple templatized doubly linked-list implementation
- */
-
-template <typename NODE>
-class LinkedList
-{
-    NODE*  mFirst;
-    NODE*  mLast;
-
-public:
-                LinkedList() : mFirst(0), mLast(0) { }
-    bool        isEmpty() const { return mFirst == 0; }
-    NODE const* head() const { return mFirst; }
-    NODE*       head() { return mFirst; }
-    NODE const* tail() const { return mLast; }
-    NODE*       tail() { return mLast; }
-
-    void insertAfter(NODE* node, NODE* newNode) {
-        newNode->prev = node;
-        newNode->next = node->next;
-        if (node->next == 0) mLast = newNode;
-        else                 node->next->prev = newNode;
-        node->next = newNode;
-    }
-
-    void insertBefore(NODE* node, NODE* newNode) {
-         newNode->prev = node->prev;
-         newNode->next = node;
-         if (node->prev == 0)   mFirst = newNode;
-         else                   node->prev->next = newNode;
-         node->prev = newNode;
-    }
-
-    void insertHead(NODE* newNode) {
-        if (mFirst == 0) {
-            mFirst = mLast = newNode;
-            newNode->prev = newNode->next = 0;
-        } else {
-            newNode->prev = 0;
-            newNode->next = mFirst;
-            mFirst->prev = newNode;
-            mFirst = newNode;
-        }
-    }
-    
-    void insertTail(NODE* newNode) {
-        if (mLast == 0) {
-            insertHead(newNode);
-        } else {
-            newNode->prev = mLast;
-            newNode->next = 0;
-            mLast->next = newNode;
-            mLast = newNode;
-        }
-    }
-
-    NODE* remove(NODE* node) {
-        if (node->prev == 0)    mFirst = node->next;
-        else                    node->prev->next = node->next;
-        if (node->next == 0)    mLast = node->prev;
-        else                    node->next->prev = node->prev;
-        return node;
-    }
-};
-
-class SimpleBestFitAllocator
-{
-public:
-
-    SimpleBestFitAllocator();
-    SimpleBestFitAllocator(size_t size);
-    ~SimpleBestFitAllocator();
-
-    ssize_t     setSize(size_t size);
-
-    ssize_t     allocate(size_t size, uint32_t flags = 0);
-    ssize_t     deallocate(size_t offset);
-    size_t      size() const;
-
-private:
-    struct chunk_t {
-        chunk_t(size_t start, size_t size) 
-            : start(start), size(size), free(1), prev(0), next(0) {
-        }
-        size_t              start;
-        size_t              size : 28;
-        int                 free : 4;
-        mutable chunk_t*    prev;
-        mutable chunk_t*    next;
-    };
-
-    ssize_t  alloc(size_t size, uint32_t flags);
-    chunk_t* dealloc(size_t start);
-
-    static const int    kMemoryAlign;
-    mutable Locker      mLock;
-    LinkedList<chunk_t> mList;
-    size_t              mHeapSize;
-};
-
-#endif /* GRALLOC_ALLOCATOR_H_ */
diff --git a/mx6/libgralloc/framebuffer.cpp b/mx6/libgralloc/framebuffer.cpp
deleted file mode 100755
index 24c5461..0000000
--- a/mx6/libgralloc/framebuffer.cpp
+++ /dev/null
@@ -1,1532 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2010-2011 Freescale Semiconductor Inc. */
-
-#include <sys/mman.h>
-
-#include <dlfcn.h>
-
-#include <cutils/ashmem.h>
-#include <cutils/log.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/ioctl.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-#include <cutils/properties.h>
-
-#if HAVE_ANDROID_OS
-#include <linux/fb.h>
-#include <linux/mxcfb.h>
-#include <linux/videodev.h>
-#include <sys/mman.h>
-
-#include <linux/ipu.h>
-
-#endif
-#include <GLES/gl.h>
-#include <pthread.h>
-#include <semaphore.h>
-
-#include "gralloc_priv.h"
-#include "gr.h"
-#define  MAX_RECT_NUM   20
-/*****************************************************************************/
-
-// numbers of buffers for page flipping
-#define NUM_BUFFERS 3
-
-enum {
-    PAGE_FLIP = 0x00000001,
-    LOCKED = 0x00000002
-};
-
-struct fb_context_t {
-    framebuffer_device_t  device;
-#ifdef FSL_EPDC_FB
-    //Partial udate feature
-    bool rect_update;
-    int count;      //count need less than MAX_RECT_NUM ;
-    int updatemode[20];
-    int partial_left[20];
-    int partial_top[20];
-    int partial_width[20];
-    int partial_height[20];
-#endif
-#ifdef FSL_IMX_DISPLAY
-    bool sec_display_inited;
-    int sec_fp;
-    int sec_disp_w;
-    int sec_disp_h;
-    int sec_disp_base;
-    int sec_disp_phys;
-    int sec_frame_size;
-    int sec_disp_next_buf;
-    struct fb_var_screeninfo sec_info;
-    struct fb_fix_screeninfo sec_finfo;
-    struct framebuffer_device_t* dev;
-    buffer_handle_t buffer;
-    sem_t sec_display_begin;
-    sem_t sec_display_end;
-    pthread_t thread_id;
-  //  C2D_CONTEXT c2dctx;
-    int sec_rotation;
-    int cleancount;
-    int mRotate;
-    struct ipu_task mTask;
-    int mIpuFd;
-    bool first_frame;
-    int last_rotation;
-#endif
-};
-
-static int nr_framebuffers;
-static int no_ipu = 0;
-
-#ifdef FSL_IMX_DISPLAY
-#define MAX_SEC_DISP_WIDTH (1024)
-#define MAX_SEC_DISP_HEIGHT (1024)
-static int mapSecFrameBuffer(fb_context_t* ctx);
-static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx);
-static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx);
-void * secDispShowFrames(void * arg);
-#endif
-
-#ifdef FSL_EPDC_FB
-#define WAVEFORM_MODE_INIT                      0x0   // Screen goes to white (clears)
-#define WAVEFORM_MODE_DU                        0x1   // Grey->white/grey->black
-#define WAVEFORM_MODE_GC16                      0x2   // High fidelity (flashing)
-#define WAVEFORM_MODE_GC4                       0x3   //
-//#define WAVEFORM_MODE_AUTO                    257  // defined in mxcfb.h
-
-
-#define EINK_WAVEFORM_MODE_INIT      0x00000000
-#define EINK_WAVEFORM_MODE_DU        0x00000001
-#define EINK_WAVEFORM_MODE_GC16      0x00000002
-#define EINK_WAVEFORM_MODE_GC4       0x00000003
-#define EINK_WAVEFORM_MODE_AUTO      0x00000004
-#define EINK_WAVEFORM_MODE_MASK      0x0000000F
-#define EINK_AUTO_MODE_REGIONAL      0x00000000
-#define EINK_AUTO_MODE_AUTOMATIC     0x00000010
-#define EINK_AUTO_MODE_MASK          0x00000010
-#define EINK_UPDATE_MODE_PARTIAL     0x00000000
-#define EINK_UPDATE_MODE_FULL        0x00000020
-#define EINK_UPDATE_MODE_MASK        0x00000020
-#define EINK_WAIT_MODE_NOWAIT        0x00000000
-#define EINK_WAIT_MODE_WAIT          0x00000040
-#define EINK_WAIT_MODE_MASK          0x00000040
-#define EINK_COMBINE_MODE_NOCOMBINE  0x00000000
-#define EINK_COMBINE_MODE_COMBINE    0x00000080
-#define EINK_COMBINE_MODE_MASK       0x00000080
-#define EINK_DITHER_MODE_NODITHER    0x00000000
-#define EINK_DITHER_MODE_DITHER      0x00000100
-#define EINK_DITHER_MODE_MASK        0x00000100
-#define EINK_INVERT_MODE_NOINVERT    0x00000000
-#define EINK_INVERT_MODE_INVERT      0x00000200
-#define EINK_INVERT_MODE_MASK        0x00000200
-#define EINK_CONVERT_MODE_NOCONVERT  0x00000000
-#define EINK_CONVERT_MODE_CONVERT    0x00000400
-#define EINK_CONVERT_MODE_MASK       0x00000400
-
-#define EINK_DEFAULT_MODE            0x00000004
-
-__u32 marker_val = 1;
-static void update_to_display(int left, int top, int width, int height, int updatemode, int fb_dev)
-{
-	struct mxcfb_update_data upd_data;
-	int retval;
-	bool wait_for_complete;
-	int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
-	memset(&upd_data, 0, sizeof(mxcfb_update_data));
-
-    LOGI("update_to_display:left=%d, top=%d, width=%d, height=%d updatemode=%d\n", left, top, width, height,updatemode);
-
-
-    if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_DU)
-	   upd_data.waveform_mode = WAVEFORM_MODE_DU;
-	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC4)
-	   upd_data.waveform_mode = WAVEFORM_MODE_GC4;
-	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_GC16)
-	   upd_data.waveform_mode = WAVEFORM_MODE_GC16;
-	else if((updatemode & EINK_WAVEFORM_MODE_MASK) == EINK_WAVEFORM_MODE_AUTO)
-	   upd_data.waveform_mode = WAVEFORM_MODE_AUTO;
-	else 
-        LOGI("waveform_mode  wrong\n");
-	   
-    if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_REGIONAL)
-        auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
-    else if((updatemode & EINK_AUTO_MODE_MASK) == EINK_AUTO_MODE_AUTOMATIC)
-        auto_update_mode = AUTO_UPDATE_MODE_AUTOMATIC_MODE;
-    else 
-        LOGI("wait_for_complete  wrong\n");
-        
-    if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_PARTIAL)
-        upd_data.update_mode = UPDATE_MODE_PARTIAL;
-    else if((updatemode & EINK_UPDATE_MODE_MASK) == EINK_UPDATE_MODE_FULL)
-        upd_data.update_mode = UPDATE_MODE_FULL;
-    else
-        LOGI("update_mode  wrong\n");
-
-    if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_NOWAIT)
-        wait_for_complete = false;
-    else if((updatemode & EINK_WAIT_MODE_MASK) == EINK_WAIT_MODE_WAIT)
-        wait_for_complete = true;
-    else 
-        LOGI("wait_for_complete  wrong\n");
-
-    if((updatemode & EINK_INVERT_MODE_MASK) == EINK_INVERT_MODE_INVERT)
-	{
-	   upd_data.flags |= EPDC_FLAG_ENABLE_INVERSION;
-       LOGI("invert mode \n");
-    }
-
-	retval = ioctl(fb_dev, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
-	if (retval < 0) {
-		LOGI("set auto update mode failed.  Error = 0x%x", retval);
-	}    
-    
-    upd_data.temp = 24; //the temperature is get from linux team
-	upd_data.update_region.left = left;
-	upd_data.update_region.width = width;
-	upd_data.update_region.top = top;
-	upd_data.update_region.height = height;
-
-	if (wait_for_complete) {
-		/* Get unique marker value */
-		upd_data.update_marker = marker_val++;
-	} else {
-		upd_data.update_marker = 0;
-	}
-
-	retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
-	while (retval < 0) {
-		/* We have limited memory available for updates, so wait and
-		 * then try again after some updates have completed */
-		usleep(300000);
-		retval = ioctl(fb_dev, MXCFB_SEND_UPDATE, &upd_data);
-        LOGI("MXCFB_SEND_UPDATE  retval = 0x%x try again maybe", retval);
-	}
-
-	if (wait_for_complete) {
-		/* Wait for update to complete */
-		retval = ioctl(fb_dev, MXCFB_WAIT_FOR_UPDATE_COMPLETE, &upd_data.update_marker);
-		if (retval < 0) {
-			LOGI("Wait for update complete failed.  Error = 0x%x", retval);
-		}
-	}
-
-
-}
-#endif
-
-
-sem_t * fslwatermark_sem_open()
-{
-    int fd;
-    int ret;
-    sem_t *pSem = NULL;
-    char *shm_path, shm_file[256];
-
-    shm_path = getenv("CODEC_SHM_PATH");      /*the CODEC_SHM_PATH is on a memory map the fs */ 
-
-    if (shm_path == NULL)
-        strcpy(shm_file, "/dev/shm");   /* default path */
-    else
-        strcpy(shm_file, shm_path);
-
-    strcat(shm_file, "/"); 
-    strcat(shm_file, "codec.shm");
-
-    fd = open(shm_file, O_RDWR, 0666);
-    if (fd < 0) { 
-        /* first thread/process need codec protection come here */
-        fd = open(shm_file, O_RDWR | O_CREAT | O_EXCL, 0666);
-       if(fd < 0)
-       {
-           return NULL;
-       }
-       ftruncate(fd, sizeof(sem_t));
-
-       /* map the semaphore variant in the file */ 
-       pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-       if((void *)(-1) == pSem)
-       {
-           return NULL;
-       }
-       /* do the semaphore initialization */
-       ret = sem_init(pSem, 0, 1);
-       if(-1 == ret)
-       {
-           return NULL;
-       }
-    }
-    else
-      pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-
-    close(fd);
-
-    return pSem;
-}
-
-
-/*****************************************************************************/
-
-static int fb_setSwapInterval(struct framebuffer_device_t* dev,
-            int interval)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if (interval < dev->minSwapInterval || interval > dev->maxSwapInterval)
-        return -EINVAL;
-    // FIXME: implement fb_setSwapInterval
-    return 0;
-}
-
-#ifdef FSL_EPDC_FB
-static int fb_setUpdateRect(struct framebuffer_device_t* dev,
-        int* left, int* top, int* width, int* height, int* updatemode, int count)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if(count > MAX_RECT_NUM)
-    {
-        LOGE("count > MAX_RECT_NUM in fb_setUpdateRect\n");
-        return -EINVAL;
-    }
-
-    ctx->rect_update      = true;
-    ctx->count            = 0;
-    for(int i=0; i < count; i++)
-    {
-        if (((width[i]|height[i]) <= 0) || ((left[i]|top[i])<0))  return -EINVAL;
-        ctx->updatemode[i]       = updatemode[i];
-        ctx->partial_left[i]     = left[i];
-        ctx->partial_top[i]      = top[i];
-        ctx->partial_width[i]    = width[i];
-        ctx->partial_height[i]   = height[i];
-    }
-    ctx->count            = count;
-    return 0;
-}
-#else
-static int fb_setUpdateRect(struct framebuffer_device_t* dev,
-        int l, int t, int w, int h)
-{
-    if (((w|h) <= 0) || ((l|t)<0))
-        return -EINVAL;
-    return 0;
-}
-
-#ifdef FSL_IMX_DISPLAY
-static int fb_setSecRotation(struct framebuffer_device_t* dev,int secRotation)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    //LOGI("fb_setSecRotation %d",secRotation);
-    if((ctx->sec_rotation != secRotation)&&(ctx->sec_disp_base != 0))      
-       memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
-    ctx->sec_rotation = secRotation;
-    switch(secRotation)
-    {
-    case 4:
-       ctx->mRotate = 90;
-       break;
-    case 3:
-       ctx->mRotate = 180;
-       break;
-    case 7:
-       ctx->mRotate = 270;
-       break;
-    case 0:
-    default:
-       ctx->mRotate = 0;
-       break;
-    }
-    return 0;
-}
-#endif
-#endif
-
-
-
-static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
-{
-    if (!buffer)
-        return -EINVAL;
-
-    fb_context_t* ctx = (fb_context_t*)dev;
-
-    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(buffer);
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-    if (m->currentBuffer) {
-        m->base.unlock(&m->base, m->currentBuffer);
-        m->currentBuffer = 0;
-    }
-
-    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-
-        void *vaddr = NULL;
-        m->base.lock(&m->base, buffer, 
-                private_module_t::PRIV_USAGE_LOCKED_FOR_POST, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres), &vaddr);
-
-        const size_t offset = hnd->base - m->framebuffer->base;
-        m->info.activate = FB_ACTIVATE_VBL;
-        m->info.yoffset = offset / m->finfo.line_length;
-
-        #ifdef FSL_IMX_DISPLAY
-        //Check the prop rw.SECOND_DISPLAY_CONNECTED
-        char value[PROPERTY_VALUE_MAX];
-     
-        property_get("rw.SECOND_DISPLAY_CONNECTED", value, "");
-        if (strcmp(value, "1") == 0) {
-            if(!ctx->sec_display_inited) {
-                //Init the second display
-                if(mapSecFrameBuffer(ctx)== 0)
-                {    
-                    ctx->first_frame = true;
-                    ctx->sec_display_inited = true;
-               //     c2dCreateContext(&ctx->c2dctx);
-                    ctx->mIpuFd = open("/dev/mxc_ipu", O_RDWR, 0);
-                    if(ctx->mIpuFd < 0) {
-                        LOGE("%s:%d,open ipu dev failed", __FUNCTION__, __LINE__);
-                    }
-
-                    sem_init(&ctx->sec_display_begin, 0, 0);
-                    sem_init(&ctx->sec_display_end, 0, 0);
-                     
-                    pthread_create(&ctx->thread_id, NULL, &secDispShowFrames, (void *)ctx);
-                                        
-                    //Set the prop rw.SECOND_DISPLAY_ENABLED to 1
-                    LOGI("sys.SECOND_DISPLAY_ENABLED Set to 1");
-                    property_set("sys.SECOND_DISPLAY_ENABLED", "1");
-                }
-            }
-
-            if(ctx->sec_display_inited) {
-                //Resize the primary display to the second display
-                ctx->dev = dev;
-                ctx->buffer = buffer;
-                sem_post(&ctx->sec_display_begin);
-            }
-        }
-        else{
-            if(ctx->sec_display_inited) {
-                
-                ctx->sec_display_inited = false;
-                
-                sem_post(&ctx->sec_display_begin);
-                sem_wait(&ctx->sec_display_end);
-                
-                sem_destroy(&ctx->sec_display_begin);
-                sem_destroy(&ctx->sec_display_end);
-                
-            //    if (ctx->c2dctx != NULL)c2dDestroyContext(ctx->c2dctx);
-                if(ctx->mIpuFd >= 0)close(ctx->mIpuFd);
-                
-                //Set the prop rw.SECOND_DISPLAY_ENABLED to 0
-                LOGI("Switch back to display 0");
-                LOGI("sys.SECOND_DISPLAY_ENABLED Set to 0");
-                property_set("sys.SECOND_DISPLAY_ENABLED", "0");
-                memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
-                //unmap the sec_disp_base
-                munmap((void *)ctx->sec_disp_base, ctx->sec_frame_size*nr_framebuffers);
-                ctx->sec_disp_base = 0;
-                //DeInit the second display
-                if(ctx->sec_fp) {
-                    close(ctx->sec_fp);
-                    ctx->sec_fp = 0;
-                }
-            }
-        }
-
-        #endif
-
-        if (ioctl(m->framebuffer->fd, FBIOPAN_DISPLAY, &m->info) == -1) {
-            LOGE("FBIOPAN_DISPLAY failed");
-            m->base.unlock(&m->base, buffer); 
-            return -errno;
-        }
-
-    #ifdef FSL_IMX_DISPLAY
-        if(ctx->sec_display_inited) sem_wait(&ctx->sec_display_end);
-    #endif
-
-#ifdef FSL_EPDC_FB
-        if(ctx->rect_update) {
-            for(int i=0; i < ctx->count; i++)
-            {
-                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
-                              ctx->partial_width[i],ctx->partial_height[i],
-                              ctx->updatemode[i],m->framebuffer->fd);
-            }
-
-            ctx->rect_update = false;
-        }
-        else{
-            update_to_display(0,0,m->info.xres,m->info.yres,EINK_DEFAULT_MODE,m->framebuffer->fd);
-        }
-#endif
-
-        m->currentBuffer = buffer;
-        
-    } else {
-        // If we can't do the page_flip, just copy the buffer to the front 
-        // FIXME: use copybit HAL instead of memcpy
-        
-        void* fb_vaddr;
-        void* buffer_vaddr;
-        
-        m->base.lock(&m->base, m->framebuffer, 
-                GRALLOC_USAGE_SW_WRITE_RARELY, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
-                &fb_vaddr);
-
-        m->base.lock(&m->base, buffer, 
-                GRALLOC_USAGE_SW_READ_RARELY, 
-                0, 0, ALIGN_PIXEL(m->info.xres), ALIGN_PIXEL_128(m->info.yres),
-                &buffer_vaddr);
-
-        memcpy(fb_vaddr, buffer_vaddr, m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres));
-
-#ifdef FSL_EPDC_FB
-        if(ctx->rect_update) {
-            for(int i=0; i < ctx->count; i++)
-            {
-                update_to_display(ctx->partial_left[i],ctx->partial_top[i],
-                              ctx->partial_width[i],ctx->partial_height[i],
-                              ctx->updatemode[i],m->framebuffer->fd);
-            }
-
-            ctx->rect_update = false;
-        }
-        else{
-            update_to_display(0,0,m->info.xres,m->info.yres, EINK_DEFAULT_MODE ,m->framebuffer->fd);
-        }
-#endif
-
-        m->base.unlock(&m->base, buffer); 
-        m->base.unlock(&m->base, m->framebuffer); 
-    }
-    
-    return 0;
-}
-
-static int fb_compositionComplete(struct framebuffer_device_t* dev)
-{
-   // glFinish();
-    return 0;
-}
-
-/*****************************************************************************/
-#define SINGLE_DISPLAY_CAPABILITY  (1920 * 1080 * 60)
-#define DUAL_DISPLAY_CAPABILITY    (1920 * 1080 * 30)
-
-typedef struct
-{
-	char* start;
-	char* end;
-	int width;
-	int height;
-	int freq;
-}
-disp_mode;
-
-static int str2int(char *p)
-{
-	int val = 0;
-	if(!p) return -1;
-
-	while(p[0] >= '0' && p[0] <= '9')
-	{
-		val = val * 10 + p[0] - '0';
-		p++;
-	}
-
-	return val;
-}
-
-typedef enum {
-    CHECK_NEXT_STATE,
-    FIND_WIDTH_STATE,
-    FIND_JOINT_STATE,
-    FIND_HEIGHT_STATE,
-    PREFIX_FREQ_STATE,
-    FREQUENCY_STATE,
-    FIND_NEWLINE_STATE
-}
-read_state;
-
-static disp_mode disp_mode_list[128];
-static int disp_mode_compare( const void *arg1, const void *arg2)
-{
-	disp_mode *dm1 = (disp_mode *)arg1;
-	disp_mode *dm2 = (disp_mode *)arg2;
-
-	if(dm1->width * dm1->height > dm2->width * dm2->height) return -1;
-	if(dm1->width * dm1->height == dm2->width * dm2->height)
-	{
-		return dm1->freq > dm2->freq ? -1 : 1;
-	}
-
-	return 1;
-}
-static char* find_available_mode(const char *mode_list, int dual_disp)
-{
-	int disp_threshold = 0;
-	int i,disp_mode_count = 0;
-	read_state state = CHECK_NEXT_STATE;
-	char *p = (char *)mode_list;
-
-    if(!p) return NULL;
-
-	while(p[0])
-	{
-		switch(state)
-		{
-		case CHECK_NEXT_STATE:
-			if(!strncmp(p, "D:", 2)
-				|| !strncmp(p, "S:", 2)
-				|| !strncmp(p, "U:", 2)
-				|| !strncmp(p, "V:", 2))
-			{
-				disp_mode_list[disp_mode_count].start = p;
-				state = FIND_WIDTH_STATE;
-				p+=2;
-			}
-			else p++;
-			break;
-		case FIND_WIDTH_STATE:
-			if(p[0]>='0' && p[0]<='9')
-			{
-				disp_mode_list[disp_mode_count].width = str2int(p);
-				state = FIND_JOINT_STATE;
-			}
-			p++;
-			break;
-		case FIND_JOINT_STATE:
-			if(p[0] == 'x' || p[0] == 'X')
-			{
-				state = FIND_HEIGHT_STATE;
-			}
-			p++;
-			break;
-		case FIND_HEIGHT_STATE:
-			if(p[0]>='0' && p[0]<='9')
-			{
-				disp_mode_list[disp_mode_count].height = str2int(p);
-				state = PREFIX_FREQ_STATE;
-			}
-			p++;
-			break;
-		case PREFIX_FREQ_STATE:
-			if(!strncmp(p, "p-", 2) || !strncmp(p, "i-", 2))
-			{
-				state = FREQUENCY_STATE;
-				p+=2;
-			}
-			else p++;
-			break;
-		case  FREQUENCY_STATE:
-			if(p[0]>='0' && p[0]<='9')
-			{
-				disp_mode_list[disp_mode_count].freq = str2int(p);
-				state = FIND_NEWLINE_STATE;
-			}
-			p++;
-			break;
-		case FIND_NEWLINE_STATE:
-			if(p[0] == '\n')
-			{
-				disp_mode_list[disp_mode_count++].end = p+1;
-				state = CHECK_NEXT_STATE;
-                if(disp_mode_count >= sizeof(disp_mode_list)/sizeof(disp_mode_list[0])) goto check_mode_end;
-			}
-			p++;
-			break;
-		default:
-			p++;
-			break;
-		}
-	}
-
-check_mode_end:
-
-	qsort(&disp_mode_list[0], disp_mode_count, sizeof(disp_mode), disp_mode_compare);
-
-	disp_threshold = dual_disp ? DUAL_DISPLAY_CAPABILITY : SINGLE_DISPLAY_CAPABILITY;
-
-	for(i=0; i<disp_mode_count; i++)
-	{
-		if(disp_mode_list[i].width * disp_mode_list[i].height * disp_mode_list[i].freq <= disp_threshold)
-			break;
-	}
-
-	if(disp_mode_list[i].end) disp_mode_list[i].end[0] = 0;
-
-    return disp_mode_list[i].start;
-}
-
-static int set_graphics_fb_mode(int fb, int dual_disp)
-{
-    int size=0;
-    int fp_cmd=0;
-    int fp_mode=0;
-    int fp_modes=0;
-    char fb_mode[256];
-    char fb_modes[1024];
-    char cmd_line[1024];
-    char temp_name[256];
-    char *disp_mode=NULL;
-
-    char value[PROPERTY_VALUE_MAX];
-    property_get("ro.AUTO_CONFIG_DISPLAY", value, "0");
-    if (strcmp(value, "1") != 0)  return 0;
-
-    fp_cmd = open("/proc/cmdline",O_RDONLY, 0);
-    if(fp_cmd < 0) {
-        LOGI("Error %d! Cannot open /proc/cmdline", fp_cmd);
-        goto set_graphics_fb_mode_error;
-    }
-
-    memset(cmd_line, 0, sizeof(cmd_line));
-    size = read(fp_cmd, cmd_line, sizeof(cmd_line));
-    if(size <= 0)
-    {
-        LOGI("Error! Cannot read /proc/cmdline");
-        goto set_graphics_fb_mode_error;
-    }
-
-    close(fp_cmd); fp_cmd = 0;
-
-    if(fb==0 && strstr(cmd_line, "di1_primary")) return 0;//XGA detected
-
-    sprintf(temp_name, "/sys/class/graphics/fb%d/modes", fb);
-    fp_modes = open(temp_name,O_RDONLY, 0);
-    if(fp_modes < 0) {
-        LOGI("Error %d! Cannot open %s", fp_modes, temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    memset(fb_modes, 0, sizeof(fb_modes));
-    size = read(fp_modes, fb_modes, sizeof(fb_modes));
-    if(size <= 0)
-    {
-        LOGI("Error! Cannot read %s", temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    close(fp_modes); fp_modes = 0;
-
-    if(size == sizeof(fb_modes)) fb_modes[size -1] = 0;
-
-    disp_mode = find_available_mode(fb_modes, dual_disp);
-    if(!disp_mode)
-    {
-        LOGI("Error! Cannot find available mode for fb%d", fb);
-        goto set_graphics_fb_mode_error;
-    }
-
-    LOGI("find fb%d available mode %s", fb,disp_mode);
-
-    sprintf(temp_name, "/sys/class/graphics/fb%d/mode", fb);
-    fp_mode = open(temp_name,O_RDWR, 0);
-    if(fp_mode < 0) {
-        LOGI("Error %d! Cannot open %s", fp_mode, temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    memset(fb_mode, 0, sizeof(fb_mode));
-    size = read(fp_mode, fb_mode, sizeof(fb_mode));
-    if(size < 0)
-    {
-        LOGI("Error! Cannot read %s", temp_name);
-        goto set_graphics_fb_mode_error;
-    }
-
-    if(strncmp(fb_mode, disp_mode, strlen(disp_mode)+1))
-    {
-        size = write(fp_mode, disp_mode, strlen(disp_mode)+1);
-        if(size <= 0)
-        {
-           LOGI("Error! Cannot write %s", temp_name);
-        }
-    }
-    close(fp_mode); fp_mode = 0;
-
-    return 0;
-
-set_graphics_fb_mode_error:
-
-    if(fp_modes > 0) close(fp_modes);
-    if(fp_mode > 0) close(fp_mode);
-    if(fp_cmd > 0) close(fp_cmd);
-
-    return -1;
-
-}
-
-int mapFrameBufferLocked(struct private_module_t* module)
-{
-    // already initialized...
-    if (module->framebuffer) {
-        return 0;
-    }
-        
-    char const * const device_template[] = {
-            "/dev/graphics/fb%u",
-            "/dev/fb%u",
-            0 };
-
-    int fd = -1;
-    int i=0;
-    char name[64];
-
-    char value[PROPERTY_VALUE_MAX];
-    property_get("ro.UI_TVOUT_DISPLAY", value, "");
-    if (strcmp(value, "1") != 0) {
-        set_graphics_fb_mode(0, 0);
-        while ((fd==-1) && device_template[i]) {
-            snprintf(name, 64, device_template[i], 0);
-            fd = open(name, O_RDWR, 0);
-            i++;
-        }
-    }
-    else{
-        set_graphics_fb_mode(1, 0);
-        while ((fd==-1) && device_template[i]) {
-            snprintf(name, 64, device_template[i], 1);
-            fd = open(name, O_RDWR, 0);
-            i++;
-        }
-    }
-
-    if (fd < 0)
-        return -errno;
-
-    struct fb_fix_screeninfo finfo;
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    struct fb_var_screeninfo info;
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-
-
-    info.reserved[0] = 0;
-    info.reserved[1] = 0;
-    info.reserved[2] = 0;
-    info.xoffset = 0;
-    info.yoffset = 0;
-    info.activate = FB_ACTIVATE_NOW;
-
-    if(info.bits_per_pixel == 32){
-        LOGW("32bpp setting of Framebuffer catched!");
-        /*
-         * Explicitly request BGRA 8/8/8
-         */
-        info.bits_per_pixel = 32;
-        info.red.offset     = 8;
-        info.red.length     = 8;
-        info.green.offset   = 16;
-        info.green.length   = 8;
-        info.blue.offset    = 24;
-        info.blue.length    = 8;
-        info.transp.offset  = 0;
-        info.transp.length  = 0;
-#ifndef FSL_EPDC_FB
-        /*
-         *  set the alpha in pixel
-         *  only when the fb set to 32bit
-         */
-        struct mxcfb_loc_alpha l_alpha;
-        l_alpha.enable = true;
-        l_alpha.alpha_in_pixel = true;
-        if (ioctl(fd, MXCFB_SET_LOC_ALPHA,
-                    &l_alpha) < 0) {
-            printf("Set local alpha failed\n");
-            close(fd);
-            return -errno;
-        }
-#endif
-    }
-    else{
-        /*
-         * Explicitly request 5/6/5
-         */
-        info.bits_per_pixel = 16;
-        info.red.offset     = 11;
-        info.red.length     = 5;
-        info.green.offset   = 5;
-        info.green.length   = 6;
-        info.blue.offset    = 0;
-        info.blue.length    = 5;
-        info.transp.offset  = 0;
-        info.transp.length  = 0;
-
-        if (!no_ipu) {
-            /* for the 16bit case, only involke the glb alpha */
-            struct mxcfb_gbl_alpha gbl_alpha;
-
-            gbl_alpha.alpha = 255;
-            gbl_alpha.enable = 1;
-            int ret = ioctl(fd, MXCFB_SET_GBL_ALPHA, &gbl_alpha);
-            if(ret <0) {
-	        LOGE("Error!MXCFB_SET_GBL_ALPHA failed!");
-	        return -1;
-            }
-
-            struct mxcfb_color_key key;
-            key.enable = 1;
-            key.color_key = 0x00000000; // Black
-            ret = ioctl(fd, MXCFB_SET_CLR_KEY, &key);
-            if(ret <0) {
-	        LOGE("Error!Colorkey setting failed for dev ");
-	        return -1;
-            }
-        }
-    }
-
-    /*
-     * Request nr_framebuffers screens (at lest 2 for page flipping)
-     */
-    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
-    info.xres_virtual = ALIGN_PIXEL(info.xres);
-    
-#ifdef FSL_EPDC_FB
-    info.bits_per_pixel = 16;
-    info.grayscale = 0;
-    info.yoffset = 0;
-#endif
-
-    uint32_t flags = PAGE_FLIP;
-    if (ioctl(fd, FBIOPUT_VSCREENINFO, &info) == -1) {
-        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
-        flags &= ~PAGE_FLIP;
-        LOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported");
-    }
-
-    if (info.yres_virtual < ALIGN_PIXEL_128(info.yres) * 2) {
-        // we need at least 2 for page-flipping
-        info.yres_virtual = ALIGN_PIXEL_128(info.yres);
-        flags &= ~PAGE_FLIP;
-        LOGW("page flipping not supported (yres_virtual=%d, requested=%d)",
-                info.yres_virtual, ALIGN_PIXEL_128(info.yres)*2);
-    }
-
-    if (ioctl(fd, FBIOGET_VSCREENINFO, &info) == -1)
-        return -errno;
-
-#ifdef FSL_EPDC_FB
-    int auto_update_mode = AUTO_UPDATE_MODE_REGION_MODE;
-    int retval = ioctl(fd, MXCFB_SET_AUTO_UPDATE_MODE, &auto_update_mode);
-    if (retval < 0) {
-	LOGE("Error! set auto update mode error!\n");
-	return -errno;
-    }
-
-    int scheme_mode = UPDATE_SCHEME_QUEUE_AND_MERGE;
-    retval = ioctl(fd, MXCFB_SET_UPDATE_SCHEME, &scheme_mode);
-    if (retval < 0) {
-	LOGE("Error! set update scheme error!\n");
-	return -errno;
-    }
-#endif
-    int refreshRate = 1000000000000000LLU /
-    (
-            uint64_t(info.upper_margin + info.lower_margin + info.yres + info.vsync_len)
-            * (info.left_margin  + info.right_margin + info.xres + info.hsync_len)
-            * info.pixclock
-    );
-
-    if (refreshRate == 0) {
-        // bleagh, bad info from the driver
-        refreshRate = 60*1000;  // 60 Hz
-    }
-
-    if (int(info.width) <= 0 || int(info.height) <= 0) {
-        // the driver doesn't return that information
-        // default to 160 dpi
-        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f);
-        info.height = ((info.yres * 25.4f)/160.0f + 0.5f);
-    }
-
-    float xdpi = (info.xres * 25.4f) / info.width;
-    float ydpi = (info.yres * 25.4f) / info.height;
-    float fps  = refreshRate / 1000.0f;
-
-    LOGI(   "using (fd=%d)\n"
-            "id           = %s\n"
-            "xres         = %d px\n"
-            "yres         = %d px\n"
-            "xres_virtual = %d px\n"
-            "yres_virtual = %d px\n"
-            "bpp          = %d\n"
-            "r            = %2u:%u\n"
-            "g            = %2u:%u\n"
-            "b            = %2u:%u\n",
-            fd,
-            finfo.id,
-            info.xres,
-            info.yres,
-            info.xres_virtual,
-            info.yres_virtual,
-            info.bits_per_pixel,
-            info.red.offset, info.red.length,
-            info.green.offset, info.green.length,
-            info.blue.offset, info.blue.length
-    );
-
-    LOGI(   "width        = %d mm (%f dpi)\n"
-            "height       = %d mm (%f dpi)\n"
-            "refresh rate = %.2f Hz\n",
-            info.width,  xdpi,
-            info.height, ydpi,
-            fps
-    );
-
-
-    if (ioctl(fd, FBIOGET_FSCREENINFO, &finfo) == -1)
-        return -errno;
-
-    if (finfo.smem_len <= 0)
-        return -errno;
-
-
-    module->flags = flags;
-    module->info = info;
-    module->finfo = finfo;
-    module->xdpi = xdpi;
-    module->ydpi = ydpi;
-    module->fps = fps;
-
-    /*
-     * map the framebuffer
-     */
-
-    int err;
-    size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-    module->framebuffer = new private_handle_t(dup(fd), fbSize,
-            private_handle_t::PRIV_FLAGS_USES_PMEM);
-
-    module->numBuffers = info.yres_virtual / ALIGN_PIXEL_128(info.yres);
-    module->bufferMask = 0;
-
-    void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
-    if (vaddr == MAP_FAILED) {
-        LOGE("Error mapping the framebuffer (%s)", strerror(errno));
-        return -errno;
-    }
-    module->framebuffer->base = intptr_t(vaddr);
-    module->framebuffer->phys = intptr_t(finfo.smem_start);
-    memset(vaddr, 0, fbSize);
-    return 0;
-}
-
-static int mapFrameBuffer(struct private_module_t* module)
-{
-    pthread_mutex_lock(&module->lock);
-    int err = mapFrameBufferLocked(module);
-    pthread_mutex_unlock(&module->lock);
-    return err;
-}
-
-#ifdef FSL_IMX_DISPLAY
-static int mapSecFrameBuffer(fb_context_t* ctx)
-{
-    int retCode = 0;
-    int sec_fp = 0,fp_property = 0;
-    size_t fbSize = 0;
-    int blank;
-    void* vaddr = NULL;
-    struct mxcfb_gbl_alpha gbl_alpha;
-    struct mxcfb_color_key key; 
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            ctx->device.common.module);
-
-    set_graphics_fb_mode(1,1);
-
-    sec_fp = open("/dev/graphics/fb2",O_RDWR, 0);
-    if (sec_fp < 0){
-        LOGE("Error!Cannot open the /dev/graphics/fb2 for second display");
-        goto disp_init_error;
-    }
-
-    struct fb_fix_screeninfo finfo;
-    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1)
-       goto disp_init_error;
-                
-    struct fb_var_screeninfo info;
-    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1)
-        goto disp_init_error;
-                
-    LOGI("Second display: xres %d,yres %d, xres_virtual %d, yres_virtual %d",
-         info.xres,info.xres_virtual,info.yres,info.yres_virtual);
-
-    info.reserved[0] = 0;
-    info.reserved[1] = 0;
-    info.reserved[2] = 0;
-    info.xoffset = 0;
-    info.yoffset = 0;
-    info.activate = FB_ACTIVATE_NOW;
-                
-    /*
-    * Explicitly request 5/6/5
-    */
-    info.bits_per_pixel = 16;
-    info.nonstd = 0;
-    info.red.offset     = 11;
-    info.red.length     = 5;
-    info.green.offset   = 5;
-    info.green.length   = 6;
-    info.blue.offset    = 0;
-    info.blue.length    = 5;
-    info.transp.offset  = 0;
-    info.transp.length  = 0;
-    info.yres_virtual = ALIGN_PIXEL_128(info.yres) * nr_framebuffers;
-    info.xres_virtual = ALIGN_PIXEL(info.xres);
-                        
-    if (ioctl(sec_fp, FBIOPUT_VSCREENINFO, &info) == -1) {
-        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
-        goto disp_init_error;
-    }
-                    
-    if (ioctl(sec_fp, FBIOGET_VSCREENINFO, &info) == -1){
-        LOGE("Error!Second display FBIOGET_VSCREENINFO");
-        goto disp_init_error;
-    }
-                    
-    if (ioctl(sec_fp, FBIOGET_FSCREENINFO, &finfo) == -1){
-        LOGE("Error!Second display FBIOGET_FSCREENINFO");
-        goto disp_init_error;
-    }
-                    
-    if(finfo.smem_len <= 0)
-        goto disp_init_error;
-
-    fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);  
-                   
-    vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, sec_fp, 0);
-    if (vaddr == MAP_FAILED) {
-        LOGE("Error!mapping the framebuffer (%s)", strerror(errno));
-        goto disp_init_error;
-    }
-
-    key.enable = 1;
-    key.color_key = 0x00000000; // Black
-    LOGI("MXCFB_SET_CLR_KEY");
-    if( ioctl(sec_fp, MXCFB_SET_CLR_KEY, &key) < 0)
-    {
-        LOGE("Error!MXCFB_SET_CLR_KEY");
-        goto disp_init_error;
-    }
-
-    gbl_alpha.alpha = 255;
-    gbl_alpha.enable = 1;
-    LOGI("MXCFB_SET_GBL_ALPHA");
-    if(ioctl(sec_fp, MXCFB_SET_GBL_ALPHA, &gbl_alpha) <0)
-    {
-        LOGI("Error!MXCFB_SET_GBL_ALPHA error");
-        goto disp_init_error;
-    }
-
-    ctx->sec_disp_base = intptr_t(vaddr);
-    ctx->sec_disp_phys = intptr_t(finfo.smem_start);
-    memset(vaddr, 0, fbSize);
-    ctx->sec_fp = sec_fp;
-    ctx->sec_disp_w = info.xres;
-    ctx->sec_disp_h = info.yres;
-    ctx->sec_frame_size = fbSize/nr_framebuffers;
-    ctx->sec_disp_next_buf = ((info.yoffset * nr_framebuffers / info.yres_virtual) + 1) % nr_framebuffers;
-    ctx->sec_info = info;
-    ctx->sec_finfo = finfo;
-    if (ioctl(m->framebuffer->fd, FBIOPUT_VSCREENINFO, &m->info) == -1) {
-        LOGE("Error!Second display FBIOPUT_VSCREENINFO");
-        goto disp_init_error;
-    }
-
-    return 0;
-
- disp_init_error:
-    if(sec_fp) {
-        close(sec_fp);
-        sec_fp = 0;
-        ctx->sec_fp = 0;
-    }
-    return -1;
-}
-
-static int resizeToSecFrameBuffer(int base,int phys,fb_context_t* ctx)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
-    int status = -EINVAL;
-    int ret = IPU_CHECK_ERR_INPUT_CROP;
-
-    if(ctx->mIpuFd < 0){
-        LOGE("%s:%d, invalid ipu device !!!!", __FUNCTION__, __LINE__);
-        return -EINVAL;
-    }
-
-    if (ctx->first_frame || ctx->sec_rotation != ctx->last_rotation) {
-       if(m->info.bits_per_pixel == 32){
-           ctx->mTask.input.format = v4l2_fourcc('B', 'G', 'R', '4');
-       }
-       else {
-           ctx->mTask.input.format = v4l2_fourcc('R', 'G', 'B', 'P');
-       }
-       ctx->mTask.input.width = ctx->device.width;
-       ctx->mTask.input.height = ctx->device.height;
-       ctx->mTask.input.crop.pos.x = 0;
-       ctx->mTask.input.crop.pos.y = 0;
-       ctx->mTask.input.crop.w = ctx->device.width;
-       ctx->mTask.input.crop.h = ctx->device.height;
-       ctx->mTask.input.paddr = phys;
-
-       ctx->mTask.output.format = v4l2_fourcc('R', 'G', 'B', 'P');
-       ctx->mTask.output.width = ctx->sec_disp_w;
-       ctx->mTask.output.height = ctx->sec_disp_h;
-       ctx->mTask.output.crop.w = ctx->sec_disp_w;
-       ctx->mTask.output.crop.h = ctx->sec_disp_h;
-
-       if((ctx->mRotate == 0)||(ctx->mRotate == 180))
-       {
-           if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.width/ctx->device.height){
-               ctx->mTask.output.crop.w = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
-           }
-           else{
-               ctx->mTask.output.crop.h = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
-           }
-       }
-       else{
-           if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.height/ctx->device.width){
-               ctx->mTask.output.crop.w = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
-           }
-           else{
-               ctx->mTask.output.crop.h = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
-           }
-       }
-
-       ctx->mTask.output.crop.pos.x = (ctx->sec_disp_w - ctx->mTask.output.crop.w)/2;
-       ctx->mTask.output.crop.pos.y = (ctx->sec_disp_h - ctx->mTask.output.crop.h)/2;
-
-       ctx->mTask.output.rotate = ctx->sec_rotation;
-       ctx->mTask.output.paddr = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-
-       while(ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN) {
-           ret = ioctl(ctx->mIpuFd, IPU_CHECK_TASK, &ctx->mTask);
-           switch(ret) {
-               case IPU_CHECK_OK:
-                   break;
-               case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
-                   ctx->mTask.input.crop.w -= 8;
-                   break;
-               case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
-                   ctx->mTask.input.crop.h -= 8;
-                   break;
-               case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
-                   ctx->mTask.output.crop.w -= 8;
-                   break;
-               case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
-                   ctx->mTask.output.crop.h -= 8;;
-                   break;
-               default:
-                   return status;
-           }
-       }
-       ctx->first_frame = false;
-       ctx->last_rotation = ctx->sec_rotation;
-    } else {
-       ctx->mTask.input.paddr = phys;
-       ctx->mTask.output.paddr = ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    }
-
-    status = ioctl(ctx->mIpuFd, IPU_QUEUE_TASK, &ctx->mTask);
-    if(status < 0) {
-        LOGE("%s:%d, IPU_QUEUE_TASK failed %d", __FUNCTION__, __LINE__ ,status);
-    }
-
-    return status;
-}
-
-#if 0
-/** convert HAL_PIXEL_FORMAT to C2D format */
-static C2D_COLORFORMAT get_format(int format) {
-    switch (format) {
-	case HAL_PIXEL_FORMAT_BGRA_8888:   return C2D_COLOR_8888;
-    case HAL_PIXEL_FORMAT_RGB_565:     return C2D_COLOR_0565;
-    default:                           return C2D_COLOR_0565;
-    }
-}
-
-/** get  pixelbit from HAL_PIXEL_FORMAT format */
-static int get_pixelbit(int format) {
-    switch (format) {
-    case HAL_PIXEL_FORMAT_BGRA_8888:   return 32;
-    case HAL_PIXEL_FORMAT_RGB_565:     return 16;
-    default:                           return 16;
-    }
-}
-
-static int resizeToSecFrameBuffer_c2d(int base,int phys,fb_context_t* ctx)
-{
-    C2D_SURFACE_DEF srcSurfaceDef;
-    C2D_SURFACE_DEF dstSurfaceDef;
-    C2D_SURFACE srcSurface;
-    C2D_SURFACE dstSurface; 
-    C2D_RECT dstRect;
-
-    if(!ctx || !ctx->c2dctx) return -1;
-
-    srcSurfaceDef.format = get_format(ctx->device.format);
-    srcSurfaceDef.width =  ctx->device.width;
-    srcSurfaceDef.height = ctx->device.height;
-
-	//make sure stride is 32 pixel aligned
-    srcSurfaceDef.stride = ((ctx->device.width + 31) & ~31)*get_pixelbit(ctx->device.format)>>3;
-
-    srcSurfaceDef.buffer = (void *)phys;
-    srcSurfaceDef.host = (void *)base;
-    srcSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
-
-    if (c2dSurfAlloc(ctx->c2dctx, &srcSurface, &srcSurfaceDef) != C2D_STATUS_OK)
-    {
-        LOGE("srcSurface c2dSurfAlloc fail");
-        return -EINVAL;
-    }
-
-    dstSurfaceDef.format = get_format(HAL_PIXEL_FORMAT_RGB_565);
-    dstSurfaceDef.width =  ctx->sec_disp_w;
-    dstSurfaceDef.height = ctx->sec_disp_h;
-
-    //make sure stride is 32 pixel aligned
-    dstSurfaceDef.stride = ((ctx->sec_disp_w + 31) & ~31)*get_pixelbit(HAL_PIXEL_FORMAT_RGB_565)>>3;
-
-    dstSurfaceDef.buffer = (void *)ctx->sec_disp_phys + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    dstSurfaceDef.host = (void *)ctx->sec_disp_base + ctx->sec_disp_next_buf*ctx->sec_frame_size;
-    dstSurfaceDef.flags = C2D_SURFACE_NO_BUFFER_ALLOC;
-
-    dstRect.x = dstRect.y = 0;
-    dstRect.width = dstSurfaceDef.width;
-    dstRect.height = dstSurfaceDef.height;
-                
-    if((ctx->mRotate == 0)||(ctx->mRotate == 180))
-    {
-        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.width/ctx->device.height){
-            dstRect.width = ctx->sec_disp_h*ctx->device.width/ctx->device.height;
-        }
-        else{
-            dstRect.height = ctx->sec_disp_w*ctx->device.height/ctx->device.width;
-        }
-    }
-    else{
-        if(ctx->sec_disp_w >= ctx->sec_disp_h*ctx->device.height/ctx->device.width){
-            dstRect.width = ctx->sec_disp_h*ctx->device.height/ctx->device.width;
-        }
-        else{
-            dstRect.height = ctx->sec_disp_w*ctx->device.width/ctx->device.height;
-        }
-    }
-
-    dstRect.x = (ctx->sec_disp_w - dstRect.width)/2;
-    dstRect.y = (ctx->sec_disp_h - dstRect.height)/2;
-            
-    if (c2dSurfAlloc(ctx->c2dctx, &dstSurface, &dstSurfaceDef) != C2D_STATUS_OK)
-    {
-        LOGE("dstSurface c2dSurfAlloc fail");
-        c2dSurfFree(ctx->c2dctx, srcSurface);
-        return -EINVAL;
-    }
-
-    c2dSetSrcSurface(ctx->c2dctx, srcSurface);
-    c2dSetDstSurface(ctx->c2dctx, dstSurface); 
-    c2dSetSrcRotate(ctx->c2dctx, ctx->mRotate);
-
-    c2dSetStretchMode(ctx->c2dctx, C2D_STRETCH_BILINEAR_SAMPLING);
-    c2dSetBlendMode(ctx->c2dctx, C2D_ALPHA_BLEND_NONE);         
-    c2dSetDither(ctx->c2dctx, 0); 
- 
-    c2dSetDstRectangle(ctx->c2dctx, &dstRect);
-    c2dDrawBlit(ctx->c2dctx); 
-        
-    c2dFinish(ctx->c2dctx);
-    c2dSurfFree(ctx->c2dctx, srcSurface);
-    c2dSurfFree(ctx->c2dctx, dstSurface);
-
-    return 0;
-}
-#endif
-void * secDispShowFrames(void * arg)
-{
-    private_module_t* m = NULL;
-    private_handle_t const* hnd = NULL;
-    fb_context_t* ctx = (fb_context_t*)arg;
-    
-    while(1)
-    {
-        sem_wait(&ctx->sec_display_begin);
-
-        if(!ctx->sec_display_inited)
-        {
-            sem_post(&ctx->sec_display_end);
-            break;
-        }
-
-        char value[PROPERTY_VALUE_MAX];
-        property_get("ro.secfb.disable-overlay", value, "0");
-        if (!strcmp(value, "1"))
-        {
-            property_get("media.VIDEO_PLAYING", value, "0");
-        }
-
-        if (strcmp(value, "1") == 0)
-        {
-            if(ctx->cleancount)
-            {
-                sem_post(&ctx->sec_display_end);
-                continue;
-            }
-
-            ctx->cleancount++;
-            memset((void *)ctx->sec_disp_base, 0, ctx->sec_frame_size*nr_framebuffers);
-        }
-        else
-        {
-           ctx->cleancount = 0;
-        }
-
-        if(!ctx->cleancount)
-        {
-            hnd = reinterpret_cast<private_handle_t const*>(ctx->buffer);
-            m = reinterpret_cast<private_module_t*>(ctx->dev->common.module);
-#if 0
-            if(ctx->c2dctx != NULL)
-            {
-                resizeToSecFrameBuffer_c2d(hnd->base,
-                           m->framebuffer->phys + hnd->base - m->framebuffer->base,
-                           ctx);
-            }
-            else
-#endif
-            {
-                resizeToSecFrameBuffer(hnd->base,
-                                   m->framebuffer->phys + hnd->base - m->framebuffer->base,
-                                   ctx);
-            }
-        }
-
-        sem_post(&ctx->sec_display_end);
-        
-        ctx->sec_info.yoffset = (ctx->sec_info.yres_virtual/nr_framebuffers) * ctx->sec_disp_next_buf;
-        ctx->sec_disp_next_buf = (ctx->sec_disp_next_buf + 1) % nr_framebuffers;
-        ctx->sec_info.activate = FB_ACTIVATE_VBL;
-
-        ioctl(ctx->sec_fp, FBIOPAN_DISPLAY, &ctx->sec_info);
-    }
-
-    return NULL;
-}
-
-#endif
-
-/*****************************************************************************/
-
-static int fb_close(struct hw_device_t *dev)
-{
-    fb_context_t* ctx = (fb_context_t*)dev;
-    if (ctx) {
-        free(ctx);
-    }
-    return 0;
-}
-
-int fb_device_open(hw_module_t const* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-    char value[PROPERTY_VALUE_MAX];
-
-    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) {
-        alloc_device_t* gralloc_device;
-        framebuffer_device_t *fbdev;
-
-        nr_framebuffers = NUM_BUFFERS;
-        property_get("ro.product.device", value, "");
-        if (0 == strcmp(value, "imx50_rdp")) {
-            nr_framebuffers = 2;
-            no_ipu = 1;
-        }
-
-        status = gralloc_open(module, &gralloc_device);
-        if (status < 0)
-            return status;
-
-        /* initialize our state here */
-        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev));
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = fb_close;
-        dev->device.setSwapInterval = fb_setSwapInterval;
-        dev->device.post            = fb_post;
-        #ifndef FSL_EPDC_FB
-        dev->device.setUpdateRect = 0;
-        #else
-        dev->device.setUpdateRect = fb_setUpdateRect;
-        #endif
-        dev->device.compositionComplete = fb_compositionComplete;
-        #ifdef FSL_IMX_DISPLAY
-        dev->device.setSecRotation = fb_setSecRotation;
-        #endif
-
-        private_module_t* m = (private_module_t*)module;
-        status = mapFrameBuffer(m);
-        if (status >= 0) {
-            int stride = m->finfo.line_length / (m->info.bits_per_pixel >> 3);
-            const_cast<uint32_t&>(dev->device.flags) = 0xfb0;
-            const_cast<uint32_t&>(dev->device.width) = m->info.xres;
-            const_cast<uint32_t&>(dev->device.height) = m->info.yres;
-            const_cast<int&>(dev->device.stride) = stride;
-            if(m->info.bits_per_pixel != 32) {
-                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_RGB_565;
-            }
-            else{
-                const_cast<int&>(dev->device.format) = HAL_PIXEL_FORMAT_BGRA_8888;
-            }
-            const_cast<float&>(dev->device.xdpi) = m->xdpi;
-            const_cast<float&>(dev->device.ydpi) = m->ydpi;
-            const_cast<float&>(dev->device.fps) = m->fps;
-            const_cast<int&>(dev->device.minSwapInterval) = 1;
-            const_cast<int&>(dev->device.maxSwapInterval) = 1;
-            *device = &dev->device.common;
-            fbdev = (framebuffer_device_t*) *device;
-            fbdev->reserved[0] = nr_framebuffers;
-      }
-
-    fslwatermark_sem_open();
-
-    }
-    return status;
-}
diff --git a/mx6/libgralloc/gr.h b/mx6/libgralloc/gr.h
deleted file mode 100755
index 4b1da84..0000000
--- a/mx6/libgralloc/gr.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#ifndef GR_H_
-#define GR_H_
-
-#include <stdint.h>
-#ifdef HAVE_ANDROID_OS      // just want PAGE_SIZE define
-# include <asm/page.h>
-#else
-# include <sys/user.h>
-#endif
-#include <limits.h>
-#include <sys/cdefs.h>
-#include <hardware/gralloc.h>
-#include <pthread.h>
-#include <errno.h>
-
-#include <cutils/native_handle.h>
-
-/*****************************************************************************/
-
-struct private_module_t;
-struct private_handle_t;
-
-inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
-int mapFrameBufferLocked(struct private_module_t* module);
-int terminateBuffer(gralloc_module_t const* module, private_handle_t* hnd);
-
-/*****************************************************************************/
-
-class Locker {
-    pthread_mutex_t mutex;
-public:
-    class Autolock {
-        Locker& locker;
-    public:
-        inline Autolock(Locker& locker) : locker(locker) {  locker.lock(); }
-        inline ~Autolock() { locker.unlock(); }
-    };
-    inline Locker()        { pthread_mutex_init(&mutex, 0); }
-    inline ~Locker()       { pthread_mutex_destroy(&mutex); }
-    inline void lock()     { pthread_mutex_lock(&mutex); }
-    inline void unlock()   { pthread_mutex_unlock(&mutex); }
-};
-
-#endif /* GR_H_ */
diff --git a/mx6/libgralloc/gralloc.cpp b/mx6/libgralloc/gralloc.cpp
deleted file mode 100755
index 0b3e3a9..0000000
--- a/mx6/libgralloc/gralloc.cpp
+++ /dev/null
@@ -1,560 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <limits.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <pthread.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-
-#include <cutils/ashmem.h>
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include "gralloc_priv.h"
-#include "allocator.h"
-
-#if HAVE_ANDROID_OS
-#include <linux/android_pmem.h>
-#endif
-
-/*****************************************************************************/
-
-static SimpleBestFitAllocator sAllocator;
-
-/*****************************************************************************/
-
-struct gralloc_context_t {
-    alloc_device_t  device;
-    /* our private data here */
-};
-
-static int gralloc_alloc_buffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle);
-
-/*****************************************************************************/
-
-int fb_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device);
-
-static int gralloc_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device);
-
-extern int gralloc_lock(gralloc_module_t const* module,
-        buffer_handle_t handle, int usage,
-        int l, int t, int w, int h,
-        void** vaddr);
-
-extern int gralloc_unlock(gralloc_module_t const* module, 
-        buffer_handle_t handle);
-
-extern int gralloc_register_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle);
-
-extern int gralloc_unregister_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle);
-
-/*****************************************************************************/
-
-static struct hw_module_methods_t gralloc_module_methods = {
-        open: gralloc_device_open
-};
-
-struct private_module_t HAL_MODULE_INFO_SYM = {
-    base: {
-        common: {
-            tag: HARDWARE_MODULE_TAG,
-            version_major: 1,
-            version_minor: 0,
-            id: GRALLOC_HARDWARE_MODULE_ID,
-            name: "Graphics Memory Allocator Module",
-            author: "The Android Open Source Project",
-            methods: &gralloc_module_methods
-        },
-        registerBuffer: gralloc_register_buffer,
-        unregisterBuffer: gralloc_unregister_buffer,
-        lock: gralloc_lock,
-        unlock: gralloc_unlock,
-    },
-    framebuffer: 0,
-    numBuffers: 0,
-    bufferMask: 0,
-    lock: PTHREAD_MUTEX_INITIALIZER,
-    currentBuffer: 0,
-};
-
-/*****************************************************************************/
-
-static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-
-    // allocate the framebuffer
-    if (m->framebuffer == NULL) {
-        // initialize the framebuffer, the framebuffer is mapped once
-        // and forever.
-        int err = mapFrameBufferLocked(m);
-        if (err < 0) {
-            return err;
-        }
-    }
-
-    const uint32_t bufferMask = m->bufferMask;
-    const uint32_t numBuffers = m->numBuffers;
-    const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
-    if (numBuffers == 1) {
-        // If we have only one buffer, we never use page-flipping. Instead,
-        // we return a regular buffer which will be memcpy'ed to the main
-        // screen when post is called.
-        int newUsage = (usage & ~GRALLOC_USAGE_HW_FB) | GRALLOC_USAGE_HW_2D;
-        pthread_mutex_unlock(&m->lock);
-        int ret = gralloc_alloc_buffer(dev, bufferSize, newUsage, pHandle);
-        pthread_mutex_lock(&m->lock);
-        return ret;
-    }
-
-    if (bufferMask >= ((1LU<<numBuffers)-1)) {
-        // We ran out of buffers.
-        return -ENOMEM;
-    }
-
-    // create a "fake" handles for it
-    intptr_t vaddr = intptr_t(m->framebuffer->base);
-    private_handle_t* hnd = new private_handle_t(dup(m->framebuffer->fd), size,
-            private_handle_t::PRIV_FLAGS_USES_PMEM |
-            private_handle_t::PRIV_FLAGS_FRAMEBUFFER);
-
-    // find a free slot
-    for (uint32_t i=0 ; i<numBuffers ; i++) {
-        if ((bufferMask & (1LU<<i)) == 0) {
-            m->bufferMask |= (1LU<<i);
-            break;
-        }
-        vaddr += bufferSize;
-    }
-    
-    hnd->base = vaddr;
-    hnd->offset = vaddr - intptr_t(m->framebuffer->base);
-    hnd->phys = intptr_t(m->framebuffer->phys) + hnd->offset;
-    *pHandle = hnd;
-
-    return 0;
-}
-
-static int gralloc_alloc_framebuffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(
-            dev->common.module);
-    pthread_mutex_lock(&m->lock);
-    int err = gralloc_alloc_framebuffer_locked(dev, size, usage, pHandle);
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
-
-static int init_pmem_area_locked(private_module_t* m)
-{
-    int err = 0;
-#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
-    int master_fd = open("/dev/pmem_gpu", O_RDWR, 0);
-    if (master_fd >= 0) {
-        
-        size_t size;
-        pmem_region region;
-        if (ioctl(master_fd, PMEM_GET_TOTAL_SIZE, &region) < 0) {
-            LOGE("PMEM_GET_TOTAL_SIZE failed, limp mode");
-            size = 8<<20;   // 8 MiB
-        } else {
-            size = region.len;
-        }
-        sAllocator.setSize(size);
-
-        void* base = mmap(0, size, 
-                PROT_READ|PROT_WRITE, MAP_SHARED, master_fd, 0);
-        if (base == MAP_FAILED) {
-            err = -errno;
-            base = 0;
-            close(master_fd);
-            master_fd = -1;
-        } else {
-            pmem_region region;
-            err = ioctl(master_fd, PMEM_GET_PHYS, &region);
-            if (err < 0) {
-                LOGE("PMEM_GET_PHYS failed (%s)", strerror(-errno));
-            } else {
-                m->master_phys = (unsigned long)region.offset;
-				LOGI("PMEM GPU enabled, size:%d, phys base:%x",size,m->master_phys);
-            }
-        }
-        m->pmem_master = master_fd;
-        m->pmem_master_base = base;
-    } else {
-        err = -errno;
-    }
-    return err;
-#else
-    return -1;
-#endif
-}
-
-static int init_pmem_area(private_module_t* m)
-{
-    pthread_mutex_lock(&m->lock);
-    int err = m->pmem_master;
-    if (err == -1) {
-        // first time, try to initialize pmem
-        err = init_pmem_area_locked(m);
-        if (err) {
-            m->pmem_master = err;
-        }
-    } else if (err < 0) {
-        // pmem couldn't be initialized, never use it
-    } else {
-        // pmem OK
-        err = 0;
-    }
-    pthread_mutex_unlock(&m->lock);
-    return err;
-}
-
-static int gralloc_alloc_buffer(alloc_device_t* dev,
-        size_t size, int usage, buffer_handle_t* pHandle)
-{
-    int err = 0;
-    int flags = 0;
-
-    int fd = -1;
-    void* base = 0;
-    int offset = 0;
-    int lockState = 0;
-
-    size = roundUpToPageSize(size);
-    
-#if HAVE_ANDROID_OS // should probably define HAVE_PMEM somewhere
-
-    if (usage & GRALLOC_USAGE_HW_TEXTURE) {
-        // enable pmem in that case, so our software GL can fallback to
-        // the copybit module.
-        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
-    }
-    
-    if (usage & GRALLOC_USAGE_HW_2D) {
-        flags |= private_handle_t::PRIV_FLAGS_USES_PMEM;
-    }
-
-    if ((flags & private_handle_t::PRIV_FLAGS_USES_PMEM) == 0) {
-try_ashmem:
-        fd = ashmem_create_region("gralloc-buffer", size);
-        if (fd < 0) {
-            LOGE("couldn't create ashmem (%s)", strerror(-errno));
-            err = -errno;
-        }
-    } else {
-        private_module_t* m = reinterpret_cast<private_module_t*>(
-                dev->common.module);
-
-        err = init_pmem_area(m);
-        if (err == 0) {
-            // PMEM buffers are always mmapped
-            base = m->pmem_master_base;
-            lockState |= private_handle_t::LOCK_STATE_MAPPED;
-
-            offset = sAllocator.allocate(size);
-            if (offset < 0) {
-                // no more pmem memory
-                err = -ENOMEM;
-            } else {
-                struct pmem_region sub = { offset, size };
-                
-                // now create the "sub-heap"
-                fd = open("/dev/pmem_gpu", O_RDWR, 0);
-                err = fd < 0 ? fd : 0;
-                
-                // and connect to it
-                if (err == 0)
-                    err = ioctl(fd, PMEM_CONNECT, m->pmem_master);
-
-                // and make it available to the client process
-                if (err == 0)
-                    err = ioctl(fd, PMEM_MAP, &sub);
-
-                if (err < 0) {
-                    err = -errno;
-                    close(fd);
-                    sAllocator.deallocate(offset);
-                    fd = -1;
-                }
-                //LOGD_IF(!err, "allocating pmem size=%d, offset=%d", size, offset);
-                memset((char*)base + offset, 0, size);
-            }
-        } else {
-            if ((usage & GRALLOC_USAGE_HW_2D) == 0) {
-                // the caller didn't request PMEM, so we can try something else
-                flags &= ~private_handle_t::PRIV_FLAGS_USES_PMEM;
-                err = 0;
-                goto try_ashmem;
-            } else {
-                LOGE("couldn't open pmem (%s)", strerror(-errno));
-            }
-        }
-    }
-
-#else // HAVE_ANDROID_OS
-    
-    fd = ashmem_create_region("Buffer", size);
-    if (fd < 0) {
-        LOGE("couldn't create ashmem (%s)", strerror(-errno));
-        err = -errno;
-    }
-
-#endif // HAVE_ANDROID_OS
-
-    if (err == 0) {
-        private_handle_t* hnd = new private_handle_t(fd, size, flags);
-        hnd->offset = offset;
-        hnd->base = int(base)+offset;
-        hnd->lockState = lockState;
-        if (flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
-            private_module_t* m = reinterpret_cast<private_module_t*>(
-                    dev->common.module);
-            hnd->phys = m->master_phys + offset;
-        }
-        *pHandle = hnd;
-    }
-    
-    LOGE_IF(err, "gralloc failed err=%s", strerror(-err));
-    
-    return err;
-}
-
-/*****************************************************************************/
-
-static int gralloc_alloc(alloc_device_t* dev,
-        int w, int h, int format, int usage,
-        buffer_handle_t* pHandle, int* pStride)
-{
-    if (!pHandle || !pStride)
-        return -EINVAL;
-
-    private_module_t* m = reinterpret_cast<private_module_t*>(dev->common.module);
-    if(!m)
-        return -EINVAL;
-
-    if (m->gpu_device && !(usage & GRALLOC_USAGE_HWC_OVERLAY)) {
-       if(format == HAL_PIXEL_FORMAT_YCbCr_420_I)format = HAL_PIXEL_FORMAT_YCbCr_420_P;
-       else if(format == HAL_PIXEL_FORMAT_YCbCr_420_P)format = HAL_PIXEL_FORMAT_YCbCr_420_I;
-
-       return m->gpu_device->alloc(dev, w, h, format, usage, pHandle, pStride);
-    }
-
-    size_t size, alignedw, alignedh;
-    if (format == HAL_PIXEL_FORMAT_YCbCr_420_SP || format == HAL_PIXEL_FORMAT_YCbCr_422_I ||
-            format == HAL_PIXEL_FORMAT_YCbCr_422_SP || format == HAL_PIXEL_FORMAT_YCbCr_420_I ||
-        format == HAL_PIXEL_FORMAT_YV12)
-    {
-        // FIXME: there is no way to return the alignedh
-        alignedw = ALIGN_PIXEL_16(w);
-        alignedh = ALIGN_PIXEL_16(h);
-        switch (format) {
-            case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-            case HAL_PIXEL_FORMAT_YCbCr_422_I:
-                size = alignedw * alignedh * 2;
-                break;
-            case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-            case HAL_PIXEL_FORMAT_YCbCr_420_I:
-            case HAL_PIXEL_FORMAT_YV12:
-                size = (alignedw * alignedh) + (w/2 * h/2) * 2;
-                break;
-            default:
-                return -EINVAL;
-        }
-    } else {
-        alignedw = ALIGN_PIXEL(w);
-        alignedh = ALIGN_PIXEL(h);
-        int bpp = 0;
-        switch (format) {
-            case HAL_PIXEL_FORMAT_RGBA_8888:
-            case HAL_PIXEL_FORMAT_RGBX_8888:
-            case HAL_PIXEL_FORMAT_BGRA_8888:
-                bpp = 4;
-                break;
-            case HAL_PIXEL_FORMAT_RGB_888:
-                bpp = 3;
-                break;
-            case HAL_PIXEL_FORMAT_RGB_565:
-            case HAL_PIXEL_FORMAT_RGBA_5551:
-            case HAL_PIXEL_FORMAT_RGBA_4444:
-                bpp = 2;
-                break;
-            default:
-                return -EINVAL;
-        }
-        size = alignedw * alignedh * bpp;
-    }
-
-    int err;
-    if (usage & GRALLOC_USAGE_HW_FB) {
-        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle);
-    } else {
-        err = gralloc_alloc_buffer(dev, size, usage, pHandle);
-    }
-
-    if (err < 0) {
-        return err;
-    }
-
-    private_handle_t* hnd = (private_handle_t*)(*pHandle);
-    hnd->usage = usage;
-    hnd->format = format;
-    hnd->width = alignedw;
-    hnd->height = alignedh;
-
-    *pStride = alignedw;
-    return 0;
-}
-
-static int gralloc_free(alloc_device_t* dev,
-        buffer_handle_t handle)
-{
-    private_module_t* m = reinterpret_cast<private_module_t*>(dev->common.module);
-    if(!m)
-       return -EINVAL;
-
-    if(m->gpu_device && ((private_handle_t*)handle)->magic != private_handle_t::sMagic) {
-       return m->gpu_device->free(dev, handle);
-    }
-
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    private_handle_t const* hnd = reinterpret_cast<private_handle_t const*>(handle);
-    if (hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER) {
-        // free this buffer
-        private_module_t* m = reinterpret_cast<private_module_t*>(
-                dev->common.module);
-        const size_t bufferSize = m->finfo.line_length * ALIGN_PIXEL_128(m->info.yres);
-        int index = (hnd->base - m->framebuffer->base) / bufferSize;
-        m->bufferMask &= ~(1<<index); 
-    } else { 
-#if HAVE_ANDROID_OS
-        if (hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) {
-            if (hnd->fd >= 0) {
-                struct pmem_region sub = { hnd->offset, hnd->size };
-                int err = ioctl(hnd->fd, PMEM_UNMAP, &sub);
-                LOGE_IF(err<0, "PMEM_UNMAP failed (%s), "
-                        "fd=%d, sub.offset=%lu, sub.size=%lu",
-                        strerror(errno), hnd->fd, hnd->offset, hnd->size);
-                if (err == 0) {
-                    // we can't deallocate the memory in case of UNMAP failure
-                    // because it would give that process access to someone else's
-                    // surfaces, which would be a security breach.
-                    sAllocator.deallocate(hnd->offset);
-                }
-            }
-        }
-#endif // HAVE_ANDROID_OS
-        gralloc_module_t* module = reinterpret_cast<gralloc_module_t*>(
-                dev->common.module);
-        terminateBuffer(module, const_cast<private_handle_t*>(hnd));
-    }
-
-    close(hnd->fd);
-    delete hnd;
-    return 0;
-}
-
-/*****************************************************************************/
-
-static int gralloc_close(struct hw_device_t *dev)
-{
-    gralloc_context_t* ctx = reinterpret_cast<gralloc_context_t*>(dev);
-    if (ctx) {
-        /* TODO: keep a list of all buffer_handle_t created, and free them
-         * all here.
-         */
-        private_module_t* m = reinterpret_cast<private_module_t*>(dev);
-        if(m && m->gpu_device){
-           gralloc_close((struct hw_device_t *)m->gpu_device);
-        }
-
-        free(ctx);
-    }
-    return 0;
-}
-
-int gralloc_device_open(const hw_module_t* module, const char* name,
-        hw_device_t** device)
-{
-    int status = -EINVAL;
-    hw_module_t *hw = const_cast<hw_module_t *>(module);
-    private_module_t* m = reinterpret_cast<private_module_t*>(hw);
-
-    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) {
-        gralloc_context_t *dev;
-        dev = (gralloc_context_t*)malloc(sizeof(*dev));
-
-        /* initialize our state here */
-        memset(dev, 0, sizeof(*dev));
-
-        /* initialize the procs */
-        dev->device.common.tag = HARDWARE_DEVICE_TAG;
-        dev->device.common.version = 0;
-        dev->device.common.module = const_cast<hw_module_t*>(module);
-        dev->device.common.close = gralloc_close;
-
-        dev->device.alloc   = gralloc_alloc;
-        dev->device.free    = gralloc_free;
-
-        *device = &dev->device.common;
-        status = 0;
-
-        if(!m->gpu_device)
-        {
-           hw_module_t const* gpu_module;;
-           if (hw_get_module(GRALLOC_VIV_HARDWARE_MODULE_ID, &gpu_module) == 0) {
-              status = gralloc_open(gpu_module, &m->gpu_device);
-              if(status || !m->gpu_device){
-                 LOGE("gralloc_device_open: gpu gralloc device open failed!");
-              }
-           }
-        }
-    } else {
-
-        m->flags = 0;
-        m->pmem_master = -1;
-        m->pmem_master_base=0;
-        m->master_phys = 0;
-        m->gpu_device = 0;
-        m->gralloc_viv= 0;
-
-        status = fb_device_open(module, name, device);
-    }
-    return status;
-}
diff --git a/mx6/libgralloc/gralloc_priv.h b/mx6/libgralloc/gralloc_priv.h
deleted file mode 100755
index 494a925..0000000
--- a/mx6/libgralloc/gralloc_priv.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#ifndef GRALLOC_PRIV_H_
-#define GRALLOC_PRIV_H_
-
-#include <stdint.h>
-#include <limits.h>
-#include <sys/cdefs.h>
-#include <hardware/gralloc.h>
-#include <pthread.h>
-#include <errno.h>
-#include <unistd.h>
-
-#include <cutils/native_handle.h>
-
-#include <linux/fb.h>
-
-#define  ALIGN_PIXEL(x)  ((x+ 31) & ~31)
-#define  ALIGN_PIXEL_16(x)  ((x+ 15) & ~15)
-/** z430 core need 4k aligned memory, since xres has been 32 aligned, make yres
-    to 128 aligned will meet this request for all pixel format (RGB565,RGB888,etc.) */
-#define  ALIGN_PIXEL_128(x)  ((x+ 127) & ~127)
-/*****************************************************************************/
-
-struct private_module_t;
-struct private_handle_t;
-
-struct private_module_t {
-/** do NOT change the elements below **/
-    gralloc_module_t base;
-    private_handle_t* framebuffer;
-    uint32_t numBuffers;
-    uint32_t bufferMask;
-    pthread_mutex_t lock;
-    buffer_handle_t currentBuffer;
-    struct fb_var_screeninfo info;
-    struct fb_fix_screeninfo finfo;
-/** do NOT change the elements above **/
-
-    float xdpi;
-    float ydpi;
-    float fps;
-
-    uint32_t flags;
-    int pmem_master;
-    void* pmem_master_base;
-    unsigned long master_phys;
-    alloc_device_t *gpu_device;
-    gralloc_module_t* gralloc_viv;
-    enum {
-        // flag to indicate we'll post this buffer
-        PRIV_USAGE_LOCKED_FOR_POST = 0x80000000
-    };
-};
-
-/*****************************************************************************/
-
-#ifdef __cplusplus
-struct private_handle_t : public native_handle {
-#else
-struct private_handle_t {
-    struct native_handle nativeHandle;
-#endif
-
-    enum {
-        PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
-        PRIV_FLAGS_USES_PMEM   = 0x00000002,
-    };
-
-    enum {
-        LOCK_STATE_WRITE     =   1<<31,
-        LOCK_STATE_MAPPED    =   1<<30,
-        LOCK_STATE_READ_MASK =   0x3FFFFFFF
-    };
-/** do NOT change any element below **/
-    int     fd;
-    int     magic;
-    int     flags;
-    int     size;
-    int     offset;
-    int     base;
-    int     phys;
-    int     format;
-    int     width;
-    int     height;
-    int     pid;
-/** do NOT change any element above **/
-
-    int     usage;
-    int     lockState;
-    int     writeOwner;
-#ifdef __cplusplus
-    static const int sNumInts = 13;
-    static const int sNumFds = 1;
-    static const int sMagic = 'pgpu';
-
-    private_handle_t(int fd, int size, int flags) :
-        fd(fd), magic(sMagic), flags(flags), size(size), offset(0),
-        base(0), lockState(0), writeOwner(0), phys(0),pid(getpid()),
-        format(0), width(0), height(0)
-    {
-        version = sizeof(native_handle);
-        numInts = sNumInts;
-        numFds = sNumFds;
-    }
-    ~private_handle_t() {
-        magic = 0;
-    }
-
-    bool usesPhysicallyContiguousMemory() {
-        return (flags & PRIV_FLAGS_USES_PMEM) != 0;
-    }
-
-    static int validate(const native_handle* h) {
-        const private_handle_t* hnd = (const private_handle_t*)h;
-        if (!h || h->version != sizeof(native_handle) ||
-                h->numInts != sNumInts || h->numFds != sNumFds ||
-                hnd->magic != sMagic)
-        {
-            LOGE("invalid gralloc handle (at %p)", h);
-            return -EINVAL;
-        }
-        return 0;
-    }
-
-    static private_handle_t* dynamicCast(const native_handle* in) {
-        if (validate(in) == 0) {
-            return (private_handle_t*) in;
-        }
-        return NULL;
-    }
-#endif
-};
-
-#endif /* GRALLOC_PRIV_H_ */
diff --git a/mx6/libgralloc/mapper.cpp b/mx6/libgralloc/mapper.cpp
deleted file mode 100755
index 98957a2..0000000
--- a/mx6/libgralloc/mapper.cpp
+++ /dev/null
@@ -1,327 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
-#include <limits.h>
-#include <errno.h>
-#include <pthread.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hardware.h>
-#include <hardware/gralloc.h>
-
-#include "gralloc_priv.h"
-
-
-// we need this for now because pmem cannot mmap at an offset
-#define PMEM_HACK   1
-
-/* desktop Linux needs a little help with gettid() */
-#if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
-#define __KERNEL__
-# include <linux/unistd.h>
-pid_t gettid() { return syscall(__NR_gettid);}
-#undef __KERNEL__
-#endif
-
-/*****************************************************************************/
-
-static int gralloc_map(gralloc_module_t const* module,
-        buffer_handle_t handle,
-        void** vaddr)
-{
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
-        size_t size = hnd->size;
-#if PMEM_HACK
-        size += hnd->offset;
-#endif
-        void* mappedAddress = mmap(0, size,
-                PROT_READ|PROT_WRITE, MAP_SHARED, hnd->fd, 0);
-        if (mappedAddress == MAP_FAILED) {
-            LOGE("Could not mmap %s", strerror(errno));
-            return -errno;
-        }
-        hnd->base = intptr_t(mappedAddress) + hnd->offset;
-        //LOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p", 
-        //        hnd->fd, hnd->offset, hnd->size, mappedAddress);
-    }
-    *vaddr = (void*)hnd->base;
-    return 0;
-}
-
-static int gralloc_unmap(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (!(hnd->flags & private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) {
-        void* base = (void*)hnd->base;
-        size_t size = hnd->size;
-#if PMEM_HACK
-        base = (void*)(intptr_t(base) - hnd->offset);
-        size += hnd->offset;
-#endif
-        //LOGD("unmapping from %p, size=%d", base, size);
-        if (munmap(base, size) < 0) {
-            LOGE("Could not unmap %s", strerror(errno));
-        }
-    }
-    hnd->base = 0;
-    return 0;
-}
-
-/*****************************************************************************/
-
-static pthread_mutex_t sMapLock = PTHREAD_MUTEX_INITIALIZER; 
-
-/*****************************************************************************/
-static gralloc_module_t const*gralloc_get(gralloc_module_t const* module, buffer_handle_t handle)
-{
-    hw_module_t const* pModule;
-
-    if(!handle)
-       return NULL;
-
-    if (((private_handle_t*)handle)->magic == private_handle_t::sMagic)
-       return NULL;
-
-    gralloc_module_t *gr = const_cast<gralloc_module_t *>(module);
-    private_module_t* m = reinterpret_cast<private_module_t*>(gr);
-
-    if(m->gralloc_viv)
-        return m->gralloc_viv;
-
-    if(hw_get_module(GRALLOC_VIV_HARDWARE_MODULE_ID, &pModule))
-       return NULL;
-
-    gralloc_module_t const* gralloc_viv = reinterpret_cast<gralloc_module_t const*>(pModule);
-    m->gralloc_viv = (gralloc_module_t*)gralloc_viv;
-
-    return gralloc_viv;
-}
-int gralloc_register_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    gralloc_module_t const* gralloc_viv = gralloc_get(module, handle);
-    if(gralloc_viv){
-        return gralloc_viv->registerBuffer(gralloc_viv, handle);
-    }
-
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    // In this implementation, we don't need to do anything here
-
-    /* NOTE: we need to initialize the buffer as not mapped/not locked
-     * because it shouldn't when this function is called the first time
-     * in a new process. Ideally these flags shouldn't be part of the
-     * handle, but instead maintained in the kernel or at least 
-     * out-of-line
-     */ 
-
-    // if this handle was created in this process, then we keep it as is.
-    private_handle_t* hnd = (private_handle_t*)handle;
-    if (hnd->pid != getpid()) {
-        hnd->base = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int gralloc_unregister_buffer(gralloc_module_t const* module,
-        buffer_handle_t handle)
-{
-    gralloc_module_t const* gralloc_viv = gralloc_get(module, handle);
-    if(gralloc_viv){
-        return gralloc_viv->unregisterBuffer(gralloc_viv, handle);
-    }
-
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     * NOTE: the framebuffer is handled differently and is never unmapped.
-     */
-
-    private_handle_t* hnd = (private_handle_t*)handle;
-    
-    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
-            "[unregister] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-
-    // never unmap buffers that were created in this process
-    if (hnd->pid != getpid()) {
-        if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
-            gralloc_unmap(module, handle);
-        }
-        hnd->base = 0;
-        hnd->lockState  = 0;
-        hnd->writeOwner = 0;
-    }
-    return 0;
-}
-
-int terminateBuffer(gralloc_module_t const* module,
-        private_handle_t* hnd)
-{
-    /*
-     * If the buffer has been mapped during a lock operation, it's time
-     * to un-map it. It's an error to be here with a locked buffer.
-     */
-
-    LOGE_IF(hnd->lockState & private_handle_t::LOCK_STATE_READ_MASK,
-            "[terminate] handle %p still locked (state=%08x)",
-            hnd, hnd->lockState);
-    
-    if (hnd->lockState & private_handle_t::LOCK_STATE_MAPPED) {
-        // this buffer was mapped, unmap it now
-        if ((hnd->flags & private_handle_t::PRIV_FLAGS_USES_PMEM) && 
-            (hnd->pid == getpid())) {
-            // ... unless it's a "master" pmem buffer, that is a buffer
-            // mapped in the process it's been allocated.
-            // (see gralloc_alloc_buffer())
-        } else {
-            gralloc_unmap(module, hnd);
-        }
-    }
-
-    return 0;
-}
-
-int gralloc_lock(gralloc_module_t const* module,
-        buffer_handle_t handle, int usage,
-        int l, int t, int w, int h,
-        void** vaddr)
-{
-    gralloc_module_t const* gralloc_viv = gralloc_get(module, handle);
-    if(gralloc_viv){
-        return gralloc_viv->lock(gralloc_viv, handle, usage, l, t, w, h, vaddr);
-    }
-
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    int err = 0;
-    private_handle_t* hnd = (private_handle_t*)handle;
-    int32_t current_value, new_value;
-    int retry;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
-            // already locked for write 
-            LOGE("handle %p already locked for write", handle);
-            return -EBUSY;
-        } else if (current_value & private_handle_t::LOCK_STATE_READ_MASK) {
-            // already locked for read
-            if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-                LOGE("handle %p already locked for read", handle);
-                return -EBUSY;
-            } else {
-                // this is not an error
-                //LOGD("%p already locked for read... count = %d", 
-                //        handle, (current_value & ~(1<<31)));
-            }
-        }
-
-        // not currently locked
-        if (usage & (GRALLOC_USAGE_SW_WRITE_MASK | GRALLOC_USAGE_HW_RENDER)) {
-            // locking for write
-            new_value |= private_handle_t::LOCK_STATE_WRITE;
-        }
-        new_value++;
-
-        retry = android_atomic_cmpxchg(current_value, new_value, 
-                (volatile int32_t*)&hnd->lockState);
-    } while (retry);
-
-    if (new_value & private_handle_t::LOCK_STATE_WRITE) {
-        // locking for write, store the tid
-        hnd->writeOwner = getpid();
-    }
-
-    if (usage & (GRALLOC_USAGE_SW_READ_MASK | GRALLOC_USAGE_SW_WRITE_MASK)) {
-        if (!(current_value & private_handle_t::LOCK_STATE_MAPPED)) {
-            // we need to map for real
-            pthread_mutex_t* const lock = &sMapLock;
-            pthread_mutex_lock(lock);
-            if (!(hnd->lockState & private_handle_t::LOCK_STATE_MAPPED)) {
-                err = gralloc_map(module, handle, vaddr);
-                if (err == 0) {
-                    android_atomic_or(private_handle_t::LOCK_STATE_MAPPED,
-                            (volatile int32_t*)&(hnd->lockState));
-                }
-            }
-            pthread_mutex_unlock(lock);
-        }
-        *vaddr = (void*)hnd->base;
-    }
-
-    return err;
-}
-
-int gralloc_unlock(gralloc_module_t const* module, 
-        buffer_handle_t handle)
-{
-    gralloc_module_t const* gralloc_viv = gralloc_get(module, handle);
-    if(gralloc_viv){
-        return gralloc_viv->unlock(gralloc_viv, handle);
-    }
-
-    if (private_handle_t::validate(handle) < 0)
-        return -EINVAL;
-
-    private_handle_t* hnd = (private_handle_t*)handle;
-    int32_t current_value, new_value;
-
-    do {
-        current_value = hnd->lockState;
-        new_value = current_value;
-
-        if (current_value & private_handle_t::LOCK_STATE_WRITE) {
-            // locked for write
-            if (hnd->writeOwner == getpid()) {
-                hnd->writeOwner = 0;
-                new_value &= ~private_handle_t::LOCK_STATE_WRITE;
-            }
-        }
-
-        if ((new_value & private_handle_t::LOCK_STATE_READ_MASK) == 0) {
-            LOGE("handle %p not locked", handle);
-            return -EINVAL;
-        }
-
-        new_value--;
-
-    } while (android_atomic_cmpxchg(current_value, new_value, 
-            (volatile int32_t*)&hnd->lockState));
-
-    return 0;
-}
diff --git a/mx6/libgralloc_wrapper/framebuffer.cpp b/mx6/libgralloc_wrapper/framebuffer.cpp
index 4bf040a..65eb14f 100755
--- a/mx6/libgralloc_wrapper/framebuffer.cpp
+++ b/mx6/libgralloc_wrapper/framebuffer.cpp
@@ -57,6 +57,10 @@
 // numbers of buffers for page flipping
 #define NUM_BUFFERS 3
 
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
 enum {
     PAGE_FLIP = 0x00000001,
     LOCKED = 0x00000002
@@ -500,7 +504,7 @@ static int mapFrameBufferWithParamLocked(struct private_module_t* module, struct
     int err;
     size_t fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
     module->framebuffer = new private_handle_t(dup(fd), fbSize,
-            private_handle_t::PRIV_FLAGS_USES_PMEM);
+            private_handle_t::PRIV_FLAGS_USES_DRV);
 
     module->numBuffers = info.yres_virtual / ALIGN_PIXEL_128(info.yres);
     module->bufferMask = 0;
diff --git a/mx6/libgralloc_wrapper/gralloc.cpp b/mx6/libgralloc_wrapper/gralloc.cpp
index 10a67bf..6454935 100755
--- a/mx6/libgralloc_wrapper/gralloc.cpp
+++ b/mx6/libgralloc_wrapper/gralloc.cpp
@@ -39,10 +39,6 @@
 #include "gralloc_priv.h"
 //#include "allocator.h"
 
-#if HAVE_ANDROID_OS
-#include <linux/android_pmem.h>
-#endif
-
 /*****************************************************************************/
 
 struct gralloc_context_t {
@@ -194,8 +190,6 @@ int gralloc_device_open(const hw_module_t* module, const char* name,
     } else {
 
         m->flags = 0;
-        m->pmem_master = -1;
-        m->pmem_master_base=0;
         m->master_phys = 0;
         //m->gpu_device = 0;
         //m->gralloc_viv= 0;
diff --git a/mx6/libgralloc_wrapper/gralloc_priv.h b/mx6/libgralloc_wrapper/gralloc_priv.h
index d86ddbf..08fdcaf 100755
--- a/mx6/libgralloc_wrapper/gralloc_priv.h
+++ b/mx6/libgralloc_wrapper/gralloc_priv.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
+ * Copyright 2009-2012 Freescale Semiconductor, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,8 +15,6 @@
  * limitations under the License.
  */
 
-/* Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.*/
-
 #ifndef GRALLOC_PRIV_H_
 #define GRALLOC_PRIV_H_
 
@@ -37,10 +36,6 @@
     to 128 aligned will meet this request for all pixel format (RGB565,RGB888,etc.) */
 #define  ALIGN_PIXEL_128(x)  ((x+ 127) & ~127)
 
-inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
 /*****************************************************************************/
 
 struct private_module_t;
@@ -63,8 +58,6 @@ struct private_module_t {
     float fps;
 
     uint32_t flags;
-    int pmem_master;
-    void* pmem_master_base;
     unsigned long master_phys;
     alloc_device_t *gpu_device;
     gralloc_module_t* gralloc_viv;
@@ -85,7 +78,7 @@ struct private_handle_t {
 
     enum {
         PRIV_FLAGS_FRAMEBUFFER = 0x00000001,
-        PRIV_FLAGS_USES_PMEM   = 0x00000002,
+        PRIV_FLAGS_USES_DRV    = 0x00000002,
     };
 
     enum {
@@ -129,7 +122,7 @@ struct private_handle_t {
     }
 
     bool usesPhysicallyContiguousMemory() {
-        return (flags & PRIV_FLAGS_USES_PMEM) != 0;
+        return (flags & PRIV_FLAGS_USES_DRV) != 0;
     }
 
     static int validate(const native_handle* h) {
diff --git a/mx6/libgralloc_wrapper/mapper.cpp b/mx6/libgralloc_wrapper/mapper.cpp
index 5d02ebc..f536d6e 100755
--- a/mx6/libgralloc_wrapper/mapper.cpp
+++ b/mx6/libgralloc_wrapper/mapper.cpp
@@ -35,9 +35,6 @@
 #include "gralloc_priv.h"
 
 
-// we need this for now because pmem cannot mmap at an offset
-#define PMEM_HACK   1
-
 /* desktop Linux needs a little help with gettid() */
 #if defined(ARCH_X86) && !defined(HAVE_ANDROID_OS)
 #define __KERNEL__
-- 
1.8.0

