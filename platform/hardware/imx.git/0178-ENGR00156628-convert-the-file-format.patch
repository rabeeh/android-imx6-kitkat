From a8cde8d8bbc74bf8efb43db5cd6485b360a6f896 Mon Sep 17 00:00:00 2001
From: Liu Xiaowen <b37945@freescale.com>
Date: Tue, 13 Sep 2011 18:07:35 +0800
Subject: [PATCH 178/502] ENGR00156628 convert the file format

convert the file format.

Signed-off-by: Liu Xiaowen <b37945@freescale.com>
---
 mx5x/hwcomposer/BG_device.cpp     | 318 ++++++++++----------
 mx5x/hwcomposer/FG_device.cpp     | 618 +++++++++++++++++++-------------------
 mx5x/hwcomposer/blit_gpu.cpp      |  86 +++---
 mx5x/hwcomposer/blit_gpu.h        |  84 +++---
 mx5x/hwcomposer/blit_ipu.h        | 104 +++----
 mx5x/hwcomposer/hwc_common.cpp    | 432 +++++++++++++-------------
 mx5x/hwcomposer/hwc_common.h      | 446 +++++++++++++--------------
 mx5x/hwcomposer/output_device.cpp | 344 ++++++++++-----------
 8 files changed, 1216 insertions(+), 1216 deletions(-)

diff --git a/mx5x/hwcomposer/BG_device.cpp b/mx5x/hwcomposer/BG_device.cpp
index 6b6a067..eb535b3 100755
--- a/mx5x/hwcomposer/BG_device.cpp
+++ b/mx5x/hwcomposer/BG_device.cpp
@@ -1,159 +1,159 @@
-
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-#include <hardware/hardware.h>
-//#include <hardware/overlay.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-using namespace android;
-
-//note: the fb1 in mx5x is hdmi port and should use 1080p=1920_1080. 
-BG_device::BG_device(const char *dev_name, int usage) 
-			: output_device(dev_name, usage)
-{
-		init();
-}
-
-BG_device::~BG_device()
-{
-		uninit();
-}
-
-int BG_device::init()
-{
-	  int status = -EINVAL;
-	  int fbSize = 0;
-	  void *vaddr = NULL;
-
-    if(m_dev <= 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_init invalid parameter!");
-    	  return -1;       	
-    }
-    
-    struct fb_var_screeninfo info;
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init VSCREENINFO getting failed!");
-    	  return -1;    	  
-    }
-    
-    struct fb_fix_screeninfo finfo;
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init FSCREENINFO getting failed!");
-    	  return -1;       	
-    }
-    
-   // m_left = 0;
-   // m_top = 0;
-    m_width = 1920;//info.xres;
-    m_height = 1080;//info.yres;
-    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
-  	
-  	info.reserved[0] = 0;
-  	info.reserved[1] = 0;
-  	info.reserved[2] = 0;  
-  	info.xoffset = 0;
-  	info.yoffset = 0;
-  	info.activate = FB_ACTIVATE_NOW;
-  	
-  	info.bits_per_pixel = fmt_to_bpp(m_format);
-  	info.nonstd = m_format;
-  	info.red.offset = 0;
-  	info.red.length = 0;
-  	info.green.offset = 0;
-  	info.green.length = 0;
-  	info.blue.offset = 0;
-  	info.blue.length = 0;
-  	info.transp.offset = 0;
-  	info.transp.length = 0;	 
-  	
-  	info.xres = m_width;
-  	info.yres = m_height;
-  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
-  	info.xres_virtual = ALIGN_PIXEL(info.xres);
-  	
-    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO setting failed!");
-    	  return -1;    	  
-    }
-
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO getting failed!");
-    	  return -1;    	  
-    }
-
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 FSCREENINFO getting failed!");
-    	  return -1;       	
-    }
-  	
-  	if(finfo.smem_len <= 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init finfo.smem_len < 0!");
-    	  return -1;      		
-  	}
-  	
-  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
-  	if(vaddr == MAP_FAILED) {
-    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init mapping the framebuffer error(%s)!", strerror(errno));
-    	  return -1;    		
-  	}
-
-        hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format); 
-        int blank = FB_BLANK_UNBLANK;
-	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-		HWCOMPOSER_LOG_ERR("Error!BG_device::init UNBLANK FB1 failed!\n");
-        return -1;
-	} 	
-//  	key.enable = 1;
-//  	key.color_key = 0x00000000; //black
-//  	if(ioctl(m_dev, MXCFB_SET_CLR_KEY, &key) < 0) {
-//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-//    	  return -1;    		
-//  	}
-//  	
-//  	gbl_alpha.alpha = 255;
-//  	gbl_alpha.enable = 1;
-//  	if(ioctl(m_dev, MXCFB_SET_GBL_ALPHA, &key) < 0) {
-//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-//    	  return -1;    		
-//  	}  	
-  	
-  	mbuffer_count = DEFAULT_BUFFERS;
-  	mbuffer_cur = 0;
-  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
-  			(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
-  			(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
-  			(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
-  			(mbuffers[i]).format = m_format;
-  	}
-	
-    status = 0;
-    return status;
-}
-
-int BG_device::uninit()
-{
-	  //int status = -EINVAL;    
-    int blank = 1;
-    HWCOMPOSER_LOG_RUNTIME("---------------BG_device::uninit()------------");
-
-    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-	    HWCOMPOSER_LOG_ERR("Error!BG_device::uninit BLANK FB2 failed!\n");
-        //return -1;
-    }	  
-    munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
-    close(m_dev);
-
-    return 0;
-}
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <hardware/hardware.h>
+//#include <hardware/overlay.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+//note: the fb1 in mx5x is hdmi port and should use 1080p=1920_1080. 
+BG_device::BG_device(const char *dev_name, int usage) 
+			: output_device(dev_name, usage)
+{
+		init();
+}
+
+BG_device::~BG_device()
+{
+		uninit();
+}
+
+int BG_device::init()
+{
+	  int status = -EINVAL;
+	  int fbSize = 0;
+	  void *vaddr = NULL;
+
+    if(m_dev <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_init invalid parameter!");
+    	  return -1;       	
+    }
+    
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init VSCREENINFO getting failed!");
+    	  return -1;    	  
+    }
+    
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init FSCREENINFO getting failed!");
+    	  return -1;       	
+    }
+    
+   // m_left = 0;
+   // m_top = 0;
+    m_width = 1920;//info.xres;
+    m_height = 1080;//info.yres;
+    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
+  	
+  	info.reserved[0] = 0;
+  	info.reserved[1] = 0;
+  	info.reserved[2] = 0;  
+  	info.xoffset = 0;
+  	info.yoffset = 0;
+  	info.activate = FB_ACTIVATE_NOW;
+  	
+  	info.bits_per_pixel = fmt_to_bpp(m_format);
+  	info.nonstd = m_format;
+  	info.red.offset = 0;
+  	info.red.length = 0;
+  	info.green.offset = 0;
+  	info.green.length = 0;
+  	info.blue.offset = 0;
+  	info.blue.length = 0;
+  	info.transp.offset = 0;
+  	info.transp.length = 0;	 
+  	
+  	info.xres = m_width;
+  	info.yres = m_height;
+  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
+  	info.xres_virtual = ALIGN_PIXEL(info.xres);
+  	
+    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO setting failed!");
+    	  return -1;    	  
+    }
+
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 VSCREENINFO getting failed!");
+    	  return -1;    	  
+    }
+
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init-2 FSCREENINFO getting failed!");
+    	  return -1;       	
+    }
+  	
+  	if(finfo.smem_len <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init finfo.smem_len < 0!");
+    	  return -1;      		
+  	}
+  	
+  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
+  	if(vaddr == MAP_FAILED) {
+    	  HWCOMPOSER_LOG_ERR("Error! BG_device::init mapping the framebuffer error(%s)!", strerror(errno));
+    	  return -1;    		
+  	}
+
+        hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format); 
+        int blank = FB_BLANK_UNBLANK;
+	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!BG_device::init UNBLANK FB1 failed!\n");
+        return -1;
+	} 	
+//  	key.enable = 1;
+//  	key.color_key = 0x00000000; //black
+//  	if(ioctl(m_dev, MXCFB_SET_CLR_KEY, &key) < 0) {
+//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+//    	  return -1;    		
+//  	}
+//  	
+//  	gbl_alpha.alpha = 255;
+//  	gbl_alpha.enable = 1;
+//  	if(ioctl(m_dev, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+//    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+//    	  return -1;    		
+//  	}  	
+  	
+  	mbuffer_count = DEFAULT_BUFFERS;
+  	mbuffer_cur = 0;
+  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
+  			(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
+  			(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
+  			(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
+  			(mbuffers[i]).format = m_format;
+  	}
+	
+    status = 0;
+    return status;
+}
+
+int BG_device::uninit()
+{
+	  //int status = -EINVAL;    
+    int blank = 1;
+    HWCOMPOSER_LOG_RUNTIME("---------------BG_device::uninit()------------");
+
+    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+	    HWCOMPOSER_LOG_ERR("Error!BG_device::uninit BLANK FB2 failed!\n");
+        //return -1;
+    }	  
+    munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
+    close(m_dev);
+
+    return 0;
+}
diff --git a/mx5x/hwcomposer/FG_device.cpp b/mx5x/hwcomposer/FG_device.cpp
index 6da50ef..1850fe5 100755
--- a/mx5x/hwcomposer/FG_device.cpp
+++ b/mx5x/hwcomposer/FG_device.cpp
@@ -1,309 +1,309 @@
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <linux/fb.h>
-#include <linux/mxcfb.h>
-#include <sys/mman.h>
-#include <sys/ioctl.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-using namespace android;
-
-FG_device::FG_device(const char *dev_name, int usage)
-			: output_device(dev_name, usage)
-{
-		init();
-}
-
-FG_device::~FG_device()
-{
-		uninit();
-}
-
-static int switch_set(int fd0, int fd1, int flag)
-{
-    struct mxcfb_gbl_alpha gbl_alpha;
-    struct mxcfb_color_key key;
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-		  	key.enable = 1;
-		  	key.color_key = 0x00000000; //black
-		  	if(ioctl(fd0, MXCFB_SET_CLR_KEY, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-
-		  	gbl_alpha.alpha = 128;
-		  	gbl_alpha.enable = 1;
-		  	if(ioctl(fd0, MXCFB_SET_GBL_ALPHA, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-  	}
-
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-		  	key.enable = 1;
-		  	key.color_key = 0x00000000; //black
-		  	if(ioctl(fd1, MXCFB_SET_CLR_KEY, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-
-		  	gbl_alpha.alpha = 255;
-		  	gbl_alpha.enable = 1;
-		  	if(ioctl(fd1, MXCFB_SET_GBL_ALPHA, &key) < 0) {
-		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
-		    	  return -1;
-		  	}
-  	}
-
-		return 0;
-}
-
-static int overlay_switch(int fd0, int fd1, int fd2, int flag)
-{
-		int blank = 1;
-  	int fp_property;
-  	char overlayStr[32];
-  	// it may be modified in mx6x.
-
-		if(ioctl(fd2, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
-        return -1;
-		}
-
-		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!BLANK FB1 failed!\n");
-	      return -1;
-		}
-
-	  if(ioctl(fd0, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
-	      return -1;
-		}
-
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-  			//fp_property;
-
-		    HWCOMPOSER_LOG_ERR("Open fb0/fsl_disp_property");
-		    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0);
-		    if(fp_property < 0) {
-		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
-		         return -1;
-		    }
-
-		    memset(overlayStr, 0 ,32);
-		    strcpy(overlayStr, "1-layer-fb\n");
-		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb0/fsl_disp_property");
-		    write(fp_property, overlayStr, strlen(overlayStr)+1);
-		    close(fp_property);
-
-  	}
-  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-		    HWCOMPOSER_LOG_ERR("Open fb1/fsl_disp_property");
-		    fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0);
-		    if(fp_property < 0) {
-		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
-		         return -1;
-		    }
-
-		    memset(overlayStr, 0 ,32);
-		    strcpy(overlayStr, "1-layer-fb\n");
-		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb1/fsl_disp_property");
-		    write(fp_property, overlayStr, strlen(overlayStr)+1);
-		    close(fp_property);
-  	}
-
-    blank = FB_BLANK_UNBLANK;
-		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB1 failed!\n");
-	      return -1;
-		}
-
-		if(ioctl(fd0, FBIOBLANK, blank) < 0) {
-				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB0 failed!\n");
-	      return -1;
-		}
-
-		return 0;
-}
-
-int FG_device::init()
-{
-    int status = -EINVAL;
-    int fbSize = 0;
-    void *vaddr = NULL;
-HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
-    if(m_dev <= 0) {
-        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_init() invalid parameter!");
-        return -1;
-    }
-#if 1
-    //fist open fb0 device that it is binded to.
-    //it may be modified in mx6x
-    int fd_def = -1;
-    int fd_fb1 = -1;
-    if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
-HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
-	    fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_def < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
-	    	  return -1;
-	    }
-			fd_fb1 = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_fb1 < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
-	    	  return -1;
-	    }
-
-  	}
-    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
-	    fd_def = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_def < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
-	    	  return -1;
-	    }
-			fd_fb1 = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
-	    if(fd_fb1 < 0) {
-	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
-	    	  return -1;
-	    }
-  	}
-  	//it may be modified in mx6x
-
-//    status = overlay_switch(fd_def, fd_fb1, m_dev, m_usage);
-
-    struct fb_var_screeninfo def_info;
-    if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
-    	  return -1;
-    }
-
-    struct fb_fix_screeninfo def_finfo;
-    if(ioctl(fd_def, FBIOGET_FSCREENINFO, &def_finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO def getting failed!");
-    	  return -1;
-    }
-
-    struct fb_var_screeninfo info;
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-    struct fb_fix_screeninfo finfo;
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-   // m_left = 0;
-   // m_top = 0;
-    m_width = def_info.xres;//info.xres;
-    m_height = def_info.yres;//info.yres;
-    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
-
-  	info.reserved[0] = def_info.reserved[0];
-  	info.reserved[1] = def_info.reserved[0];
-  	info.reserved[2] = def_info.reserved[0];
-  	info.xoffset = 0;
-  	info.yoffset = 0;
-  	info.activate = FB_ACTIVATE_NOW;
-
-  	info.bits_per_pixel = fmt_to_bpp(m_format);//def_info.bits_per_pixel;
-  	info.nonstd = m_format;
-  	info.red.offset = 0;//def_info.red.offset;
-  	info.red.length = 0;//def_info.red.length;
-  	info.green.offset = 0;//def_info.green.offset;
-  	info.green.length = 0;//def_info.green.length;
-  	info.blue.offset = 0;//def_info.blue.offset;
-  	info.blue.length = 0;//def_info.blue.length;
-  	info.transp.offset = 0;//def_info.transp.offset;
-  	info.transp.length = 0;//def_info.transp.length;
-
-  	info.xres = m_width;
-  	info.yres = m_height;
-  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
-  	info.xres_virtual = ALIGN_PIXEL(info.xres);
-
-    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO setting failed!");
-    	  return -1;
-    }
-
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 FSCREENINFO getting failed!");
-    	  return -1;
-    }
-
-  	if(finfo.smem_len <= 0) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init finfo.smem_len < 0!");
-    	  return -1;
-  	}
-
-  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
-  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
-  	if(vaddr == MAP_FAILED) {
-    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init mapping the framebuffer error(%s)!", strerror(errno));
-    	  return -1;
-  	}
-    //memset(vaddr, 0, fbSize);
-    hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format);
-    int blank = FB_BLANK_UNBLANK;
-	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-		HWCOMPOSER_LOG_ERR("Error!FG_device::init UNBLANK FB1 failed!\n");
-        return -1;
-	}
-  	//do it after switch fb2 to fb1 or fb0
-  	//status = switch_set(fd_def, fd_fb1, m_usage);
-  	close(fd_def);
-  	close(fd_fb1);
-
-  	mbuffer_count = DEFAULT_BUFFERS;
-  	mbuffer_cur = 0;
-  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
-		(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
-		(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
-		(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
-		(mbuffers[i]).width = m_width;
-        (mbuffers[i]).height = m_height;
-        (mbuffers[i]).format = m_format;
-  	}
-
-  	//pthread_mutex_init(&dev->buf_mutex, NULL);
-#endif
-    status = 0;
-    return status;
-}
-
-int FG_device::uninit()
-{
-	  //int status = -EINVAL;
-    int blank = 1;
-    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::uninit()------------");
-
-    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
-		HWCOMPOSER_LOG_ERR("Error!FG_device::uninit BLANK FB2 failed!\n");
-        //return -1;
-	}
-	munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
-    close(m_dev);
-    return 0;
-}
-
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <linux/fb.h>
+#include <linux/mxcfb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+using namespace android;
+
+FG_device::FG_device(const char *dev_name, int usage)
+			: output_device(dev_name, usage)
+{
+		init();
+}
+
+FG_device::~FG_device()
+{
+		uninit();
+}
+
+static int switch_set(int fd0, int fd1, int flag)
+{
+    struct mxcfb_gbl_alpha gbl_alpha;
+    struct mxcfb_color_key key;
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+		  	key.enable = 1;
+		  	key.color_key = 0x00000000; //black
+		  	if(ioctl(fd0, MXCFB_SET_CLR_KEY, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+
+		  	gbl_alpha.alpha = 128;
+		  	gbl_alpha.enable = 1;
+		  	if(ioctl(fd0, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+  	}
+
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+		  	key.enable = 1;
+		  	key.color_key = 0x00000000; //black
+		  	if(ioctl(fd1, MXCFB_SET_CLR_KEY, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+
+		  	gbl_alpha.alpha = 255;
+		  	gbl_alpha.enable = 1;
+		  	if(ioctl(fd1, MXCFB_SET_GBL_ALPHA, &key) < 0) {
+		    	  HWCOMPOSER_LOG_ERR("Error! MXCFB_SET_CLR_KEY failed!");
+		    	  return -1;
+		  	}
+  	}
+
+		return 0;
+}
+
+static int overlay_switch(int fd0, int fd1, int fd2, int flag)
+{
+		int blank = 1;
+  	int fp_property;
+  	char overlayStr[32];
+  	// it may be modified in mx6x.
+
+		if(ioctl(fd2, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
+        return -1;
+		}
+
+		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB1 failed!\n");
+	      return -1;
+		}
+
+	  if(ioctl(fd0, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!BLANK FB0 failed!\n");
+	      return -1;
+		}
+
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+  			//fp_property;
+
+		    HWCOMPOSER_LOG_ERR("Open fb0/fsl_disp_property");
+		    fp_property = open("/sys/class/graphics/fb0/fsl_disp_property",O_RDWR, 0);
+		    if(fp_property < 0) {
+		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
+		         return -1;
+		    }
+
+		    memset(overlayStr, 0 ,32);
+		    strcpy(overlayStr, "1-layer-fb\n");
+		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb0/fsl_disp_property");
+		    write(fp_property, overlayStr, strlen(overlayStr)+1);
+		    close(fp_property);
+
+  	}
+  	if(flag & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+		    HWCOMPOSER_LOG_ERR("Open fb1/fsl_disp_property");
+		    fp_property = open("/sys/class/graphics/fb1/fsl_disp_property",O_RDWR, 0);
+		    if(fp_property < 0) {
+		         HWCOMPOSER_LOG_ERR("Error!Cannot switch the overlay to second disp");
+		         return -1;
+		    }
+
+		    memset(overlayStr, 0 ,32);
+		    strcpy(overlayStr, "1-layer-fb\n");
+		    HWCOMPOSER_LOG_ERR("WRITE 1-layer-fb to fb1/fsl_disp_property");
+		    write(fp_property, overlayStr, strlen(overlayStr)+1);
+		    close(fp_property);
+  	}
+
+    blank = FB_BLANK_UNBLANK;
+		if(ioctl(fd1, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB1 failed!\n");
+	      return -1;
+		}
+
+		if(ioctl(fd0, FBIOBLANK, blank) < 0) {
+				HWCOMPOSER_LOG_ERR("Error!UNBLANK FB0 failed!\n");
+	      return -1;
+		}
+
+		return 0;
+}
+
+int FG_device::init()
+{
+    int status = -EINVAL;
+    int fbSize = 0;
+    void *vaddr = NULL;
+HWCOMPOSER_LOG_RUNTIME("---------------FG_device::init()------------");
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_init() invalid parameter!");
+        return -1;
+    }
+#if 1
+    //fist open fb0 device that it is binded to.
+    //it may be modified in mx6x
+    int fd_def = -1;
+    int fd_fb1 = -1;
+    if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP0) {
+HWCOMPOSER_LOG_RUNTIME("-------------FG_device::init()---open fb0-------------");
+	    fd_def = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_def < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
+	    	  return -1;
+	    }
+			fd_fb1 = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_fb1 < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  return -1;
+	    }
+
+  	}
+    else if(m_usage & GRALLOC_USAGE_HWC_OVERLAY_DISP1) {
+	    fd_def = open(FB1_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_def < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", FB1_DEV_NAME);
+	    	  return -1;
+	    }
+			fd_fb1 = open(DEFAULT_FB_DEV_NAME, O_RDWR | O_NONBLOCK, 0);
+	    if(fd_fb1 < 0) {
+	    	  HWCOMPOSER_LOG_ERR("Error! Open fb device %s failed!", DEFAULT_FB_DEV_NAME);
+	    	  return -1;
+	    }
+  	}
+  	//it may be modified in mx6x
+
+//    status = overlay_switch(fd_def, fd_fb1, m_dev, m_usage);
+
+    struct fb_var_screeninfo def_info;
+    if(ioctl(fd_def, FBIOGET_VSCREENINFO, &def_info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO def getting failed!");
+    	  return -1;
+    }
+
+    struct fb_fix_screeninfo def_finfo;
+    if(ioctl(fd_def, FBIOGET_FSCREENINFO, &def_finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO def getting failed!");
+    	  return -1;
+    }
+
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init VSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init FSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+   // m_left = 0;
+   // m_top = 0;
+    m_width = def_info.xres;//info.xres;
+    m_height = def_info.yres;//info.yres;
+    m_format = fourcc('R', 'G', 'B', 'P');//('U', 'Y', 'V', 'Y');
+
+  	info.reserved[0] = def_info.reserved[0];
+  	info.reserved[1] = def_info.reserved[0];
+  	info.reserved[2] = def_info.reserved[0];
+  	info.xoffset = 0;
+  	info.yoffset = 0;
+  	info.activate = FB_ACTIVATE_NOW;
+
+  	info.bits_per_pixel = fmt_to_bpp(m_format);//def_info.bits_per_pixel;
+  	info.nonstd = m_format;
+  	info.red.offset = 0;//def_info.red.offset;
+  	info.red.length = 0;//def_info.red.length;
+  	info.green.offset = 0;//def_info.green.offset;
+  	info.green.length = 0;//def_info.green.length;
+  	info.blue.offset = 0;//def_info.blue.offset;
+  	info.blue.length = 0;//def_info.blue.length;
+  	info.transp.offset = 0;//def_info.transp.offset;
+  	info.transp.length = 0;//def_info.transp.length;
+
+  	info.xres = m_width;
+  	info.yres = m_height;
+  	info.yres_virtual = ALIGN_PIXEL_128(info.yres) * DEFAULT_BUFFERS;
+  	info.xres_virtual = ALIGN_PIXEL(info.xres);
+
+    if(ioctl(m_dev, FBIOPUT_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO setting failed!");
+    	  return -1;
+    }
+
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 VSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init-2 FSCREENINFO getting failed!");
+    	  return -1;
+    }
+
+  	if(finfo.smem_len <= 0) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init finfo.smem_len < 0!");
+    	  return -1;
+  	}
+
+  	fbSize = roundUpToPageSize(finfo.line_length * info.yres_virtual);
+  	vaddr = mmap(0, fbSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_dev, 0);
+  	if(vaddr == MAP_FAILED) {
+    	  HWCOMPOSER_LOG_ERR("Error! FG_device::init mapping the framebuffer error(%s)!", strerror(errno));
+    	  return -1;
+  	}
+    //memset(vaddr, 0, fbSize);
+    hwc_fill_frame_back((char *)vaddr, fbSize, m_width, m_height, m_format);
+    int blank = FB_BLANK_UNBLANK;
+	if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!FG_device::init UNBLANK FB1 failed!\n");
+        return -1;
+	}
+  	//do it after switch fb2 to fb1 or fb0
+  	//status = switch_set(fd_def, fd_fb1, m_usage);
+  	close(fd_def);
+  	close(fd_fb1);
+
+  	mbuffer_count = DEFAULT_BUFFERS;
+  	mbuffer_cur = 0;
+  	for(int i = 0; i < DEFAULT_BUFFERS; i++){
+		(mbuffers[i]).size = fbSize/DEFAULT_BUFFERS;
+		(mbuffers[i]).virt_addr = (void *)((unsigned long)vaddr + i * (mbuffers[i]).size);
+		(mbuffers[i]).phy_addr = finfo.smem_start + i * (mbuffers[i]).size;
+		(mbuffers[i]).width = m_width;
+        (mbuffers[i]).height = m_height;
+        (mbuffers[i]).format = m_format;
+  	}
+
+  	//pthread_mutex_init(&dev->buf_mutex, NULL);
+#endif
+    status = 0;
+    return status;
+}
+
+int FG_device::uninit()
+{
+	  //int status = -EINVAL;
+    int blank = 1;
+    HWCOMPOSER_LOG_RUNTIME("---------------FG_device::uninit()------------");
+
+    if(ioctl(m_dev, FBIOBLANK, blank) < 0) {
+		HWCOMPOSER_LOG_ERR("Error!FG_device::uninit BLANK FB2 failed!\n");
+        //return -1;
+	}
+	munmap((mbuffers[0]).virt_addr, (mbuffers[0]).size * DEFAULT_BUFFERS);
+    close(m_dev);
+    return 0;
+}
+
diff --git a/mx5x/hwcomposer/blit_gpu.cpp b/mx5x/hwcomposer/blit_gpu.cpp
index d7b81c5..4fc2421 100755
--- a/mx5x/hwcomposer/blit_gpu.cpp
+++ b/mx5x/hwcomposer/blit_gpu.cpp
@@ -1,43 +1,43 @@
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include "blit_gpu.h"
-/*****************************************************************************/
-using namespace android;
-
-blit_gpu::blit_gpu()
-{
-		init();
-}
-
-blit_gpu::~blit_gpu()
-{
-		uninit();
-}
-
-int blit_gpu::init()
-{
-		return 0;
-}
-
-int blit_gpu::uninit()
-{
-		return 0;
-}
-
-int blit_gpu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
-{
-		return 0;
-}
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_gpu.h"
+/*****************************************************************************/
+using namespace android;
+
+blit_gpu::blit_gpu()
+{
+		init();
+}
+
+blit_gpu::~blit_gpu()
+{
+		uninit();
+}
+
+int blit_gpu::init()
+{
+		return 0;
+}
+
+int blit_gpu::uninit()
+{
+		return 0;
+}
+
+int blit_gpu::blit(hwc_layer_t *layer, hwc_buffer *out_buf)
+{
+		return 0;
+}
diff --git a/mx5x/hwcomposer/blit_gpu.h b/mx5x/hwcomposer/blit_gpu.h
index 04e86f0..ed8f5d9 100755
--- a/mx5x/hwcomposer/blit_gpu.h
+++ b/mx5x/hwcomposer/blit_gpu.h
@@ -1,42 +1,42 @@
-#ifndef _BLIT_GPU_H_
-#define _BLIT_GPU_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-/*****************************************************************************/
-
-class blit_gpu : public blit_device{
-public:  
-    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
-
-		blit_gpu();
-		virtual ~blit_gpu();
-    
-private:
-		int init();
-    int uninit();
-	
-		blit_gpu& operator = (blit_gpu& out);
-		blit_gpu(const blit_gpu& out);  
-    //add private members.		    
-};
-
-
-//int gpu_init(struct blit_device *dev);
-//
-//int gpu_uninit(struct blit_device*dev);
-//
-//int gpu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
-
-#endif
+#ifndef _BLIT_GPU_H_
+#define _BLIT_GPU_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+/*****************************************************************************/
+
+class blit_gpu : public blit_device{
+public:  
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
+
+		blit_gpu();
+		virtual ~blit_gpu();
+    
+private:
+		int init();
+    int uninit();
+	
+		blit_gpu& operator = (blit_gpu& out);
+		blit_gpu(const blit_gpu& out);  
+    //add private members.		    
+};
+
+
+//int gpu_init(struct blit_device *dev);
+//
+//int gpu_uninit(struct blit_device*dev);
+//
+//int gpu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
+
+#endif
diff --git a/mx5x/hwcomposer/blit_ipu.h b/mx5x/hwcomposer/blit_ipu.h
index 8f641a5..b12114f 100755
--- a/mx5x/hwcomposer/blit_ipu.h
+++ b/mx5x/hwcomposer/blit_ipu.h
@@ -1,52 +1,52 @@
-#ifndef _BLIT_IPU_H_
-#define _BLIT_IPU_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-extern "C" {
-#include "mxc_ipu_hl_lib.h"
-}
-/*****************************************************************************/
-
-#define BLIT_PIXEL_FORMAT_RGB_565  209
-
-class blit_ipu : public blit_device
-{
-public:
-    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
-
-		blit_ipu();
-		virtual ~blit_ipu();
-
-private:
-		ipu_lib_input_param_t  mIPUInputParam;
-    ipu_lib_output_param_t mIPUOutputParam;
-    ipu_lib_handle_t       mIPUHandle;
-//    int                    mIPURet;
-private:
-		int init();
-    int uninit();
-
-		blit_ipu& operator = (blit_ipu& out);
-		blit_ipu(const blit_ipu& out);
-};
-
-
-//int ipu_init(struct blit_device *dev);
-//
-//int ipu_uninit(struct blit_device*dev);
-//
-//int ipu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
-
-#endif // _BLIT_IPU_H_
+#ifndef _BLIT_IPU_H_
+#define _BLIT_IPU_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h"
+}
+/*****************************************************************************/
+
+#define BLIT_PIXEL_FORMAT_RGB_565  209
+
+class blit_ipu : public blit_device
+{
+public:
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf);
+
+		blit_ipu();
+		virtual ~blit_ipu();
+
+private:
+		ipu_lib_input_param_t  mIPUInputParam;
+    ipu_lib_output_param_t mIPUOutputParam;
+    ipu_lib_handle_t       mIPUHandle;
+//    int                    mIPURet;
+private:
+		int init();
+    int uninit();
+
+		blit_ipu& operator = (blit_ipu& out);
+		blit_ipu(const blit_ipu& out);
+};
+
+
+//int ipu_init(struct blit_device *dev);
+//
+//int ipu_uninit(struct blit_device*dev);
+//
+//int ipu_blit(struct blit_device *dev, hwc_layer_t *layer, hwc_buffer *out_buf);
+
+#endif // _BLIT_IPU_H_
diff --git a/mx5x/hwcomposer/hwc_common.cpp b/mx5x/hwcomposer/hwc_common.cpp
index f0f147d..ec2a88b 100755
--- a/mx5x/hwcomposer/hwc_common.cpp
+++ b/mx5x/hwcomposer/hwc_common.cpp
@@ -1,216 +1,216 @@
-
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-#include "blit_gpu.h"
-#include "blit_ipu.h"
-extern "C" {
-#include "mxc_ipu_hl_lib.h" 
-}
-/*****************************************************************************/
-using namespace android;
-//int hwc_check_property(hwc_context_t *dev)
-//{
-//    bool bValue = false;
-//    char value[10];
-//    property_get("rw.VIDEO_TVOUT_DISPLAY", value, "");
-//    if (strcmp(value, "1") == 0)
-//        bValue = true;
-//
-//    if((dev->display_mode == DISPLAY_MODE_TV)  !=  bValue){
-//        dev->display_mode = bValue ? DISPLAY_MODE_TV : DISPLAY_MODE_NORMAL;
-//        switchTvOut(dev);
-//        *mode_changed = true;
-//        return 0;
-//    }
-//
-//    bValue = false;
-//    property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
-//    if (strcmp(value, "1") == 0)
-//        bValue = true;
-//
-//    if((dev->display_mode == DISPLAY_MODE_DUAL_DISP)  !=  bValue){
-//        dev->display_mode = bValue ? DISPLAY_MODE_DUAL_DISP : DISPLAY_MODE_NORMAL;
-//        switchDualDisp(dev);
-//        *mode_changed = true;
-//    }    	
-//		return 0;
-//}
-
-
-unsigned long fmt_to_bpp(unsigned long pixelformat)
-{
-	unsigned long bpp;
-
-	switch (pixelformat)
-	{
-		case OUT_PIX_FMT_RGB565:
-		/*interleaved 422*/
-		case OUT_PIX_FMT_YUYV:
-		case OUT_PIX_FMT_UYVY:
-		/*non-interleaved 422*/
-		case OUT_PIX_FMT_YUV422P:
-		case OUT_PIX_FMT_YVU422P:
-			bpp = 16;
-			break;
-		case OUT_PIX_FMT_BGR24:
-		case OUT_PIX_FMT_RGB24:
-		case OUT_PIX_FMT_YUV444:
-			bpp = 24;
-			break;
-		case OUT_PIX_FMT_BGR32:
-		case OUT_PIX_FMT_BGRA32:
-		case OUT_PIX_FMT_RGB32:
-		case OUT_PIX_FMT_RGBA32:
-		case OUT_PIX_FMT_ABGR32:
-			bpp = 32;
-			break;
-		/*non-interleaved 420*/
-		case OUT_PIX_FMT_YUV420P:
-		case OUT_PIX_FMT_YVU420P:
-		case OUT_PIX_FMT_YUV420P2:
-		case OUT_PIX_FMT_NV12:
-			bpp = 12;
-			break;
-		default:
-			bpp = 8;
-			break;
-	}
-	return bpp;
-}
-
-int hwc_fill_frame_back(char * frame,int frame_size, int xres,
-                           int yres, unsigned int pixelformat)
-{
-    int ret = 0;
-    char * base;
-    int j, screen_size;
-    short * tmp;
-    short color;
-    if((xres<=0)||(yres<=0)||(!frame)) {
-        HWCOMPOSER_LOG_ERR("Error!Not valid parameters in fill_frame_back");
-        return -1;
-    }
-    switch(pixelformat) {
-        case OUT_PIX_FMT_RGB565:
-            memset(frame, 0, frame_size);
-            break;
-        case OUT_PIX_FMT_YUYV:
-        case OUT_PIX_FMT_UYVY:
-            tmp = (short *) frame;
-            if(pixelformat == OUT_PIX_FMT_YUYV)
-               color = 0x8000;
-            else
-               color = 0x80;
-            for(int i = 0; i < frame_size/2;i++, tmp++)
-                *tmp = color;
-            break;
-        case OUT_PIX_FMT_YUV422P:
-            base = (char *)frame;
-            screen_size = xres * yres;
-            memset(base, 0, frame_size);
-            base += screen_size;
-            for (int i = 0; i < screen_size; i++, base++)
-                *base = 0x80;
-            break;
-        case OUT_PIX_FMT_YUV420:
-        case OUT_PIX_FMT_YVU420:
-        case OUT_PIX_FMT_NV12:
-            base = (char *)frame;
-            screen_size = xres * yres;
-            memset(base, 0, frame_size);
-            base += screen_size;
-            for (int i = 0; i < screen_size/2; i++, base++)
-                 *base = 0x80;
-            break;
-        defaule:
-            HWCOMPOSER_LOG_ERR("Error!Not supported pixel format");
-            ret = -1;
-            break;
-    }
-    return ret;
-}
-
-int blit_dev_open(const char *dev_name, blit_device **device)
-{
-	  int status = -EINVAL;
-	  
-	  int isIPU = blit_device::isIPUDevice(dev_name);	  
-	  if(isIPU) {
-	  	  blit_ipu *dev;
-	  	  dev = new blit_ipu();
-	  	  if(dev == NULL)
-	  	      return status;
-	  	  
-	  	  *device = (blit_device *)dev;
-	  	  return 0;
-	  }
-	  
-	  int isGPU = blit_device::isGPUDevice(dev_name);
-	  if(isGPU) {
-	  	  blit_gpu *dev;
-	  	  dev = new blit_gpu();
-	  	  if(dev == NULL)
-	  	      return status;
-	  	      	  	  
-	  	  *device = (blit_device *)dev;
-	  	  return 0;	  	  	  
-	  }	  
-	  
-	  return status;
-}
-
-int blit_dev_close(blit_device *dev)
-{
-		delete(dev);
-		return 0;
-}
-
-int output_dev_open(const char *dev_name, output_device **device, int flag)
-{
-   	int is_overlay = output_device::isFGDevice(dev_name);
-HWCOMPOSER_LOG_INFO("!!!!!!!!!!!!!!!!!!!!!!!!!output_dev_open: %s", dev_name);   	
-   	if(is_overlay < 0) {
-   			return HWC_EGL_ERROR;
-   	}
-   	
-    if(is_overlay == 1) {
-HWCOMPOSER_LOG_RUNTIME("******output_dev_open() is_overlay =1");    	
-			  FG_device *dev;
-			  dev = new FG_device(dev_name, flag);
-			  	  if(dev == NULL)
-			  	      return HWC_EGL_ERROR;
-			
-			  //dev->setUsage(flag);					   	
-    		*device = (output_device *)dev;
-    }
-		else {
-			  BG_device *dev;
-			  dev = new BG_device(dev_name, flag);
-			  	  if(dev == NULL)
-			  	      return HWC_EGL_ERROR;
-			
-			  //dev->setUsage(flag);	  	
-    		*device = (output_device *)dev;
-		}
-       
-    return 0;
-}
-
-int output_dev_close(output_device *dev)
-{
-  	delete(dev); 
-  	
-  	return 0;
-}
+
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+#include "blit_gpu.h"
+#include "blit_ipu.h"
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+}
+/*****************************************************************************/
+using namespace android;
+//int hwc_check_property(hwc_context_t *dev)
+//{
+//    bool bValue = false;
+//    char value[10];
+//    property_get("rw.VIDEO_TVOUT_DISPLAY", value, "");
+//    if (strcmp(value, "1") == 0)
+//        bValue = true;
+//
+//    if((dev->display_mode == DISPLAY_MODE_TV)  !=  bValue){
+//        dev->display_mode = bValue ? DISPLAY_MODE_TV : DISPLAY_MODE_NORMAL;
+//        switchTvOut(dev);
+//        *mode_changed = true;
+//        return 0;
+//    }
+//
+//    bValue = false;
+//    property_get("sys.SECOND_DISPLAY_ENABLED", value, "");
+//    if (strcmp(value, "1") == 0)
+//        bValue = true;
+//
+//    if((dev->display_mode == DISPLAY_MODE_DUAL_DISP)  !=  bValue){
+//        dev->display_mode = bValue ? DISPLAY_MODE_DUAL_DISP : DISPLAY_MODE_NORMAL;
+//        switchDualDisp(dev);
+//        *mode_changed = true;
+//    }    	
+//		return 0;
+//}
+
+
+unsigned long fmt_to_bpp(unsigned long pixelformat)
+{
+	unsigned long bpp;
+
+	switch (pixelformat)
+	{
+		case OUT_PIX_FMT_RGB565:
+		/*interleaved 422*/
+		case OUT_PIX_FMT_YUYV:
+		case OUT_PIX_FMT_UYVY:
+		/*non-interleaved 422*/
+		case OUT_PIX_FMT_YUV422P:
+		case OUT_PIX_FMT_YVU422P:
+			bpp = 16;
+			break;
+		case OUT_PIX_FMT_BGR24:
+		case OUT_PIX_FMT_RGB24:
+		case OUT_PIX_FMT_YUV444:
+			bpp = 24;
+			break;
+		case OUT_PIX_FMT_BGR32:
+		case OUT_PIX_FMT_BGRA32:
+		case OUT_PIX_FMT_RGB32:
+		case OUT_PIX_FMT_RGBA32:
+		case OUT_PIX_FMT_ABGR32:
+			bpp = 32;
+			break;
+		/*non-interleaved 420*/
+		case OUT_PIX_FMT_YUV420P:
+		case OUT_PIX_FMT_YVU420P:
+		case OUT_PIX_FMT_YUV420P2:
+		case OUT_PIX_FMT_NV12:
+			bpp = 12;
+			break;
+		default:
+			bpp = 8;
+			break;
+	}
+	return bpp;
+}
+
+int hwc_fill_frame_back(char * frame,int frame_size, int xres,
+                           int yres, unsigned int pixelformat)
+{
+    int ret = 0;
+    char * base;
+    int j, screen_size;
+    short * tmp;
+    short color;
+    if((xres<=0)||(yres<=0)||(!frame)) {
+        HWCOMPOSER_LOG_ERR("Error!Not valid parameters in fill_frame_back");
+        return -1;
+    }
+    switch(pixelformat) {
+        case OUT_PIX_FMT_RGB565:
+            memset(frame, 0, frame_size);
+            break;
+        case OUT_PIX_FMT_YUYV:
+        case OUT_PIX_FMT_UYVY:
+            tmp = (short *) frame;
+            if(pixelformat == OUT_PIX_FMT_YUYV)
+               color = 0x8000;
+            else
+               color = 0x80;
+            for(int i = 0; i < frame_size/2;i++, tmp++)
+                *tmp = color;
+            break;
+        case OUT_PIX_FMT_YUV422P:
+            base = (char *)frame;
+            screen_size = xres * yres;
+            memset(base, 0, frame_size);
+            base += screen_size;
+            for (int i = 0; i < screen_size; i++, base++)
+                *base = 0x80;
+            break;
+        case OUT_PIX_FMT_YUV420:
+        case OUT_PIX_FMT_YVU420:
+        case OUT_PIX_FMT_NV12:
+            base = (char *)frame;
+            screen_size = xres * yres;
+            memset(base, 0, frame_size);
+            base += screen_size;
+            for (int i = 0; i < screen_size/2; i++, base++)
+                 *base = 0x80;
+            break;
+        defaule:
+            HWCOMPOSER_LOG_ERR("Error!Not supported pixel format");
+            ret = -1;
+            break;
+    }
+    return ret;
+}
+
+int blit_dev_open(const char *dev_name, blit_device **device)
+{
+	  int status = -EINVAL;
+	  
+	  int isIPU = blit_device::isIPUDevice(dev_name);	  
+	  if(isIPU) {
+	  	  blit_ipu *dev;
+	  	  dev = new blit_ipu();
+	  	  if(dev == NULL)
+	  	      return status;
+	  	  
+	  	  *device = (blit_device *)dev;
+	  	  return 0;
+	  }
+	  
+	  int isGPU = blit_device::isGPUDevice(dev_name);
+	  if(isGPU) {
+	  	  blit_gpu *dev;
+	  	  dev = new blit_gpu();
+	  	  if(dev == NULL)
+	  	      return status;
+	  	      	  	  
+	  	  *device = (blit_device *)dev;
+	  	  return 0;	  	  	  
+	  }	  
+	  
+	  return status;
+}
+
+int blit_dev_close(blit_device *dev)
+{
+		delete(dev);
+		return 0;
+}
+
+int output_dev_open(const char *dev_name, output_device **device, int flag)
+{
+   	int is_overlay = output_device::isFGDevice(dev_name);
+HWCOMPOSER_LOG_INFO("!!!!!!!!!!!!!!!!!!!!!!!!!output_dev_open: %s", dev_name);   	
+   	if(is_overlay < 0) {
+   			return HWC_EGL_ERROR;
+   	}
+   	
+    if(is_overlay == 1) {
+HWCOMPOSER_LOG_RUNTIME("******output_dev_open() is_overlay =1");    	
+			  FG_device *dev;
+			  dev = new FG_device(dev_name, flag);
+			  	  if(dev == NULL)
+			  	      return HWC_EGL_ERROR;
+			
+			  //dev->setUsage(flag);					   	
+    		*device = (output_device *)dev;
+    }
+		else {
+			  BG_device *dev;
+			  dev = new BG_device(dev_name, flag);
+			  	  if(dev == NULL)
+			  	      return HWC_EGL_ERROR;
+			
+			  //dev->setUsage(flag);	  	
+    		*device = (output_device *)dev;
+		}
+       
+    return 0;
+}
+
+int output_dev_close(output_device *dev)
+{
+  	delete(dev); 
+  	
+  	return 0;
+}
diff --git a/mx5x/hwcomposer/hwc_common.h b/mx5x/hwcomposer/hwc_common.h
index 4016df1..60359bd 100755
--- a/mx5x/hwcomposer/hwc_common.h
+++ b/mx5x/hwcomposer/hwc_common.h
@@ -1,223 +1,223 @@
-
-#ifndef _HWC_FSL_H_
-#define _HWC_FSL_H_
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <utils/threads.h>
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include <asm/page.h>
-#include <ui/Rect.h>
-#include <ui/Region.h>
-
-#undef LOG_TAG
-#define LOG_TAG "FslHwcomposer"
-#include <utils/Log.h>
-
-//#define HWCOMPOSER__DEBUG_LOG
-
-#ifdef HWCOMPOSER_DEBUG_LOG
-#define HWCOMPOSER_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
-#define HWCOMPOSER_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
-#else
-#define HWCOMPOSER_LOG_RUNTIME(format, ...)
-#define HWCOMPOSER_LOG_FUNC
-#endif
-
-#define HWCOMPOSER_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
-#define HWCOMPOSER_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
-
-#define HWCOMPOSER_LOG_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
-/*****************************************************************************/
-#define DEFAULT_FB_DEV_NAME "/dev/graphics/fb0"
-#define FB1_DEV_NAME "/dev/graphics/fb1"
-#define FB2_DEV_NAME "/dev/graphics/fb2"
-#define V4L_DEV_NAME "/dev/video16"
-#define MAX_OUTPUT_DISPLAY  10
-
-#define BLIT_IPU "blt_ipu"
-#define BLIT_GPU "blt_gpu"
-
-#define DEFAULT_BUFFERS  3 
-
-using namespace android;
-
-//typedef unsigned long __u32;
-#define fourcc(a, b, c, d)\
-	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
-
-#define OUT_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
-#define OUT_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
-#define OUT_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
-#define OUT_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
-#define OUT_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
-#define OUT_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
-#define OUT_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
-#define OUT_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
-
-#define OUT_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
-#define OUT_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
-#define OUT_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
-#define OUT_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
-#define OUT_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
-#define OUT_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
-#define OUT_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
-#define OUT_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
-#define OUT_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
-#define OUT_PIX_FMT_YUV420  fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
-#define OUT_PIX_FMT_YVU420  fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
-
-inline size_t roundUpToPageSize(size_t x) {
-    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
-}
-
-typedef enum {
-    DISPLAY_MODE_OVERLAY_DISP0 = 0x00000001,
-    DISPLAY_MODE_OVERLAY_DISP1 = 0x00000002,
-    DISPLAY_MODE_OVERLAY_DISP2 = 0x00000004,
-    DISPLAY_MODE_OVERLAY_DISP3 = 0x00000008,
-    DISPLAY_MODE_DISP1 = 0x00000010,
-    DISPLAY_MODE_DISP2 = 0x00000020,
-    DISPLAY_MODE_DISP3 = 0x00000040,
-}DISPLAY_MODE;
-
-//seperate into three groups. one group member can be or with other group member.
-//but the group member can not be or with that in the same group except display group.
-#define GRALLOC_USAGE_OVERLAY0_MASK   0x00300000
-#define GRALLOC_USAGE_OVERLAY1_MASK   0x00C00000
-#define GRALLOC_USAGE_DISPLAY_MASK    0x07000000
-#define GRALLOC_USAGE_OVERLAY_DISPLAY_MASK 0x07F00000
-
-typedef struct{
-    void *virt_addr;
-    unsigned long phy_addr;
-    unsigned long size;
-    int format;
-    int width;
-    int height;
-    int usage;
-    Region disp_region;
-}hwc_buffer;
-
-class output_device
-{
-public:
-		virtual int post(hwc_buffer *);
-		virtual int fetch(hwc_buffer *);
-
-		void setUsage(int usage);
-		int getUsage();
-		int getWidth();
-		int getHeight();
-        void setDisplayFrame(hwc_rect_t *disFrame);
-        int needFillBlack(hwc_buffer *buf);
-        void fillBlack(hwc_buffer *buf);
-
-		output_device(const char *dev_name, int usage);
-		virtual ~output_device();
-
-		static int isFGDevice(const char *dev_name);
-
-private:
-		output_device& operator = (output_device& out);
-		output_device(const output_device& out);
-
-protected:
-		int m_dev;
-		//int m_left;
-		//int m_top;
-		int m_usage;
-		int m_width;
-		int m_height;
-		int m_format;
-//		int is_overlay;
-
-        //Region orignRegion;
-        Region currenRegion;
-
-		mutable Mutex mLock;
-		hwc_buffer mbuffers[DEFAULT_BUFFERS];
-		unsigned long mbuffer_count;
-		unsigned long mbuffer_cur;
-
-};
-
-//the normal display device
-class BG_device : public output_device
-{
-public:
-//		virtual int post(hwc_buffer *);
-//		virtual int fetch(hwc_buffer *);
-
-		BG_device(const char *dev_name, int usage);
-		virtual ~BG_device();
-
-private:
-		BG_device& operator = (BG_device& out);
-		BG_device(const BG_device& out);
-
-		int init();
-		int uninit();
-
-public:
-		//add private data
-};
-
-//the overlay display device
-class FG_device : public output_device
-{
-public:
-//		virtual int post(hwc_buffer *);
-//		virtual int fetch(hwc_buffer *);
-
-		FG_device(const char *dev_name, int usage);
-		virtual ~FG_device();
-
-private:
-		FG_device& operator = (FG_device& out);
-		FG_device(const FG_device& out);
-
-		int init();
-		int uninit();
-
-private:
-		//add private data
-		//int m_flag; //for display number flag.
-};
-
-class blit_device{
-public:
-		static int isIPUDevice(const char *dev_name);
-		static int isGPUDevice(const char *dev_name);
-    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
-		virtual ~blit_device(){}
-};
-
-//int FG_init(struct output_device *dev);
-//int FG_uninit(struct output_device *dev);
-//int FG_fetch(struct output_device *dev, hwc_buffer *buf);
-//int FG_post(struct output_device *dev);
-//
-//int BG_init(struct output_device *dev);
-//int BG_uninit(struct output_device *dev);
-//int BG_fetch(struct output_device *dev, hwc_buffer *buf);
-//int BG_post(struct output_device *dev);
-unsigned long fmt_to_bpp(unsigned long pixelformat);
-int hwc_fill_frame_back(char * frame,int frame_size, int xres,
-                           int yres, unsigned int pixelformat);
-int blit_dev_open(const char *dev_name, blit_device **);
-int blit_dev_close(blit_device *);
-
-int output_dev_open(const char *dev_name, output_device **, int);
-int output_dev_close(output_device *);
-
-#endif
+
+#ifndef _HWC_FSL_H_
+#define _HWC_FSL_H_
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <utils/threads.h>
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include <asm/page.h>
+#include <ui/Rect.h>
+#include <ui/Region.h>
+
+#undef LOG_TAG
+#define LOG_TAG "FslHwcomposer"
+#include <utils/Log.h>
+
+//#define HWCOMPOSER__DEBUG_LOG
+
+#ifdef HWCOMPOSER_DEBUG_LOG
+#define HWCOMPOSER_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
+#define HWCOMPOSER_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
+#else
+#define HWCOMPOSER_LOG_RUNTIME(format, ...)
+#define HWCOMPOSER_LOG_FUNC
+#endif
+
+#define HWCOMPOSER_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
+#define HWCOMPOSER_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
+
+#define HWCOMPOSER_LOG_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
+/*****************************************************************************/
+#define DEFAULT_FB_DEV_NAME "/dev/graphics/fb0"
+#define FB1_DEV_NAME "/dev/graphics/fb1"
+#define FB2_DEV_NAME "/dev/graphics/fb2"
+#define V4L_DEV_NAME "/dev/video16"
+#define MAX_OUTPUT_DISPLAY  10
+
+#define BLIT_IPU "blt_ipu"
+#define BLIT_GPU "blt_gpu"
+
+#define DEFAULT_BUFFERS  3 
+
+using namespace android;
+
+//typedef unsigned long __u32;
+#define fourcc(a, b, c, d)\
+	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+#define OUT_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define OUT_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define OUT_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define OUT_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define OUT_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define OUT_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define OUT_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define OUT_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+
+#define OUT_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+#define OUT_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define OUT_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+#define OUT_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define OUT_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define OUT_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define OUT_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+#define OUT_PIX_FMT_YUV420  fourcc('Y', 'U', '1', '2') /* 12  YUV 4:2:0     */
+#define OUT_PIX_FMT_YVU420  fourcc('Y', 'V', '1', '2') /* 12  YVU 4:2:0     */
+
+inline size_t roundUpToPageSize(size_t x) {
+    return (x + (PAGE_SIZE-1)) & ~(PAGE_SIZE-1);
+}
+
+typedef enum {
+    DISPLAY_MODE_OVERLAY_DISP0 = 0x00000001,
+    DISPLAY_MODE_OVERLAY_DISP1 = 0x00000002,
+    DISPLAY_MODE_OVERLAY_DISP2 = 0x00000004,
+    DISPLAY_MODE_OVERLAY_DISP3 = 0x00000008,
+    DISPLAY_MODE_DISP1 = 0x00000010,
+    DISPLAY_MODE_DISP2 = 0x00000020,
+    DISPLAY_MODE_DISP3 = 0x00000040,
+}DISPLAY_MODE;
+
+//seperate into three groups. one group member can be or with other group member.
+//but the group member can not be or with that in the same group except display group.
+#define GRALLOC_USAGE_OVERLAY0_MASK   0x00300000
+#define GRALLOC_USAGE_OVERLAY1_MASK   0x00C00000
+#define GRALLOC_USAGE_DISPLAY_MASK    0x07000000
+#define GRALLOC_USAGE_OVERLAY_DISPLAY_MASK 0x07F00000
+
+typedef struct{
+    void *virt_addr;
+    unsigned long phy_addr;
+    unsigned long size;
+    int format;
+    int width;
+    int height;
+    int usage;
+    Region disp_region;
+}hwc_buffer;
+
+class output_device
+{
+public:
+		virtual int post(hwc_buffer *);
+		virtual int fetch(hwc_buffer *);
+
+		void setUsage(int usage);
+		int getUsage();
+		int getWidth();
+		int getHeight();
+        void setDisplayFrame(hwc_rect_t *disFrame);
+        int needFillBlack(hwc_buffer *buf);
+        void fillBlack(hwc_buffer *buf);
+
+		output_device(const char *dev_name, int usage);
+		virtual ~output_device();
+
+		static int isFGDevice(const char *dev_name);
+
+private:
+		output_device& operator = (output_device& out);
+		output_device(const output_device& out);
+
+protected:
+		int m_dev;
+		//int m_left;
+		//int m_top;
+		int m_usage;
+		int m_width;
+		int m_height;
+		int m_format;
+//		int is_overlay;
+
+        //Region orignRegion;
+        Region currenRegion;
+
+		mutable Mutex mLock;
+		hwc_buffer mbuffers[DEFAULT_BUFFERS];
+		unsigned long mbuffer_count;
+		unsigned long mbuffer_cur;
+
+};
+
+//the normal display device
+class BG_device : public output_device
+{
+public:
+//		virtual int post(hwc_buffer *);
+//		virtual int fetch(hwc_buffer *);
+
+		BG_device(const char *dev_name, int usage);
+		virtual ~BG_device();
+
+private:
+		BG_device& operator = (BG_device& out);
+		BG_device(const BG_device& out);
+
+		int init();
+		int uninit();
+
+public:
+		//add private data
+};
+
+//the overlay display device
+class FG_device : public output_device
+{
+public:
+//		virtual int post(hwc_buffer *);
+//		virtual int fetch(hwc_buffer *);
+
+		FG_device(const char *dev_name, int usage);
+		virtual ~FG_device();
+
+private:
+		FG_device& operator = (FG_device& out);
+		FG_device(const FG_device& out);
+
+		int init();
+		int uninit();
+
+private:
+		//add private data
+		//int m_flag; //for display number flag.
+};
+
+class blit_device{
+public:
+		static int isIPUDevice(const char *dev_name);
+		static int isGPUDevice(const char *dev_name);
+    virtual int blit(hwc_layer_t *layer, hwc_buffer *out_buf) = 0;
+		virtual ~blit_device(){}
+};
+
+//int FG_init(struct output_device *dev);
+//int FG_uninit(struct output_device *dev);
+//int FG_fetch(struct output_device *dev, hwc_buffer *buf);
+//int FG_post(struct output_device *dev);
+//
+//int BG_init(struct output_device *dev);
+//int BG_uninit(struct output_device *dev);
+//int BG_fetch(struct output_device *dev, hwc_buffer *buf);
+//int BG_post(struct output_device *dev);
+unsigned long fmt_to_bpp(unsigned long pixelformat);
+int hwc_fill_frame_back(char * frame,int frame_size, int xres,
+                           int yres, unsigned int pixelformat);
+int blit_dev_open(const char *dev_name, blit_device **);
+int blit_dev_close(blit_device *);
+
+int output_dev_open(const char *dev_name, output_device **, int);
+int output_dev_close(output_device *);
+
+#endif
diff --git a/mx5x/hwcomposer/output_device.cpp b/mx5x/hwcomposer/output_device.cpp
index 3ae381e..0022305 100755
--- a/mx5x/hwcomposer/output_device.cpp
+++ b/mx5x/hwcomposer/output_device.cpp
@@ -1,172 +1,172 @@
-
-#include <hardware/hardware.h>
-
-#include <fcntl.h>
-#include <errno.h>
-
-#include <cutils/log.h>
-#include <cutils/atomic.h>
-
-#include <hardware/hwcomposer.h>
-
-#include <EGL/egl.h>
-#include "gralloc_priv.h"
-#include "hwc_common.h"
-
-void output_device::setUsage(int usage)
-{
-    m_usage = usage;
-}
-
-int output_device::getUsage()
-{
-    return m_usage;
-}
-
-int output_device::getWidth()
-{
-    return m_width;
-}
-
-int output_device::getHeight()
-{
-    return m_height;
-}
-
-output_device::output_device(const char *dev_name, int usage)
-{
-    m_dev = open(dev_name, O_RDWR | O_NONBLOCK, 0);
-    if(m_dev < 0) {
-        HWCOMPOSER_LOG_ERR("Error! output_device Open fb device %s failed!", dev_name);
-    }
-    m_usage = usage;
-}
-
-output_device::~output_device()
-{
-	if(m_dev > 0) {
-        close(m_dev);
-	}
-}
-
-int output_device::isFGDevice(const char *dev_name)
-{
-    int status = -EINVAL;
-    int fd = -1;
-    char fb_usage[32];
-    char fb_name[32];
-    int fd_n = 0;
-    int size = 0;
-    int is_overlay = 0;
-    char *psname;
-
-    memset(fb_name, 0, sizeof(fb_name));
-    psname = (char *)dev_name;
-    psname += (strlen(dev_name) - 1);
-    strcpy(fb_name, "/sys/class/graphics/fb");
-    strcat(fb_name, psname);
-    strcat(fb_name, "/name");
-    fd_n = open(fb_name, O_RDONLY, 0);
-    //fd_n = open("/sys/class/graphics/fb0/name", O_RDONLY, 0);
-    if(fd_n < 0) {
-		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice  open %s failed!", fb_name);
-		return -1;
-    }
-    memset(fb_usage, 0, sizeof(fb_usage));
-    size = read(fd_n, fb_usage, sizeof(fb_usage));
-    if(size < 0) {
-		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice read /sys/class/graphics/fb0/name failed!");
-		return -1;
-    }
-    close(fd_n);
-HWCOMPOSER_LOG_INFO("output_device::isFGDevice===%s, %s, %s", dev_name, fb_name, fb_usage);
-    if(strstr(fb_usage, "FG"))
-    	return 1;
- 	return 0;
-}
-
-void output_device::setDisplayFrame(hwc_rect_t *disFrame)
-{
-    if(disFrame == NULL) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::setDisplayFrame invalid parameter!");
-    }
-    Rect disRect(disFrame->left, disFrame->top, disFrame->right, disFrame->bottom);
-    currenRegion.orSelf(disRect);
-}
-
-int output_device::needFillBlack(hwc_buffer *buf)
-{
-    Rect orignBound(buf->disp_region.getBounds());
-    Rect currentBound(currenRegion.getBounds());
-    return currentBound != orignBound;
-}
-
-void output_device::fillBlack(hwc_buffer *buf)
-{
-    if(buf == NULL) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::fillBlack invalid parameter!");
-        return;
-    }
-
-    hwc_fill_frame_back((char *)buf->virt_addr, buf->size, buf->width, buf->height, buf->format);
-}
-
-int output_device::fetch(hwc_buffer *buf)
-{
-	  //int status = -EINVAL;
-    if(m_dev <= 0 || buf == NULL) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::fetch invalid parameter! usage=%x", m_usage);
-        return -1;
-    }
-
-	  Mutex::Autolock _l(mLock);
-	  buf->size = (mbuffers[mbuffer_cur]).size;
-	  buf->virt_addr = (mbuffers[mbuffer_cur]).virt_addr;
-	  buf->phy_addr = (mbuffers[mbuffer_cur]).phy_addr;
-	  buf->width = m_width;
-	  buf->height = m_height;
-	  buf->usage = m_usage;
-	  buf->format = m_format;
-	  //dev->buffer_cur = (dev->buffer_cur + 1) % DEFAULT_BUFFERS;
-      if((m_usage & (GRALLOC_USAGE_OVERLAY0_MASK | GRALLOC_USAGE_OVERLAY1_MASK)) && needFillBlack(&mbuffers[mbuffer_cur])) {
-          fillBlack(&mbuffers[mbuffer_cur]);
-          mbuffers[mbuffer_cur].disp_region = currenRegion;
-      }
-      //orignRegion = currenRegion;
-      currenRegion.clear();
-
-	  return 0;
-}
-
-int output_device::post(hwc_buffer *buf)
-{
-	  //int status = -EINVAL;
-    if(m_dev <= 0) {
-        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_post() invalid parameter! usage=%x", m_usage);
-        return -1;
-    }
-HWCOMPOSER_LOG_RUNTIME("#######output_device::post()############");
-
-	Mutex::Autolock _l(mLock);
-    struct fb_var_screeninfo info;
-    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::post VSCREENINFO getting failed! usage=%x", m_usage);
-        return -1;
-    }
-
-    struct fb_fix_screeninfo finfo;
-    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
-        HWCOMPOSER_LOG_ERR("Error! output_device::post FSCREENINFO getting failed! usage=%x", m_usage);
-        return -1;
-    }
-
-    info.yoffset = ((unsigned long)buf->virt_addr - (unsigned long)(mbuffers[0]).virt_addr) / finfo.line_length;
-    //info.yoffset = ((info.yres_virtual * finfo.line_length)/ DEFAULT_BUFFERS) * mbuffer_cur;
-    mbuffer_cur = (mbuffer_cur + 1) % DEFAULT_BUFFERS;
-    info.activate = FB_ACTIVATE_VBL;
-//HWCOMPOSER_LOG_RUNTIME("#######yoffset=%d, mbuffer_cur=%d######", info.yoffset, mbuffer_cur);
-    ioctl(m_dev, FBIOPAN_DISPLAY, &info);
-
-HWCOMPOSER_LOG_RUNTIME("#######output_device::post()##end##########");
-    return 0;
-}
+
+#include <hardware/hardware.h>
+
+#include <fcntl.h>
+#include <errno.h>
+
+#include <cutils/log.h>
+#include <cutils/atomic.h>
+
+#include <hardware/hwcomposer.h>
+
+#include <EGL/egl.h>
+#include "gralloc_priv.h"
+#include "hwc_common.h"
+
+void output_device::setUsage(int usage)
+{
+    m_usage = usage;
+}
+
+int output_device::getUsage()
+{
+    return m_usage;
+}
+
+int output_device::getWidth()
+{
+    return m_width;
+}
+
+int output_device::getHeight()
+{
+    return m_height;
+}
+
+output_device::output_device(const char *dev_name, int usage)
+{
+    m_dev = open(dev_name, O_RDWR | O_NONBLOCK, 0);
+    if(m_dev < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device Open fb device %s failed!", dev_name);
+    }
+    m_usage = usage;
+}
+
+output_device::~output_device()
+{
+	if(m_dev > 0) {
+        close(m_dev);
+	}
+}
+
+int output_device::isFGDevice(const char *dev_name)
+{
+    int status = -EINVAL;
+    int fd = -1;
+    char fb_usage[32];
+    char fb_name[32];
+    int fd_n = 0;
+    int size = 0;
+    int is_overlay = 0;
+    char *psname;
+
+    memset(fb_name, 0, sizeof(fb_name));
+    psname = (char *)dev_name;
+    psname += (strlen(dev_name) - 1);
+    strcpy(fb_name, "/sys/class/graphics/fb");
+    strcat(fb_name, psname);
+    strcat(fb_name, "/name");
+    fd_n = open(fb_name, O_RDONLY, 0);
+    //fd_n = open("/sys/class/graphics/fb0/name", O_RDONLY, 0);
+    if(fd_n < 0) {
+		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice  open %s failed!", fb_name);
+		return -1;
+    }
+    memset(fb_usage, 0, sizeof(fb_usage));
+    size = read(fd_n, fb_usage, sizeof(fb_usage));
+    if(size < 0) {
+		HWCOMPOSER_LOG_ERR("Error! output_device::isFGDevice read /sys/class/graphics/fb0/name failed!");
+		return -1;
+    }
+    close(fd_n);
+HWCOMPOSER_LOG_INFO("output_device::isFGDevice===%s, %s, %s", dev_name, fb_name, fb_usage);
+    if(strstr(fb_usage, "FG"))
+    	return 1;
+ 	return 0;
+}
+
+void output_device::setDisplayFrame(hwc_rect_t *disFrame)
+{
+    if(disFrame == NULL) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::setDisplayFrame invalid parameter!");
+    }
+    Rect disRect(disFrame->left, disFrame->top, disFrame->right, disFrame->bottom);
+    currenRegion.orSelf(disRect);
+}
+
+int output_device::needFillBlack(hwc_buffer *buf)
+{
+    Rect orignBound(buf->disp_region.getBounds());
+    Rect currentBound(currenRegion.getBounds());
+    return currentBound != orignBound;
+}
+
+void output_device::fillBlack(hwc_buffer *buf)
+{
+    if(buf == NULL) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::fillBlack invalid parameter!");
+        return;
+    }
+
+    hwc_fill_frame_back((char *)buf->virt_addr, buf->size, buf->width, buf->height, buf->format);
+}
+
+int output_device::fetch(hwc_buffer *buf)
+{
+	  //int status = -EINVAL;
+    if(m_dev <= 0 || buf == NULL) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::fetch invalid parameter! usage=%x", m_usage);
+        return -1;
+    }
+
+	  Mutex::Autolock _l(mLock);
+	  buf->size = (mbuffers[mbuffer_cur]).size;
+	  buf->virt_addr = (mbuffers[mbuffer_cur]).virt_addr;
+	  buf->phy_addr = (mbuffers[mbuffer_cur]).phy_addr;
+	  buf->width = m_width;
+	  buf->height = m_height;
+	  buf->usage = m_usage;
+	  buf->format = m_format;
+	  //dev->buffer_cur = (dev->buffer_cur + 1) % DEFAULT_BUFFERS;
+      if((m_usage & (GRALLOC_USAGE_OVERLAY0_MASK | GRALLOC_USAGE_OVERLAY1_MASK)) && needFillBlack(&mbuffers[mbuffer_cur])) {
+          fillBlack(&mbuffers[mbuffer_cur]);
+          mbuffers[mbuffer_cur].disp_region = currenRegion;
+      }
+      //orignRegion = currenRegion;
+      currenRegion.clear();
+
+	  return 0;
+}
+
+int output_device::post(hwc_buffer *buf)
+{
+	  //int status = -EINVAL;
+    if(m_dev <= 0) {
+        HWCOMPOSER_LOG_ERR("Error! FG_device::FG_post() invalid parameter! usage=%x", m_usage);
+        return -1;
+    }
+HWCOMPOSER_LOG_RUNTIME("#######output_device::post()############");
+
+	Mutex::Autolock _l(mLock);
+    struct fb_var_screeninfo info;
+    if(ioctl(m_dev, FBIOGET_VSCREENINFO, &info) < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::post VSCREENINFO getting failed! usage=%x", m_usage);
+        return -1;
+    }
+
+    struct fb_fix_screeninfo finfo;
+    if(ioctl(m_dev, FBIOGET_FSCREENINFO, &finfo) < 0) {
+        HWCOMPOSER_LOG_ERR("Error! output_device::post FSCREENINFO getting failed! usage=%x", m_usage);
+        return -1;
+    }
+
+    info.yoffset = ((unsigned long)buf->virt_addr - (unsigned long)(mbuffers[0]).virt_addr) / finfo.line_length;
+    //info.yoffset = ((info.yres_virtual * finfo.line_length)/ DEFAULT_BUFFERS) * mbuffer_cur;
+    mbuffer_cur = (mbuffer_cur + 1) % DEFAULT_BUFFERS;
+    info.activate = FB_ACTIVATE_VBL;
+//HWCOMPOSER_LOG_RUNTIME("#######yoffset=%d, mbuffer_cur=%d######", info.yoffset, mbuffer_cur);
+    ioctl(m_dev, FBIOPAN_DISPLAY, &info);
+
+HWCOMPOSER_LOG_RUNTIME("#######output_device::post()##end##########");
+    return 0;
+}
-- 
1.8.0

