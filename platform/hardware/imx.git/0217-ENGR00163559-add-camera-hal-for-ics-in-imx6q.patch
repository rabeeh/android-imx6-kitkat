From cca1ef4a0eb67311e9d692d6f9b10cfb7a5ba7ae Mon Sep 17 00:00:00 2001
From: Liu Xiaowen <b37945@freescale.com>
Date: Wed, 30 Nov 2011 18:20:26 +0800
Subject: [PATCH 217/498] ENGR00163559 add camera hal for ics in imx6q.

add camera hal for ics in imx6q.

Signed-off-by: Liu Xiaowen <b37945@freescale.com>
---
 mx6/libcamera/Android.mk                     |   74 +
 mx6/libcamera/CameraHal.cpp                  | 2546 ++++++++++++++++++++++++++
 mx6/libcamera/CameraHal.h                    |  444 +++++
 mx6/libcamera/CameraModule.cpp               |  707 +++++++
 mx6/libcamera/Camera_pmem.cpp                |  163 ++
 mx6/libcamera/Camera_pmem.h                  |   53 +
 mx6/libcamera/Camera_utils.h                 |   77 +
 mx6/libcamera/CaptureDeviceInterface.cpp     |   40 +
 mx6/libcamera/CaptureDeviceInterface.h       |  110 ++
 mx6/libcamera/JpegEncoderInterface.cpp       |   34 +
 mx6/libcamera/JpegEncoderInterface.h         |  173 ++
 mx6/libcamera/JpegEncoderSoftware.cpp        |  661 +++++++
 mx6/libcamera/JpegEncoderSoftware.h          |   84 +
 mx6/libcamera/PP_ipulib.cpp                  |  138 ++
 mx6/libcamera/PP_ipulib.h                    |   47 +
 mx6/libcamera/PostProcessDeviceInterface.cpp |   26 +
 mx6/libcamera/PostProcessDeviceInterface.h   |   78 +
 mx6/libcamera/V4l2CapDeviceBase.cpp          |  704 +++++++
 mx6/libcamera/V4l2CapDeviceBase.h            |   88 +
 mx6/libcamera/V4l2CsiDevice.cpp              |  389 ++++
 mx6/libcamera/V4l2CsiDevice.h                |   54 +
 mx6/libcamera/V4l2UVCDevice.h                |   41 +
 mx6/libcamera/messageQueue.cpp               |  167 ++
 mx6/libcamera/messageQueue.h                 |  104 ++
 24 files changed, 7002 insertions(+)
 create mode 100755 mx6/libcamera/Android.mk
 create mode 100755 mx6/libcamera/CameraHal.cpp
 create mode 100755 mx6/libcamera/CameraHal.h
 create mode 100755 mx6/libcamera/CameraModule.cpp
 create mode 100755 mx6/libcamera/Camera_pmem.cpp
 create mode 100755 mx6/libcamera/Camera_pmem.h
 create mode 100755 mx6/libcamera/Camera_utils.h
 create mode 100755 mx6/libcamera/CaptureDeviceInterface.cpp
 create mode 100755 mx6/libcamera/CaptureDeviceInterface.h
 create mode 100755 mx6/libcamera/JpegEncoderInterface.cpp
 create mode 100755 mx6/libcamera/JpegEncoderInterface.h
 create mode 100755 mx6/libcamera/JpegEncoderSoftware.cpp
 create mode 100755 mx6/libcamera/JpegEncoderSoftware.h
 create mode 100755 mx6/libcamera/PP_ipulib.cpp
 create mode 100755 mx6/libcamera/PP_ipulib.h
 create mode 100755 mx6/libcamera/PostProcessDeviceInterface.cpp
 create mode 100755 mx6/libcamera/PostProcessDeviceInterface.h
 create mode 100755 mx6/libcamera/V4l2CapDeviceBase.cpp
 create mode 100755 mx6/libcamera/V4l2CapDeviceBase.h
 create mode 100755 mx6/libcamera/V4l2CsiDevice.cpp
 create mode 100755 mx6/libcamera/V4l2CsiDevice.h
 create mode 100755 mx6/libcamera/V4l2UVCDevice.h
 create mode 100755 mx6/libcamera/messageQueue.cpp
 create mode 100755 mx6/libcamera/messageQueue.h

diff --git a/mx6/libcamera/Android.mk b/mx6/libcamera/Android.mk
new file mode 100755
index 0000000..bdbdae8
--- /dev/null
+++ b/mx6/libcamera/Android.mk
@@ -0,0 +1,74 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+ifeq ($(BOARD_SOC_CLASS),IMX6)
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=    \
+	CameraHal.cpp    \
+	CameraModule.cpp \
+    Camera_pmem.cpp  \
+	CaptureDeviceInterface.cpp \
+	V4l2CsiDevice.cpp \
+	V4l2CapDeviceBase.cpp  \
+	PostProcessDeviceInterface.cpp \
+	PP_ipulib.cpp    \
+	JpegEncoderInterface.cpp \
+    JpegEncoderSoftware.cpp \
+    messageQueue.cpp
+
+LOCAL_CPPFLAGS +=
+
+LOCAL_SHARED_LIBRARIES:= \
+    libcamera_client \
+    libui \
+    libutils \
+    libcutils \
+    libbinder \
+    libmedia \
+    libhardware_legacy \
+    libdl \
+    libc \
+	libipu
+
+LOCAL_C_INCLUDES += \
+	frameworks/base/include/binder \
+	frameworks/base/include/ui \
+	frameworks/base/camera/libcameraservice \
+	external/linux-lib/ipu \
+    hardware/imx/mx6/libgralloc
+
+ifeq ($(HAVE_FSL_IMX_CODEC),true)
+    LOCAL_SHARED_LIBRARIES += libfsl_jpeg_enc_arm11_elinux
+    LOCAL_CPPFLAGS += -DUSE_FSL_JPEG_ENC
+    LOCAL_C_INCLUDES +=	\
+					device/fsl/proprietary/codec/ghdr
+endif
+ifeq ($(BOARD_CAMERA_NV12),true)
+    LOCAL_CPPFLAGS += -DRECORDING_FORMAT_NV12
+else
+    LOCAL_CPPFLAGS += -DRECORDING_FORMAT_YUV420
+endif
+
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw	
+LOCAL_MODULE:= camera.$(TARGET_BOARD_PLATFORM)
+
+LOCAL_CFLAGS += -fno-short-enums
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := eng
+
+include $(BUILD_SHARED_LIBRARY)
+endif
diff --git a/mx6/libcamera/CameraHal.cpp b/mx6/libcamera/CameraHal.cpp
new file mode 100755
index 0000000..c1d6640
--- /dev/null
+++ b/mx6/libcamera/CameraHal.cpp
@@ -0,0 +1,2546 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#include <cutils/properties.h>
+#include "CameraHal.h"
+#include <time.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <hardware_legacy/power.h>
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Rect.h>
+#include "gralloc_priv.h"
+
+namespace android {
+
+    CameraHal::CameraHal(int cameraid)
+        : mParameters(),
+        mCallbackCookie(NULL),
+        mNotifyCb(NULL),
+        mDataCb(NULL),
+        mDataCbTimestamp(NULL),
+        mCaptureFrameThread(NULL),
+        mPostProcessThread(NULL),
+        mPreviewShowFrameThread(NULL),
+        mEncodeFrameThread(NULL),
+        mAutoFocusThread(NULL),
+        mTakePicThread(NULL),
+        mLock(),
+        mSupportedPictureSizes(NULL),
+        mSupportedPreviewSizes(NULL),
+        mSupportedFPS(NULL),
+        mSupprotedThumbnailSizes(NULL),
+        mSupportPreviewFormat(NULL),
+        mNativeWindow(NULL),
+        mMsgEnabled(0),
+        mPreviewMemory(NULL),
+        mVideoMemory(NULL),
+        mVideoBufNume(VIDEO_OUTPUT_BUFFER_NUM),
+        mPPbufNum(0),
+        mPreviewRunning(0), mCaptureRunning(0),
+        mDefaultPreviewFormat(V4L2_PIX_FMT_NV12), //the optimized selected format, hard code
+        mPreviewFrameSize(0),
+        mTakePicFlag(false),
+        mUvcSpecialCaptureFormat(V4L2_PIX_FMT_YUYV),
+        mCaptureFrameSize(0),
+        mCaptureBufNum(0),
+        mEnqueuedBufs(0),
+        isCaptureBufsAllocated(0),
+        //isPreviewFinsh(0),
+        mRecordRunning(0),
+        mCurrentRecordFrame(0),
+        nCameraBuffersQueued(0),
+        mPreviewHeapBufNum(PREVIEW_HEAP_BUF_NUM),
+        mTakePicBufQueNum(TAKE_PIC_QUE_BUF_NUM),
+        mCameraReady(false),
+        mCaptureDeviceOpen(false),
+        mPPDeviceNeed(false),
+	bDerectInput(false),
+        mCameraid(cameraid),
+        mPPDeviceNeedForPic(false),
+        mPowerLock(false),
+        mPreviewRotate(CAMERA_PREVIEW_BACK_REF),
+        mExitCaptureThread(false), mExitPreviewThread(false), 
+        mExitPostProcessThread(false), mExitEncodeThread(false), mTakePictureInProcess(false)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        preInit();
+    }
+
+    CameraHal :: ~CameraHal()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CameraMiscDeInit();
+        CloseCaptureDevice();
+        FreeInterBuf();
+        postDestroy();
+    }
+
+    void CameraHal :: release()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        Mutex::Autolock lock(mLock);
+
+        mCameraReady = false;
+        CameraHALStopPreview();
+        UnLockWakeLock();
+        return;
+    }
+
+    void CameraHal :: preInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+    }
+    void CameraHal :: postDestroy()
+    {
+        CAMERA_HAL_LOG_FUNC;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: setCaptureDevice(sp<CaptureDeviceInterface> capturedevice)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mCaptureDevice = capturedevice;
+        else
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mPPDevice = postprocessdevice;
+        else 
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: setJpegEncoder(sp<JpegEncoderInterface>jpegencoder)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        if (mCameraReady == false)
+            mJpegEncoder = jpegencoder;
+        else
+            ret = CAMERA_HAL_ERR_BAD_ALREADY_RUN;
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal::Init()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        mCameraReady == true;
+
+        CAMERA_TYPE cType;
+        mCaptureDevice->GetDevType(&cType);
+        if(cType == CAMERA_TYPE_UVC) {
+            mPPDeviceNeed = true;
+            CAMERA_HAL_LOG_INFO("-----%s: it is uvc device", __FUNCTION__);
+        }else {
+            mPPDeviceNeed = false;
+            CAMERA_HAL_LOG_INFO("-----%s: it is csi device", __FUNCTION__);
+        }
+
+        if ((ret = AolLocForInterBuf())<0)
+            return ret;
+        if ((ret = InitCameraHalParam()) < 0)
+            return ret;
+        if (mPPDeviceNeed == true && mPPDevice == NULL)
+            return CAMERA_HAL_ERR_PP_NULL;
+        if ((ret = CameraMiscInit()) < 0)
+            return ret;
+
+        return ret;
+    }
+    void  CameraHal::setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mPreviewRotate = previewRotate;
+        return ;
+    }
+
+    CAMERA_HAL_ERR_RET  CameraHal :: AolLocForInterBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+
+        mSupportedPictureSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupportedPreviewSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupportedFPS          = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupprotedThumbnailSizes = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+        mSupportPreviewFormat = (char *)malloc(CAMER_PARAM_BUFFER_SIZE);
+
+        if (mSupportedPictureSizes == NULL ||
+                mSupportedPreviewSizes == NULL ||
+                mSupportedFPS          == NULL ||
+                mSupprotedThumbnailSizes == NULL ||
+                mSupportPreviewFormat == NULL)
+            ret = CAMERA_HAL_ERR_ALLOC_BUF;
+
+        return ret;
+    }
+    void  CameraHal :: FreeInterBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (mSupportedPictureSizes)
+            free(mSupportedPictureSizes);
+        if (mSupportedPreviewSizes)
+            free(mSupportedPreviewSizes);
+        if (mSupportedFPS)
+            free(mSupportedFPS);
+        if (mSupprotedThumbnailSizes)
+            free(mSupprotedThumbnailSizes);
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: InitCameraHalParam()
+    {	
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+
+        if ((ret = InitCameraBaseParam(&mParameters)) < 0)
+            return ret;
+
+        if ((ret = InitPictureExifParam(&mParameters)) < 0)
+            return ret;
+
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal::CameraMiscInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        pthread_mutex_init(&mPPIOParamMutex, NULL);
+        pthread_mutex_init(&mOverlayMutex, NULL);
+
+        mPreviewRunning = false;
+        mCaptureRunning = false;
+        mWaitForTakingPicture = false;
+        sem_init(&mCaptureStoppedCondition, 0, 0);
+        sem_init(&mPreviewStoppedCondition, 0, 0);
+        sem_init(&mEncodeStoppedCondition, 0, 0);
+        sem_init(&mPostProcessStoppedCondition, 0, 0);
+        sem_init(&mTakingPicture, 0, 0);
+        //mPostProcessRunning = false;
+        //mEncodeRunning = false;
+        mCaptureFrameThread = new CaptureFrameThread(this);
+        mPreviewShowFrameThread = new PreviewShowFrameThread(this);
+        mEncodeFrameThread = new EncodeFrameThread(this);
+        mTakePicThread= new TakePicThread(this);
+
+        if(mPPDeviceNeed){
+            mPostProcessThread = new PostProcessThread(this);
+            if (mPostProcessThread == NULL)
+                 return CAMERA_HAL_ERR_INIT;
+        }
+
+        if (mCaptureFrameThread == NULL || mPreviewShowFrameThread == NULL ||
+                mEncodeFrameThread == NULL || mTakePicThread == NULL){
+            return CAMERA_HAL_ERR_INIT;
+        }
+        return ret;
+    }
+    CAMERA_HAL_ERR_RET CameraHal::CameraMiscDeInit()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_ERR_RET ret = CAMERA_HAL_ERR_NONE;
+        mCaptureThreadQueue.postQuitMessage();
+        pthread_mutex_destroy(&mPPIOParamMutex);
+        pthread_mutex_destroy(&mOverlayMutex);
+        return ret;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal::InitCameraPreviewFormatToParam(int nFmt)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int i;
+        char fmtStr[40];
+
+        memset(fmtStr, 0, 40);
+        convertPreviewFormatToString(fmtStr, 40, mDefaultPreviewFormat);
+        mParameters.setPreviewFormat(fmtStr);
+        mParameters.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, fmtStr);
+
+        memset(fmtStr, 0, 40);
+        for(i = 0; i < nFmt; i++) {
+            if(mCaptureSupportedFormat[i] == v4l2_fourcc('Y','U','1','2')) {
+                strcat(fmtStr, "yuv420p");
+                strcat(fmtStr, ",");
+            }
+            else if(mCaptureSupportedFormat[i] == v4l2_fourcc('N','V','1','2')) {
+                strcat(fmtStr, "yuv420sp");
+                strcat(fmtStr, ",");
+            }
+            //else if(mCaptureSupportedFormat[i] == v4l2_fourcc('Y','U','Y','V')) {
+            //    strcat(fmtStr, "yuv422i-yuyv");
+            //    strcat(fmtStr, ",");
+            //}
+        }
+        mParameters.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, fmtStr);
+        return CAMERA_HAL_ERR_NONE;
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: InitCameraBaseParam(CameraParameters *pParam)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        char TmpStr[20];
+        unsigned int CapPreviewFmt[MAX_QUERY_FMT_TIMES];
+        struct capture_config_t CaptureSizeFps;
+        int  previewCnt= 0, pictureCnt = 0, i;
+        char previewFmt[20] = {0};
+
+        //the Camera Open here will not be close immediately, for later preview.
+        if (OpenCaptureDevice() < 0)
+            return CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE;
+
+        memset(mCaptureSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+
+        for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+            if (mCaptureDevice->EnumDevParam(OUTPU_FMT,&(mCaptureSupportedFormat[i])) < 0)
+                break;
+        }
+        if (i == 0)
+            return CAMERA_HAL_ERR_GET_PARAM;
+
+        InitCameraPreviewFormatToParam(i);
+
+        if (NegotiateCaptureFmt(false) < 0)
+            return CAMERA_HAL_ERR_GET_PARAM;
+
+        CaptureSizeFps.fmt = mCaptureDeviceCfg.fmt;//mPreviewCapturedFormat;
+
+        memset(TmpStr, 0, 20);
+        convertPreviewFormatToString(TmpStr, 20, mCaptureDeviceCfg.fmt);
+        mParameters.setPreviewFormat(TmpStr);
+
+        CAMERA_HAL_LOG_INFO("mCaptureDeviceCfg.fmt is %x", mCaptureDeviceCfg.fmt);
+
+        for(;;){
+            if (mCaptureDevice->EnumDevParam(FRAME_SIZE_FPS,&CaptureSizeFps) <0){
+                CAMERA_HAL_LOG_RUNTIME("get the frame size and time interval error");
+                break;
+            }
+            memset(TmpStr, 0, 20);
+            sprintf(TmpStr, "%dx%d", CaptureSizeFps.width,CaptureSizeFps.height);
+            CAMERA_HAL_LOG_INFO("the size is %s , the framerate is %d ", TmpStr, (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator));
+            if (previewCnt == 0)
+                strncpy((char*) mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+            else{
+                strncat(mSupportedPictureSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                strncat(mSupportedPictureSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+            }
+            pictureCnt ++;
+
+            if (CaptureSizeFps.tv.denominator/CaptureSizeFps.tv.numerator > 25){
+                if (previewCnt == 0)
+                    strncpy((char*) mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                else{
+                    strncat(mSupportedPreviewSizes,  PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+                    strncat(mSupportedPreviewSizes, TmpStr, CAMER_PARAM_BUFFER_SIZE);
+                }
+                previewCnt ++;
+            }
+        }
+
+        /*hard code here*/
+        strcpy(mSupportedFPS, "15,30");
+        CAMERA_HAL_LOG_INFO("##The supportedPictureSizes is %s##", mSupportedPictureSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedPreviewSizes is %s##", mSupportedPreviewSizes);
+        CAMERA_HAL_LOG_INFO("##the supportedFPS is %s##", mSupportedFPS);
+
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES, mSupportedPictureSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, mSupportedPreviewSizes);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, mSupportedFPS);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(15000,15000),(30000,30000)");
+        pParam->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "30000,30000");
+
+        pParam->setPreviewSize(640, 480);
+        pParam->setPictureSize(640, 480);
+        pParam->setPreviewFrameRate(5);
+
+        return CAMERA_HAL_ERR_NONE;
+
+    }
+
+    status_t CameraHal :: OpenCaptureDevice()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        if (mCaptureDeviceOpen){
+            CAMERA_HAL_LOG_INFO("The capture device already open");
+            return NO_ERROR;
+        }
+        else if (mCaptureDevice != NULL){
+            if ( mCaptureDevice->DevOpen()<0 )
+                return INVALID_OPERATION;
+            mCaptureDeviceOpen = true;
+        }else{
+            CAMERA_HAL_ERR("no capture device assigned");
+            return INVALID_OPERATION;
+        }
+        return ret;
+    }
+    void CameraHal ::CloseCaptureDevice()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (mCaptureDeviceOpen && mCaptureDevice != NULL){
+            mCaptureDevice->DevClose();
+            mCaptureDeviceOpen = false;
+        }
+    }
+
+    CAMERA_HAL_ERR_RET CameraHal :: InitPictureExifParam(CameraParameters *pParam)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        char tmpBuffer[CAMER_PARAM_BUFFER_SIZE];
+
+        /*hard code here*/
+        pParam->set(CameraParameters::KEY_FOCUS_DISTANCES, "24.0,50.0,2147483648.0");
+        pParam->setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG);
+        pParam->set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG);
+        pParam->set(CameraParameters::KEY_JPEG_QUALITY, 100);
+        strcpy(mSupprotedThumbnailSizes, "0x0,128x128,96x96");
+        pParam->set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, mSupprotedThumbnailSizes);
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "96");
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "96");
+        pParam->set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "90");
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_INCANDESCENT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_FLUORESCENT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_DAYLIGHT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::WHITE_BALANCE_SHADE, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, tmpBuffer);
+        pParam->set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NONE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_MONO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_NEGATIVE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SOLARIZE,  CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::EFFECT_SEPIA, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_EFFECTS, tmpBuffer);
+        pParam->set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_AUTO, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_LANDSCAPE, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_SPORTS, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT_PORTRAIT, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_FIREWORKS, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::SCENE_MODE_NIGHT, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO);
+
+        pParam->set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES, CameraParameters::FOCUS_MODE_AUTO);
+        pParam->set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO);
+
+        pParam->set(CameraParameters::KEY_FOCAL_LENGTH, "10.001");
+        pParam->set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "54.8");
+        pParam->set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "42.5");
+        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "0");
+        pParam->set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.0");
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_50HZ, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_60HZ, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) PARAMS_DELIMITER, CAMER_PARAM_BUFFER_SIZE);
+        strncat((char*) tmpBuffer, (const char*) CameraParameters::ANTIBANDING_OFF, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_ANTIBANDING, tmpBuffer);
+        pParam->set(CameraParameters::KEY_ANTIBANDING, CameraParameters::ANTIBANDING_OFF);
+
+        memset(tmpBuffer, '\0', sizeof(*tmpBuffer));
+        strncat( (char*) tmpBuffer, (const char*) CameraParameters::FLASH_MODE_OFF, CAMER_PARAM_BUFFER_SIZE);
+        pParam->set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, tmpBuffer);
+        pParam->set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF);
+        pParam->set(CameraParameters::KEY_ZOOM_SUPPORTED, CameraParameters::TRUE);
+        pParam->set(CameraParameters::KEY_MAX_ZOOM, "1");
+        // default zoom should be 0 as CTS defined
+        pParam->set(CameraParameters::KEY_ZOOM, "0");
+        //the zoom ratios in 1/100 increments. Ex: a zoom of 3.2x is
+        //returned as 320. The number of elements is {@link
+        //#getMaxZoom} + 1. The list is sorted from small to large. The
+        //first element is always 100. The last element is the zoom
+        //ratio of the maximum zoom value.
+        pParam->set(CameraParameters::KEY_ZOOM_RATIOS, "100,200");
+
+        return CAMERA_HAL_ERR_NONE;
+    }
+
+    sp<IMemoryHeap> CameraHal::getRawHeap() const
+    {
+        return NULL;
+    }
+
+    status_t CameraHal::dump(int fd) const
+    {
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::sendCommand(int32_t command, int32_t arg1,
+            int32_t arg2)
+    {
+        return BAD_VALUE;
+    }
+
+    void CameraHal::setCallbacks(camera_notify_callback notify_cb,
+            camera_data_callback data_cb,
+            camera_data_timestamp_callback data_cb_timestamp,
+            camera_request_memory get_memory,
+            void* user)
+    {
+        Mutex::Autolock lock(mLock);
+        mNotifyCb = notify_cb;
+        mDataCb = data_cb;
+        mDataCbTimestamp = data_cb_timestamp;
+        mRequestMemory = get_memory;
+        mCallbackCookie = user;
+    }
+
+    void CameraHal::enableMsgType(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg enabled is %x###", msgType);
+        mMsgEnabled |= msgType;
+    }
+
+    void CameraHal::disableMsgType(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg disabled is %x###", msgType);
+        mMsgEnabled &= ~msgType;
+    }
+    bool CameraHal::msgTypeEnabled(int32_t msgType)
+    {
+        Mutex::Autolock lock(mLock);
+        CAMERA_HAL_LOG_INFO("###the mesg check is %x###", msgType);
+        return (mMsgEnabled & msgType);
+    }
+
+    void CameraHal::putParameters(char *params)
+    {
+        free(params);
+    }
+
+    char* CameraHal::getParameters() const
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        Mutex::Autolock lock(mLock);
+        char* params_string;
+        String8 params_str8;
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        CameraParameters mParams = mParameters;
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+
+        params_str8 = mParams.flatten();
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        params_string = (char*)malloc(sizeof(char) * (params_str8.length() + 1));
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        strcpy(params_string, params_str8.string());
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        return params_string;
+    }
+
+    status_t  CameraHal:: setParameters(const char* params)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CameraParameters parameters;
+        String8 str_params(params);
+
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        parameters.unflatten(str_params);
+	CAMERA_HAL_LOG_INFO("%s, %d", __FUNCTION__, __LINE__);
+        return setParameters(parameters);
+    }
+
+    status_t  CameraHal:: setParameters(const CameraParameters& params)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int w, h;
+        int framerate;
+        int max_zoom,zoom, max_fps, min_fps;
+        char tmp[128];
+        Mutex::Autolock lock(mLock);
+
+        max_zoom = params.getInt(CameraParameters::KEY_MAX_ZOOM);
+        zoom = params.getInt(CameraParameters::KEY_ZOOM);
+        if(zoom > max_zoom){
+            CAMERA_HAL_ERR("Invalid zoom setting, zoom %d, max zoom %d",zoom,max_zoom);
+            return BAD_VALUE;
+        }
+        if (!((strcmp(params.getPreviewFormat(), "yuv420sp") == 0) ||
+                (strcmp(params.getPreviewFormat(), "yuv420p") == 0)/* || (strcmp(params.getPreviewFormat(), "yuv422i-yuyv") == 0)*/
+                )) {
+            CAMERA_HAL_ERR("Only yuv420sp or yuv420pis supported, but input format is %s", params.getPreviewFormat());
+            //CAMERA_HAL_ERR("Only yuv420sp,yuv420p or yuv422i-yuyv is supported, but input format is %s", params.getPreviewFormat());
+            return BAD_VALUE;
+        }
+
+        if (strcmp(params.getPictureFormat(), "jpeg") != 0) {
+            CAMERA_HAL_ERR("Only jpeg still pictures are supported");
+            return BAD_VALUE;
+        }
+
+        params.getPreviewSize(&w, &h);
+        sprintf(tmp, "%dx%d", w, h);
+        CAMERA_HAL_LOG_INFO("##the set preview size is %s ##", tmp);
+        if (strstr(mSupportedPreviewSizes, tmp) == NULL){
+            CAMERA_HAL_ERR("The preview size w %d, h %d is not corrected", w, h);
+            return BAD_VALUE;
+        }
+
+        params.getPictureSize(&w, &h);
+        sprintf(tmp, "%dx%d", w, h);
+        CAMERA_HAL_LOG_INFO("##the set picture size is %s ##", tmp);
+        if (strstr(mSupportedPictureSizes, tmp) == NULL){
+            CAMERA_HAL_ERR("The picture size w %d, h %d is not corrected", w, h);
+            return BAD_VALUE;
+        }
+
+        framerate = params.getPreviewFrameRate();
+        CAMERA_HAL_LOG_INFO("##the set frame rate is %d ##", framerate);
+        if (framerate >30 || framerate<0 ){
+            CAMERA_HAL_ERR("The framerate is not corrected");
+            return BAD_VALUE;
+        }
+
+        params.getPreviewFpsRange(&min_fps, &max_fps);
+        CAMERA_HAL_LOG_INFO("###the fps is %d###", max_fps);
+        if (max_fps < 1000 || min_fps < 1000 || max_fps > 30000 || min_fps > 30000){
+            CAMERA_HAL_ERR("The fps range from %d to %d is error", min_fps, max_fps);
+            return BAD_VALUE;
+        }
+
+        const char *pFlashStr;
+        pFlashStr = params.get(CameraParameters::KEY_FLASH_MODE);
+        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) != 0 
+                && strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) != 0 && strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) != 0
+                && strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) != 0) {
+            CAMERA_HAL_ERR("The flash mode is not corrected");
+            return BAD_VALUE;
+        }
+
+        const char *pFocusStr;
+        pFocusStr = params.get(CameraParameters::KEY_FOCUS_MODE);
+        if(strcmp(pFocusStr, CameraParameters::FOCUS_MODE_AUTO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_INFINITY) != 0
+                && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_MACRO) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_FIXED) != 0
+                && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_EDOF) != 0 && strcmp(pFocusStr, CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO) != 0) {
+            CAMERA_HAL_ERR("The focus mode is not corrected");
+            return BAD_VALUE;
+        }
+        mParameters = params;
+        CAMERA_HAL_LOG_INFO("%s return", __FUNCTION__);
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::setPreviewWindow(struct preview_stream_ops *window)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(window == NULL) {
+            isCaptureBufsAllocated = 0;
+            CAMERA_HAL_ERR("the buf is null!");
+        }
+        else {
+            CAMERA_HAL_ERR("the buf is not null!");
+        }
+        mNativeWindow = window;
+        if((mNativeWindow != NULL) && !isCaptureBufsAllocated && mCaptureBufNum) {
+        //if((mNativeWindow != NULL) && !isCaptureBufsAllocated) {
+            if(PrepareCaptureBufs() < 0) {
+                CAMERA_HAL_ERR("PrepareCaptureBufs()-2 error");
+                return BAD_VALUE;
+            }
+            if(CameraHALPreviewStart() < 0) {
+                CAMERA_HAL_ERR("CameraHALPreviewStart()-2 error");
+                return BAD_VALUE;
+            }
+        }
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::freeBuffersToNativeWindow()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        //Mutex::Autolock lock(mLock);
+        if (mNativeWindow == NULL){
+            CAMERA_HAL_ERR("the native window is null!");
+            return BAD_VALUE;
+        }
+ 
+        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+        android_native_buffer_t *buf;
+        private_handle_t *handle;
+        for(unsigned int i = 0; i < mCaptureBufNum; i++) {
+            //if(mCaptureBuffers[i].buf_state == WINDOW_BUFS_DEQUEUED) {    
+                buf = (android_native_buffer_t *)mCaptureBuffers[i].native_buf;
+                if(mCaptureBuffers[i].virt_start != NULL) {
+                    handle = (private_handle_t *)buf->handle;
+                    mapper.unlock(handle);
+                }
+                if(buf != NULL) {
+                    mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                }
+            //}
+            mCaptureBuffers[i].buf_state = WINDOW_BUFS_INVALID;//WINDOW_BUFS_QUEUED;
+            mCaptureBuffers[i].refCount = 0;
+            mCaptureBuffers[i].native_buf = NULL;
+            mCaptureBuffers[i].virt_start = NULL;
+            mCaptureBuffers[i].length = 0;
+            mCaptureBuffers[i].phy_offset = 0;
+        }
+        mCaptureBufNum = 0;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::allocateBuffersFromNativeWindow()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        //Mutex::Autolock lock(mLock);
+        if (mNativeWindow == NULL){
+            CAMERA_HAL_ERR("the native window is null!");
+            return NO_ERROR;//BAD_VALUE;
+        }
+        status_t err = mNativeWindow->set_buffers_geometry(mNativeWindow,
+                mCaptureDeviceCfg.width, mCaptureDeviceCfg.height, 
+                HAL_PIXEL_FORMAT_YCbCr_420_SP);//mCaptureDeviceCfg.fmt);
+        if(err != 0){
+            CAMERA_HAL_ERR("native_window_set_buffers_geometry failed:%s(%d)", 
+                    strerror(-err), -err);
+            return err;
+        }
+
+        err = mNativeWindow->set_usage(mNativeWindow, GRALLOC_USAGE_SW_READ_OFTEN |
+                GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HWC_OVERLAY);
+        if(err != 0){
+            CAMERA_HAL_ERR("native_window_set_usage failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        int minUndequeueBufs = 0;
+        err = mNativeWindow->get_min_undequeued_buffer_count(mNativeWindow,
+                &minUndequeueBufs);
+        if(err != 0) {
+            CAMERA_HAL_ERR("NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS query failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        if(mCaptureBufNum > PREVIEW_CAPTURE_BUFFER_NUM) {
+            CAMERA_HAL_ERR("%s: the actual buffer number %d is too large than %d", __FUNCTION__, mCaptureBufNum, PREVIEW_CAPTURE_BUFFER_NUM);
+            return BAD_VALUE;
+        }
+
+        err = mNativeWindow->set_buffer_count(mNativeWindow, mCaptureBufNum);
+        if(err != 0) {
+            CAMERA_HAL_ERR("native_window_set_buffer_count failed:%s(%d)",
+                    strerror(-err), -err);
+            return err;
+        }
+
+        unsigned int i;
+        Rect bounds(mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
+        void *pVaddr = NULL;
+        GraphicBufferMapper &mapper = GraphicBufferMapper::get();
+        for(i = 0; i < mCaptureBufNum; i++) {
+            android_native_buffer_t *buf = NULL;
+            buffer_handle_t* buf_h = NULL;
+            pVaddr = NULL;
+            int stride;
+            err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
+            if((err != 0) || (buf_h == NULL)) {
+                CAMERA_HAL_ERR("dequeueBuffer failed: %s(%d)", strerror(-err), -err);
+                return BAD_VALUE;
+            }
+            buf = container_of(buf_h, ANativeWindowBuffer, handle);
+            private_handle_t *handle = (private_handle_t *)buf->handle;
+            mapper.lock(handle, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, bounds, &pVaddr);
+
+            if((handle->phys == 0) || (handle->base == 0) || (handle->size == 0)) {
+                 CAMERA_HAL_ERR("%s: dequeue invalide Buffer, phys=%x, base=%x, size=%d", __FUNCTION__, handle->phys, handle->base, handle->size);
+                 mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                 return BAD_VALUE;
+            }
+
+            mCaptureBuffers[i].virt_start = (unsigned char *)handle->base;
+            mCaptureBuffers[i].phy_offset = handle->phys;
+            mCaptureBuffers[i].length = handle->size;
+            mCaptureBuffers[i].native_buf = (void *)buf;
+            mCaptureBuffers[i].refCount = 0;
+            mCaptureBuffers[i].buf_state = WINDOW_BUFS_DEQUEUED;
+            CAMERA_HAL_LOG_RUNTIME("mCaptureBuffers[%d]-phys=%x, base=%x, size=%d", i, mCaptureBuffers[i].phy_offset, mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+        }
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::startPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+
+        if(mTakePictureInProcess) {
+            mWaitForTakingPicture = true;
+            sem_wait(&mTakingPicture);
+            mWaitForTakingPicture = false;
+	}
+        Mutex::Autolock lock(mLock);
+        //isPreviewFinsh = 0;
+        mEnqueuedBufs = 0;
+
+        mPreviewLock.lock();
+        if (mPreviewRunning) {
+            // already running
+            CAMERA_HAL_LOG_RUNTIME("%s : preview thread already running", __func__);
+            mPreviewLock.unlock();
+            return NO_ERROR;//INVALID_OPERATION;
+        }        
+            
+        if ((ret == CameraHALStartPreview())<0) {
+            CAMERA_HAL_LOG_RUNTIME("%s : CameraHALStartPreview error", __func__);
+            mPreviewLock.unlock();
+            return ret;            
+        }
+
+        mPreviewRunning = true;
+        mPreviewLock.unlock();
+        
+        mCaptureLock.lock();
+        if(mCaptureRunning) {
+            CAMERA_HAL_ERR("%s : preview thread already running", __func__);
+            mCaptureLock.unlock();
+            return NO_ERROR;
+        }
+        mCaptureRunning = true;
+        mCaptureLock.unlock();                  
+
+        if(mPPDeviceNeed) {
+            //mPostProcessLock.lock(); 
+            //mPostProcessCondition.signal();
+            //mPostProcessLock.unlock();            
+        }
+    
+        LockWakeLock();
+        return ret;
+    }
+
+    void CameraHal::stopPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        struct timeval af_time, be_time;
+        Mutex::Autolock lock(mLock);
+        /* Cannot stop preview in recording */
+        //   if(mMsgEnabled & CAMERA_MSG_VIDEO_FRAME)
+        //       return;
+
+        //isPreviewFinsh = 1;
+        CameraHALStopPreview();
+        UnLockWakeLock();
+
+    }
+
+    bool CameraHal::previewEnabled()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        return mPreviewRunning;
+    }
+
+    status_t CameraHal::storeMetaDataInBuffers(bool enable)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        unsigned int i;
+
+	bDerectInput = enable;
+	if (bDerectInput == true) {
+		if (!mPPDeviceNeed){
+			for(i = 0 ; i < mCaptureBufNum; i ++) {
+				mVideoBufferPhy[i].phy_offset = mCaptureBuffers[i].phy_offset;
+				CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mCaptureBuffers[i].phy_offset);
+				mVideoBufferPhy[i].length = mCaptureBuffers[i].length;
+				memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
+						(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
+			}
+		}else{
+			for(i = 0 ; i < mPPbufNum; i ++) {
+				mVideoBufferPhy[i].phy_offset = mPPbuf[i].phy_offset;
+				CAMERA_HAL_LOG_INFO("Camera HAL physic address: %p", mPPbuf[i].phy_offset);
+				mVideoBufferPhy[i].length = mPPbuf[i].length;
+				memcpy((unsigned char*)mVideoMemory->data + i*mPreviewFrameSize,
+						(void*)&mVideoBufferPhy[i], sizeof(VIDEOFRAME_BUFFER_PHY));
+			}
+		}
+	}
+
+	return NO_ERROR;
+    }
+#if 0
+    int32_t CameraHal::getNumberOfVideoBuffers() const
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+	if (!mPPDeviceNeed){
+		return mCaptureBufNum;
+	}else{
+		return  mPPbufNum;
+	}
+    }
+
+    sp<IMemory> CameraHal::getVideoBuffer(int32_t index) const
+    {
+        CAMERA_HAL_LOG_FUNC;
+        //this may be done in cameraHardwareInterface
+        //CameraHardwareInterface::CameraHeapMemory* mem;
+        //mem = (CameraHardwareInterface::CameraHeapMemory*)(mVideoMemory->handle);
+	//return mem->mBuffers[index];
+        return mVideoMemory;
+    }
+#endif
+    status_t CameraHal::startRecording()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int i;
+
+        mEncodeLock.lock();
+        if (mRecordRunning == true ) {
+            CAMERA_HAL_LOG_INFO("%s: Recording is already existed\n", __FUNCTION__);
+            mEncodeLock.unlock();
+            return ret;
+        }
+        
+        if((ret = AllocateRecordVideoBuf())<0) {
+            CAMERA_HAL_LOG_INFO("%s: AllocateRecordVideoBuf error\n", __FUNCTION__);
+            mEncodeLock.unlock();
+            return ret;            
+        }
+            
+		if (bDerectInput == true) {
+			for(i = 0; i < mVideoBufNume; i++) {
+				mVideoBufferUsing[i] = 0;
+			}
+		}
+		mEncodeLock.unlock();
+        mRecordRunning = true;
+
+        return NO_ERROR;
+    }
+
+    void CameraHal::stopRecording()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        
+        mEncodeLock.lock();        
+
+        if(mRecordRunning) {
+            mRecordRunning = false;
+            mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_STOP, 0));
+            sem_wait(&mEncodeStoppedCondition);
+            CAMERA_HAL_LOG_RUNTIME("---%s, after wait--", __FUNCTION__);
+        }
+		//if(bDerectInput == true) 
+		//	bDerectInput = false;		                
+        mEncodeLock.unlock();
+	}
+
+    void CameraHal::releaseRecordingFrame(const void* mem)
+    {
+        //CAMERA_HAL_LOG_FUNC;
+        ssize_t offset;
+        size_t  size;
+        int index;
+#if 0
+        offset = mem->offset();
+        size   = mem->size();
+        index = offset / size;
+
+        mVideoBufferUsing[index] = 0;
+
+		if (bDerectInput == true) {
+            if(mCaptureBuffers[index].refCount == 0) {
+                CAMERA_HAL_ERR("warning:%s about to release mCaptureBuffers[%d].refcount=%d-", __FUNCTION__, index, mCaptureBuffers[index].refCount);
+                return;
+            }
+			putBufferCount(&mCaptureBuffers[index]);
+        }
+#endif
+    }
+
+    bool CameraHal::recordingEnabled()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        return (mPreviewRunning && mRecordRunning);
+    }
+
+    status_t CameraHal::autoFocus()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        Mutex::Autolock lock(mLock);
+
+        if (mAutoFocusThread != NULL)
+            mAutoFocusThread.clear();
+
+        mAutoFocusThread = new AutoFocusThread(this);
+        if (mAutoFocusThread == NULL)
+            return UNKNOWN_ERROR;
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::cancelAutoFocus()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::takePicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        Mutex::Autolock lock(mLock);
+
+        //CameraHALStopPreview();
+        if(mTakePictureInProcess) {
+            CAMERA_HAL_ERR("%s: takePicture already in process", __FUNCTION__);
+            return INVALID_OPERATION;
+        }
+
+        if(mTakePicThread->run("takepicThread", PRIORITY_URGENT_DISPLAY) != NO_ERROR) {
+            CAMERA_HAL_ERR("%s: could't run take picture thread", __FUNCTION__);
+            return INVALID_OPERATION;
+        }
+        mTakePictureInProcess = true;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::cancelPicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        mTakePicThread->requestExitAndWait();
+
+        return NO_ERROR;
+    }
+
+
+    int CameraHal::autoFocusThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int FocusFlag = 0;
+
+        if (mMsgEnabled & CAMERA_MSG_FOCUS)
+            mNotifyCb(CAMERA_MSG_FOCUS, true, 0, mCallbackCookie);
+
+        return UNKNOWN_ERROR; //exit the thread
+    }
+
+    int CameraHal::takepicThread()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_LOG_INFO("Camera is taking picture!");
+
+        /* Stop preview, start picture capture, and then restart preview again for CSI camera*/
+        CameraHALStopPreview();
+        cameraHALTakePicture();
+        mTakePictureInProcess = false;
+
+        return UNKNOWN_ERROR;
+    }
+
+    int CameraHal :: cameraHALTakePicture()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR;
+        unsigned int DeQueBufIdx = 0;
+        struct jpeg_encoding_conf JpegEncConf;
+        DMA_BUFFER *Buf_input, Buf_output;
+        //sp<MemoryBase> JpegMemBase = NULL;
+        //sp<MemoryHeapBase> JpegImageHeap = NULL;
+        camera_memory_t* JpegMemBase = NULL;
+        int  max_fps, min_fps;
+
+        if (mJpegEncoder == NULL){
+            CAMERA_HAL_ERR("the jpeg encoder is NULL");
+            return BAD_VALUE;
+        }
+        mParameters.getPictureSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+        mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDevice->GetDevName(mCameraSensorName);
+        if (strstr(mCameraSensorName, "uvc") == NULL){
+        //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
+        // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
+        if (mParameters.getPreviewFrameRate() >= 15)
+            mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+        else{
+            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
+            CAMERA_HAL_LOG_INFO("###start the preview the fps is %d###", max_fps);
+            mCaptureDeviceCfg.tv.denominator = max_fps/1000;
+        }
+        }else{
+                mCaptureDeviceCfg.tv.denominator = 15;
+        }
+        mCaptureBufNum = PICTURE_CAPTURE_BUFFER_NUM;
+        mPPbufNum = 1;
+        mTakePicFlag = true;
+        mPPDeviceNeedForPic = false;
+        if ((ret = GetJpegEncoderParam()) < 0)
+            return ret;
+        if ((ret = NegotiateCaptureFmt(true)) < 0)
+            return ret;
+
+        if (mPPDeviceNeedForPic){
+            if ((ret = PreparePostProssDevice()) < 0){
+                CAMERA_HAL_ERR("PreparePostProssDevice error");
+                return ret;
+            }
+        }
+        if ((ret = PrepareCaptureDevices()) < 0)
+            return ret;
+
+        if (mPPDeviceNeedForPic){
+            if ((ret = PreparePreviwBuf()) < 0){
+                CAMERA_HAL_ERR("PreparePreviwBuf error");
+                return ret;
+            }
+        }
+        if ((ret = PrepareJpegEncoder()) < 0)
+            return ret;
+
+        if (mCaptureDevice->DevStart()<0){
+            CAMERA_HAL_ERR("the capture start up failed !!!!");
+            return INVALID_OPERATION;
+        }
+
+        for (unsigned int i =0;;){
+            if (mCaptureDevice->DevDequeue(&DeQueBufIdx) < 0){
+                LOGE("VIDIOC_DQBUF Failed!!!");
+                ret = UNKNOWN_ERROR;
+                goto Pic_out;
+            }
+
+            if (++i == mCaptureDeviceCfg.picture_waite_number)
+                break;
+
+            if (mCaptureDevice->DevQueue(DeQueBufIdx) < 0 ){
+                ret = UNKNOWN_ERROR;
+                goto Pic_out;
+            }
+        }
+
+        JpegMemBase = mRequestMemory(-1, mCaptureFrameSize, 1, NULL);
+        if (JpegMemBase == NULL || JpegMemBase->data == NULL){
+            ret = NO_MEMORY;
+            goto Pic_out;
+        }
+
+        // do the csc if necessary
+        if (mPPDeviceNeedForPic){
+            mPPInputParam.user_def_paddr = mCaptureBuffers[DeQueBufIdx].phy_offset;
+            mPPOutputParam.user_def_paddr = mPPbuf[0].phy_offset;
+            mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
+            mPPDevice->DoPorcess(&(mCaptureBuffers[DeQueBufIdx]), &(mPPbuf[0]));
+            mPPDevice->PPDeviceDeInit();
+            Buf_input = &mPPbuf[0];
+        }else{
+            Buf_input = &mCaptureBuffers[DeQueBufIdx];
+        }
+
+        Buf_output.virt_start = (unsigned char *)(JpegMemBase->data);
+        CAMERA_HAL_LOG_INFO("Generated a picture");
+
+        if (mMsgEnabled & CAMERA_MSG_SHUTTER) {
+            CAMERA_HAL_LOG_INFO("CAMERA_MSG_SHUTTER");
+            mNotifyCb(CAMERA_MSG_SHUTTER, 0, 0, mCallbackCookie);
+        }
+
+        if (mJpegEncoder->DoEncode(Buf_input,&Buf_output,&JpegEncConf) < 0){
+            ret = UNKNOWN_ERROR;
+            goto Pic_out;
+        }
+
+Pic_out:
+        freeBuffersToNativeWindow();
+        //JpegMemBase = new MemoryBase(JpegImageHeap, 0, JpegEncConf.output_jpeg_size);
+        if ((JpegMemBase != NULL) &&(JpegMemBase->data != NULL) && (mMsgEnabled & CAMERA_MSG_COMPRESSED_IMAGE)) {
+            CAMERA_HAL_LOG_INFO("==========CAMERA_MSG_COMPRESSED_IMAGE==================");
+            mDataCb(CAMERA_MSG_COMPRESSED_IMAGE, JpegMemBase, 0, NULL, mCallbackCookie);
+        }
+
+        mCaptureDevice->DevStop();
+        //mCaptureDevice->DevDeAllocate();
+        //freeBuffersToNativeWindow();
+        //CloseCaptureDevice();
+
+        if(JpegMemBase) {
+            JpegMemBase->release(JpegMemBase);
+        }
+        if(mWaitForTakingPicture) {
+            sem_post(&mTakingPicture);
+        }
+        return ret;
+
+    }
+
+    int CameraHal :: GetJpegEncoderParam()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR, i = 0;
+        memset(mEncoderSupportedFormat, 0, sizeof(unsigned int)*MAX_QUERY_FMT_TIMES);
+
+        for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
+            if (mJpegEncoder->EnumJpegEncParam(SUPPORTED_FMT,&(mEncoderSupportedFormat[i])) < 0)
+                break;
+        }
+        if (i == 0){
+            CAMERA_HAL_ERR("Get the parameters error");
+            return UNKNOWN_ERROR;
+        }
+        return ret;
+    }
+    int CameraHal :: NegotiateCaptureFmt(bool TakePicFlag)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int ret = NO_ERROR, i = 0, j = 0;
+
+
+        if(TakePicFlag){
+            mPictureEncodeFormat = 0;
+            for (i = 0; i < MAX_QUERY_FMT_TIMES; i++){
+                for (j = 0; j < MAX_QUERY_FMT_TIMES; j++){
+                    if (mEncoderSupportedFormat[j] == 0)
+                        break;
+                    if (mCaptureSupportedFormat[i] == mEncoderSupportedFormat[j]){
+                        mPictureEncodeFormat= mCaptureSupportedFormat[i];
+
+                        CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
+                                mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
+                                (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
+                        break;
+                    }
+                }
+                if ((mPictureEncodeFormat != 0) || (mCaptureSupportedFormat[i] == 0))
+                    break;
+            }
+            if (mPictureEncodeFormat == 0){
+                mPictureEncodeFormat = mEncoderSupportedFormat[0];
+                mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat; //For uvc now, IPU only can support yuyv.
+                mPPDeviceNeedForPic = true;
+                CAMERA_HAL_LOG_INFO("Need to do the CSC for Jpeg encoder");
+                CAMERA_HAL_LOG_INFO(" Get the captured format is :%c%c%c%c\n",
+                        mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
+                        (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
+                CAMERA_HAL_LOG_INFO(" Get the mPictureEncodeFormat :%c%c%c%c\n",
+                        mPictureEncodeFormat & 0xFF, (mPictureEncodeFormat >> 8) & 0xFF,
+                        (mPictureEncodeFormat >> 16) & 0xFF, (mPictureEncodeFormat >> 24) & 0xFF);
+            }else{
+                mCaptureDeviceCfg.fmt = mPictureEncodeFormat;
+            }
+        }else{
+            CAMERA_HAL_LOG_INFO("mDefaultPreviewFormat :%c%c%c%c\n",
+                    mDefaultPreviewFormat & 0xFF, (mDefaultPreviewFormat >> 8) & 0xFF,
+                    (mDefaultPreviewFormat >> 16) & 0xFF, (mDefaultPreviewFormat >> 24) & 0xFF);
+            CAMERA_HAL_LOG_INFO("mUvcSpecialCaptureFormat :%c%c%c%c\n",
+                    mUvcSpecialCaptureFormat & 0xFF, (mUvcSpecialCaptureFormat >> 8) & 0xFF,
+                    (mUvcSpecialCaptureFormat >> 16) & 0xFF, (mUvcSpecialCaptureFormat >> 24) & 0xFF);
+
+            if(mPPDeviceNeed == false) {
+                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                    CAMERA_HAL_LOG_RUNTIME("mCaptureSupportedFormat[%d] is %x", i, mCaptureSupportedFormat[i]);
+                    if (mCaptureSupportedFormat[i] == mDefaultPreviewFormat){
+                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                        //mPPDeviceNeed = false;
+                        //mPreviewCapturedFormat = mPreviewFormat;
+                        mCaptureDeviceCfg.fmt = mDefaultPreviewFormat;
+                        break;
+                    }
+                }
+            }
+            else {
+                for(i =0; i< MAX_QUERY_FMT_TIMES; i ++){
+                    //since for CSI, the CSI can convert to any YUV format if necessary, so specailly is just for UVC
+                    if (mCaptureSupportedFormat[i] == mUvcSpecialCaptureFormat){
+                        CAMERA_HAL_LOG_RUNTIME("get the correct format [%d] is %x", i, mCaptureSupportedFormat[i]);
+                        //mPPDeviceNeed = true;
+                        //mPreviewCapturedFormat = mUvcSpecialCaptureFormat;
+                        mCaptureDeviceCfg.fmt = mUvcSpecialCaptureFormat;
+                        break;
+                    }
+                }
+            }
+
+            CAMERA_HAL_LOG_INFO("mCaptureDeviceCfg.fmt :%c%c%c%c\n",
+                    mCaptureDeviceCfg.fmt & 0xFF, (mCaptureDeviceCfg.fmt >> 8) & 0xFF,
+                    (mCaptureDeviceCfg.fmt >> 16) & 0xFF, (mCaptureDeviceCfg.fmt >> 24) & 0xFF);
+
+            if ((i == MAX_QUERY_FMT_TIMES)){
+                CAMERA_HAL_ERR("Negotiate for the preview format error");
+                return BAD_VALUE;
+            }
+        }
+
+
+        return ret;
+    }
+
+    int CameraHal :: PrepareJpegEncoder()
+    {
+        int ret = NO_ERROR;
+        struct jpeg_enc_make_info_t make_info;
+        struct jpeg_enc_makernote_info_t makernote_info;
+        struct jpeg_enc_model_info_t model_info;
+        struct jpeg_enc_datetime_info_t datetime_info;
+        struct jpeg_enc_focallength_t focallength_info;
+        struct jpeg_enc_gps_param gps_info;
+        int rotate_angle = 0;
+        JPEG_ENCODER_WHITEBALANCE whitebalance_info;
+        JPEG_ENCODER_FLASH flash_info;
+        const char * pWhiteBalanceStr, *pFlashStr;
+
+        char temp_string[30], gps_datetime_string[11];
+        char format[30] = "%Y:%m:%d %k:%M:%S";
+        time_t clock;
+        struct tm *tm, *temp_tm;
+        char * cLatitude, *cLongtitude, *cAltitude,*cTimeStamp;
+        double dAltitude;
+
+        mJpegEncCfg.BufFmt = mPictureEncodeFormat;
+        mParameters.getPictureSize((int *)&(mJpegEncCfg.PicWidth), (int *)&(mJpegEncCfg.PicHeight));
+        mJpegEncCfg.ThumbWidth = (unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH);
+        mJpegEncCfg.ThumbHeight =(unsigned int)mParameters.getInt(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT);
+        CAMERA_HAL_LOG_INFO("the pic width %d, height %d, fmt %d", mJpegEncCfg.PicWidth, mJpegEncCfg.PicHeight, mJpegEncCfg.BufFmt);
+        CAMERA_HAL_LOG_INFO("the thumbnail width is %d, height is %d", mJpegEncCfg.ThumbWidth, mJpegEncCfg.ThumbHeight);
+        //set focallength info
+        focallength_info.numerator=10001;
+        focallength_info.denominator=1000;  // hardcode here for the cts
+        mJpegEncCfg.pFoclLength = &focallength_info;
+
+        //set the make info
+        make_info.make_bytes=strlen(EXIF_MAKENOTE);
+        strcpy((char *)make_info.make, EXIF_MAKENOTE);
+        mJpegEncCfg.pMakeInfo = &make_info;
+
+        //set makernote info
+        makernote_info.makernote_bytes=strlen(EXIF_MAKENOTE);
+        strcpy((char *)makernote_info.makernote, EXIF_MAKENOTE);
+        mJpegEncCfg.pMakeNote = &makernote_info;
+
+        //set model info
+        model_info.model_bytes=strlen(EXIF_MODEL);
+        strcpy((char *)model_info.model,EXIF_MODEL);
+        mJpegEncCfg.pModelInfo = &model_info;
+
+        //set datetime
+        time(&clock);
+        tm = localtime(&clock);
+        time_t GpsUtcTime;
+        strftime(temp_string, sizeof(temp_string), format, tm);
+        CAMERA_HAL_LOG_INFO("the date time is %s", temp_string);
+        memcpy((char *)datetime_info.datetime, temp_string, sizeof(datetime_info.datetime));
+        mJpegEncCfg.pDatetimeInfo = &datetime_info;
+
+        rotate_angle = mParameters.getInt(CameraParameters::KEY_ROTATION);
+        if (rotate_angle == 0)
+            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL; //the android and the jpeg has the same define
+        else if (rotate_angle == 90)
+            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_90;
+        else if (rotate_angle == 180)
+            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_180;
+        else if (rotate_angle == 270)
+            mJpegEncCfg.RotationInfo = ORIENTATION_ROTATE_270;
+        else
+            mJpegEncCfg.RotationInfo = ORIENTATION_NORMAL;
+        CAMERA_HAL_LOG_INFO("ratate info is %d", rotate_angle);
+
+        pWhiteBalanceStr = mParameters.get(CameraParameters::KEY_WHITE_BALANCE);
+        CAMERA_HAL_LOG_INFO("white balance is %s",pWhiteBalanceStr);
+        if (strcmp(pWhiteBalanceStr, CameraParameters::WHITE_BALANCE_AUTO) == 0){
+            whitebalance_info = WHITEBALANCE_AUTO;
+        }else{
+            whitebalance_info = WHITEBALANCE_MANUAL;
+        }
+        mJpegEncCfg.WhiteBalanceInfo = whitebalance_info;
+
+        pFlashStr = mParameters.get(CameraParameters::KEY_FLASH_MODE);
+        CAMERA_HAL_LOG_INFO("flash mode is %s", pFlashStr);
+        if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_OFF) == 0){
+            flash_info = FLASH_NOT_FIRE;
+        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_AUTO) == 0){
+            flash_info = FLASH_FIRED_AUTO;
+        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_ON) == 0){
+            flash_info = FLASH_FIRED;
+        }else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_RED_EYE) == 0){
+            flash_info = FLASH_FIRED_RED_EYE_REDUCE;
+        }
+        else if (strcmp(pFlashStr, CameraParameters::FLASH_MODE_TORCH) == 0){
+            flash_info = FLASH_FIRED_COMPULOSORY;
+        }
+        else{
+            flash_info = FLASH_NOT_FIRE;
+        }
+        mJpegEncCfg.FlashInfo = flash_info;
+
+        cLatitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_LATITUDE);
+        cLongtitude = (char *)mParameters.get(CameraParameters::KEY_GPS_LONGITUDE);
+        cAltitude   = (char *)mParameters.get(CameraParameters::KEY_GPS_ALTITUDE);
+        cTimeStamp  = (char *)mParameters.get(CameraParameters::KEY_GPS_TIMESTAMP);
+
+        if (cLatitude !=NULL && cLongtitude!=NULL && cAltitude!=NULL && cTimeStamp!=NULL){
+
+            gps_info.version=0x02020000;
+
+            //latitude: dd/1,mm/1,ss/1
+            gps_info.latitude_degree[1]=1;
+            gps_info.latitude_minute[1]=1;
+            gps_info.latitude_second[1]=1000;
+            memcpy((char *)gps_info.latitude_ref, (char *)"N ", sizeof(gps_info.latitude_ref));
+
+            if (stringTodegree(cLatitude, gps_info.latitude_degree[0],gps_info.latitude_minute[0],gps_info.latitude_second[0])>0){
+                //the ref is south
+                memcpy((char *)gps_info.latitude_ref, (char *)"S ", sizeof(gps_info.latitude_ref));
+            }
+
+            //longtitude: dd/1,mm/1,ss/1
+            gps_info.longtitude_degree[1]=1;
+            gps_info.longtitude_minute[1]=1;
+            gps_info.longtitude_second[1]=1000;
+            memcpy((char *)gps_info.longtitude_ref, (char *)"E ", sizeof(gps_info.longtitude_ref));
+
+            if (stringTodegree(cLongtitude, gps_info.longtitude_degree[0],gps_info.longtitude_minute[0],gps_info.longtitude_second[0])>0){
+                //the ref is Weston
+                memcpy((char *)gps_info.longtitude_ref, (char *)"W ", sizeof(gps_info.longtitude_ref));
+            }
+
+            //altitude(meters): aa/1
+            gps_info.altitude_ref=0;		// 0: up sea level; 1: below sea level
+            gps_info.altitude[0]=1000;
+            gps_info.altitude[1]=1;
+            if (cAltitude != NULL){
+                int intValue;
+                gps_info.altitude[1]=1000;	   // the precision is CM
+                dAltitude= atof(cAltitude);
+                CAMERA_HAL_LOG_RUNTIME("the altitude is %s", cAltitude);
+                intValue = (int)(dAltitude * 1000.0);
+                if (intValue<0) {gps_info.altitude_ref = 1; intValue *= -1;}
+                gps_info.altitude[0] = (unsigned long) intValue;
+                CAMERA_HAL_LOG_RUNTIME("gps_info.altitude[0] is %u, gps_info.altitude_ref is %d", gps_info.altitude[0], gps_info.altitude_ref);
+            }
+
+            //timestamp: hh/1,mm/1,ss/1
+            gps_info.hour[1]=1;
+            gps_info.minute[1]=1;
+            gps_info.seconds[1]=1;
+            if (cTimeStamp != NULL){
+
+                GpsUtcTime = atol(cTimeStamp);
+                CAMERA_HAL_LOG_INFO("the Timestamp is %s", cTimeStamp);
+                temp_tm = gmtime((const time_t*)&GpsUtcTime);
+                if (temp_tm != NULL)
+                    tm = temp_tm;
+            }
+
+            gps_info.hour[0] = tm->tm_hour;
+            gps_info.minute[0] = tm->tm_min;
+            gps_info.seconds[0] = tm->tm_sec;
+
+            strcpy (format, "%Y:%m:%d ");
+
+
+            strftime((char *)temp_string, strlen(temp_string), format, tm);
+            memcpy(gps_info.datestamp, temp_string, sizeof(gps_info.datestamp));
+
+
+            char * progressMehod = (char *)mParameters.get(CameraParameters::KEY_GPS_PROCESSING_METHOD);
+            if (progressMehod == NULL){
+                CAMERA_HAL_LOG_INFO("The progressMethod is NULL, add a fake");
+                progressMehod = (char *)"fsl_fake_method";
+            }
+            CAMERA_HAL_LOG_INFO("the progressMethod is %s", progressMehod);
+
+            memcpy(gps_info.processmethod, progressMehod, strlen(progressMehod));
+
+            gps_info.processmethod_bytes=strlen(progressMehod);
+
+            CAMERA_HAL_LOG_INFO("the method is %s", gps_info.processmethod);
+
+            mJpegEncCfg.pGps_info = &gps_info;
+        }else{
+            mJpegEncCfg.pGps_info = NULL;
+        }
+
+        if (mJpegEncoder->JpegEncoderInit(&mJpegEncCfg)< 0){
+            CAMERA_HAL_ERR("Jpeg Encoder Init error !!!");
+            return UNKNOWN_ERROR;
+        }
+
+        return ret;
+    }
+
+    status_t CameraHal::convertPreviewFormatToString(char *pStr, int length, unsigned int format)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(pStr == NULL || length < 10) {
+            CAMERA_HAL_ERR("%s: invalide parameters", __FUNCTION__);
+            return BAD_VALUE;
+        }
+        if(format == v4l2_fourcc('Y','U','1','2')) {
+            strcpy(pStr, "yuv420p");
+        }
+        else if(format == v4l2_fourcc('N','V','1','2')) {
+            strcpy(pStr, "yuv420sp");
+        }
+        //else if(format == v4l2_fourcc('Y','U','Y','V')) {
+        //    strcpy(pStr, "yuv422i-yuyv");
+        //}
+        else {
+            CAMERA_HAL_ERR("%s: Only YU12 or NV12 is supported", __FUNCTION__);
+            return BAD_VALUE;
+        }
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::convertStringToPreviewFormat(unsigned int *pFormat)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(!strcmp(mParameters.getPreviewFormat(), "yuv420p")) {
+            *pFormat = v4l2_fourcc('Y','U','1','2');
+        }
+        else if(!strcmp(mParameters.getPreviewFormat(), "yuv420sp")) {
+            *pFormat = v4l2_fourcc('N','V','1','2');
+        }
+        //else if(!strcmp(mParameters.getPreviewFormat(), "yuv422i-yuyv")) {
+        //    *pFormat = v4l2_fourcc('Y','U','Y','V');
+        //}
+        else {
+            CAMERA_HAL_ERR("Only yuv420sp or yuv420p is supported");
+            return BAD_VALUE;
+        }
+        return NO_ERROR;
+    }
+
+    status_t CameraHal::CameraHALStartPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int  max_fps, min_fps;
+
+        mParameters.getPreviewSize((int *)&(mCaptureDeviceCfg.width),(int *)&(mCaptureDeviceCfg.height));
+
+        if ((ret = convertStringToPreviewFormat(&mPreviewCapturedFormat)) != 0) {
+            CAMERA_HAL_ERR("%s: convertStringToPreviewFormat error", __FUNCTION__);
+            return ret;
+        }
+
+        mCaptureDeviceCfg.fmt = mPreviewCapturedFormat;
+        CAMERA_HAL_LOG_RUNTIME("*********%s,mCaptureDeviceCfg.fmt=%x************", __FUNCTION__, mCaptureDeviceCfg.fmt);
+        mCaptureDeviceCfg.rotate = (SENSOR_PREVIEW_ROTATE)mPreviewRotate;
+        mCaptureDeviceCfg.tv.numerator = 1;
+        mCaptureDevice->GetDevName(mCameraSensorName);
+        if (strstr(mCameraSensorName, "uvc") == NULL){
+        //according to google's doc getPreviewFrameRate & getPreviewFpsRange should support both.
+        // so here just a walkaround, if the app set the frameRate, will follow this frame rate.
+        if (mParameters.getPreviewFrameRate() >= 15)
+            mCaptureDeviceCfg.tv.denominator = mParameters.getPreviewFrameRate();
+        else{
+            mParameters.getPreviewFpsRange(&min_fps, &max_fps);
+            CAMERA_HAL_LOG_INFO("###start the capture the fps is %d###", max_fps);
+            mCaptureDeviceCfg.tv.denominator = max_fps/1000;
+        }
+        }else{
+                mCaptureDeviceCfg.tv.denominator = 15;
+        }
+        mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
+        mPPbufNum = POST_PROCESS_BUFFER_NUM;
+        mTakePicFlag = false;
+
+        if ((ret = PrepareCaptureDevices()) < 0){
+            CAMERA_HAL_ERR("PrepareCaptureDevices error ");
+            return ret;
+        }
+        if (mPPDeviceNeed){
+            if ((ret = PreparePostProssDevice()) < 0){
+                CAMERA_HAL_ERR("PreparePostProssDevice error");
+                return ret;
+            }
+        }
+        if ((ret = PreparePreviwBuf()) < 0){
+            CAMERA_HAL_ERR("PreparePreviwBuf error");
+            return ret;
+        }
+
+        if ((ret = PreparePreviwMisc()) < 0){
+            CAMERA_HAL_ERR("PreparePreviwMisc error");
+            return ret;
+        }
+
+        if(mNativeWindow != NULL) {
+            if ((ret = CameraHALPreviewStart()) < 0){
+                CAMERA_HAL_ERR("CameraHALPreviewStart error");
+                return ret;
+            }
+        }
+        //mPreviewRunning = true;
+        return ret;
+    }
+    void CameraHal::CameraHALStopPreview()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if (mPreviewRunning != 0)	{
+            CameraHALStopThreads();
+            CameraHALStopMisc();
+            mCaptureBufNum = 0;
+            CAMERA_HAL_LOG_INFO("camera hal stop preview done");
+        }else{
+            CAMERA_HAL_LOG_INFO("Camera hal already stop preview");
+        }
+        //mCaptureBufNum = 0;
+        return ;
+    }
+
+    void CameraHal :: CameraHALStopThreads()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        
+        mCaptureLock.lock();
+        if(mCaptureRunning) {
+            CAMERA_HAL_LOG_INFO("%s :capture run", __FUNCTION__);
+            mCaptureThreadQueue.postStopMessage();
+            mCaptureRunning = false;
+            sem_wait(&mCaptureStoppedCondition);
+        }else {
+            CAMERA_HAL_LOG_INFO("%s :capture not run", __FUNCTION__);
+        }
+        mCaptureLock.unlock();
+        CAMERA_HAL_LOG_INFO("%s :---------", __FUNCTION__);
+
+        mPostProcessLock.lock(); 
+        if(mPPDeviceNeed && mPreviewRunning) {
+            CAMERA_HAL_LOG_INFO("%s :postprocess run", __FUNCTION__);
+            mPostProcessThreadQueue.postStopMessage();
+            sem_wait(&mPostProcessStoppedCondition);
+        }
+        mPostProcessLock.unlock(); 
+
+        mPreviewLock.lock();
+        if(mPreviewRunning) {
+            CAMERA_HAL_LOG_INFO("%s :preview run", __FUNCTION__);
+            mPreviewThreadQueue.postStopMessage();
+            mPreviewRunning = false;
+            sem_wait(&mPreviewStoppedCondition);
+        }else {
+            CAMERA_HAL_LOG_INFO("%s :preview not run", __FUNCTION__);
+        }
+        mPreviewLock.unlock();
+        CAMERA_HAL_LOG_INFO("%s :exit", __FUNCTION__);
+        
+        return ;
+    }
+
+    void CameraHal :: CameraHALStopMisc()
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        if(mPPDeviceNeed){
+            for (unsigned int i = 0; i < mPPbufNum; i++){
+                mPmemAllocator->deAllocate(&mPPbuf[i]);
+            }
+            mPmemAllocator = NULL;
+        }
+        mCaptureDevice->DevStop();
+        //mCaptureDevice->DevDeAllocate();
+        freeBuffersToNativeWindow();
+        //CloseCaptureDevice();
+        //mCaptureBufNum = 0;
+    }
+
+    status_t CameraHal :: PrepareCaptureBufs()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        //status_t ret = NO_ERROR;
+        //if(mCaptureBufNum == 0) {
+        //    mCaptureBufNum = PREVIEW_CAPTURE_BUFFER_NUM;
+        //}
+        unsigned int CaptureBufNum = mCaptureBufNum;
+        
+        if(allocateBuffersFromNativeWindow() < 0) {
+            CAMERA_HAL_ERR("allocateBuffersFromNativeWindow error");
+            return BAD_VALUE;
+        }
+
+        if (mCaptureDevice->DevRegisterBufs(mCaptureBuffers,&CaptureBufNum)< 0){
+            CAMERA_HAL_ERR("capture device allocat buf error");
+            return BAD_VALUE;
+        }
+        if(mCaptureBufNum != CaptureBufNum){
+            CAMERA_HAL_LOG_INFO("The driver can only supply %d bufs, but required %d bufs", CaptureBufNum, mCaptureBufNum);
+        }
+
+        mCaptureBufNum = CaptureBufNum;
+
+        if (mCaptureDevice->DevPrepare()< 0){
+            CAMERA_HAL_ERR("capture device prepare error");
+            return BAD_VALUE;
+        }
+        nCameraBuffersQueued = mCaptureBufNum;
+        isCaptureBufsAllocated = 1;
+
+        return NO_ERROR;
+    }
+
+    status_t CameraHal :: PrepareCaptureDevices()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int i =0;
+        //unsigned int CaptureBufNum = mCaptureBufNum;
+        struct capture_config_t *pCapcfg;
+        if ((ret = OpenCaptureDevice())<0)
+            return ret;
+
+        if (mCaptureDevice->DevSetConfig(&mCaptureDeviceCfg) < 0) {//set the config and get the captured framesize
+            CAMERA_HAL_ERR("Dev config failed");
+            return BAD_VALUE;
+        }
+        mCaptureFrameSize = mCaptureDeviceCfg.framesize;
+
+        if(mNativeWindow != 0) {
+            if(PrepareCaptureBufs() < 0) {
+                CAMERA_HAL_ERR("PrepareCaptureBufs() error");
+                return BAD_VALUE;
+            }
+        }
+
+        return ret;
+    }
+
+    status_t CameraHal::PreparePostProssDevice()
+    {
+
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int targetFmt;
+        if (mTakePicFlag)
+            targetFmt = mPictureEncodeFormat;
+        else
+            targetFmt = mDefaultPreviewFormat;
+
+        pthread_mutex_lock(&mPPIOParamMutex);
+        mPPInputParam.width = mCaptureDeviceCfg.width;
+        mPPInputParam.height= mCaptureDeviceCfg.height;
+        mPPInputParam.fmt   = mCaptureDeviceCfg.fmt;
+        mPPInputParam.input_crop_win.pos.x = 0;
+        mPPInputParam.input_crop_win.pos.y = 0;
+        mPPInputParam.input_crop_win.win_w = mCaptureDeviceCfg.width;
+        mPPInputParam.input_crop_win.win_h = mCaptureDeviceCfg.height;
+
+        mPPOutputParam.width = mCaptureDeviceCfg.width;
+        mPPOutputParam.height= mCaptureDeviceCfg.height;
+        mPPOutputParam.fmt   = targetFmt;
+        mPPOutputParam.rot   = 0;
+        mPPOutputParam.output_win.pos.x = 0;
+        mPPOutputParam.output_win.pos.y = 0;
+        mPPOutputParam.output_win.win_w = mCaptureDeviceCfg.width;
+        mPPOutputParam.output_win.win_h = mCaptureDeviceCfg.height;
+        pthread_mutex_unlock(&mPPIOParamMutex);
+        return ret;
+    }
+
+    status_t CameraHal::PreparePreviwBuf()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        unsigned int i =0;
+
+        //temply hard code here
+        if (mTakePicFlag == 0){
+            if(V4L2_PIX_FMT_NV12)
+                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height*3/2;
+            else 
+                mPreviewFrameSize = mCaptureDeviceCfg.width*mCaptureDeviceCfg.height *2;
+
+            if(mPreviewMemory != NULL) {
+                mPreviewMemory->release(mPreviewMemory);
+            }
+
+            mPreviewMemory = mRequestMemory(-1, mPreviewFrameSize, mPreviewHeapBufNum, NULL);
+            if(mPreviewMemory == NULL) {
+                CAMERA_HAL_ERR("%s, allocate memory failed", __FUNCTION__);
+                return NO_MEMORY;
+            }
+            //now the preview fmt is supposed to be YUV420SP, so, it is now hard code here
+            //mPreviewHeap.clear();
+            //for (i = 0; i< mPreviewHeapBufNum; i++)
+            //    mPreviewBuffers[i].clear();
+            //mPreviewHeap = new MemoryHeapBase(mPreviewFrameSize * mPreviewHeapBufNum);
+            //if (mPreviewHeap == NULL)
+            //    return NO_MEMORY;
+            //for (i = 0; i < mPreviewHeapBufNum; i++)
+            //    mPreviewBuffers[i] = new MemoryBase(mPreviewHeap, mPreviewFrameSize* i, mPreviewFrameSize);
+        }
+        /*allocate the buffer for IPU process*/
+        if (mPPDeviceNeed || mPPDeviceNeedForPic){
+            mPmemAllocator = new PmemAllocator(mPPbufNum, mCaptureFrameSize);
+
+            if(mPmemAllocator == NULL || mPmemAllocator->err_ret < 0){
+                return NO_MEMORY;
+            }
+            for (i = 0; i < mPPbufNum; i++){
+                if(mPmemAllocator->allocate(&(mPPbuf[i]),mCaptureFrameSize) < 0){
+                    return NO_MEMORY;
+                }
+            }
+        }
+        return ret;
+    }
+
+    status_t CameraHal ::PreparePreviwMisc()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        dequeue_head = 0;
+        preview_heap_buf_head = 0;
+        display_head = 0;
+        enc_head     = 0;
+        pp_in_head   = 0;
+        pp_out_head  = 0;
+        error_status = 0;
+        is_first_buffer = 1;
+        last_display_index = 0;
+
+        //for(unsigned int i=0; i < mCaptureBufNum; i++) {
+        //    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
+        //}
+//        sem_init(&avab_dequeue_frame, 0, mCaptureBufNum);
+//        sem_init(&avab_show_frame, 0, 0);
+//        sem_init(&avab_enc_frame, 0, 0);
+//		sem_init(&avab_enc_frame_finish, 0, 0);
+		if(mPPDeviceNeed){
+            sem_init(&avab_pp_in_frame, 0, 0);
+            sem_init(&avab_pp_out_frame, 0, mPPbufNum);
+        }
+        return ret;
+    }
+
+    status_t CameraHal ::CameraHALPreviewStart()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        if (mCaptureDevice->DevStart()<0)
+            return INVALID_OPERATION;
+        
+        isCaptureBufsAllocated = 1;
+        for(unsigned int i=0; i < mCaptureBufNum; i++) {
+            mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, i));
+        }
+        return ret;
+    }
+    
+    status_t CameraHal::putBufferCount(DMA_BUFFER *pBuf)
+    {
+        if(pBuf == NULL)
+            return INVALID_OPERATION;
+            
+        Mutex::Autolock _l(pBuf->mBufferLock);
+        pBuf->refCount --;
+        if(pBuf->refCount == 0) {
+            if(!mPPDeviceNeed && mNativeWindow != 0 && mCaptureRunning) {
+                unsigned int buf_index = -1;    
+                //queue the v4l2 buf back
+                android_native_buffer_t *buf = NULL;
+                buffer_handle_t *buf_h = NULL;
+                int stride;
+                int err = mNativeWindow->dequeue_buffer(mNativeWindow, &buf_h, &stride);
+                if((err != 0) || buf_h == NULL) {
+                    CAMERA_HAL_ERR("%s: dequeueBuffer failed.", __FUNCTION__);
+                    return INVALID_OPERATION;
+                }
+                buf = container_of(buf_h, ANativeWindowBuffer, handle);
+                //mNativeWindow->lockBuffer(mNativeWindow.get(), buf);
+                SearchBuffer((void *)buf, &buf_index);
+                if(buf_index < mCaptureBufNum) {
+                    if(mCaptureDevice->DevQueue(buf_index) <0){
+                        CAMERA_HAL_ERR("The Capture device queue buf error !!!!");
+                        mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                        return INVALID_OPERATION;
+                    }
+                    mCaptureBuffers[buf_index].buf_state = WINDOW_BUFS_DEQUEUED;
+                    mCaptureBuffers[buf_index].refCount = 0;
+                    nCameraBuffersQueued++;
+                    mEnqueuedBufs --;
+                    mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, buf_index));
+                }else {
+                    mNativeWindow->cancel_buffer(mNativeWindow, &buf->handle);
+                    CAMERA_HAL_ERR("dequeue invalide buffer!!!!");
+                    return INVALID_OPERATION;
+                }                  
+            }else if(mPPDeviceNeed){
+                mCaptureThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, 0));
+            }//end elseif            
+        }
+        return NO_ERROR;
+    }
+    
+    void CameraHal ::getBufferCount(DMA_BUFFER *pBuf)
+    {
+        if(pBuf == NULL)
+            return;
+        Mutex::Autolock _l(pBuf->mBufferLock);
+        pBuf->refCount ++;        
+    }
+
+    int CameraHal ::captureframeThreadWrapper() 
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        while(1) {
+            if(mExitCaptureThread) {
+                CAMERA_HAL_LOG_INFO("%s: exiting normally", __FUNCTION__);
+                return 0;
+            }
+            ret = captureframeThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s: capture thread exit with exception", __FUNCTION__);
+                return ret;
+            }
+        }
+        return ret;
+    }
+
+    int CameraHal ::captureframeThread()
+    {
+        //CAMERA_HAL_LOG_FUNC;
+        
+        unsigned int bufIndex = -1;
+        status_t ret = NO_ERROR;
+        sp<CMessage> msg = mCaptureThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;            
+        }
+                
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                ret = mCaptureDevice->DevDequeue(&bufIndex);
+                //handle the error return.
+                if(ret < 0) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer", __FUNCTION__);
+                    mCaptureThreadQueue.postQuitMessage();
+                    return NO_ERROR;
+                }
+                //handle the normal return.
+                if(!mPPDeviceNeed) {
+                    getBufferCount(&mCaptureBuffers[bufIndex]);
+                    mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                    
+                    if(mRecordRunning) {
+                        getBufferCount(&mCaptureBuffers[bufIndex]);
+                        //CAMERA_HAL_LOG_INFO("%s: post encode message %d", __FUNCTION__, bufIndex);
+                        mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                    }
+                }else {
+                    getBufferCount(&mCaptureBuffers[bufIndex]);
+                    mPostProcessThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, bufIndex));
+                }
+                break;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: capture thread stop", __FUNCTION__);
+                mCaptureThreadQueue.clearMessage();
+                sem_post(&mCaptureStoppedCondition);
+                CAMERA_HAL_LOG_INFO("%s: capture thread stop finish", __FUNCTION__);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitCaptureThread = 1;
+                if(!mPPDeviceNeed) {
+                    mPreviewThreadQueue.postQuitMessage();
+                    if(mRecordRunning)
+                        mEncodeThreadQueue.postQuitMessage();
+                }else {
+                    mPostProcessThreadQueue.postQuitMessage();
+                }
+                break;
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;
+        }//end switch
+        
+        return ret;
+    }
+
+    int CameraHal::postprocessThreadWrapper()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+
+        while(1) {
+            if(mExitPostProcessThread) {
+                CAMERA_HAL_LOG_INFO("%s, postprocessThread exit normally", __FUNCTION__);
+                return ret;
+            }
+            ret = postprocessThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s, postprocessThread exit with exception", __FUNCTION__);
+                return ret;
+            }
+        }
+        return ret;
+    }
+
+    int CameraHal::postprocessThread()
+    {
+        int PPInIdx = 0, PPoutIdx = 0;
+        DMA_BUFFER *PPInBuf, *PPoutBuf;
+        status_t ret = NO_ERROR;
+        
+        sp<CMessage> msg = mPostProcessThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;
+        }
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                PPInIdx = msg->arg0;
+                if(PPInIdx < 0 || (unsigned int)PPInIdx >= mCaptureBufNum) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    return BAD_VALUE;  
+                }
+                PPInBuf = &mCaptureBuffers[PPInIdx];
+                PPoutIdx = pp_out_head;
+                PPoutBuf = &mPPbuf[PPoutIdx];
+                pp_out_head ++;
+                pp_out_head %= mPPbufNum;
+
+                pthread_mutex_lock(&mPPIOParamMutex);
+                mPPInputParam.user_def_paddr = PPInBuf->phy_offset;
+                mPPOutputParam.user_def_paddr = PPoutBuf->phy_offset;
+                mPPDevice->PPDeviceInit(&mPPInputParam, &mPPOutputParam);
+                mPPDevice->DoPorcess(PPInBuf, PPoutBuf);
+                mPPDevice->PPDeviceDeInit();
+                pthread_mutex_unlock(&mPPIOParamMutex);
+
+                getBufferCount(&mPPbuf[PPoutIdx]);
+                mPreviewThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, PPoutIdx));
+                
+                if(mRecordRunning) {
+                    getBufferCount(&mPPbuf[PPoutIdx]);
+                    //CAMERA_HAL_LOG_INFO("%s: post encode message %d", __FUNCTION__, PPoutIdx);
+                    mEncodeThreadQueue.postMessage(new CMessage(CMESSAGE_TYPE_NORMAL, PPoutIdx));
+                }
+
+                ret = putBufferCount(PPInBuf);                       
+                break;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: postprocess thread stop", __FUNCTION__);
+                mPostProcessThreadQueue.clearMessage();
+                sem_post(&mPostProcessStoppedCondition);
+                CAMERA_HAL_LOG_INFO("%s: postprocess thread stop finish", __FUNCTION__);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitPostProcessThread = 1;
+                mPreviewThreadQueue.postQuitMessage();
+                if(mRecordRunning)
+                    mEncodeThreadQueue.postQuitMessage();
+                break;
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;
+        }
+        return ret;
+    }
+
+    void CameraHal::SearchBuffer(void *pNativeBuf, unsigned int *pIndex)
+    {
+        //int index;
+        for(unsigned int i=0; i < mCaptureBufNum; i++){
+            if(mCaptureBuffers[i].native_buf == pNativeBuf) {
+                *pIndex = i;
+                return;
+            }
+        }
+
+        *pIndex = -1;
+        return;
+    }
+    
+    int CameraHal ::previewshowFrameThreadWrapper()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        while(1) {
+            if(mExitPreviewThread) {
+                CAMERA_HAL_LOG_INFO("%s: exiting", __FUNCTION__);
+                return 0;
+            }
+            ret = previewshowFrameThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s: capture thread exit with exception", __FUNCTION__);
+                return ret;
+            }            
+        }
+        return ret;
+    }
+
+    static void bufferDump(DMA_BUFFER *pBufs)
+    {
+#ifdef FSL_CAMERAHAL_DUMP
+            //for test code
+            char value[10] = {0};
+            static int vflg = 0;
+            property_get("rw.camera.test", value, "");
+            if(strcmp(value, "1") == 0)
+                vflg = 1;
+            if(vflg){
+                FILE *pf = NULL;
+                pf = fopen("/sdcard/camera_tst.data", "wb");
+                if(pf == NULL) {
+                    CAMERA_HAL_ERR("open /sdcard/camera_tst.data failed");
+                }
+                else {
+                    fwrite(pInBuf->virt_start, pInBuf->length, 1, pf);
+                    fclose(pf);
+                }
+                vflg = 0;
+            }
+#endif                    
+    }
+    
+    int CameraHal ::previewshowFrameThread()
+    {
+        //CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int display_index;
+        DMA_BUFFER *pInBuf = NULL;
+        
+        sp<CMessage> msg = mPreviewThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;            
+        }
+                
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                display_index = msg->arg0;
+                if(display_index < 0 || (unsigned int)display_index >= mCaptureBufNum) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    return BAD_VALUE;  
+                }
+                                
+                if(!mPPDeviceNeed) {
+                    pInBuf = &mCaptureBuffers[display_index];
+                }else {
+                    pInBuf = &mPPbuf[display_index];
+                }
+                
+                if (mMsgEnabled & CAMERA_MSG_PREVIEW_FRAME) {
+                    //CAMERA_HAL_ERR("*******CAMERA_MSG_PREVIEW_FRAME*******");
+                    convertNV12toYUV420SP((uint8_t*)(pInBuf->virt_start),
+                            (uint8_t*)((unsigned char*)mPreviewMemory->data + preview_heap_buf_head*mPreviewFrameSize),mCaptureDeviceCfg.width, mCaptureDeviceCfg.height);
+                    mDataCb(CAMERA_MSG_PREVIEW_FRAME, mPreviewMemory, preview_heap_buf_head, NULL, mCallbackCookie);
+                    preview_heap_buf_head ++;
+                    preview_heap_buf_head %= mPreviewHeapBufNum;
+                }                
+
+                if (mNativeWindow != 0) {
+                    if (mNativeWindow->enqueue_buffer(mNativeWindow, &((android_native_buffer_t * )pInBuf->native_buf)->handle) < 0){
+                        CAMERA_HAL_ERR("queueBuffer failed. May be bcos stream was not turned on yet.");
+                        return BAD_VALUE;
+                    }
+                    pInBuf->buf_state = WINDOW_BUFS_QUEUED;
+
+                    mEnqueuedBufs ++;
+                    bufferDump(pInBuf);
+                    if (mEnqueuedBufs <= 2) {
+                        return NO_ERROR;
+                    }
+                } 
+                
+                ret = putBufferCount(pInBuf);                       
+                break;
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: preview thread stop", __FUNCTION__);
+                mPreviewThreadQueue.clearMessage();
+                sem_post(&mPreviewStoppedCondition);
+                CAMERA_HAL_LOG_INFO("%s: preview thread stop finish", __FUNCTION__);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitPreviewThread = 1;
+                break;
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;   
+        }
+        
+        return ret;
+    }
+    
+    int CameraHal::encodeframeThreadWrapper()
+    {
+        CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        while(1) {
+            if(mExitEncodeThread) {
+                CAMERA_HAL_ERR("%s: encode thread exit normally", __FUNCTION__);
+                return 0;
+            }
+            ret = encodeframeThread();
+            if(ret < 0) {
+                CAMERA_HAL_ERR("%s: encode thread exit with exception", __FUNCTION__);
+                return ret;
+            }
+        }
+        return ret;
+    }
+    
+    int CameraHal::encodeframeThread()
+    {
+        //CAMERA_HAL_LOG_FUNC;
+        status_t ret = NO_ERROR;
+        int enc_index;
+        sp<CMessage> msg = mEncodeThreadQueue.waitMessage();
+        if(msg == 0) {
+            CAMERA_HAL_ERR("%s: get invalide message", __FUNCTION__);
+            return BAD_VALUE;            
+        }
+            
+        switch(msg->what) {
+            case CMESSAGE_TYPE_NORMAL:
+                enc_index = msg->arg0;
+                unsigned int i;
+                if(enc_index < 0 || (unsigned int)enc_index >= mCaptureBufNum) {
+                    CAMERA_HAL_ERR("%s: get invalide buffer index", __FUNCTION__);
+                    return BAD_VALUE;  
+                }
+                
+                struct timespec ts;
+                DMA_BUFFER *EncBuf;
+                if (!mPPDeviceNeed){
+                    EncBuf = &mCaptureBuffers[enc_index];
+                }else{
+                    EncBuf = &mPPbuf[enc_index];
+                }
+
+                if ((mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) && mRecordRunning) {
+                    nsecs_t timeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
+                    //for(i = 0 ; i < mVideoBufNume; i ++) {
+        			//	if(mVideoBufferUsing[i] == 0) {
+        					if (bDerectInput == true) {
+        						memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
+        								(void*)&mVideoBufferPhy[enc_index], sizeof(VIDEOFRAME_BUFFER_PHY));
+        					} else {
+        						memcpy((unsigned char*)mVideoMemory->data + enc_index*mPreviewFrameSize,
+        								(void*)EncBuf->virt_start, mPreviewFrameSize);
+        						ret = putBufferCount(EncBuf);
+        					}
+        
+                            mVideoBufferUsing[enc_index] = 1;
+                            mDataCbTimestamp(timeStamp, CAMERA_MSG_VIDEO_FRAME, mVideoMemory, enc_index, mCallbackCookie);
+                            break;
+                    //    }
+                    //}
+                    //if (i == mVideoBufNume)
+                    //    CAMERA_HAL_LOG_INFO("no Buffer can be used for record\n");
+                }else {
+                    ret = putBufferCount(EncBuf);
+                }
+                break;
+
+            case CMESSAGE_TYPE_STOP:
+                CAMERA_HAL_LOG_INFO("%s: encode thread stop", __FUNCTION__);
+                //mEncodeThreadQueue.clearMessage();
+                sem_post(&mEncodeStoppedCondition);
+                break;
+            case CMESSAGE_TYPE_QUITE:
+                mExitEncodeThread = 1;
+                break;                
+
+            default:
+                CAMERA_HAL_ERR("%s: wrong msg type %d", __FUNCTION__, msg->what);
+                ret = INVALID_OPERATION;
+                break;                   
+        }
+        
+        return ret;
+    }
+
+    status_t CameraHal :: AllocateRecordVideoBuf()
+    {
+        status_t ret = NO_ERROR;
+        unsigned int i = 0;
+        //mVideoHeap.clear();
+        if(mVideoMemory != NULL) {
+            mVideoMemory->release(mVideoMemory);
+        }
+        //for(i = 0; i < mVideoBufNume; i++) {
+        //    mVideoBuffers[i].clear();
+        //    mVideoBufferUsing[i] = 0;
+        //}
+
+        CAMERA_HAL_LOG_RUNTIME("Init the video Memory size %d", mPreviewFrameSize);
+        //mVideoHeap = new MemoryHeapBase(mPreviewFrameSize * mVideoBufNume);
+        mVideoMemory = mRequestMemory(-1, mPreviewFrameSize, mVideoBufNume, NULL);
+        //if (mVideoHeap == NULL)
+        if(mVideoMemory == NULL) {
+            CAMERA_HAL_ERR("%s, request video buffer failed", __FUNCTION__);
+            return NO_MEMORY;
+        }
+        //for(i = 0; i < mVideoBufNume; i++) {
+        //    CAMERA_HAL_LOG_RUNTIME("Init Video Buffer:%d ",i);
+        //    mVideoBuffers[i] = new MemoryBase(mVideoHeap,
+        //            mPreviewFrameSize * i, mPreviewFrameSize);
+        //}
+
+        return ret;
+    }
+
+
+    void CameraHal :: LockWakeLock()
+    {
+        if (!mPowerLock) {
+            acquire_wake_lock (PARTIAL_WAKE_LOCK, V4LSTREAM_WAKE_LOCK);
+            mPowerLock = true;
+        }
+    }
+    void CameraHal :: UnLockWakeLock()
+    {
+        if (mPowerLock) {
+            release_wake_lock (V4LSTREAM_WAKE_LOCK);
+            mPowerLock = false;
+        }
+    }
+
+    void CameraHal::convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height)
+    {
+        /* Color space conversion from I420 to YUV420SP */
+        int Ysize = 0, UVsize = 0;
+        uint8_t *Yin, *Uin, *Vin, *Yout, *Uout, *Vout;
+
+        Ysize = width * height;
+        UVsize = width *  height >> 2;
+
+        Yin = inputBuffer;
+        Uin = Yin + Ysize;
+        Vin = Uin + 1;
+
+        Yout = outputBuffer;
+        Vout = Yout + Ysize;
+        Uout = Vout + 1;
+
+        memcpy(Yout, Yin, Ysize);
+
+        for(int k = 0; k < UVsize; k++) {
+            *Uout = *Uin;
+            *Vout = *Vin;
+            Uout += 2;
+            Vout += 2;
+            Uin  += 2;
+            Vin += 2;
+        }
+    }
+
+
+
+    int CameraHal::stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second)
+    {
+        double dAttribtute;
+        double eAttr;
+        long intAttribute;
+        int ret  = 0;
+        if (cAttribute == NULL){
+            return -1;
+        }
+
+        CAMERA_HAL_LOG_RUNTIME("the attribute is %s", cAttribute);
+
+        dAttribtute = atof(cAttribute);
+
+        CAMERA_HAL_LOG_RUNTIME("the double of the attribute is %lf", dAttribtute);
+        intAttribute  = (long)(dAttribtute*(double)3600.0);
+        if (intAttribute < 0){
+            ret = 1;
+            intAttribute *=-1;
+            dAttribtute *=-1;
+            eAttr = dAttribtute - (double)((double)intAttribute/(double)3600.0);
+            eAttr = eAttr * (double)3600.0 *(double)1000.0;
+        }else {
+            eAttr = dAttribtute - (double)((double)intAttribute/(double)3600.0);
+            eAttr = eAttr * (double)3600.0 *(double)1000.0;
+        }
+
+        second = (unsigned int)(intAttribute%60);
+        minute = (unsigned int)((intAttribute%3600-second)/60);
+        degree = (unsigned int)(intAttribute/3600);
+        second = (unsigned int)eAttr + second * 1000;
+
+        CAMERA_HAL_LOG_RUNTIME("the degree is %u, %u, %u", degree,minute,second);
+
+        return ret;
+
+    }
+
+#if 0
+#define FACE_BACK_CAMERA_NAME "back_camera_name"
+#define FACE_FRONT_CAMERA_NAME "front_camera_name"
+#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
+#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
+#define DEFAULT_ERROR_NAME '#'
+#define DEFAULT_ERROR_NAME_str "#"
+#define UVC_NAME "uvc"
+    static CameraInfo sCameraInfo[2];
+    static char Camera_name[2][MAX_SENSOR_NAME];
+
+    static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
+    {
+        char orientStr[10];
+
+        property_get (FACE_BACK_CAMERA_NAME,
+                pFaceBackCameraName,
+                DEFAULT_ERROR_NAME_str );
+        property_get (FACE_BACK_CAMERA_ORIENT,
+                orientStr,
+                DEFAULT_ERROR_NAME_str );
+
+        if (orientStr[0] == DEFAULT_ERROR_NAME )
+            *pFaceBackOrient = 0;
+        else 
+            *pFaceBackOrient = atoi(orientStr);
+
+        LOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
+
+        property_get (FACE_FRONT_CAMERA_NAME,
+                pFaceFrontCameraName,
+                DEFAULT_ERROR_NAME_str );
+
+        property_get (FACE_FRONT_CAMERA_ORIENT,
+                orientStr,
+                DEFAULT_ERROR_NAME_str );
+
+
+        if (orientStr[0] == DEFAULT_ERROR_NAME )
+            *pFaceFrontOrient = 0;
+        else 
+            *pFaceFrontOrient = atoi(orientStr);
+
+        LOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
+
+    }
+
+    int HAL_getNumberOfCameras()
+    {
+        int back_orient =0,  front_orient = 0;
+        int back_camera_num = 0, front_camera_num = 0;
+        GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
+        if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
+            sCameraInfo[0].facing = CAMERA_FACING_BACK;
+            sCameraInfo[0].orientation = back_orient;
+            back_camera_num++;
+        }
+        if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
+            if(back_camera_num > 0){
+                sCameraInfo[1].facing = CAMERA_FACING_FRONT;
+                sCameraInfo[1].orientation = front_orient;
+            }else{
+                sCameraInfo[0].facing = CAMERA_FACING_FRONT;
+                sCameraInfo[0].orientation = front_orient;
+            }
+            front_camera_num ++;
+        }
+        return (back_camera_num + front_camera_num);					
+
+    }
+
+    void HAL_getCameraInfo(int cameraId, struct CameraInfo* cameraInfo)
+    {
+        memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(CameraInfo));					
+    }
+
+    sp<CameraHardwareInterface> HAL_openCameraHardware(int cameraId)
+    {
+        char *SelectedCameraName;
+        int back_camera_num = 0, front_camera_num = 0;
+        sp<CaptureDeviceInterface> pCaptureDevice = NULL;
+        sp<PostProcessDeviceInterface> pPPDevice = NULL;
+        sp<JpegEncoderInterface>pJpegEncoder = NULL;
+
+        if (HAL_getNumberOfCameras() ==0 ){
+            CAMERA_HAL_ERR("There is no configure for Cameras");
+            return NULL;
+        }
+
+        SelectedCameraName = Camera_name[sCameraInfo[cameraId].facing];
+
+        pCaptureDevice = createCaptureDevice(SelectedCameraName);
+        pPPDevice = createPPDevice();
+        pJpegEncoder = createJpegEncoder(SOFTWARE_JPEG_ENC);
+
+        CameraHal *pCameraHal = new CameraHal();
+        if (pCameraHal->setCaptureDevice(pCaptureDevice) < 0 ||
+                pCameraHal->setPostProcessDevice(pPPDevice) < 0 ||
+                pCameraHal->setJpegEncoder(pJpegEncoder) < 0)
+            return NULL;
+
+        if (pCameraHal->Init() < 0)
+            return NULL;
+
+        //now the board has only one csi camera sensor, so just do mirror for it
+        if(strstr(SelectedCameraName, "ov") != NULL){
+            pCameraHal->setPreviewRotate(CAMERA_PREVIEW_BACK_REF);
+        }
+
+        sp<CameraHardwareInterface> hardware(pCameraHal);
+        CAMERA_HAL_LOG_INFO("created the fsl Camera hal");
+
+        return hardware;
+    }
+
+#endif
+};
+
+
diff --git a/mx6/libcamera/CameraHal.h b/mx6/libcamera/CameraHal.h
new file mode 100755
index 0000000..bddce07
--- /dev/null
+++ b/mx6/libcamera/CameraHal.h
@@ -0,0 +1,444 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#ifndef CAMERA_HAL_BASE_H
+#define CAMERA_HAL_BASE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+#include <camera/CameraParameters.h>
+#include <hardware/camera.h>
+#include <semaphore.h>
+
+#include "Camera_pmem.h"
+#include "CaptureDeviceInterface.h"
+#include "PostProcessDeviceInterface.h"
+#include "JpegEncoderInterface.h"
+#include "messageQueue.h"
+
+
+#define EXIF_MAKENOTE "fsl_makernote"
+#define EXIF_MODEL    "fsl_model"
+
+#define CAMER_PARAM_BUFFER_SIZE 512
+#define MAX_QUERY_FMT_TIMES 20
+#define PARAMS_DELIMITER ","
+#define V4LSTREAM_WAKE_LOCK "V4LCapture"
+#define MAX_SENSOR_NAME 32
+
+#define PREVIEW_HEAP_BUF_NUM    5
+#define VIDEO_OUTPUT_BUFFER_NUM 5
+#define POST_PROCESS_BUFFER_NUM 5
+#define TAKE_PIC_QUE_BUF_NUM 5
+
+#define PREVIEW_CAPTURE_BUFFER_NUM 5
+#define PICTURE_CAPTURE_BUFFER_NUM 3
+
+namespace android {
+
+    typedef enum{
+        CAMERA_HAL_ERR_NONE = 0,
+        CAMERA_HAL_ERR_OPEN_CAPTURE_DEVICE = -1,
+        CAMERA_HAL_ERR_GET_PARAM           = -2,
+        CAMERA_HAL_ERR_BAD_PARAM =-3,
+        CAMERA_HAL_ERR_BAD_ALREADY_RUN = -4,
+        CAMERA_HAL_ERR_INIT = -5,
+        CAMERA_HAL_ERR_ALLOC_BUF =-6,
+        CAMERA_HAL_ERR_PP_NULL = -7
+    }CAMERA_HAL_ERR_RET;
+
+	typedef enum{
+        CAMERA_PREVIEW_BACK_REF = 0,
+        CAMERA_PREVIEW_VERT_FLIP = 1,
+        CAMERA_PREVIEW_HORIZ_FLIP = 2,
+        CAMERA_PREVIEW_ROATE_180 = 3,
+        CAMERA_PREVIEW_ROATE_LAST = 3
+	}CAMERA_PREVIEW_ROTATE;
+
+#ifndef container_of
+#define container_of(ptr, type, member) ({                      \
+        const typeof(((type *) 0)->member) *__mptr = (ptr);     \
+        (type *) ((char *) __mptr - (char *)(&((type *)0)->member)); })
+#endif
+
+    class CameraHal {
+    public:
+        //virtual sp<IMemoryHeap> getPreviewHeap() const;
+        virtual sp<IMemoryHeap> getRawHeap() const;
+
+        virtual status_t setPreviewWindow(struct preview_stream_ops *window);
+        virtual void        setCallbacks(camera_notify_callback notify_cb,
+                camera_data_callback data_cb,
+                camera_data_timestamp_callback data_cb_timestamp,
+                camera_request_memory get_memory,
+                void* user);
+
+        virtual void        enableMsgType(int32_t msgType);
+        virtual void        disableMsgType(int32_t msgType);
+        virtual bool        msgTypeEnabled(int32_t msgType);
+
+        virtual status_t    startPreview();
+        virtual void        stopPreview();
+        virtual bool        previewEnabled();
+
+		virtual status_t  storeMetaDataInBuffers(bool enable);
+		//virtual int32_t getNumberOfVideoBuffers() const;
+		//virtual sp<IMemory> getVideoBuffer(int32_t index) const;
+
+        virtual status_t    startRecording();
+        virtual void        stopRecording();
+        virtual bool        recordingEnabled();
+        virtual void        releaseRecordingFrame(const void*  mem);
+
+        virtual status_t    autoFocus();
+        virtual status_t    cancelAutoFocus();
+        virtual status_t    takePicture();
+        virtual status_t    cancelPicture();
+        virtual status_t    dump(int fd) const;
+        virtual status_t    setParameters(const CameraParameters& params);
+        virtual status_t    setParameters(const char* params);
+        virtual char*  getParameters() const;
+        void putParameters(char *);
+        virtual status_t    sendCommand(int32_t command, int32_t arg1,
+                int32_t arg2);
+        virtual void release();
+
+        CAMERA_HAL_ERR_RET setCaptureDevice(sp<CaptureDeviceInterface> capturedevice);
+        CAMERA_HAL_ERR_RET setPostProcessDevice(sp<PostProcessDeviceInterface> postprocessdevice);
+        CAMERA_HAL_ERR_RET setJpegEncoder(sp<JpegEncoderInterface>jpegencoder);
+        CAMERA_HAL_ERR_RET  Init();
+        void  setPreviewRotate(CAMERA_PREVIEW_ROTATE previewRotate);
+
+        CameraHal(int cameraid);
+        virtual             ~CameraHal();
+
+    private:
+
+        class CaptureFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            CaptureFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("CaptureFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->captureframeThreadWrapper();
+                return false;
+            }
+        };
+
+        class PostProcessThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            PostProcessThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("PostProcessThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->postprocessThreadWrapper();
+                return false;
+            }
+        };
+
+
+        class PreviewShowFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            PreviewShowFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("CameraPreviewShowFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->previewshowFrameThreadWrapper();
+                return false;
+            }
+        };
+
+        class EncodeFrameThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            EncodeFrameThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("EncodeFrameThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                mHardware->encodeframeThreadWrapper();
+                return true;
+            }
+        };
+
+        class AutoFocusThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            AutoFocusThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+            virtual void onFirstRef() {
+                run("AutoFocusThread", PRIORITY_URGENT_DISPLAY);
+            }
+            virtual bool threadLoop() {
+                if (mHardware->autoFocusThread()>=0)
+                    return true;
+                else
+                    return false;
+            }
+        };
+
+
+        class TakePicThread : public Thread {
+            CameraHal* mHardware;
+        public:
+            TakePicThread(CameraHal* hw)
+                : Thread(false), mHardware(hw) { }
+#if 0
+            virtual void onFirstRef() {
+                run("TakePicThread", PRIORITY_URGENT_DISPLAY);
+            }
+#endif  
+            virtual bool threadLoop() {
+                mHardware->takepicThread();
+                return false;
+            }
+        };
+
+        void preInit();
+        void postDestroy();
+
+        status_t OpenCaptureDevice();
+        void CloseCaptureDevice();
+
+        CAMERA_HAL_ERR_RET AolLocForInterBuf();
+        void  FreeInterBuf();
+        CAMERA_HAL_ERR_RET InitCameraHalParam();
+        CAMERA_HAL_ERR_RET InitCameraBaseParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET InitPictureExifParam(CameraParameters *pParam);
+        CAMERA_HAL_ERR_RET CameraMiscInit();
+        CAMERA_HAL_ERR_RET CameraMiscDeInit();
+        status_t CameraHALPreviewStart();
+        int captureframeThread();
+        int postprocessThread();
+        int previewshowFrameThread();
+        int encodeframeThread();
+        int captureframeThreadWrapper();
+        int postprocessThreadWrapper();
+        int previewshowFrameThreadWrapper();
+        int encodeframeThreadWrapper();
+        status_t AllocateRecordVideoBuf();
+
+        status_t CameraHALStartPreview();
+        void     CameraHALStopPreview();
+
+        status_t PreparePreviwBuf();
+        status_t PrepareCaptureDevices();
+        status_t PreparePostProssDevice();
+        status_t PreparePreviwMisc();
+
+        void CameraHALStopThreads();
+        void LockWakeLock();
+
+        void UnLockWakeLock();
+
+        int autoFocusThread();
+        int takepicThread();
+
+        int GetJpegEncoderParam();
+        int NegotiateCaptureFmt(bool TakePicFlag);
+        int cameraHALTakePicture();
+        void CameraHALStopMisc();
+        int PrepareJpegEncoder();
+        void convertNV12toYUV420SP(uint8_t *inputBuffer, uint8_t *outputBuffer, int width, int height);
+
+        int stringTodegree(char* cAttribute, unsigned int &degree, unsigned int &minute, unsigned int &second);
+
+        status_t allocateBuffersFromNativeWindow();
+        void SearchBuffer(void *pNativeBuf, unsigned int *pIndex);
+        status_t freeBuffersToNativeWindow();
+        status_t PrepareCaptureBufs();
+        volatile bool isCaptureBufsAllocated;
+        //volatile bool isPreviewFinsh;
+        status_t convertStringToPreviewFormat(unsigned int *pFormat);
+        status_t convertPreviewFormatToString(char *pStr, int length, unsigned int format);
+        status_t putBufferCount(DMA_BUFFER *pBuf);
+        void getBufferCount(DMA_BUFFER *pBuf);
+        CAMERA_HAL_ERR_RET InitCameraPreviewFormatToParam(int nFmt);
+
+        CMessageQueue mCaptureThreadQueue;
+        CMessageQueue mPreviewThreadQueue;
+        CMessageQueue mPostProcessThreadQueue;
+        CMessageQueue mEncodeThreadQueue;
+
+        mutable Mutex mCaptureLock;
+        mutable Condition mCaptureCondition;
+        //mutable Condition mCaptureStoppedCondition;
+        mutable sem_t mCaptureStoppedCondition;
+        bool mCaptureRunning;
+        bool mExitCaptureThread;
+        mutable Mutex mPreviewLock;
+        mutable Condition mPreviewCondition;
+        //mutable Condition mPreviewStoppedCondition;
+        mutable sem_t mPreviewStoppedCondition;
+        bool mPreviewRunning;
+        bool mExitPreviewThread;
+        mutable Mutex mPostProcessLock;
+        //mutable Condition mPostProcessCondition;
+        mutable sem_t mPostProcessStoppedCondition;
+        //bool mPostProcessRunning;
+        bool mExitPostProcessThread;
+        mutable Mutex mEncodeLock;
+        mutable Condition mEncodeCondition;
+        //mutable Condition mEncodeStoppedCondition;
+        mutable sem_t mEncodeStoppedCondition;
+        //bool mEncodeRunning;
+        bool mExitEncodeThread;
+        mutable sem_t mTakingPicture;
+        bool mWaitForTakingPicture;
+        bool mTakePictureInProcess;
+
+        CameraParameters    mParameters;
+        void               *mCallbackCookie;
+        camera_notify_callback    mNotifyCb;
+        camera_data_callback      mDataCb;
+        camera_data_timestamp_callback mDataCbTimestamp;
+        camera_request_memory mRequestMemory;
+
+        sp<CaptureDeviceInterface> mCaptureDevice;
+        sp<PostProcessDeviceInterface> mPPDevice;
+        sp<JpegEncoderInterface> mJpegEncoder;
+
+
+        sp<CaptureFrameThread> mCaptureFrameThread;
+        sp<PostProcessThread>  mPostProcessThread;
+        sp<PreviewShowFrameThread> mPreviewShowFrameThread;
+        sp<EncodeFrameThread> mEncodeFrameThread;
+        sp<AutoFocusThread>mAutoFocusThread;
+        sp<TakePicThread> mTakePicThread;
+
+        mutable Mutex       mLock;
+
+        char *mSupportedPictureSizes;
+        char *mSupportedPreviewSizes;
+        char *mSupportedFPS;
+        char *mSupprotedThumbnailSizes;
+        char *mSupportPreviewFormat;
+
+        preview_stream_ops_t*   mNativeWindow;
+        unsigned int        mMsgEnabled;
+
+        struct capture_config_t mCaptureDeviceCfg;
+        DMA_BUFFER          mCaptureBuffers[PREVIEW_CAPTURE_BUFFER_NUM];
+
+        //sp<MemoryHeapBase>  mPreviewHeap;
+        camera_memory_t* mPreviewMemory;
+        //sp<MemoryBase>      mPreviewBuffers[PREVIEW_HEAP_BUF_NUM]; 
+
+        /* the buffer for recorder */
+        unsigned int        mVideoBufNume;
+        camera_memory_t* mVideoMemory;
+        //sp<MemoryHeapBase>  mVideoHeap;
+        //sp<MemoryBase>      mVideoBuffers[VIDEO_OUTPUT_BUFFER_NUM];
+        volatile  int       mVideoBufferUsing[VIDEO_OUTPUT_BUFFER_NUM];
+		VIDEOFRAME_BUFFER_PHY mVideoBufferPhy[VIDEO_OUTPUT_BUFFER_NUM];
+
+        sp<PmemAllocator>   mPmemAllocator;
+        DMA_BUFFER          mPPbuf[POST_PROCESS_BUFFER_NUM];
+        unsigned int        mPPbufNum;
+        pp_input_param_t    mPPInputParam;
+        pp_output_param_t   mPPOutputParam;
+
+        //volatile bool       mPreviewRunning;
+        unsigned int        mDefaultPreviewFormat;
+        unsigned int 		mPreviewFrameSize;
+        unsigned int        mPreviewCapturedFormat;
+
+        bool                mTakePicFlag;
+        unsigned int        mEncoderSupportedFormat[MAX_QUERY_FMT_TIMES];
+        enc_cfg_param       mJpegEncCfg;
+
+        unsigned int        mUvcSpecialCaptureFormat;
+        unsigned int        mCaptureSupportedFormat[MAX_QUERY_FMT_TIMES];
+        unsigned int        mPictureEncodeFormat;
+        unsigned int        mCaptureFrameSize;
+        unsigned int        mCaptureBufNum;
+        //unsigned int        mCaptureBufsActual;
+        unsigned int        mEnqueuedBufs;
+
+        bool                mRecordRunning;
+        int                 mCurrentRecordFrame;
+        int 		        nCameraBuffersQueued;
+
+        unsigned int        mPreviewHeapBufNum;
+        unsigned int        mTakePicBufQueNum;
+
+        char                mCameraSensorName[MAX_SENSOR_NAME];
+        bool mCameraReady;
+        bool mCaptureDeviceOpen;
+        bool mPPDeviceNeed;
+        bool mPPDeviceNeedForPic;
+        bool mPreviewStopped;
+        bool mRecordStopped;
+        bool mPowerLock;
+	bool bDerectInput;
+        int mCameraid;
+
+        int error_status;
+        unsigned int preview_heap_buf_head;
+        unsigned int display_head;
+        unsigned int enc_head;
+        unsigned int dequeue_head;
+        unsigned int is_first_buffer;
+        unsigned int last_display_index;
+        unsigned int pp_in_head;
+        unsigned int pp_out_head;
+        unsigned int buffer_index_maps[PREVIEW_CAPTURE_BUFFER_NUM];
+
+        sem_t avab_show_frame;
+        sem_t avab_dequeue_frame;
+        sem_t avab_enc_frame;
+        sem_t avab_enc_frame_finish;
+        sem_t avab_pp_in_frame;
+        sem_t avab_pp_out_frame;
+
+        pthread_mutex_t mOverlayMutex;
+        pthread_mutex_t mMsgMutex;
+        pthread_mutex_t mPPIOParamMutex;
+        CAMERA_PREVIEW_ROTATE mPreviewRotate;
+
+    };
+
+}; // namespace android
+
+#endif
+
diff --git a/mx6/libcamera/CameraModule.cpp b/mx6/libcamera/CameraModule.cpp
new file mode 100755
index 0000000..be72fc8
--- /dev/null
+++ b/mx6/libcamera/CameraModule.cpp
@@ -0,0 +1,707 @@
+/*
+ * Copyright (C) Freescale - http://www.Freescale.com/
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+* @file CameraHal.cpp
+*
+* This file maps the Camera Hardware Interface to V4L2.
+*
+*/
+
+#define LOG_TAG "CameraHAL"
+
+#include <utils/threads.h>
+#include <cutils/properties.h>
+#include "CameraHal.h"
+#include "Camera_utils.h"
+
+#define MAX_CAMERAS_SUPPORTED 2
+//static android::CameraProperties gCameraProperties;
+static android::CameraHal* gCameraHals[MAX_CAMERAS_SUPPORTED];
+static unsigned int gCamerasOpen = 0;
+static android::Mutex gCameraHalDeviceLock;
+
+static int camera_device_open(const hw_module_t* module, const char* name,
+                hw_device_t** device);
+static int camera_device_close(hw_device_t* device);
+static int camera_get_number_of_cameras(void);
+static int camera_get_camera_info(int camera_id, struct camera_info *info);
+
+static struct hw_module_methods_t camera_module_methods = {
+        open: camera_device_open
+};
+
+camera_module_t HAL_MODULE_INFO_SYM = {
+    common: {
+         tag: HARDWARE_MODULE_TAG,
+         version_major: 1,
+         version_minor: 0,
+         id: CAMERA_HARDWARE_MODULE_ID,
+         name: "Freescale CameraHal Module",
+         author: "Freescale",
+         methods: &camera_module_methods,
+         dso: NULL, /* remove compilation warnings */
+         reserved: {0}, /* remove compilation warnings */
+    },
+    get_number_of_cameras: camera_get_number_of_cameras,
+    get_camera_info: camera_get_camera_info,
+};
+
+typedef struct fsl_camera_device {
+    camera_device_t base;
+    /* TI specific "private" data can go here (base.priv) */
+    int cameraid;
+} fsl_camera_device_t;
+
+
+/*******************************************************************
+ * implementation of camera_device_ops functions
+ *******************************************************************/
+
+int camera_set_preview_window(struct camera_device * device,
+        struct preview_stream_ops *window)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->setPreviewWindow(window);
+
+    return rv;
+}
+
+void camera_set_callbacks(struct camera_device * device,
+        camera_notify_callback notify_cb,
+        camera_data_callback data_cb,
+        camera_data_timestamp_callback data_cb_timestamp,
+        camera_request_memory get_memory,
+        void *user)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->setCallbacks(notify_cb, data_cb, data_cb_timestamp, get_memory, user);
+}
+
+void camera_enable_msg_type(struct camera_device * device, int32_t msg_type)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->enableMsgType(msg_type);
+}
+
+void camera_disable_msg_type(struct camera_device * device, int32_t msg_type)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->disableMsgType(msg_type);
+}
+
+int camera_msg_type_enabled(struct camera_device * device, int32_t msg_type)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return 0;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    return gCameraHals[fsl_dev->cameraid]->msgTypeEnabled(msg_type);
+}
+
+int camera_start_preview(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->startPreview();
+
+    return rv;
+}
+
+void camera_stop_preview(struct camera_device * device)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->stopPreview();
+}
+
+int camera_preview_enabled(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->previewEnabled();
+    return rv;
+}
+
+int camera_store_meta_data_in_buffers(struct camera_device * device, int enable)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    //  TODO: meta data buffer not current supported
+    rv = gCameraHals[fsl_dev->cameraid]->storeMetaDataInBuffers(enable);
+    return rv;
+    //return enable ? android::INVALID_OPERATION: android::OK;
+}
+
+int camera_start_recording(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->startRecording();
+    return rv;
+}
+
+void camera_stop_recording(struct camera_device * device)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->stopRecording();
+}
+
+int camera_recording_enabled(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->recordingEnabled();
+    return rv;
+}
+
+void camera_release_recording_frame(struct camera_device * device,
+                const void *opaque)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->releaseRecordingFrame(opaque);
+}
+
+int camera_auto_focus(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->autoFocus();
+    return rv;
+}
+
+int camera_cancel_auto_focus(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->cancelAutoFocus();
+    return rv;
+}
+
+int camera_take_picture(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->takePicture();
+    return rv;
+}
+
+int camera_cancel_picture(struct camera_device * device)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->cancelPicture();
+    return rv;
+}
+
+int camera_set_parameters(struct camera_device * device, const char *params)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->setParameters(params);
+    return rv;
+}
+
+char* camera_get_parameters(struct camera_device * device)
+{
+    char* param = NULL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return NULL;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    param = gCameraHals[fsl_dev->cameraid]->getParameters();
+
+    return param;
+}
+
+static void camera_put_parameters(struct camera_device *device, char *parms)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->putParameters(parms);
+}
+
+int camera_send_command(struct camera_device * device,
+            int32_t cmd, int32_t arg1, int32_t arg2)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->sendCommand(cmd, arg1, arg2);
+    return rv;
+}
+
+void camera_release(struct camera_device * device)
+{
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    if(!device)
+        return;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    gCameraHals[fsl_dev->cameraid]->release();
+}
+
+int camera_dump(struct camera_device * device, int fd)
+{
+    int rv = -EINVAL;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    if(!device)
+        return rv;
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    rv = gCameraHals[fsl_dev->cameraid]->dump(fd);
+    return rv;
+}
+
+extern "C" void heaptracker_free_leaked_memory(void);
+
+int camera_device_close(hw_device_t* device)
+{
+    int ret = 0;
+    fsl_camera_device_t* fsl_dev = NULL;
+
+    LOGV("%s", __FUNCTION__);
+
+    android::Mutex::Autolock lock(gCameraHalDeviceLock);
+
+    if (!device) {
+        ret = -EINVAL;
+        goto done;
+    }
+
+    fsl_dev = (fsl_camera_device_t*) device;
+
+    if (fsl_dev) {
+        if (gCameraHals[fsl_dev->cameraid]) {
+            delete gCameraHals[fsl_dev->cameraid];
+            gCameraHals[fsl_dev->cameraid] = NULL;
+            gCamerasOpen--;
+        }
+
+        if (fsl_dev->base.ops) {
+            free(fsl_dev->base.ops);
+        }
+        free(fsl_dev);
+    }
+done:
+#ifdef HEAPTRACKER
+    heaptracker_free_leaked_memory();
+#endif
+    return ret;
+}
+
+#define FACE_BACK_CAMERA_NAME "back_camera_name"
+#define FACE_FRONT_CAMERA_NAME "front_camera_name"
+#define FACE_BACK_CAMERA_ORIENT "back_camera_orient"
+#define FACE_FRONT_CAMERA_ORIENT "front_camera_orient"
+#define DEFAULT_ERROR_NAME '#'
+#define DEFAULT_ERROR_NAME_str "#"
+#define UVC_NAME "uvc"
+static struct camera_info sCameraInfo[2];
+static char Camera_name[2][MAX_SENSOR_NAME];
+/*******************************************************************
+ * implementation of camera_module functions
+ *******************************************************************/
+
+/* open device handle to one of the cameras
+ *
+ * assume camera service will keep singleton of each camera
+ * so this function will always only be called once per camera instance
+ */
+
+int camera_device_open(const hw_module_t* module, const char* name,
+                hw_device_t** device)
+{
+    int rv = 0;
+    int num_cameras = 0;
+    int cameraid;
+    fsl_camera_device_t* camera_device = NULL;
+    camera_device_ops_t* camera_ops = NULL;
+    android::CameraHal* camera = NULL;
+    char *SelectedCameraName;
+    android::sp<android::CaptureDeviceInterface> pCaptureDevice = NULL;
+    android::sp<android::PostProcessDeviceInterface> pPPDevice = NULL;
+    android::sp<android::JpegEncoderInterface>pJpegEncoder = NULL;
+    //android::CameraProperties::Properties* properties = NULL;
+
+    android::Mutex::Autolock lock(gCameraHalDeviceLock);
+
+    LOGI("camera_device open");
+
+    if (name != NULL) {
+        cameraid = atoi(name);
+        num_cameras = camera_get_number_of_cameras();//gCameraProperties.camerasSupported();
+
+        if(cameraid > num_cameras)
+        {
+            LOGE("camera service provided cameraid out of bounds, "
+                    "cameraid = %d, num supported = %d",
+                    cameraid, num_cameras);
+            rv = -EINVAL;
+            goto fail;
+        }
+#if 0
+        if(gCamerasOpen >= MAX_SIMUL_CAMERAS_SUPPORTED)
+        {
+            LOGE("maximum number of cameras already open");
+            rv = -ENOMEM;
+            goto fail;
+        }
+#endif
+        camera_device = (fsl_camera_device_t*)malloc(sizeof(*camera_device));
+        if(!camera_device)
+        {
+            LOGE("camera_device allocation fail");
+            rv = -ENOMEM;
+            goto fail;
+        }
+
+        camera_ops = (camera_device_ops_t*)malloc(sizeof(*camera_ops));
+        if(!camera_ops)
+        {
+            LOGE("camera_ops allocation fail");
+            rv = -ENOMEM;
+            goto fail;
+        }
+
+        memset(camera_device, 0, sizeof(*camera_device));
+        memset(camera_ops, 0, sizeof(*camera_ops));
+
+        camera_device->base.common.tag = HARDWARE_DEVICE_TAG;
+        camera_device->base.common.version = 0;
+        camera_device->base.common.module = (hw_module_t *)(module);
+        camera_device->base.common.close = camera_device_close;
+        camera_device->base.ops = camera_ops;
+
+        camera_ops->set_preview_window = camera_set_preview_window;
+        camera_ops->set_callbacks = camera_set_callbacks;
+        camera_ops->enable_msg_type = camera_enable_msg_type;
+        camera_ops->disable_msg_type = camera_disable_msg_type;
+        camera_ops->msg_type_enabled = camera_msg_type_enabled;
+        camera_ops->start_preview = camera_start_preview;
+        camera_ops->stop_preview = camera_stop_preview;
+        camera_ops->preview_enabled = camera_preview_enabled;
+        camera_ops->store_meta_data_in_buffers = camera_store_meta_data_in_buffers;
+        camera_ops->start_recording = camera_start_recording;
+        camera_ops->stop_recording = camera_stop_recording;
+        camera_ops->recording_enabled = camera_recording_enabled;
+        camera_ops->release_recording_frame = camera_release_recording_frame;
+        camera_ops->auto_focus = camera_auto_focus;
+        camera_ops->cancel_auto_focus = camera_cancel_auto_focus;
+        camera_ops->take_picture = camera_take_picture;
+        camera_ops->cancel_picture = camera_cancel_picture;
+        camera_ops->set_parameters = camera_set_parameters;
+        camera_ops->get_parameters = camera_get_parameters;
+        camera_ops->put_parameters = camera_put_parameters;
+        camera_ops->send_command = camera_send_command;
+        camera_ops->release = camera_release;
+        camera_ops->dump = camera_dump;
+
+        *device = &camera_device->base.common;
+
+        // -------- TI specific stuff --------
+
+        camera_device->cameraid = cameraid;
+#if 0
+        if(gCameraProperties.getProperties(cameraid, &properties) < 0)
+        {
+            LOGE("Couldn't get camera properties");
+            rv = -ENOMEM;
+            goto fail;
+        }
+#endif
+        SelectedCameraName = Camera_name[sCameraInfo[cameraid].facing];
+
+        pCaptureDevice = android::createCaptureDevice(SelectedCameraName);
+        pPPDevice = android::createPPDevice();
+        pJpegEncoder = android::createJpegEncoder(android::SOFTWARE_JPEG_ENC);
+
+        camera = new android::CameraHal(cameraid);
+
+        if(!camera)
+        {
+            LOGE("Couldn't create instance of CameraHal class");
+            rv = -ENOMEM;
+            goto fail;
+        }
+#if 0
+        if(properties && (camera->initialize(properties) != android::NO_ERROR))
+        {
+            LOGE("Couldn't initialize camera instance");
+            rv = -ENODEV;
+            goto fail;
+        }
+#endif
+        if (camera->setCaptureDevice(pCaptureDevice) < 0 ||
+                camera->setPostProcessDevice(pPPDevice) < 0 ||
+                camera->setJpegEncoder(pJpegEncoder) < 0)
+            return NULL;
+
+        if (camera->Init() < 0)
+            return NULL;
+
+        //now the board has only one csi camera sensor, so just do mirror for it
+        if(strstr(SelectedCameraName, "ov") != NULL){
+            camera->setPreviewRotate(android::CAMERA_PREVIEW_HORIZ_FLIP);
+        }
+
+        gCameraHals[cameraid] = camera;
+        gCamerasOpen++;
+    }
+
+    return rv;
+
+fail:
+    if(camera_device) {
+        free(camera_device);
+        camera_device = NULL;
+    }
+    if(camera_ops) {
+        free(camera_ops);
+        camera_ops = NULL;
+    }
+    if(camera) {
+        delete camera;
+        camera = NULL;
+    }
+    *device = NULL;
+    return rv;
+}
+
+static void GetCameraPropery(char * pFaceBackCameraName, char *pFaceFrontCameraName, int *pFaceBackOrient, int *pFaceFrontOrient)
+{
+    char orientStr[10];
+
+    property_get (FACE_BACK_CAMERA_NAME, pFaceBackCameraName, DEFAULT_ERROR_NAME_str );
+    property_get (FACE_BACK_CAMERA_ORIENT, orientStr, DEFAULT_ERROR_NAME_str );
+
+    if (orientStr[0] == DEFAULT_ERROR_NAME )
+        *pFaceBackOrient = 0;
+    else 
+        *pFaceBackOrient = atoi(orientStr);
+
+    LOGI("Face Back Camera is %s, orient is %d", pFaceBackCameraName, *pFaceBackOrient);
+
+    property_get(FACE_FRONT_CAMERA_NAME, pFaceFrontCameraName, DEFAULT_ERROR_NAME_str );
+
+    property_get(FACE_FRONT_CAMERA_ORIENT, orientStr, DEFAULT_ERROR_NAME_str );
+
+
+    if (orientStr[0] == DEFAULT_ERROR_NAME )
+        *pFaceFrontOrient = 0;
+    else 
+        *pFaceFrontOrient = atoi(orientStr);
+
+    LOGI("Face Front Camera is %s, orient is %d", pFaceFrontCameraName, *pFaceFrontOrient);
+
+}
+
+int camera_get_number_of_cameras()
+{
+    int back_orient =0,  front_orient = 0;
+    int back_camera_num = 0, front_camera_num = 0;
+    GetCameraPropery(Camera_name[0], Camera_name[1], &back_orient, &front_orient);
+    if (Camera_name[0][0] != DEFAULT_ERROR_NAME){
+        sCameraInfo[0].facing = CAMERA_FACING_BACK;
+        sCameraInfo[0].orientation = back_orient;
+        back_camera_num++;
+    }
+    if (Camera_name[1][0] != DEFAULT_ERROR_NAME){
+        if(back_camera_num > 0){
+            sCameraInfo[1].facing = CAMERA_FACING_FRONT;
+            sCameraInfo[1].orientation = front_orient;
+        }else{
+	    sCameraInfo[0].facing = CAMERA_FACING_FRONT;
+	    sCameraInfo[0].orientation = front_orient;
+        }
+        front_camera_num ++;
+    }
+    return (back_camera_num + front_camera_num);					
+
+}
+
+int camera_get_camera_info(int cameraId, struct camera_info* cameraInfo)
+{
+    memcpy(cameraInfo, &sCameraInfo[cameraId], sizeof(camera_info));
+    return 0;
+}
+
diff --git a/mx6/libcamera/Camera_pmem.cpp b/mx6/libcamera/Camera_pmem.cpp
new file mode 100755
index 0000000..865b352
--- /dev/null
+++ b/mx6/libcamera/Camera_pmem.cpp
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <linux/time.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <linux/android_pmem.h>
+#include "Camera_pmem.h"
+
+
+/*
+ *   input parameter: 
+ */
+
+using namespace android;
+
+PmemAllocator::PmemAllocator(int bufCount, int bufSize):
+    err_ret(0), mFD(0),mTotalSize(0),mBufCount(bufCount),mBufSize(bufSize),
+    mVirBase(NULL),mPhyBase(NULL)
+{
+
+    memset(mSlotAllocated, 0, sizeof(bool)*MAX_SLOT);
+
+    int err;
+    struct pmem_region region;
+    mFD = open(PMEM_DEV, O_RDWR);
+    if (mFD < 0) {
+        CAMERA_HAL_ERR("Error!PmemAllocator constructor");
+        err_ret = -1;
+        return;
+    }
+
+    err = ioctl(mFD, PMEM_GET_TOTAL_SIZE, &region);
+    if (err == 0)
+    {
+        CAMERA_HAL_ERR("Info!get pmem total size %d",(int)region.len);
+    }
+    else
+    {
+        CAMERA_HAL_ERR("Error!Cannot get total length in PmemAllocator constructor");
+        err_ret = -1;
+        return;
+    }
+
+    mBufSize = (bufSize + DEFAULT_PMEM_ALIGN-1) & ~(DEFAULT_PMEM_ALIGN-1);
+
+    mTotalSize = mBufSize*bufCount;
+    if((mTotalSize > region.len)||(mBufCount > MAX_SLOT)) {
+        CAMERA_HAL_ERR("Error!Out of PmemAllocator capability");
+    }
+    else
+    {
+        uint8_t *virtualbase = (uint8_t*)mmap(0, mTotalSize,
+                PROT_READ|PROT_WRITE, MAP_SHARED, mFD, 0);
+
+        if (virtualbase == MAP_FAILED) {
+            CAMERA_HAL_ERR("Error!mmap(fd=%d, size=%u) failed (%s)",
+                    mFD, (unsigned int)mTotalSize, strerror(errno));
+            return;
+        }
+
+        memset(&region, 0, sizeof(region));
+
+        if (ioctl(mFD, PMEM_GET_PHYS, &region) == -1)
+        {
+            CAMERA_HAL_ERR("Error!Failed to get physical address of source!\n");
+            munmap(virtualbase, mTotalSize);
+            return;
+        }
+        mVirBase = (void *)virtualbase;
+        mPhyBase = region.offset;
+        CAMERA_HAL_LOG_RUNTIME("Allocator total size %d, vir addr 0x%x, phy addr 0x%x",mTotalSize,mVirBase,mPhyBase);
+    }
+}
+
+PmemAllocator::~PmemAllocator()
+{
+    CAMERA_HAL_LOG_FUNC;
+
+    for(int index=0;index < MAX_SLOT;index ++) {
+        if(mSlotAllocated[index]) {
+            CAMERA_HAL_ERR("Error!Cannot deinit PmemAllocator before all memory back to allocator");
+        }
+    }
+
+    if(mVirBase) {
+        munmap(mVirBase, mTotalSize);
+    }
+    if(mFD) {
+        close(mFD);
+    }
+
+}
+
+int PmemAllocator::allocate(DMA_BUFFER *pbuf, int size)
+{
+    CAMERA_HAL_LOG_FUNC;
+
+    if((!mVirBase)||(!pbuf)||(size>mBufSize)) {
+        CAMERA_HAL_ERR("Error!No memory for allocator");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+
+    for(int index=0;index < MAX_SLOT;index ++) {
+        if(!mSlotAllocated[index]) {
+            CAMERA_HAL_ERR("Free slot %d for allocating mBufSize %d request size %d",
+                    index,mBufSize,size);
+
+            pbuf->virt_start= (unsigned char *)mVirBase+index*mBufSize; 
+            pbuf->phy_offset= mPhyBase+index*mBufSize;
+            pbuf->length= mBufSize;
+            mSlotAllocated[index] = true;
+            return DMA_ALLOCATE_ERR_NONE;
+        }
+    }
+    return DMA_ALLOCATE_ERR_BAD_PARAM;
+}
+
+int PmemAllocator::deAllocate(DMA_BUFFER *pbuf)
+{
+    CAMERA_HAL_LOG_FUNC;
+    if((!mVirBase)||(!pbuf)) {
+        CAMERA_HAL_ERR("Error!No memory for allocator");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+    int nSlot = ((unsigned int)pbuf->virt_start- (unsigned int)mVirBase)/mBufSize;
+    if((nSlot<MAX_SLOT)&&(mSlotAllocated[nSlot])) {
+        CAMERA_HAL_ERR("Info!deAllocate for slot %d",nSlot);
+        mSlotAllocated[nSlot] = false;
+        return DMA_ALLOCATE_ERR_NONE;
+    }
+    else{
+        CAMERA_HAL_ERR("Error!Not a valid buffer");
+        return DMA_ALLOCATE_ERR_BAD_PARAM;
+    }
+}
diff --git a/mx6/libcamera/Camera_pmem.h b/mx6/libcamera/Camera_pmem.h
new file mode 100755
index 0000000..8b174a4
--- /dev/null
+++ b/mx6/libcamera/Camera_pmem.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef __CAMERA_MEM__H__
+#define __CAMERA_MEM__H__
+
+#include "Camera_utils.h"
+#include <utils/RefBase.h>
+
+
+#define DEFAULT_PMEM_ALIGN (4096)
+#define PMEM_DEV "/dev/pmem_adsp"
+#define MAX_SLOT 64
+
+namespace android {
+
+class PmemAllocator : public virtual RefBase
+{
+public:
+    PmemAllocator(int bufCount,int bufSize);
+    virtual ~PmemAllocator();
+    virtual int allocate(DMA_BUFFER *p_buf, int size);
+    virtual int deAllocate(DMA_BUFFER *p_buf);
+	int err_ret;
+private:
+    int mFD;
+    unsigned long mTotalSize;
+    int mBufCount;
+    int mBufSize;
+    void *mVirBase;
+    unsigned int mPhyBase;
+    bool mSlotAllocated[MAX_SLOT];
+	
+};
+};
+
+#endif
diff --git a/mx6/libcamera/Camera_utils.h b/mx6/libcamera/Camera_utils.h
new file mode 100755
index 0000000..2182c05
--- /dev/null
+++ b/mx6/libcamera/Camera_utils.h
@@ -0,0 +1,77 @@
+
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef CAMERA_UTILS_H
+#define CAMERA_UTILS_H
+
+#undef LOG_TAG
+#define LOG_TAG "FslCameraHAL"
+#include <utils/Log.h>
+#include <utils/threads.h>
+
+#define CAMERA_HAL_DEBUG_LOG
+
+#ifdef CAMERA_HAL_DEBUG_LOG
+#define CAMERA_HAL_LOG_RUNTIME(format, ...) LOGI((format), ## __VA_ARGS__)
+#define CAMERA_HAL_LOG_FUNC LOGI("%s is excuting...",  __FUNCTION__)
+#else
+#define CAMERA_HAL_LOG_RUNTIME(format, ...) 
+#define CAMERA_HAL_LOG_FUNC
+#endif
+
+#define CAMERA_HAL_LOG_TRACE   LOGI("%s : %d", __FUNCTION__,__LINE__)
+#define CAMERA_HAL_LOG_INFO(format, ...) LOGI((format), ## __VA_ARGS__)
+
+#define CAMERA_HAL_ERR(format, ...) LOGE((format), ##__VA_ARGS__)
+namespace android {
+
+    typedef enum{
+        DMA_ALLOCATE_ERR_NONE = 0,
+        DMA_ALLOCATE_ERR_BAD_PARAM = -1,
+
+    }DMA_ALLOCATE_ERR_RET;
+
+    typedef enum{
+        WINDOW_BUFS_INVALID = 0,
+        WINDOW_BUFS_DEQUEUED = 1,
+        WINDOW_BUFS_QUEUED = 2,
+    }WINDOW_BUFS_STATE;
+
+    typedef struct {
+        unsigned char *virt_start;
+        size_t phy_offset;
+        unsigned int length;
+        void *native_buf;
+        Mutex mBufferLock;
+        unsigned int refCount;
+        WINDOW_BUFS_STATE buf_state;
+    }DMA_BUFFER;
+
+	// If struct change. Need info Camera Source.
+    typedef struct {
+        size_t phy_offset;
+        unsigned int length;
+    }VIDEOFRAME_BUFFER_PHY;
+
+}; //name space android
+
+#endif
+
diff --git a/mx6/libcamera/CaptureDeviceInterface.cpp b/mx6/libcamera/CaptureDeviceInterface.cpp
new file mode 100755
index 0000000..f004e43
--- /dev/null
+++ b/mx6/libcamera/CaptureDeviceInterface.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "V4l2UVCDevice.h"
+#include "V4l2CsiDevice.h"
+namespace android{
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName)
+    {
+        if(strstr(deviceName, UVC_NAME_STRING)){
+            CAMERA_HAL_LOG_INFO("It is the UVC device, name:%s", deviceName);
+
+            sp<CaptureDeviceInterface>  device(new V4l2UVCDevice());
+            device->SetDevName(deviceName);
+            return device;
+        }else{
+            CAMERA_HAL_LOG_INFO("It is the CSI device");
+            sp<CaptureDeviceInterface>  device(new V4l2CsiDevice());
+            device->SetDevName(deviceName);
+            return device;
+        }
+    }
+
+
+}
diff --git a/mx6/libcamera/CaptureDeviceInterface.h b/mx6/libcamera/CaptureDeviceInterface.h
new file mode 100755
index 0000000..6ea427c
--- /dev/null
+++ b/mx6/libcamera/CaptureDeviceInterface.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef CAPTURE_DEVICE_INTERFACE_H
+#define CAPTURE_DEVICE_INTERFACE_H
+
+#include <utils/RefBase.h>
+#include "Camera_utils.h"
+
+
+namespace android {
+#define UVC_NAME_STRING "uvc"
+
+    typedef enum{
+        CAPTURE_DEVICE_ERR_ALRADY_OPENED  = 3,
+        CAPTURE_DEVICE_ERR_ENUM_CONTINUE  = 2,
+        CAPTURE_DEVICE_ERR_ENUM_PARAM_END = 1,
+        CAPTURE_DEVICE_ERR_NONE = 0,
+        CAPTURE_DEVICE_ERR_OPEN = -1,
+        CAPTURE_DEVICE_ERR_GET_PARAM = -2,
+        CAPTURE_DEVICE_ERR_SET_PARAM = -3,
+        CAPTURE_DEVICE_ERR_ALLOCATE_BUF = -4,
+        CAPTURE_DEVICE_ERR_BAD_PARAM  = -5,
+        CAPTURE_DEVICE_ERR_SYS_CALL=-6,
+        CAPTURE_DEVICE_ERR_UNKNOWN = -100
+    }CAPTURE_DEVICE_ERR_RET;
+
+    typedef enum{
+        MOTION_MODE = 0,
+        HIGH_QUALITY_MODE = 1
+    }CAPTURE_MODE;
+    
+    typedef enum{
+        CAMERA_TYPE_CSI = 0,
+        CAMERA_TYPE_UVC = 1,
+    }CAMERA_TYPE;
+
+    typedef enum{
+        OUTPU_FMT = 0,
+        FRAME_SIZE_FPS = 1
+    }DevParamType;
+
+	typedef enum{
+        SENSOR_PREVIEW_BACK_REF = 0,
+        SENSOR_PREVIEW_VERT_FLIP = 1,
+        SENSOR_PREVIEW_HORIZ_FLIP = 2,
+        SENSOR_PREVIEW_ROATE_180 = 3,
+        SENSOR_PREVIEW_ROATE_LAST = 3,
+        SENSOR_PREVIEW_ROATE_INVALID =4
+	}SENSOR_PREVIEW_ROTATE;
+
+    struct timeval_fract{
+        unsigned int numerator;
+        unsigned int denominator;
+    };
+
+    struct capture_config_t{
+        unsigned int fmt;
+        unsigned int width;
+        unsigned int height;
+        unsigned int framesize;   //out
+        unsigned int picture_waite_number;//out
+        struct timeval_fract tv;
+		SENSOR_PREVIEW_ROTATE rotate;
+    };
+
+
+    class CaptureDeviceInterface : public virtual RefBase{
+    public:
+
+        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName)=0;
+        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevOpen()=0;
+        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevPrepare()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevStart()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevQueue(unsigned int BufQueIdx)=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevStop()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate()=0;
+        virtual CAPTURE_DEVICE_ERR_RET DevClose()=0;
+        virtual CAPTURE_DEVICE_ERR_RET GetDevType(CAMERA_TYPE *pType)=0;
+
+        virtual ~ CaptureDeviceInterface(){}
+    };
+    extern "C" sp<CaptureDeviceInterface> createCaptureDevice(char *deviceName);
+
+};
+#endif
+
diff --git a/mx6/libcamera/JpegEncoderInterface.cpp b/mx6/libcamera/JpegEncoderInterface.cpp
new file mode 100755
index 0000000..30b9d96
--- /dev/null
+++ b/mx6/libcamera/JpegEncoderInterface.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. 
+ */
+#include "JpegEncoderSoftware.h"
+namespace android{
+
+    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type)
+    {
+        if (jpeg_enc_type == SOFTWARE_JPEG_ENC){
+            CAMERA_HAL_LOG_INFO("Create the software encoder");
+            return JpegEncoderSoftware::createInstance();
+        }
+        else{
+            CAMERA_HAL_ERR("the hardware encoder is not supported");
+            return NULL;
+        }
+    }
+};
diff --git a/mx6/libcamera/JpegEncoderInterface.h b/mx6/libcamera/JpegEncoderInterface.h
new file mode 100755
index 0000000..b515757
--- /dev/null
+++ b/mx6/libcamera/JpegEncoderInterface.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef JPEG_ENCODER_INTERFACE_H
+#define JPEG_ENCODER_INTERFACE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include "Camera_utils.h"
+#include <utils/RefBase.h>
+
+namespace android{
+
+
+#define MAX_JPEG_MAKE_BYTES 256
+#define MAX_JPEG_MAKERNOTE_BYTES 256
+#define MAX_JPEG_MODEL_BYTES 256
+#define TIME_FMT_LENGTH 20
+#define MAX_GPS_PROCESSING_BYTES	256
+
+    typedef enum{
+    ORIENTATION_UNDEFINED = 0,
+    ORIENTATION_NORMAL = 1,
+    ORIENTATION_FLIP_HORIZONTAL = 2,
+    ORIENTATION_ROTATE_180 = 3,
+    ORIENTATION_FLIP_VERTICAL = 4,
+    ORIENTATION_TRANSPOSE = 5,
+    ORIENTATION_ROTATE_90 = 6,
+    ORIENTATION_TRANSVERSE = 7,
+    ORIENTATION_ROTATE_270 = 8
+    }JPEG_ENCODER_ROTATION;
+
+    typedef enum{
+    WHITEBALANCE_AUTO = 0,
+    WHITEBALANCE_MANUAL = 1
+    }JPEG_ENCODER_WHITEBALANCE;
+
+    typedef enum{
+    FLASH_NOT_FIRE = 0x00,
+    FLASH_FIRED    = 0x01,
+    FLASH_FIRED_AUTO = 0x19,
+    FLASH_FIRED_RED_EYE_REDUCE = 0x41,
+    FLASH_FIRED_COMPULOSORY = 0x09
+    }JPEG_ENCODER_FLASH;
+
+    typedef enum{
+        SOFTWARE_JPEG_ENC = 0,
+        HARDWARE_JPEG_ENC = 1
+    }JPEG_ENCODER_TYPE;
+
+    typedef enum{
+        JPEG_ENC_ERROR_NONE = 0,
+        JPEG_ENC_ERROR_BAD_PARAM = -1,
+        JPEG_ENC_ERROR_ALOC_BUF = -2
+    }JPEG_ENC_ERR_RET;
+
+
+    typedef enum{
+        SUPPORTED_FMT = 0,
+    }JPEEG_QUERY_TYPE;
+
+    struct jpeg_enc_focallength_t
+    {
+        unsigned int numerator;
+        unsigned int denominator;
+    };
+
+    struct jpeg_enc_make_info_t
+    {
+        unsigned char make_bytes;
+        unsigned char make[MAX_JPEG_MAKE_BYTES];
+    };
+    struct jpeg_enc_makernote_info_t
+    {
+        unsigned char makernote_bytes;
+        unsigned char makernote[MAX_JPEG_MAKERNOTE_BYTES];
+    };
+
+    struct jpeg_enc_model_info_t
+    {
+        unsigned char model_bytes;
+        unsigned char model[MAX_JPEG_MODEL_BYTES];	
+    };
+
+    struct jpeg_enc_datetime_info_t
+    {
+        unsigned char datetime[TIME_FMT_LENGTH];	// "YYYY:MM:DD HH:MM:SS" with time shown in 24-hour format
+    };
+
+    struct jpeg_enc_gps_param{
+        unsigned int version;//GPSVersionID
+        char latitude_ref[2];//GPSLatitudeRef: "N " is positive; "S " is negative
+        char longtitude_ref[2];	//GPSLongtitudeRef: "E " is positive; "W " is negative
+        unsigned int latitude_degree[2];//GPSLatitude
+        unsigned int latitude_minute[2];
+        unsigned int latitude_second[2];
+        unsigned int longtitude_degree[2];//GPSLongitude
+        unsigned int longtitude_minute[2];
+        unsigned int longtitude_second[2];
+        char altitude_ref;//GPSAltitudeRef: 0 or 1(negative)
+        unsigned int altitude[2];//GPSAltitude: unit is meters
+        unsigned int hour[2];//GPSTimeStamp
+        unsigned int minute[2];
+        unsigned int seconds[2];
+        char processmethod[MAX_GPS_PROCESSING_BYTES]; //GPSProcessingMethod
+        char processmethod_bytes;
+        char datestamp[11];//GPSDateStamp: "YYYY:MM:DD "
+    };
+
+    typedef struct{
+        unsigned int PicWidth;
+        unsigned int PicHeight;
+        unsigned int ThumbWidth;
+        unsigned int ThumbHeight;
+        unsigned int BufFmt;
+        JPEG_ENCODER_ROTATION RotationInfo;
+        JPEG_ENCODER_WHITEBALANCE WhiteBalanceInfo;
+        JPEG_ENCODER_FLASH FlashInfo;
+        struct jpeg_enc_focallength_t *pFoclLength;
+        struct jpeg_enc_make_info_t *pMakeInfo;
+        struct jpeg_enc_makernote_info_t *pMakeNote;
+        struct jpeg_enc_model_info_t *pModelInfo;
+        struct jpeg_enc_datetime_info_t *pDatetimeInfo;
+        struct jpeg_enc_gps_param *pGps_info;
+    }enc_cfg_param;
+
+    struct jpeg_encoding_conf{
+        unsigned int output_jpeg_size;
+    };
+
+    class JpegEncoderInterface : public virtual RefBase{
+    public:
+        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)=0;
+        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg)=0;
+        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg)=0;
+        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit()=0;
+
+        virtual ~ JpegEncoderInterface(){}
+    }; 
+
+    extern "C" sp<JpegEncoderInterface> createJpegEncoder(JPEG_ENCODER_TYPE jpeg_enc_type);
+
+};
+
+#endif
diff --git a/mx6/libcamera/JpegEncoderSoftware.cpp b/mx6/libcamera/JpegEncoderSoftware.cpp
new file mode 100755
index 0000000..14adb6a
--- /dev/null
+++ b/mx6/libcamera/JpegEncoderSoftware.cpp
@@ -0,0 +1,661 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "JpegEncoderSoftware.h"
+
+namespace android{
+
+    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataSize = 0;//Total size of g_JpegData
+    JPEG_ENC_UINT32 JpegEncoderSoftware::g_JpegDataLen = 0;//Valid data len of g_JpegData
+    JPEG_ENC_UINT8 *JpegEncoderSoftware::g_JpegData = NULL;//Buffer to hold jpeg data
+
+    JpegEncoderSoftware :: JpegEncoderSoftware()
+        :mSupportedTypeIdx(0),
+        pEncCfgLocal(NULL),
+        pEncObj(NULL)
+    {
+        mSupportedType[0] = v4l2_fourcc('Y','U','1','2');
+    }
+
+    JpegEncoderSoftware :: ~JpegEncoderSoftware()
+    {
+
+    }
+
+    JPEG_ENC_ERR_RET  JpegEncoderSoftware :: EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet)
+    {
+
+        int * pSupportedType = (int *)pQueryRet;
+        switch(QueryType){	
+            case SUPPORTED_FMT:
+                if (mSupportedTypeIdx < MAX_ENC_SUPPORTED_YUV_TYPE){
+                    *pSupportedType = mSupportedType[mSupportedTypeIdx];
+                    mSupportedTypeIdx ++;
+                }else{
+                    mSupportedTypeIdx = 0;
+                    return JPEG_ENC_ERROR_BAD_PARAM;
+                }
+                break;
+            default:
+                return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        return JPEG_ENC_ERROR_NONE;
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderInit(enc_cfg_param *pEncCfg)
+    {
+        CAMERA_HAL_LOG_FUNC;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+        struct jpeg_enc_focallength_t * pFoclLength = NULL;
+        struct jpeg_enc_make_info_t *pMakeInfo = NULL;
+        struct jpeg_enc_makernote_info_t *pMakeNote = NULL;
+        struct jpeg_enc_model_info_t *pModelInfo = NULL;
+        struct jpeg_enc_datetime_info_t *pDatetimeInfo = NULL;
+        struct jpeg_enc_gps_param *pGpsInfoLocal = NULL;
+
+        if(pEncCfg == NULL){
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        pEncCfgLocal = (enc_cfg_param *)malloc(sizeof(enc_cfg_param));
+
+        if (pEncCfgLocal == NULL){
+            CAMERA_HAL_ERR("Allocat buffer for EncCfg failed");
+            return JPEG_ENC_ERROR_ALOC_BUF;
+        }
+
+        memset(pEncCfgLocal, 0, sizeof(enc_cfg_param));
+        memcpy(pEncCfgLocal, pEncCfg, sizeof(enc_cfg_param));
+
+
+        if ((ret = CheckEncParm()) != JPEG_ENC_ERROR_NONE){
+            goto INT_ERR_RET;
+        }
+
+        if (pEncCfg->pFoclLength != NULL){
+            pFoclLength = (struct jpeg_enc_focallength_t *)malloc(sizeof(struct jpeg_enc_focallength_t));
+
+            if (pFoclLength == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pFoclLength failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pFoclLength, 0, sizeof(struct jpeg_enc_focallength_t));
+            memcpy(pFoclLength, pEncCfg->pFoclLength, sizeof(struct jpeg_enc_focallength_t));
+            pEncCfgLocal->pFoclLength = pFoclLength;
+        }
+
+
+        if (pEncCfg->pMakeInfo != NULL){
+            pMakeInfo = (struct jpeg_enc_make_info_t *)malloc(sizeof(struct jpeg_enc_make_info_t));
+
+            if (pMakeInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pMakeInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pMakeInfo, 0, sizeof(struct jpeg_enc_make_info_t));
+            memcpy(pMakeInfo, pEncCfg->pMakeInfo, sizeof(struct jpeg_enc_make_info_t));
+            pEncCfgLocal->pMakeInfo = pMakeInfo;
+        }
+
+        if (pEncCfg->pMakeNote != NULL){
+            pMakeNote = (struct jpeg_enc_makernote_info_t *)malloc(sizeof(struct jpeg_enc_makernote_info_t));
+
+            if (pMakeNote == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pMakeNote failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pMakeNote, 0, sizeof(struct jpeg_enc_makernote_info_t));
+            memcpy(pMakeNote, pEncCfg->pMakeNote, sizeof(struct jpeg_enc_makernote_info_t));
+            pEncCfgLocal->pMakeNote = pMakeNote;
+        }
+
+        if (pEncCfg->pModelInfo != NULL){
+            pModelInfo = (struct jpeg_enc_model_info_t *)malloc(sizeof(struct jpeg_enc_model_info_t));
+
+            if (pModelInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pModelInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pModelInfo, 0, sizeof(struct jpeg_enc_model_info_t));
+            memcpy(pModelInfo, pEncCfg->pModelInfo, sizeof(struct jpeg_enc_model_info_t));
+            pEncCfgLocal->pModelInfo = pModelInfo;
+        }
+
+        if (pEncCfg->pDatetimeInfo != NULL){
+            pDatetimeInfo = (struct jpeg_enc_datetime_info_t *)malloc(sizeof(struct jpeg_enc_datetime_info_t));
+
+            if (pDatetimeInfo == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pDatetimeInfo failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pDatetimeInfo, 0, sizeof(struct jpeg_enc_datetime_info_t));
+            memcpy(pDatetimeInfo, pEncCfg->pDatetimeInfo, sizeof(struct jpeg_enc_datetime_info_t));
+            pEncCfgLocal->pDatetimeInfo = pDatetimeInfo;
+        }
+
+        if (pEncCfg->pGps_info != NULL){
+            pGpsInfoLocal = (struct jpeg_enc_gps_param *)malloc(sizeof(struct jpeg_enc_gps_param));
+
+            if (pGpsInfoLocal == NULL){
+                CAMERA_HAL_ERR("Allocat buffer for pGpsInfoLocal failed");
+                ret = JPEG_ENC_ERROR_ALOC_BUF;
+                goto INT_ERR_RET;
+            }
+            memset(pGpsInfoLocal, 0, sizeof(struct jpeg_enc_gps_param));
+            memcpy(pGpsInfoLocal, pEncCfg->pGps_info, sizeof(struct jpeg_enc_gps_param));
+            pEncCfgLocal->pGps_info = pGpsInfoLocal;
+        }
+
+        return ret;
+
+INT_ERR_RET:
+        if(pEncCfgLocal)
+            free(pEncCfgLocal);
+        if(pFoclLength)
+            free(pFoclLength);
+        if(pMakeInfo)
+            free(pMakeInfo);
+        if(pMakeNote)
+            free(pMakeNote);
+        if(pModelInfo)
+            free(pModelInfo);
+        if(pDatetimeInfo)
+            free(pDatetimeInfo);
+        if(pGpsInfoLocal)
+            free(pGpsInfoLocal);
+        return ret;
+
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg){
+        if (inBuf == NULL || outBuf == NULL || inBuf->virt_start == NULL || outBuf->virt_start == NULL){
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }else{
+            return encodeImge(inBuf,outBuf, &(pJpegEncCfg->output_jpeg_size));
+        }
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: JpegEncoderDeInit(){
+        CAMERA_HAL_LOG_FUNC;
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+
+        if (pEncCfgLocal != NULL ){
+            if (pEncCfgLocal->pFoclLength != NULL)
+                free(pEncCfgLocal->pFoclLength);
+            if (pEncCfgLocal->pMakeInfo != NULL)
+                free(pEncCfgLocal->pMakeInfo);
+            if (pEncCfgLocal->pMakeNote != NULL)
+                free(pEncCfgLocal->pMakeNote);
+            if (pEncCfgLocal->pModelInfo != NULL)
+                free(pEncCfgLocal->pModelInfo);
+            if (pEncCfgLocal->pDatetimeInfo != NULL)
+                free(pEncCfgLocal->pDatetimeInfo);
+            if (pEncCfgLocal->pGps_info != NULL)
+                free(pEncCfgLocal->pGps_info);
+            free(pEncCfgLocal);
+        }
+
+        return ret;
+
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: CheckEncParm(){
+
+        CAMERA_HAL_LOG_FUNC;
+        int i = 0;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+
+        if ((pEncCfgLocal->PicWidth <= 0) && (pEncCfgLocal->PicHeight<= 0)){
+            CAMERA_HAL_ERR("The input widht and height is wrong");
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        if((pEncCfgLocal->PicWidth <= 0) || (pEncCfgLocal->PicHeight <= 0)|| 
+                (pEncCfgLocal->ThumbWidth > pEncCfgLocal->PicWidth) ||
+                (pEncCfgLocal->ThumbHeight > pEncCfgLocal->PicHeight) ){
+            CAMERA_HAL_ERR("The input widht and height is wrong");
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        for (i = 0; i< MAX_ENC_SUPPORTED_YUV_TYPE; i++){
+            if(pEncCfgLocal->BufFmt == mSupportedType[i])
+                break;
+        }
+
+        if (i == MAX_ENC_SUPPORTED_YUV_TYPE)
+            ret = JPEG_ENC_ERROR_BAD_PARAM;
+
+        return ret;
+    }
+
+    JPEG_ENC_ERR_RET JpegEncoderSoftware :: encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        JPEG_ENC_ERR_RET ret = JPEG_ENC_ERROR_NONE;
+        int width, height, size,index;
+        JPEG_ENC_UINT8 * i_buff = NULL;
+        JPEG_ENC_UINT8 * y_buff = NULL;
+        JPEG_ENC_UINT8 * u_buff = NULL;
+        JPEG_ENC_UINT8 * v_buff = NULL;
+        JPEG_ENC_RET_TYPE return_val;
+        jpeg_enc_parameters * params = NULL;
+        jpeg_enc_object * obj_ptr = NULL;
+        JPEG_ENC_UINT8 number_mem_info;
+        jpeg_enc_memory_info * mem_info = NULL;
+        unsigned char *thumbnail_buffer,*temp_buffer=NULL;
+        int thumbnail_width, thumbnail_height;
+        unsigned char *buffer = inBuf->virt_start;
+
+        bool mEncodeThumbnailFlag = true;
+
+        width = pEncCfgLocal->PicWidth;
+        height = pEncCfgLocal->PicHeight;
+
+        thumbnail_width = pEncCfgLocal->ThumbWidth;
+        thumbnail_height = pEncCfgLocal->ThumbHeight;
+
+
+        if (thumbnail_width <= 0 || thumbnail_height<= 0)
+            mEncodeThumbnailFlag = false;
+
+        g_JpegDataSize = 0;//Total size of g_JpegData
+        g_JpegDataLen = 0;//Valid data len of g_JpegData
+        g_JpegData = NULL;//Buffer to hold jpeg data
+        size = width * height * 3 / 2;
+
+        g_JpegData = outBuf->virt_start;
+        g_JpegDataSize = size;
+        if(!g_JpegData)
+        {
+            return JPEG_ENC_ERROR_BAD_PARAM;
+        }
+
+        /* --------------------------------------------
+         * Allocate memory for Encoder Object
+         * -------------------------------------------*/
+        obj_ptr = (jpeg_enc_object *) malloc(sizeof(jpeg_enc_object));
+        if(!obj_ptr)
+        {
+            return JPEG_ENC_ERROR_ALOC_BUF;
+        }
+        memset(obj_ptr, 0, sizeof(jpeg_enc_object));
+
+        /* Assign the function for streaming output */
+        obj_ptr->jpeg_enc_push_output = pushJpegOutput;
+        obj_ptr->context=NULL;   //user can put private variables into it
+        /* --------------------------------------------
+         * Fill up the parameter structure of JPEG Encoder
+         * -------------------------------------------*/
+        params = &(obj_ptr->parameters);
+
+        if(mEncodeThumbnailFlag==true)
+        {
+
+            //need resizing code here!!!
+            thumbnail_buffer = (unsigned char *)malloc(thumbnail_width * thumbnail_height * 3 / 2);
+            if(!thumbnail_buffer)
+            {
+                return JPEG_ENC_ERROR_ALOC_BUF;
+            }
+
+            yuv_resize((unsigned char *)thumbnail_buffer, thumbnail_width, thumbnail_height, buffer, width, height);
+
+            width = thumbnail_width;
+            height = thumbnail_height;
+
+            temp_buffer = buffer;
+            buffer = thumbnail_buffer;
+
+            params->mode = JPEG_ENC_THUMB;
+        }
+        else
+        {
+            params->mode = JPEG_ENC_MAIN_ONLY;
+        }
+
+encodeframe:
+
+        params->compression_method = JPEG_ENC_SEQUENTIAL;
+        params->quality = 75;
+        params->restart_markers = 0;
+        if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','1','2')){
+            params->y_width = width;
+            params->y_height = height;
+            params->u_width = params->y_width/2;
+            params->u_height = params->y_height/2;
+            params->v_width = params->y_width/2;
+            params->v_height = params->y_height/2;
+            params->primary_image_height = height;
+            params->primary_image_width = width;
+            params->yuv_format = JPEG_ENC_YUV_420_NONINTERLEAVED;
+        }else if (pEncCfgLocal->BufFmt == v4l2_fourcc('Y','U','Y','V')){
+            params->y_width = width;
+            params->y_height = height;
+            params->u_width = params->y_width/2;
+            params->u_height = params->y_height;
+            params->v_width = params->y_width/2;
+            params->v_height = params->y_height;
+            params->primary_image_height = height;
+            params->primary_image_width = width;
+            params->yuv_format = JPEG_ENC_YU_YV_422_INTERLEAVED;
+        }
+        params->exif_flag = 1;
+
+        params->y_left = 0;
+        params->y_top = 0;
+        params->y_total_width = 0;
+        params->y_total_height = 0;
+        params->raw_dat_flag= 0;
+
+        if(params->y_total_width==0)
+        {
+            params->y_left=0;
+            params->u_left=0;
+            params->v_left=0;
+            params->y_total_width=params->y_width;  // no cropping
+            params->u_total_width=params->u_width;  // no cropping
+            params->v_total_width=params->v_width;  // no cropping
+        }
+
+        if(params->y_total_height==0)
+        {
+            params->y_top=0;
+            params->u_top=0;
+            params->v_top=0;
+            params->y_total_height=params->y_height; // no cropping
+            params->u_total_height=params->u_height; // no cropping
+            params->v_total_height=params->v_height; // no cropping
+        }
+
+        /* Pixel size is unknown by default */
+        params->jfif_params.density_unit = 0;
+        /* Pixel aspect ratio is square by default */
+        params->jfif_params.X_density = 1;
+        params->jfif_params.Y_density = 1;
+        if (params->yuv_format == JPEG_ENC_YUV_420_NONINTERLEAVED){
+            y_buff = (JPEG_ENC_UINT8 *)buffer;
+            u_buff = y_buff+width*height;
+            v_buff = u_buff+width*height/4;
+            i_buff = NULL;
+        }else if (params->yuv_format == JPEG_ENC_YU_YV_422_INTERLEAVED){
+            y_buff = NULL;
+            u_buff = NULL;
+            v_buff = NULL;
+            i_buff = (JPEG_ENC_UINT8 *)buffer;
+        }
+        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+
+        /* --------------------------------------------
+         * QUERY MEMORY REQUIREMENTS
+         * -------------------------------------------*/
+        return_val = jpeg_enc_query_mem_req(obj_ptr);
+
+        if(return_val != JPEG_ENC_ERR_NO_ERROR)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_query_mem_req was called \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_query_mem_req success");
+        /* --------------------------------------------
+         * ALLOCATE MEMORY REQUESTED BY CODEC
+         * -------------------------------------------*/
+        number_mem_info = obj_ptr->mem_infos.no_entries;
+        for(index = 0; index < number_mem_info; index++)
+        {
+            /* This example code ignores the 'alignment' and
+             * 'memory_type', but some other applications might want
+             * to allocate memory based on them */
+            mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+            mem_info->memptr = (void *) malloc(mem_info->size);
+            if(mem_info->memptr==NULL) {
+                CAMERA_HAL_LOG_RUNTIME("Malloc error after query\n");
+                goto done;
+            }
+        }
+
+        return_val = jpeg_enc_init(obj_ptr);
+        if(return_val != JPEG_ENC_ERR_NO_ERROR)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error when jpeg_enc_init was called \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_init success");
+        if(params->mode == JPEG_ENC_THUMB)
+            createJpegExifTags(obj_ptr);
+
+        return_val = jpeg_enc_encodeframe(obj_ptr, i_buff,
+                y_buff, u_buff, v_buff);
+
+        if(return_val != JPEG_ENC_ERR_ENCODINGCOMPLETE)
+        {
+            CAMERA_HAL_LOG_RUNTIME("JPEG encoder returned an error in jpeg_enc_encodeframe \n");
+            CAMERA_HAL_LOG_RUNTIME("Return Val %d\n",return_val);
+            goto done;
+        }
+
+        if(params->mode == JPEG_ENC_THUMB)
+        {
+            JPEG_ENC_UINT8 num_entries;
+            JPEG_ENC_UINT32 *offset_tbl_ptr = (JPEG_ENC_UINT32 *)malloc(sizeof(JPEG_ENC_UINT32)*JPEG_ENC_NUM_OF_OFFSETS);
+            JPEG_ENC_UINT8 *value_tbl_ptr = (JPEG_ENC_UINT8 *)malloc(sizeof(JPEG_ENC_UINT8)*JPEG_ENC_NUM_OF_OFFSETS);
+
+            jpeg_enc_find_length_position(obj_ptr, offset_tbl_ptr,value_tbl_ptr,&num_entries);
+
+            for(int i = 0; i < num_entries; i++)
+            {
+                *((JPEG_ENC_UINT8 *)g_JpegData+offset_tbl_ptr[i]) = value_tbl_ptr[i];
+            }
+
+            free(offset_tbl_ptr);
+            free(value_tbl_ptr);
+
+            free(buffer);
+
+            number_mem_info = obj_ptr->mem_infos.no_entries;
+            for(index = 0; index < number_mem_info; index++)
+            {
+                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+                if(mem_info)
+                    free(mem_info->memptr);
+            }
+
+            g_JpegData += g_JpegDataLen;
+            g_JpegDataSize -= g_JpegDataLen;
+
+
+            //recover to build the main jpeg
+            params->mode = JPEG_ENC_MAIN;
+
+            buffer = temp_buffer;
+            width = pEncCfgLocal->PicWidth;
+            height = pEncCfgLocal->PicHeight;
+
+            goto encodeframe;
+        }
+        CAMERA_HAL_LOG_RUNTIME("jpeg_enc_encodeframe success");
+        // Make an IMemory for each frame
+        //jpegPtr = new MemoryBase(mJpegImageHeap, 0, g_JpegDataLen);
+        *pEncSize = g_JpegDataLen;
+
+done:
+        /* --------------------------------------------
+         * FREE MEMORY REQUESTED BY CODEC
+         * -------------------------------------------*/
+        if(obj_ptr)
+        {
+            number_mem_info = obj_ptr->mem_infos.no_entries;
+            for(index = 0; index < number_mem_info; index++)
+            {
+                mem_info = &(obj_ptr->mem_infos.mem_info[index]);
+                if(mem_info)
+                    free(mem_info->memptr);
+            }
+            free(obj_ptr);
+        }
+
+        return ret;
+    }
+
+    JPEG_ENC_UINT8 JpegEncoderSoftware::pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,JPEG_ENC_UINT32 *out_buf_len_ptr,
+            JPEG_ENC_UINT8 flush, void * context, JPEG_ENC_MODE enc_mode)
+    {
+        JPEG_ENC_UINT32 i;
+        if(*out_buf_ptrptr == NULL)
+        {
+            /* This function is called for the 1'st time from the
+             * codec */
+            *out_buf_ptrptr = g_JpegData;
+            *out_buf_len_ptr = g_JpegDataSize;
+        }
+
+        else if(flush == 1)
+        {
+            /* Flush the buffer*/
+            g_JpegDataLen += *out_buf_len_ptr;
+            CAMERA_HAL_LOG_RUNTIME("jpeg output data len %d",(int)g_JpegDataLen);
+
+            *out_buf_ptrptr = NULL;
+            *out_buf_len_ptr = NULL;
+        }
+        else
+        {
+            CAMERA_HAL_LOG_RUNTIME("Not enough buffer for encoding");
+            return 0;
+        }
+
+        return(1); /* Success */
+    }
+
+    void JpegEncoderSoftware::createJpegExifTags(jpeg_enc_object * obj_ptr)
+    {
+        CAMERA_HAL_LOG_RUNTIME("version: %s\n", jpege_CodecVersionInfo());
+
+        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_ORIENTATION, (unsigned int)(&(pEncCfgLocal->RotationInfo)));
+        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_WHITEBALANCE, (unsigned int)(&(pEncCfgLocal->WhiteBalanceInfo)));
+        jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FLASH, (unsigned int)(&(pEncCfgLocal->FlashInfo)));
+
+        if(pEncCfgLocal->pMakeInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKE, (unsigned int)(pEncCfgLocal->pMakeInfo));
+        if(pEncCfgLocal->pMakeNote)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MAKERNOTE, (unsigned int)(pEncCfgLocal->pMakeNote));
+        if(pEncCfgLocal->pModelInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_MODEL, (unsigned int)(pEncCfgLocal->pModelInfo));
+        if(pEncCfgLocal->pDatetimeInfo)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_DATETIME, (unsigned int)(pEncCfgLocal->pDatetimeInfo));
+        if(pEncCfgLocal->pFoclLength)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_FOCALLENGTH, (unsigned int)(pEncCfgLocal->pFoclLength));
+
+        if (pEncCfgLocal->pGps_info)
+            jpeg_enc_set_exifheaderinfo(obj_ptr, JPEGE_ENC_SET_HEADER_GPS, (unsigned int)(pEncCfgLocal->pGps_info));
+
+        return;
+    }
+
+    int JpegEncoderSoftware::yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height)
+    {
+        int i,j,s;
+        int h_offset;
+        int v_offset;
+        unsigned char *ptr,cc;
+        int h_scale_ratio;
+        int v_scale_ratio;
+
+        s = 0;
+
+_resize_begin:
+
+        if(!dst_width) return -1;
+        if(!dst_height) return -1;
+
+        h_scale_ratio = src_width / dst_width;
+        if(!h_scale_ratio) return -1;
+
+        v_scale_ratio = src_height / dst_height;
+        if(!v_scale_ratio) return -1;
+
+        h_offset = (src_width - dst_width * h_scale_ratio) / 2;
+        v_offset = (src_height - dst_height * v_scale_ratio) / 2;
+
+        for(i = 0; i < dst_height * v_scale_ratio; i += v_scale_ratio)
+        {
+            for(j = 0; j < dst_width * h_scale_ratio; j += h_scale_ratio)
+            {
+                ptr = src_ptr + i * src_width + j + v_offset * src_width + h_offset;
+                cc = ptr[0];
+
+                ptr = dst_ptr + (i / v_scale_ratio) * dst_width + (j / h_scale_ratio);
+                ptr[0] = cc;
+            }
+        }
+
+        src_ptr += src_width*src_height;
+        dst_ptr += dst_width*dst_height;
+
+        if(s < 2)
+        {
+            if(!s++)
+            {
+                src_width >>= 1;
+                src_height >>= 1;
+
+                dst_width >>= 1;
+                dst_height >>= 1;
+            }
+
+            goto _resize_begin;
+        }
+
+        return 0;
+    }
+
+    sp<JpegEncoderInterface> JpegEncoderSoftware::createInstance(){
+        sp<JpegEncoderInterface> hardware(new JpegEncoderSoftware());
+        return hardware;
+    }
+
+
+};
diff --git a/mx6/libcamera/JpegEncoderSoftware.h b/mx6/libcamera/JpegEncoderSoftware.h
new file mode 100755
index 0000000..2bcd2d1
--- /dev/null
+++ b/mx6/libcamera/JpegEncoderSoftware.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef JPEG_ENCODER_SOFTWARE_H
+#define JPEG_ENCODER_SOFTWARE_H
+
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+
+#include "JpegEncoderInterface.h"
+#include "jpeg_enc_interface.h"
+
+
+namespace android{
+#define MAX_ENC_SUPPORTED_YUV_TYPE  1
+
+    class JpegEncoderSoftware : public JpegEncoderInterface{
+    public:
+        virtual  JPEG_ENC_ERR_RET  EnumJpegEncParam(JPEEG_QUERY_TYPE QueryType, void * pQueryRet);
+        virtual  JPEG_ENC_ERR_RET JpegEncoderInit(enc_cfg_param *pEncCfg);
+        virtual  JPEG_ENC_ERR_RET DoEncode( DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, struct jpeg_encoding_conf *pJpegEncCfg);
+        virtual  JPEG_ENC_ERR_RET JpegEncoderDeInit();
+
+        static sp<JpegEncoderInterface>createInstance();
+    private:
+
+        JpegEncoderSoftware();
+        virtual ~JpegEncoderSoftware();
+
+        virtual JPEG_ENC_ERR_RET CheckEncParm();
+        virtual JPEG_ENC_ERR_RET encodeImge(DMA_BUFFER *inBuf, DMA_BUFFER *outBuf, unsigned int *pEncSize);
+
+
+        static JPEG_ENC_UINT8 pushJpegOutput(JPEG_ENC_UINT8 ** out_buf_ptrptr,
+                JPEG_ENC_UINT32 *out_buf_len_ptr,
+                JPEG_ENC_UINT8 flush, 
+                void * context, 
+                JPEG_ENC_MODE enc_mode);
+        void createJpegExifTags(jpeg_enc_object * obj_ptr);
+        int yuv_resize(unsigned char *dst_ptr, int dst_width, int dst_height, unsigned char *src_ptr, int src_width, int src_height);
+
+
+        unsigned int mSupportedType[MAX_ENC_SUPPORTED_YUV_TYPE];
+        unsigned int mSupportedTypeIdx;
+        enc_cfg_param *pEncCfgLocal;
+        jpeg_enc_object *pEncObj;
+
+
+        static JPEG_ENC_UINT32 g_JpegDataSize ;//Total size of g_JpegData
+        static JPEG_ENC_UINT32 g_JpegDataLen ;//Valid data len of g_JpegData
+        static JPEG_ENC_UINT8 *g_JpegData ;//Buffer to hold jpeg data
+
+    }; 
+};
+
+#endif
diff --git a/mx6/libcamera/PP_ipulib.cpp b/mx6/libcamera/PP_ipulib.cpp
new file mode 100755
index 0000000..69d91ee
--- /dev/null
+++ b/mx6/libcamera/PP_ipulib.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "PP_ipulib.h"
+#include <stdlib.h>
+#include <string.h>
+
+namespace android{
+
+    wp<PostProcessDeviceInterface> PPIpuLib :: singleton;
+
+    PPIpuLib :: PPIpuLib(){
+        return;
+    }
+
+    PPIpuLib :: ~PPIpuLib(){
+
+        singleton.clear();
+    }
+    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        int mIPURet;
+
+        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+        //Setting input format
+        mIPUInputParam.width = pp_input->width;
+        mIPUInputParam.height = pp_input->height;
+
+        mIPUInputParam.input_crop_win.pos.x = pp_input->input_crop_win.pos.x;
+        mIPUInputParam.input_crop_win.pos.y = pp_input->input_crop_win.pos.y;  
+        mIPUInputParam.input_crop_win.win_w = pp_input->input_crop_win.win_w;
+        mIPUInputParam.input_crop_win.win_h = pp_input->input_crop_win.win_h;
+        mIPUInputParam.fmt = pp_input->fmt;
+        mIPUInputParam.user_def_paddr[0] = pp_input->user_def_paddr;
+
+        //Setting output format
+        mIPUOutputParam.fmt = pp_output->fmt;
+        mIPUOutputParam.width = pp_output->width;
+        mIPUOutputParam.height = pp_output->height;   
+        mIPUOutputParam.show_to_fb = 0;
+        //Output param should be same as input, since no resize,crop
+        mIPUOutputParam.output_win.pos.x = pp_output->output_win.pos.x;
+        mIPUOutputParam.output_win.pos.y = pp_output->output_win.pos.y;
+        mIPUOutputParam.output_win.win_w = pp_output->output_win.win_w;
+        mIPUOutputParam.output_win.win_h = pp_output->output_win.win_h;
+        mIPUOutputParam.rot = pp_output->rot;
+        mIPUOutputParam.user_def_paddr[0] = pp_output->user_def_paddr;
+        CAMERA_HAL_LOG_RUNTIME(" Output param: width %d,height %d, pos.x %d, pos.y %d,win_w %d,win_h %d,rot %d",
+                mIPUOutputParam.width,
+                mIPUOutputParam.height,
+                mIPUOutputParam.output_win.pos.x,
+                mIPUOutputParam.output_win.pos.y,
+                mIPUOutputParam.output_win.win_w,
+                mIPUOutputParam.output_win.win_h,
+                mIPUOutputParam.rot);
+
+        CAMERA_HAL_LOG_RUNTIME("Input param: width %d, height %d, fmt %d, crop_win pos x %d, crop_win pos y %d, crop_win win_w %d,crop_win win_h %d",
+                mIPUInputParam.width,
+                mIPUInputParam.height,
+                mIPUInputParam.fmt,
+                mIPUInputParam.input_crop_win.pos.x,
+                mIPUInputParam.input_crop_win.pos.y,
+                mIPUInputParam.input_crop_win.win_w,
+                mIPUInputParam.input_crop_win.win_h);	  
+
+        mIPURet =  mxc_ipu_lib_task_init(&mIPUInputParam,NULL,&mIPUOutputParam,OP_NORMAL_MODE|TASK_ENC_MODE,&mIPUHandle);
+        if (mIPURet < 0) {
+            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_init ret %d!",mIPURet);
+            return PPDEVICE_ERROR_INIT;
+        }  
+
+        return ret;
+    }
+
+    PPDEVICE_ERR_RET PPIpuLib :: DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        int mIPURet;
+        mIPUInputParam.user_def_paddr[0] = pp_input_addr->phy_offset;
+
+        mIPUOutputParam.user_def_paddr[0] = pp_output_addr->phy_offset;
+
+        mIPURet = mxc_ipu_lib_task_buf_update(&mIPUHandle,pp_input_addr->phy_offset,pp_output_addr->phy_offset,NULL,NULL,NULL);
+        if (mIPURet < 0) {
+            CAMERA_HAL_ERR("Error! convertYUYVtoNV12, mxc_ipu_lib_task_buf_update ret %d!",mIPURet);
+            mxc_ipu_lib_task_uninit(&mIPUHandle);
+            memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+            return PPDEVICE_ERROR_PROCESS;
+        }
+
+        return ret;
+
+    }
+
+    PPDEVICE_ERR_RET PPIpuLib :: PPDeviceDeInit(){
+        CAMERA_HAL_LOG_FUNC;
+        PPDEVICE_ERR_RET ret = PPDEVICE_ERROR_NONE;
+
+        mxc_ipu_lib_task_uninit(&mIPUHandle);
+        memset(&mIPUHandle, 0, sizeof(ipu_lib_handle_t));
+
+        return ret;
+    }
+
+    sp<PostProcessDeviceInterface> PPIpuLib :: createInstance(){
+        CAMERA_HAL_LOG_FUNC;
+        if (singleton != 0) {
+            sp<PostProcessDeviceInterface> device = singleton.promote();
+            if (device != 0) {
+                return device;
+            }
+        }
+        sp<PostProcessDeviceInterface> device(new PPIpuLib());
+
+        singleton = device;
+        return device;
+    }
+
+};
diff --git a/mx6/libcamera/PP_ipulib.h b/mx6/libcamera/PP_ipulib.h
new file mode 100755
index 0000000..39b0d4c
--- /dev/null
+++ b/mx6/libcamera/PP_ipulib.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef PP_IPU_LIB_H
+#define PP_IPU_LIB_H
+extern "C" {
+#include "mxc_ipu_hl_lib.h" 
+} 
+
+#include "PostProcessDeviceInterface.h"
+
+namespace android{
+    class PPIpuLib : public PostProcessDeviceInterface
+    {
+    public:
+        virtual PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output);
+        virtual PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr);
+        virtual PPDEVICE_ERR_RET PPDeviceDeInit();
+        static sp<PostProcessDeviceInterface> createInstance();
+    private:
+        PPIpuLib();
+        virtual ~PPIpuLib();
+        static wp<PostProcessDeviceInterface> singleton;
+
+        ipu_lib_input_param_t mIPUInputParam;	
+        ipu_lib_output_param_t mIPUOutputParam; 
+        ipu_lib_handle_t			mIPUHandle;
+    };
+};
+#endif
diff --git a/mx6/libcamera/PostProcessDeviceInterface.cpp b/mx6/libcamera/PostProcessDeviceInterface.cpp
new file mode 100755
index 0000000..3d7e752
--- /dev/null
+++ b/mx6/libcamera/PostProcessDeviceInterface.cpp
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include "PP_ipulib.h" 
+namespace android{
+    extern "C" sp<PostProcessDeviceInterface> createPPDevice(){
+        return PPIpuLib :: createInstance();
+    }
+
+};
diff --git a/mx6/libcamera/PostProcessDeviceInterface.h b/mx6/libcamera/PostProcessDeviceInterface.h
new file mode 100755
index 0000000..9d730b6
--- /dev/null
+++ b/mx6/libcamera/PostProcessDeviceInterface.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+#ifndef POSTPROCESS_DEVICE_INTERFACE_H
+#define POSTPROCESS_DEVICE_INTERFACE_H
+
+#include <utils/RefBase.h>
+#include "Camera_utils.h"
+#include <linux/videodev2.h>
+
+namespace android {
+
+    typedef enum{
+        PPDEVICE_ERROR_NONE = 0,
+        PPDEVICE_ERROR_INIT = -1,
+        PPDEVICE_ERROR_PROCESS  = -2,
+        PPDEVICE_ERROR_DEINIT = -3
+    }PPDEVICE_ERR_RET;
+
+    struct pp_fb_pos{
+        unsigned short x;
+        unsigned short y;
+    };
+
+    struct win_t{
+        struct pp_fb_pos pos;
+        unsigned int win_w;
+        unsigned int win_h;
+    } ;
+
+    typedef struct {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fmt;
+        struct win_t input_crop_win;
+        int user_def_paddr;
+    } pp_input_param_t;
+
+    typedef struct {
+        unsigned int width;
+        unsigned int height;
+        unsigned int fmt;
+        unsigned int rot;
+        struct win_t output_win;
+        int user_def_paddr;
+    } pp_output_param_t;
+
+
+    class PostProcessDeviceInterface : public virtual RefBase{
+    public:
+        virtual  PPDEVICE_ERR_RET PPDeviceInit(pp_input_param_t *pp_input, pp_output_param_t *pp_output)=0;
+        virtual  PPDEVICE_ERR_RET DoPorcess(DMA_BUFFER *pp_input_addr, DMA_BUFFER *pp_output_addr)=0;
+        virtual  PPDEVICE_ERR_RET PPDeviceDeInit()=0;
+
+        virtual ~PostProcessDeviceInterface(){}
+    }; 
+    extern "C" sp<PostProcessDeviceInterface> createPPDevice();
+
+};
+#endif
+
diff --git a/mx6/libcamera/V4l2CapDeviceBase.cpp b/mx6/libcamera/V4l2CapDeviceBase.cpp
new file mode 100755
index 0000000..ff0e094
--- /dev/null
+++ b/mx6/libcamera/V4l2CapDeviceBase.cpp
@@ -0,0 +1,704 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "V4l2CapDeviceBase.h"
+
+
+
+
+namespace android{
+
+    V4l2CapDeviceBase ::V4l2CapDeviceBase()
+        :mCameraDevice(0),
+        mFmtParamIdx(0),
+        mSizeFPSParamIdx(0),
+        mRequiredFmt(0),
+        mBufQueNum(0),
+        mQueuedBufNum(0)
+
+    {
+        mCaptureDeviceName[0] = '#';
+        memset((void*)&mCapCfg, 0, sizeof(mCapCfg));
+    }
+
+    V4l2CapDeviceBase :: ~V4l2CapDeviceBase()
+    {
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::SetDevName(char * deviceName){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        if(NULL == deviceName)
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        strcpy(mInitalDeviceName, deviceName);
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevName(char * deviceName){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if(NULL == deviceName)
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        strcpy(deviceName, mInitalDeviceName);
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::DevOpen(){
+        CAMERA_HAL_LOG_FUNC;
+
+        return V4l2Open(); 
+    } 
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::GetDevType(CAMERA_TYPE *pType)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        if(pType == NULL)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        *pType = mCameraType;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase::EnumDevParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        CAMERA_HAL_LOG_FUNC;
+
+        if(mCameraDevice <= 0)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        else
+            return V4l2EnumParam(devParamType,retParam);
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevSetConfig(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if(mCapCfg.fmt != pCapcfg->fmt || mCapCfg.width != pCapcfg->width || mCapCfg.height != pCapcfg->height
+                || mCapCfg.tv.denominator/mCapCfg.tv.numerator != pCapcfg->tv.denominator/pCapcfg->tv.numerator) {
+            mCapCfg.fmt = pCapcfg->fmt;
+            mCapCfg.width = pCapcfg->width;
+            mCapCfg.height = pCapcfg->height;
+            mCapCfg.tv.denominator = pCapcfg->tv.denominator;
+            mCapCfg.tv.numerator = pCapcfg->tv.numerator;
+            CAMERA_HAL_LOG_RUNTIME("V4l2SetConfig=width=%d,height=%d", mCapCfg.width, mCapCfg.height);
+            ret = V4l2SetConfig(pCapcfg);
+            if(ret < 0) {
+                return ret;
+            }
+            mCapCfg.rotate = SENSOR_PREVIEW_ROATE_INVALID;
+        }
+
+        if(mCapCfg.rotate != pCapcfg->rotate) {
+            mCapCfg.rotate = pCapcfg->rotate;
+            CAMERA_HAL_LOG_RUNTIME("V4l2SetRot=rotate=%d", mCapCfg.rotate);
+            if(V4l2SetRot(pCapcfg) < 0)
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        return ret;
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2RegisterBufs(DevBufQue, pBufQueNum);
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2AllocateBuf(DevBufQue, pBufQueNum);
+    }
+
+    CAPTURE_DEVICE_ERR_RET  V4l2CapDeviceBase :: DevPrepare(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2Prepare();
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStart(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else
+            return V4l2Start();
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDequeue(unsigned int *pBufQueIdx){
+
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Dequeue(pBufQueIdx);
+        }
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevQueue( unsigned int BufQueIdx){
+
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Queue(BufQueIdx);
+        }
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevStop(){
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Stop();
+        }
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevDeAllocate(){
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2DeAlloc();
+        }
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: DevClose(){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }else{
+            return V4l2Close();
+        }
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Open(){
+        CAMERA_HAL_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char   dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_capability v4l2_cap;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                        continue;
+                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_QUERYCAP, &v4l2_cap) < 0 ) {
+                        close(fd);
+                        fd = 0;
+                        continue;
+                    } else if ((strstr((char *)v4l2_cap.driver, mInitalDeviceName) != 0) &&
+                            (v4l2_cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
+                        is_found = 1;
+                        strcpy(mCaptureDeviceName, dev_node);
+                        CAMERA_HAL_LOG_RUNTIME("device name is %s", mCaptureDeviceName);
+                        break;
+                    } else {
+                        close(fd);
+                        fd = 0;
+                    }
+                }
+            }
+            if (fd > 0)
+                mCameraDevice = fd;
+            else{
+                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        return ret; 
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumParam(DevParamType devParamType, void *retParam){
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+
+        CAMERA_HAL_LOG_FUNC;
+        CAMERA_HAL_LOG_RUNTIME("devParamType is %d", devParamType);
+
+        if(mCameraDevice <= 0)
+            return CAPTURE_DEVICE_ERR_OPEN;
+        switch(devParamType){
+            case OUTPU_FMT: 
+                ret = V4l2EnumFmt(retParam);
+                break;
+            case FRAME_SIZE_FPS:
+                {
+                    ret = V4l2EnumSizeFps(retParam);
+                    break;
+                }
+            default:
+                {
+                    ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+                    break;
+                }
+        }
+        return ret;
+
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumFmt(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_fmtdesc vid_fmtdesc;
+        unsigned int *pParamVal = (unsigned int *)retParam;
+
+        vid_fmtdesc.index = mFmtParamIdx;
+        vid_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FMT, &vid_fmtdesc ) != 0){
+            mFmtParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+        }else{
+            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", vid_fmtdesc.pixelformat);
+            *pParamVal = vid_fmtdesc.pixelformat;
+            mFmtParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_frmsizeenum vid_frmsize;
+        struct v4l2_frmivalenum vid_frmval;
+
+        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = mSizeFPSParamIdx;
+        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            memset(&vid_frmval, 0, sizeof(struct v4l2_frmivalenum));
+            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            vid_frmval.index = 0; //get the first, that is the min frame interval, but the biggest fps
+            vid_frmval.pixel_format = pCapCfg->fmt;
+            vid_frmval.width = vid_frmsize.discrete.width;
+            vid_frmval.height= vid_frmsize.discrete.height;
+            if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMEINTERVALS, &vid_frmval) != 0){
+                CAMERA_HAL_ERR("VIDIOC_ENUM_FRAMEINTERVALS error");
+                mSizeFPSParamIdx = 0;
+                ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+            }else{
+                pCapCfg->width	= vid_frmsize.discrete.width;
+                pCapCfg->height = vid_frmsize.discrete.height;
+                pCapCfg->tv.numerator = vid_frmval.discrete.numerator;
+                pCapCfg->tv.denominator = vid_frmval.discrete.denominator;
+                mSizeFPSParamIdx ++;
+                ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+            }
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2ConfigInput(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        //For uvc Camera do nothing here.
+
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        *pMode = 0;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetRot(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        //For uvc Camera do nothing here.
+
+        return ret;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2SetConfig(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        struct v4l2_format fmt;
+        struct v4l2_control ctrl;
+        struct v4l2_streamparm parm;
+
+        V4l2ConfigInput(pCapcfg);
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
+
+        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
+        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
+        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
+        else
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
+        fmt.fmt.pix.priv = 0;
+        fmt.fmt.pix.sizeimage = 0;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
+            CAMERA_HAL_ERR("set format failed\n");
+            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
+                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
+        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode));
+        if (ret != CAPTURE_DEVICE_ERR_NONE)
+            return ret;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
+            CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+            CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator,
+                    parm.parm.capture.timeperframe.denominator);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+
+
+        if(V4l2SetRot(pCapcfg) < 0)
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &parm) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }else{
+
+            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+        }
+        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
+        pCapcfg->picture_waite_number = 1; //For uvc, the first frame is ok.
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+        unsigned int i;
+        struct v4l2_buffer buf;
+        enum v4l2_buf_type type;
+        struct v4l2_requestbuffers req;
+        int BufQueNum;
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mBufQueNum = *pBufQueNum;
+
+        memset(&req, 0, sizeof (req));
+        req.count = mBufQueNum;
+        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        req.memory = V4L2_MEMORY_MMAP;
+        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
+            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        /*the driver may can't meet the request, and return the buf num it can handle*/
+        *pBufQueNum = mBufQueNum = req.count;
+
+        for (i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (buf));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.index = i;
+            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } else {
+                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+            }
+
+            mCaptureBuffers[i].length = DevBufQue[i].length= buf.length;
+            mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset = (size_t) buf.m.offset;
+            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start = (unsigned char *)mmap (NULL, mCaptureBuffers[i].length,
+                    PROT_READ | PROT_WRITE, MAP_SHARED, mCameraDevice, mCaptureBuffers[i].phy_offset);
+            memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum){
+        unsigned int i;
+        struct v4l2_buffer buf;
+        enum v4l2_buf_type type;
+        struct v4l2_requestbuffers req;
+        int BufQueNum;
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || DevBufQue == NULL || pBufQueNum == NULL || *pBufQueNum == 0){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        mBufQueNum = *pBufQueNum;
+
+        memset(&req, 0, sizeof (req));
+        req.count = mBufQueNum;
+        req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        req.memory = V4L2_MEMORY_USERPTR;
+        if (ioctl(mCameraDevice, VIDIOC_REQBUFS, &req) < 0) {
+            CAMERA_HAL_ERR("v4l_capture_setup: VIDIOC_REQBUFS failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        /*the driver may can't meet the request, and return the buf num it can handle*/
+        *pBufQueNum = mBufQueNum = req.count;
+
+        for (i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (buf));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.memory = V4L2_MEMORY_USERPTR;
+            buf.index = i;
+            buf.m.offset = mCaptureBuffers[i].phy_offset = DevBufQue[i].phy_offset;
+            buf.length = mCaptureBuffers[i].length = DevBufQue[i].length;
+            mCaptureBuffers[i].virt_start = DevBufQue[i].virt_start;
+            //memset(mCaptureBuffers[i].virt_start, 0xFF, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].length = %d\n", i, mCaptureBuffers[i].length);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].phy_offset = 0x%x\n", i, mCaptureBuffers[i].phy_offset);
+            CAMERA_HAL_LOG_RUNTIME("capture buffers[%d].virt_start = 0x%x\n", i, (unsigned int)(mCaptureBuffers[i].virt_start));
+            if (ioctl(mCameraDevice, VIDIOC_QUERYBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QUERYBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } else {
+                CAMERA_HAL_LOG_RUNTIME("VIDIOC_QUERYBUF ok\n");
+            }
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Prepare(){
+        CAMERA_HAL_LOG_FUNC;
+        struct v4l2_buffer buf;
+        mQueuedBufNum = 0;
+        for (unsigned int i = 0; i < mBufQueNum; i++) {
+            memset(&buf, 0, sizeof (struct v4l2_buffer));
+            buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+            buf.memory = V4L2_MEMORY_USERPTR;
+            buf.index = i;
+            buf.m.offset = mCaptureBuffers[i].phy_offset;
+
+            if (ioctl (mCameraDevice, VIDIOC_QBUF, &buf) < 0) {
+                CAMERA_HAL_ERR("VIDIOC_QBUF error\n");
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            } 
+            mQueuedBufNum ++;
+        }
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Start(){
+        enum v4l2_buf_type type;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl (mCameraDevice, VIDIOC_STREAMON, &type) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else{
+            CAMERA_HAL_LOG_RUNTIME("VIDIOC_STREAMON ok\n");
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Dequeue(unsigned int *pBufQueIdx){
+        int ret;
+        struct v4l2_buffer cfilledbuffer;
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        memset(&cfilledbuffer, 0, sizeof (cfilledbuffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
+        ret = ioctl(mCameraDevice, VIDIOC_DQBUF, &cfilledbuffer);
+        if (ret < 0) {
+            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        *pBufQueIdx = cfilledbuffer.index;
+
+        mQueuedBufNum --;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Queue(unsigned int BufQueIdx){
+        int ret;
+        struct v4l2_buffer cfilledbuffer;
+        //CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || mBufQueNum == 0 || mCaptureBuffers == NULL){
+            return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        memset(&cfilledbuffer, 0, sizeof (struct v4l2_buffer));
+        cfilledbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        cfilledbuffer.memory = V4L2_MEMORY_USERPTR;
+        cfilledbuffer.index = BufQueIdx;
+        ret = ioctl(mCameraDevice, VIDIOC_QBUF, &cfilledbuffer);
+        if (ret < 0) {
+            CAMERA_HAL_ERR("Camera VIDIOC_DQBUF failure, ret=%d", ret);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        mQueuedBufNum ++;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Stop(){
+        enum v4l2_buf_type type;
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl (mCameraDevice, VIDIOC_STREAMOFF, &type) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_STREAMON error\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        } else
+            CAMERA_HAL_LOG_INFO("VIDIOC_STREAMOFF ok\n");
+
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2DeAlloc(){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 ){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        for (unsigned int i = 0; i < mBufQueNum; i++) {
+            if (mCaptureBuffers[i].length && (mCaptureBuffers[i].virt_start > 0)) {
+                munmap(mCaptureBuffers[i].virt_start, mCaptureBuffers[i].length);
+                mCaptureBuffers[i].length = 0;
+                CAMERA_HAL_LOG_RUNTIME("munmap buffers 0x%x\n", (unsigned int)(mCaptureBuffers[i].virt_start));
+            }
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+    CAPTURE_DEVICE_ERR_RET V4l2CapDeviceBase :: V4l2Close(){
+
+        CAMERA_HAL_LOG_FUNC;
+
+        if (mCameraDevice <= 0 ){
+            CAMERA_HAL_LOG_INFO("the device handle is error");
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+        CAMERA_HAL_LOG_INFO("close the device");
+        close(mCameraDevice);
+        mCameraDevice = -1;
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+};
diff --git a/mx6/libcamera/V4l2CapDeviceBase.h b/mx6/libcamera/V4l2CapDeviceBase.h
new file mode 100755
index 0000000..6483e74
--- /dev/null
+++ b/mx6/libcamera/V4l2CapDeviceBase.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_CAP_DEVICE_BASE_H
+#define V4L2_CAP_DEVICE_BASE_H
+#include <linux/videodev2.h>
+
+#include "CaptureDeviceInterface.h"
+
+#define CAMAERA_FILENAME_LENGTH     256
+#define MAX_CAPTURE_BUF_QUE_NUM     6
+#define CAMAERA_SENSOR_LENGTH       32
+
+namespace android{
+
+    class V4l2CapDeviceBase : public CaptureDeviceInterface{
+    public:
+
+        virtual CAPTURE_DEVICE_ERR_RET SetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_ERR_RET GetDevName(char * deviceName);
+        virtual CAPTURE_DEVICE_ERR_RET GetDevType(CAMERA_TYPE *pType);
+        virtual CAPTURE_DEVICE_ERR_RET DevOpen();
+        virtual CAPTURE_DEVICE_ERR_RET EnumDevParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET DevSetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET DevAllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET DevRegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET DevPrepare();
+        virtual CAPTURE_DEVICE_ERR_RET DevStart();
+        virtual CAPTURE_DEVICE_ERR_RET DevDequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET DevQueue( unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET DevStop();
+        virtual CAPTURE_DEVICE_ERR_RET DevDeAllocate();
+        virtual CAPTURE_DEVICE_ERR_RET DevClose();
+
+    protected:
+
+        V4l2CapDeviceBase();
+        virtual ~V4l2CapDeviceBase();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Open();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumParam(DevParamType devParamType, void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2AllocateBuf(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2RegisterBufs(DMA_BUFFER *DevBufQue, unsigned int *pBufQueNum);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Prepare();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Start();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Dequeue(unsigned int *pBufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Queue(unsigned int BufQueIdx);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Stop();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2DeAlloc();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2Close();
+        virtual CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        virtual CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, unsigned int *pMode); 
+        virtual CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+
+        char         mCaptureDeviceName[CAMAERA_FILENAME_LENGTH];
+        char         mInitalDeviceName[CAMAERA_SENSOR_LENGTH];
+        int          mCameraDevice;
+        unsigned int mFmtParamIdx;
+        unsigned int mSizeFPSParamIdx;
+        unsigned int mRequiredFmt;
+        unsigned int mBufQueNum;
+        int          mQueuedBufNum;
+        DMA_BUFFER mCaptureBuffers[MAX_CAPTURE_BUF_QUE_NUM];
+        struct   capture_config_t mCapCfg;
+        CAMERA_TYPE  mCameraType;
+
+    };
+};
+
+#endif
diff --git a/mx6/libcamera/V4l2CsiDevice.cpp b/mx6/libcamera/V4l2CsiDevice.cpp
new file mode 100755
index 0000000..5a66cc6
--- /dev/null
+++ b/mx6/libcamera/V4l2CsiDevice.cpp
@@ -0,0 +1,389 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <linux/time.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/mxc_v4l2.h>
+#include <linux/mxcfb.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <utils/threads.h>
+#include <dirent.h>
+
+#include "V4l2CsiDevice.h"
+
+namespace android{
+    V4l2CsiDevice :: V4l2CsiDevice(){
+        mSupportedFmt[0] = v4l2_fourcc('N','V','1','2');
+        mSupportedFmt[1] = v4l2_fourcc('Y','U','1','2');
+        mSupportedFmt[2] = v4l2_fourcc('Y','U','Y','V');
+        mCameraType = CAMERA_TYPE_CSI;
+    }
+    V4l2CsiDevice :: ~V4l2CsiDevice()
+    {
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2Open(){
+        CAMERA_HAL_LOG_FUNC;
+        int fd = 0, i, j, is_found = 0;
+        const char *flags[] = {"uncompressed", "compressed"};
+
+        char	dev_node[CAMAERA_FILENAME_LENGTH];
+        DIR *v4l_dir = NULL;
+        struct dirent *dir_entry;
+        struct v4l2_dbg_chip_ident vid_chip;
+        struct v4l2_fmtdesc vid_fmtdesc;
+        struct v4l2_frmsizeenum vid_frmsize;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+
+        if(mCameraDevice > 0)
+            return CAPTURE_DEVICE_ERR_ALRADY_OPENED;
+        else if (mCaptureDeviceName[0] != '#'){
+            CAMERA_HAL_LOG_RUNTIME("already get the device name %s", mCaptureDeviceName);
+            mCameraDevice = open(mCaptureDeviceName, O_RDWR, O_NONBLOCK);
+            if (mCameraDevice < 0)
+                return CAPTURE_DEVICE_ERR_OPEN;
+        }
+        else{
+            CAMERA_HAL_LOG_RUNTIME("deviceName is %s", mInitalDeviceName);
+            v4l_dir = opendir("/sys/class/video4linux");
+            if (v4l_dir){
+                while((dir_entry = readdir(v4l_dir))) {
+                    memset((void *)dev_node, 0, CAMAERA_FILENAME_LENGTH);
+                    if(strncmp(dir_entry->d_name, "video", 5)) 
+                        continue;
+                    sprintf(dev_node, "/dev/%s", dir_entry->d_name);
+                    if ((fd = open(dev_node, O_RDWR, O_NONBLOCK)) < 0)
+                        continue;
+                    CAMERA_HAL_LOG_RUNTIME("dev_node is %s", dev_node);
+                    if(ioctl(fd, VIDIOC_DBG_G_CHIP_IDENT, &vid_chip) < 0 ) {
+                        close(fd);
+                        fd = 0;
+                        continue;
+                    } else if (strstr(vid_chip.match.name, mInitalDeviceName) != 0) {
+                        is_found = 1;
+                        strcpy(mCaptureDeviceName, dev_node);
+                        strcpy(mInitalDeviceName, vid_chip.match.name);
+                        CAMERA_HAL_LOG_INFO("device name is %s", mCaptureDeviceName);
+                        CAMERA_HAL_LOG_INFO("sensor name is %s", mInitalDeviceName);
+                        break;
+                    } else{
+                        close(fd);
+                        fd = 0;
+                    }
+                }
+            }
+            if (fd > 0)
+                mCameraDevice = fd;
+            else{
+                CAMERA_HAL_ERR("The device name is not correct or the device is error");
+                return CAPTURE_DEVICE_ERR_OPEN;
+            }
+        }
+        return ret; 
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumFmt(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        unsigned int *pParamVal = (unsigned int *)retParam;
+
+        if (mFmtParamIdx < ENUM_SUPPORTED_FMT){
+            CAMERA_HAL_LOG_RUNTIME("vid_fmtdesc.pixelformat is %x", mSupportedFmt[mFmtParamIdx]);
+            *pParamVal = mSupportedFmt[mFmtParamIdx];
+            mFmtParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }else{
+            mFmtParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_GET_PARAM;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2EnumSizeFps(void *retParam){
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE; 
+        struct v4l2_frmsizeenum vid_frmsize;
+
+        struct capture_config_t *pCapCfg =(struct capture_config_t *) retParam;
+        memset(&vid_frmsize, 0, sizeof(struct v4l2_frmsizeenum));
+        vid_frmsize.index = mSizeFPSParamIdx;
+        CAMERA_HAL_LOG_RUNTIME("the query for size fps fmt is %x",pCapCfg->fmt);
+        vid_frmsize.pixel_format = pCapCfg->fmt;
+        if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+            mSizeFPSParamIdx = 0;
+            ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+        }else{
+            //hardcode here for ov3640
+            if (strstr(mInitalDeviceName, "3640") != NULL){
+                CAMERA_HAL_LOG_INFO("the sensor  is  mInitalDeviceName");
+                if (vid_frmsize.discrete.width == 1024 && vid_frmsize.discrete.height == 768){
+                    mSizeFPSParamIdx ++;
+                    vid_frmsize.index = mSizeFPSParamIdx;
+                    if (ioctl(mCameraDevice, VIDIOC_ENUM_FRAMESIZES, &vid_frmsize) != 0){
+                        mSizeFPSParamIdx = 0;
+                        ret = CAPTURE_DEVICE_ERR_SET_PARAM;
+                    }
+                }
+            }
+            CAMERA_HAL_LOG_RUNTIME("in %s the w %d, h %d", __FUNCTION__,vid_frmsize.discrete.width, vid_frmsize.discrete.height);
+            pCapCfg->width  = vid_frmsize.discrete.width;
+            pCapCfg->height = vid_frmsize.discrete.height;
+            if(vid_frmsize.discrete.width > 1280 || vid_frmsize.discrete.height >720){
+                pCapCfg->tv.numerator = 1;
+                pCapCfg->tv.denominator = 15;
+            }else{
+                pCapCfg->tv.numerator = 1;
+                pCapCfg->tv.denominator = 30;
+            }
+            mSizeFPSParamIdx ++;
+            ret = CAPTURE_DEVICE_ERR_ENUM_CONTINUE;
+        }
+        return ret;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2ConfigInput(struct capture_config_t *pCapcfg)
+    {
+        CAMERA_HAL_LOG_FUNC;
+        int input = 1;
+        if (ioctl(mCameraDevice, VIDIOC_S_INPUT, &input) < 0) {
+            CAMERA_HAL_ERR("set input failed");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetConfig(struct capture_config_t *pCapcfg)
+    {
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        struct v4l2_format fmt;
+        struct v4l2_control ctrl;
+        struct v4l2_streamparm parm;
+
+        memset(&parm, 0, sizeof(struct v4l2_streamparm));
+        memset(&fmt, 0, sizeof(struct v4l2_format));
+        V4l2ConfigInput(pCapcfg);
+
+        parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        //hard code here to do a walk around.
+        if(pCapcfg->tv.denominator != 30 && pCapcfg->tv.denominator != 15){
+            pCapcfg->tv.numerator = 1;
+            pCapcfg->tv.denominator = 30;
+        }
+        CAMERA_HAL_LOG_RUNTIME("the fps is %d", pCapcfg->tv.denominator);
+
+        parm.parm.capture.timeperframe.numerator = pCapcfg->tv.numerator;
+        parm.parm.capture.timeperframe.denominator = pCapcfg->tv.denominator;
+        ret = V4l2GetCaptureMode(pCapcfg, &(parm.parm.capture.capturemode), 
+                &(parm.parm.capture.timeperframe));
+        if (ret != CAPTURE_DEVICE_ERR_NONE)
+            return ret;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0) {
+            parm.parm.capture.timeperframe.numerator = 1;
+            parm.parm.capture.timeperframe.denominator = 15;
+            if (ioctl(mCameraDevice, VIDIOC_S_PARM, &parm) < 0){
+                CAMERA_HAL_ERR("%s:%d  VIDIOC_S_PARM failed\n", __FUNCTION__,__LINE__);
+                CAMERA_HAL_ERR("frame timeval is numerator %d, denominator %d",parm.parm.capture.timeperframe.numerator, 
+                        parm.parm.capture.timeperframe.denominator);
+                return CAPTURE_DEVICE_ERR_SYS_CALL;
+            }
+        }
+
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        fmt.fmt.pix.pixelformat = pCapcfg->fmt;
+
+        fmt.fmt.pix.width = pCapcfg->width&0xFFFFFFF8;
+        fmt.fmt.pix.height = pCapcfg->height&0xFFFFFFF8;
+        if (pCapcfg->fmt == V4L2_PIX_FMT_YUYV)
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width * 2;
+        else
+            fmt.fmt.pix.bytesperline = fmt.fmt.pix.width;
+        fmt.fmt.pix.priv = 0;
+        fmt.fmt.pix.sizeimage = 0;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_FMT, &fmt) < 0) {
+            CAMERA_HAL_ERR("set format failed\n");
+            CAMERA_HAL_ERR("pCapcfg->width is %d, pCapcfg->height is %d", pCapcfg->width, pCapcfg->height);
+            CAMERA_HAL_ERR(" Set the Format :%c%c%c%c\n",
+                    pCapcfg->fmt & 0xFF, (pCapcfg->fmt >> 8) & 0xFF,
+                    (pCapcfg->fmt >> 16) & 0xFF, (pCapcfg->fmt >> 24) & 0xFF);
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (ioctl(mCameraDevice, VIDIOC_G_FMT, &fmt) < 0) {
+            CAMERA_HAL_ERR("VIDIOC_S_PARM failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }else{
+
+            CAMERA_HAL_LOG_RUNTIME(" Width = %d\n", fmt.fmt.pix.width);
+            CAMERA_HAL_LOG_RUNTIME(" Height = %d \n", fmt.fmt.pix.height);
+            CAMERA_HAL_LOG_RUNTIME(" Image size = %d\n", fmt.fmt.pix.sizeimage);
+            CAMERA_HAL_LOG_RUNTIME(" pixelformat = %x\n", fmt.fmt.pix.pixelformat);
+        }
+        pCapcfg->framesize = fmt.fmt.pix.sizeimage;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2GetCaptureMode(struct capture_config_t *pCapcfg, 
+            unsigned int *pMode, struct v4l2_fract *pTimeFrame){
+
+        CAMERA_HAL_LOG_FUNC;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        unsigned int capturemode = 0;
+        unsigned int capturewidth =  pCapcfg->width;
+        unsigned int captureheight = pCapcfg->height;
+        unsigned int pic_waite_buf_num = 0;
+        if ((strstr(mInitalDeviceName, OV5640_NAME_STR) != 0) ||
+                (strstr(mInitalDeviceName, OV5642_NAME_STR) != 0)){
+            pic_waite_buf_num = 6;
+            if (capturewidth == 640 && captureheight == 480) {
+                capturemode = 0;	/* VGA mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 320 && captureheight == 240) {
+                capturemode = 1;	/* QVGA mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 720 && captureheight == 480) {
+                capturemode = 2;	/* PAL mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 720 && captureheight == 576) {
+                capturemode = 3;	/* PAL mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 1280 && captureheight == 720) {
+                capturemode = 4;	/* 720P mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 30;
+            }
+            else if (capturewidth == 1920 && captureheight == 1080){
+                pic_waite_buf_num = 3;
+                capturemode = 5;	/* 1080P mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 15;
+            }
+            else if (capturewidth == 2592 && captureheight == 1944) {
+                pic_waite_buf_num =1;
+                capturemode = 6;	/* 2592x1944 mode */
+                pTimeFrame->numerator = 1;
+                pTimeFrame->denominator = 15;
+            }
+            else if (capturewidth == 176 && captureheight == 144) {
+                capturemode = 7;       /* QCIF mode */
+                //pTimeFrame->numerator = 1;
+                //pTimeFrame->denominator = 30;
+            }
+            else{
+                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }else if(strstr(mInitalDeviceName, OV3640_NAME_STR) != 0){
+            pic_waite_buf_num = 10;
+            if (capturewidth == 320 && captureheight == 240)
+                capturemode = 1;	/* QVGA mode */
+            else if (capturewidth == 640 && captureheight == 480)
+                capturemode = 0;	/* VGA mode */
+            else if (capturewidth == 720 && captureheight == 480)
+                capturemode = 4;
+            else if (capturewidth == 720 && captureheight == 576)
+                capturemode = 5;
+            else if (capturewidth == 2048 && captureheight == 1536)
+            {
+                pic_waite_buf_num = 10;
+                capturemode = 3;	/* QXGA mode */
+            }
+            else
+            {
+                CAMERA_HAL_ERR("The camera mode is not supported!!!!");
+                return CAPTURE_DEVICE_ERR_BAD_PARAM;
+            }
+        }else{
+            CAMERA_HAL_ERR("The camera sensor %s not configure!!!!", mInitalDeviceName);
+            capturemode = 0;
+            pic_waite_buf_num = 0;
+        }
+
+        CAMERA_HAL_LOG_INFO("the mode is %d", capturemode);
+        *pMode = capturemode;
+        pCapcfg->picture_waite_number = pic_waite_buf_num;
+
+        return CAPTURE_DEVICE_ERR_NONE;
+    }
+
+    CAPTURE_DEVICE_ERR_RET V4l2CsiDevice :: V4l2SetRot(struct capture_config_t *pCapcfg){
+
+        CAMERA_HAL_LOG_FUNC;
+        CAPTURE_DEVICE_ERR_RET ret = CAPTURE_DEVICE_ERR_NONE;
+        if (mCameraDevice <= 0 || pCapcfg == NULL){
+            return CAPTURE_DEVICE_ERR_BAD_PARAM;
+        }
+
+        struct v4l2_control ctrl;
+
+        // Set rotation
+        ctrl.id = V4L2_CID_MXC_ROT;
+        if (pCapcfg->rotate == SENSOR_PREVIEW_BACK_REF)
+            ctrl.value = V4L2_MXC_ROTATE_NONE;
+        else if (pCapcfg->rotate == SENSOR_PREVIEW_VERT_FLIP)
+            ctrl.value = V4L2_MXC_ROTATE_VERT_FLIP;
+        else if (pCapcfg->rotate == SENSOR_PREVIEW_HORIZ_FLIP)
+            ctrl.value = V4L2_MXC_ROTATE_HORIZ_FLIP;
+        else if (pCapcfg->rotate == SENSOR_PREVIEW_ROATE_180)
+            ctrl.value = V4L2_MXC_ROTATE_180;
+        else
+            ctrl.value = V4L2_MXC_ROTATE_NONE;
+
+        if (ioctl(mCameraDevice, VIDIOC_S_CTRL, &ctrl) < 0) {
+            CAMERA_HAL_ERR("set ctrl failed\n");
+            return CAPTURE_DEVICE_ERR_SYS_CALL;
+        }
+
+        return ret;
+    }
+};
+
diff --git a/mx6/libcamera/V4l2CsiDevice.h b/mx6/libcamera/V4l2CsiDevice.h
new file mode 100755
index 0000000..c695ef3
--- /dev/null
+++ b/mx6/libcamera/V4l2CsiDevice.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_CSI_DEVICE_H
+#define V4L2_CSI_DEVICE_H
+
+#include <linux/videodev2.h>
+#include "V4l2CapDeviceBase.h"
+#define ENUM_SUPPORTED_FMT     3
+
+#define OV3640_NAME_STR   "ov3640"
+#define OV5640_NAME_STR   "ov5640"
+#define OV5642_NAME_STR   "ov5642"
+namespace android{
+
+class V4l2CsiDevice : public V4l2CapDeviceBase{
+    public:
+        
+        V4l2CsiDevice();
+        virtual ~V4l2CsiDevice();
+    protected:
+		
+		CAPTURE_DEVICE_ERR_RET V4l2Open();
+		CAPTURE_DEVICE_ERR_RET V4l2EnumFmt(void *retParam);
+		CAPTURE_DEVICE_ERR_RET V4l2EnumSizeFps(void *retParam);
+		CAPTURE_DEVICE_ERR_RET V4l2SetConfig(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_ERR_RET V4l2ConfigInput(struct capture_config_t *pCapcfg);
+        CAPTURE_DEVICE_ERR_RET V4l2GetCaptureMode(struct capture_config_t *pCapcfg, 
+                unsigned int *pMode, struct v4l2_fract *pTimeFrame); 
+        CAPTURE_DEVICE_ERR_RET V4l2SetRot(struct capture_config_t *pCapcfg);
+
+		unsigned int mSupportedFmt[ENUM_SUPPORTED_FMT];
+   };
+
+};
+#endif
+
+
diff --git a/mx6/libcamera/V4l2UVCDevice.h b/mx6/libcamera/V4l2UVCDevice.h
new file mode 100755
index 0000000..4aac97f
--- /dev/null
+++ b/mx6/libcamera/V4l2UVCDevice.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#ifndef V4L2_UVC_DEVICE_H
+#define V4L2_UVC_DEVICE_H
+
+#include <linux/videodev2.h>
+
+
+#include "V4l2CapDeviceBase.h"
+
+#define MAX_DEV_NAME_LENGTH 10
+
+namespace android{
+
+    class V4l2UVCDevice : public V4l2CapDeviceBase{
+    public:
+        V4l2UVCDevice(){mCameraType = CAMERA_TYPE_UVC;}
+        ~V4l2UVCDevice(){}
+
+    };
+
+};
+#endif
+
diff --git a/mx6/libcamera/messageQueue.cpp b/mx6/libcamera/messageQueue.cpp
new file mode 100755
index 0000000..48c8bcf
--- /dev/null
+++ b/mx6/libcamera/messageQueue.cpp
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/types.h>
+
+#include <utils/threads.h>
+#include <utils/Timers.h>
+#include <utils/Log.h>
+#include <binder/IPCThreadState.h>
+
+#include "messageQueue.h"
+#include "Camera_utils.h"
+
+namespace android {
+
+void CMessageList::insert(const sp<CMessage>& node)
+{
+    mList.push_back(node);
+};
+
+void CMessageList::remove(CMessageList::LIST::iterator pos)
+{
+    mList.erase(pos);
+}
+
+void CMessageList::clear()
+{
+    mList.clear();
+}
+
+CMessageQueue::CMessageQueue()
+    :mQuit(false), mStop(false)
+{
+    mQuitMessage = new CMessage(CMESSAGE_TYPE_QUITE);
+    mStopMessage = new CMessage(CMESSAGE_TYPE_STOP);
+}
+
+CMessageQueue::~CMessageQueue()
+{
+        Mutex::Autolock _l(mLock);
+    LIST::iterator curr(mMessages.begin());
+    //sp<CMessage> tmp;
+
+    while(curr != mMessages.end()) {
+        //tmp = *cur;
+        //tmp.clear();
+        mMessages.remove(curr);
+        //tmp.clear();
+        curr ++;
+    }
+}
+
+void CMessageQueue::clearMessage()
+{
+    CAMERA_HAL_ERR("-------CMessageQueue::clearMessage--------");
+        Mutex::Autolock _l(mLock);
+        mMessages.clear();
+#if 0
+    LIST::iterator icur(mMessages.begin());
+    LIST::iterator iend(mMessages.end());
+    //sp<CMessage> tmp;
+
+    while(icur != iend) {
+    CAMERA_HAL_ERR("*********CMessageQueue::clearMessage********");
+        //tmp = *cur;
+        //tmp.clear();
+        mMessages.remove(icur);
+        //tmp.clear();i
+        icur ++;
+    }
+#endif 
+    mStop = false;
+}
+
+sp<CMessage> CMessageQueue::waitMessage(nsecs_t timeout)
+{
+    sp<CMessage> result;
+    nsecs_t timeoutTime = systemTime() + timeout;
+    
+    while(true) {
+        Mutex::Autolock _l(mLock);
+        nsecs_t now = systemTime();
+        LIST::iterator cur(mMessages.begin());
+
+        if(mQuit) {
+            result = mQuitMessage;
+            return result;
+        }
+        if(mStop) {
+            result = mStopMessage;
+            return result;
+        }
+
+        if(cur != mMessages.end()) {
+            result = *cur;
+        }
+
+        if(result != 0) {
+            mMessages.remove(cur);
+            break;
+        }
+
+        if(timeout >= 0) {
+            if(timeoutTime < now) {
+                result = 0;
+                break;
+            }
+            nsecs_t relTime = timeoutTime - systemTime();
+            mCondition.waitRelative(mLock, relTime);
+        }else {
+            mCondition.wait(mLock);
+        }
+    }
+    return result;
+}
+
+status_t CMessageQueue::postMessage(const sp<CMessage>& message, int32_t flags) 
+{
+    return queueMessage(message, flags);
+}
+
+status_t CMessageQueue::postQuitMessage()
+{
+    Mutex::Autolock _l(mLock);
+    mQuit = true;
+    mCondition.signal();
+    return NO_ERROR;
+}
+
+status_t CMessageQueue::postStopMessage()
+{
+    Mutex::Autolock _l(mLock);
+    mStop = true;
+    //mMessages.insert(new CMessage(CMESSAGE_TYPE_STOP, 0));
+    mCondition.signal();
+    return NO_ERROR;
+}
+
+status_t CMessageQueue::queueMessage(const sp<CMessage>& message, int32_t flags)
+{
+    Mutex::Autolock _l(mLock);
+    mMessages.insert(message);
+    mCondition.signal();
+    return NO_ERROR;
+}
+};
+
diff --git a/mx6/libcamera/messageQueue.h b/mx6/libcamera/messageQueue.h
new file mode 100755
index 0000000..02314cc
--- /dev/null
+++ b/mx6/libcamera/messageQueue.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+
+#ifndef CAMERA_HAL_MESSAGE_QUEUE_H
+#define CAMERA_HAL_MESSAGE_QUEUE_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <utils/threads.h>
+#include <utils/Timers.h>
+#include <utils/List.h>
+
+//#include "Barrier.h"
+
+namespace android {
+
+typedef enum{
+    CMESSAGE_TYPE_NORMAL = 0,
+    CMESSAGE_TYPE_STOP = -1,
+    CMESSAGE_TYPE_QUITE = -2,
+}CMESSAGE_TYPE;
+
+class CMessage;
+
+class CMessageList
+{
+    List< sp<CMessage> > mList;
+    typedef List< sp<CMessage> > LIST;
+public:
+    inline LIST::iterator begin() {return mList.begin();}
+    inline LIST::const_iterator begin() const {return mList.begin();}
+    inline LIST::iterator end() {return mList.end();}
+    inline LIST::const_iterator end() const {return mList.end();}
+    inline bool isEmpty() const {return mList.empty();}
+    void insert(const sp<CMessage> &node);
+    void remove(LIST::iterator pos);
+    void clear();
+};
+
+class CMessage : public LightRefBase<CMessage>
+{
+public:
+    CMESSAGE_TYPE what;
+    int32_t arg0;
+
+    //CMessage(): what(0), arg0(0) {}
+    CMessage(CMESSAGE_TYPE what, int32_t arg0=0)
+        : what(what), arg0(arg0) {}
+
+//protected:
+    virtual ~CMessage() {}
+
+private:
+    friend class LightRefBase<CMessage>;
+};
+
+class CMessageQueue
+{
+    typedef List< sp<CMessage> > LIST;
+public:
+    CMessageQueue();
+    ~CMessageQueue();
+
+    sp<CMessage> waitMessage(nsecs_t timeout=-1);
+    status_t postMessage(const sp<CMessage>& message, int32_t flags=0);
+    status_t postQuitMessage();
+    status_t postStopMessage();
+    void clearMessage();
+
+private:
+    status_t queueMessage(const sp<CMessage>& message, int32_t flags);
+
+    Mutex mLock;
+    Condition mCondition;
+    CMessageList mMessages;
+    bool mQuit;
+    bool mStop;
+    sp<CMessage> mQuitMessage;
+    sp<CMessage> mStopMessage;
+};
+
+
+};
+
+#endif
-- 
1.8.0

