From 1d2810bfcb029b3eea118993910de55f51f50668 Mon Sep 17 00:00:00 2001
From: Jianzheng Zhou <jianzheng.zhou@freescale.com>
Date: Wed, 27 Mar 2013 13:44:25 +0800
Subject: [PATCH 435/486] ENGR00256086 BT: refactor BT HAL

Refactor BT hal to realize both AR3001 and AR3002's adaption to
new BT stack. Mainly add firmware download behavior.

Signed-off-by: Jianzheng Zhou <jianzheng.zhou@freescale.com>
---
 libbt-ath3k/Android.mk                          |   23 +-
 libbt-ath3k/Note.txt                            |  189 ++
 libbt-ath3k/conf/fsl/imx53_smd/Android.mk       |   14 -
 libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf   |    5 -
 libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk     |   14 -
 libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf |    5 -
 libbt-ath3k/include/bt_vendor_QCA3002.h         |   60 +
 libbt-ath3k/include/bt_vendor_ath3k.h           |   45 -
 libbt-ath3k/include/hci.h                       | 2395 +++++++++++++++++++++++
 libbt-ath3k/include/upio.h                      |   77 +-
 libbt-ath3k/include/userial_vendor.h            |  175 --
 libbt-ath3k/include/userial_vendor_QCA3002.h    |  176 ++
 libbt-ath3k/include/vnd_generic.txt             |    6 +-
 libbt-ath3k/include/vnd_imx53_smd.txt           |    8 +
 libbt-ath3k/include/vnd_mako.txt                |    8 +
 libbt-ath3k/include/vnd_sabresd_6dq.txt         |    8 +
 libbt-ath3k/src/bt_vendor_QCA3002.c             |  211 ++
 libbt-ath3k/src/bt_vendor_ath3k.c               |  208 --
 libbt-ath3k/src/conf.c                          |  139 --
 libbt-ath3k/src/hardware.c                      | 1253 ------------
 libbt-ath3k/src/hardware_QCA3002.c              | 1465 ++++++++++++++
 libbt-ath3k/src/upio.c                          |  333 +++-
 libbt-ath3k/src/userial_vendor.c                |  360 ----
 libbt-ath3k/src/userial_vendor_QCA3002.c        |  292 +++
 libbt-ath3k/vnd_buildcfg.mk                     |    4 +-
 25 files changed, 5200 insertions(+), 2273 deletions(-)
 mode change 100755 => 100644 libbt-ath3k/Android.mk
 create mode 100644 libbt-ath3k/Note.txt
 delete mode 100755 libbt-ath3k/conf/fsl/imx53_smd/Android.mk
 delete mode 100755 libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf
 delete mode 100755 libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk
 delete mode 100755 libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf
 create mode 100644 libbt-ath3k/include/bt_vendor_QCA3002.h
 delete mode 100644 libbt-ath3k/include/bt_vendor_ath3k.h
 create mode 100644 libbt-ath3k/include/hci.h
 delete mode 100644 libbt-ath3k/include/userial_vendor.h
 create mode 100644 libbt-ath3k/include/userial_vendor_QCA3002.h
 create mode 100644 libbt-ath3k/include/vnd_imx53_smd.txt
 create mode 100644 libbt-ath3k/include/vnd_mako.txt
 create mode 100644 libbt-ath3k/include/vnd_sabresd_6dq.txt
 create mode 100644 libbt-ath3k/src/bt_vendor_QCA3002.c
 delete mode 100644 libbt-ath3k/src/bt_vendor_ath3k.c
 delete mode 100644 libbt-ath3k/src/conf.c
 delete mode 100644 libbt-ath3k/src/hardware.c
 create mode 100644 libbt-ath3k/src/hardware_QCA3002.c
 delete mode 100644 libbt-ath3k/src/userial_vendor.c
 create mode 100644 libbt-ath3k/src/userial_vendor_QCA3002.c
 mode change 100755 => 100644 libbt-ath3k/vnd_buildcfg.mk

diff --git a/libbt-ath3k/Android.mk b/libbt-ath3k/Android.mk
old mode 100755
new mode 100644
index 8c7c0dd..1aefdeb
--- a/libbt-ath3k/Android.mk
+++ b/libbt-ath3k/Android.mk
@@ -16,18 +16,17 @@
 
 LOCAL_PATH := $(call my-dir)
 
-ifneq ($(BOARD_HAVE_BLUETOOTH_QCOM_ATH3K),)
+ifneq ($(BOARD_USE_AR3K_BLUETOOTH),)
 
 include $(CLEAR_VARS)
 
-BDROID_DIR := $(TOP_DIR)external/bluetooth/bluedroid
+BDROID_DIR:= external/bluetooth/bluedroid
 
 LOCAL_SRC_FILES := \
-        src/bt_vendor_ath3k.c \
-        src/hardware.c \
-        src/userial_vendor.c \
-        src/upio.c \
-        src/conf.c
+        src/bt_vendor_QCA3002.c \
+        src/hardware_QCA3002.c \
+        src/userial_vendor_QCA3002.c \
+        src/upio.c
 
 LOCAL_C_INCLUDES += \
         $(LOCAL_PATH)/include \
@@ -37,7 +36,7 @@ LOCAL_SHARED_LIBRARIES := \
         libcutils
 
 LOCAL_MODULE := libbt-vendor
-LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE_CLASS := SHARED_LIBRARIES
 LOCAL_MODULE_OWNER := qcom
 LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR_SHARED_LIBRARIES)
@@ -46,10 +45,4 @@ include $(LOCAL_PATH)/vnd_buildcfg.mk
 
 include $(BUILD_SHARED_LIBRARY)
 
-ifeq ($(TARGET_DEVICE), imx53_smd)
-    include $(LOCAL_PATH)/conf/fsl/imx53_smd/Android.mk
-endif
-ifeq ($(TARGET_DEVICE), sabresd_6dq)
-    include $(LOCAL_PATH)/conf/fsl/sabresd_6dq/Android.mk
-endif
-endif # BOARD_HAVE_BLUETOOTH_QCOM_ATH3K
+endif # BOARD_HAVE_BLUETOOTH_QCOM_AR3002
diff --git a/libbt-ath3k/Note.txt b/libbt-ath3k/Note.txt
new file mode 100644
index 0000000..002f1cb
--- /dev/null
+++ b/libbt-ath3k/Note.txt
@@ -0,0 +1,189 @@
+
+   Copyright (c) 2005-2012, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
diff --git a/libbt-ath3k/conf/fsl/imx53_smd/Android.mk b/libbt-ath3k/conf/fsl/imx53_smd/Android.mk
deleted file mode 100755
index 974e213..0000000
--- a/libbt-ath3k/conf/fsl/imx53_smd/Android.mk
+++ /dev/null
@@ -1,14 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := bt_vendor.conf
-LOCAL_MODULE_CLASS := ETC
-LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/bluetooth
-
-LOCAL_MODULE_TAGS := eng
-
-LOCAL_SRC_FILES := $(LOCAL_MODULE)
-
-include $(BUILD_PREBUILT)
-
diff --git a/libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf b/libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf
deleted file mode 100755
index b853e76..0000000
--- a/libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-# UART device port where Bluetooth controller is attached
-UartPort = /dev/ttymxc2
-
-# Firmware patch file location
-FwPatchFilePath = /lib/firmware/ar3k/
diff --git a/libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk b/libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk
deleted file mode 100755
index 974e213..0000000
--- a/libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk
+++ /dev/null
@@ -1,14 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := bt_vendor.conf
-LOCAL_MODULE_CLASS := ETC
-LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/bluetooth
-
-LOCAL_MODULE_TAGS := eng
-
-LOCAL_SRC_FILES := $(LOCAL_MODULE)
-
-include $(BUILD_PREBUILT)
-
diff --git a/libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf b/libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf
deleted file mode 100755
index 2b3b0ff..0000000
--- a/libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-# UART device port where Bluetooth controller is attached
-UartPort = /dev/ttymxc4
-
-# Firmware patch file location
-FwPatchFilePath = /system/lib/firmware/ar3k/
diff --git a/libbt-ath3k/include/bt_vendor_QCA3002.h b/libbt-ath3k/include/bt_vendor_QCA3002.h
new file mode 100644
index 0000000..9473149
--- /dev/null
+++ b/libbt-ath3k/include/bt_vendor_QCA3002.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef BT_VENDOR_QCA3002_H
+#define BT_VENDOR_QCA3002_H
+
+#include "bt_vendor_lib.h"
+#include "vnd_buildcfg.h"
+#include "userial_vendor_QCA3002.h"
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+#ifndef TRUE
+#define TRUE   (!FALSE)
+#endif
+/*
+#ifdef ppoll
+#undef ppoll
+#endif
+
+//typedef unsigned long nfds_t;
+
+#define ppoll compat_ppoll
+
+static inline int compat_ppoll(struct pollfd *fds, nfds_t nfds,
+		const struct timespec *timeout, const sigset_t *sigmask)
+{
+	if (timeout == NULL)
+		return poll(fds, nfds, -1);
+	else if (timeout->tv_sec == 0)
+		return poll(fds, nfds, 500);
+	else
+		return poll(fds, nfds, timeout->tv_sec * 1000);
+}
+*/
+// File discriptor using Transport
+extern int fd;
+
+//extern bt_hci_transport_device_type bt_hci_transport_device;
+
+extern bt_vendor_callbacks_t *bt_vendor_cbacks;
+
+#endif /* BT_VENDOR_QCA3002_H */
+
diff --git a/libbt-ath3k/include/bt_vendor_ath3k.h b/libbt-ath3k/include/bt_vendor_ath3k.h
deleted file mode 100644
index f3f7be2..0000000
--- a/libbt-ath3k/include/bt_vendor_ath3k.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
-
-#ifndef BT_VENDOR_ATH3K_H
-#define BT_VENDOR_ATH3K_H
-
-#include "bt_vendor_lib.h"
-#include "vnd_buildcfg.h"
-
-#ifndef FALSE
-#define FALSE  0
-#endif
-
-#ifndef TRUE
-#define TRUE   (!FALSE)
-#endif
-
-/* Run-time configuration file */
-#ifndef VENDOR_LIB_CONF_FILE
-#define VENDOR_LIB_CONF_FILE "/etc/bluetooth/bt_vendor.conf"
-#endif
-
-#ifndef UART_TARGET_BAUD_RATE
-#define UART_TARGET_BAUD_RATE           3000000
-#endif
-
-extern bt_vendor_callbacks_t *bt_vendor_cbacks;
-
-#endif /* BT_VENDOR_ATH3K_H */
-
diff --git a/libbt-ath3k/include/hci.h b/libbt-ath3k/include/hci.h
new file mode 100644
index 0000000..0efac09
--- /dev/null
+++ b/libbt-ath3k/include/hci.h
@@ -0,0 +1,2395 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef __HCI_H
+#define __HCI_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/socket.h>
+
+#define HCI_MAX_DEV	16
+
+#define HCI_MAX_ACL_SIZE	1024
+#define HCI_MAX_SCO_SIZE	255
+#define HCI_MAX_EVENT_SIZE	260
+#define HCI_MAX_FRAME_SIZE	(HCI_MAX_ACL_SIZE + 4)
+
+/* HCI dev events */
+#define HCI_DEV_REG	1
+#define HCI_DEV_UNREG	2
+#define HCI_DEV_UP	3
+#define HCI_DEV_DOWN	4
+#define HCI_DEV_SUSPEND	5
+#define HCI_DEV_RESUME	6
+
+/* HCI bus types */
+#define HCI_VIRTUAL	0
+#define HCI_USB		1
+#define HCI_PCCARD	2
+#define HCI_UART	3
+#define HCI_RS232	4
+#define HCI_PCI		5
+#define HCI_SDIO	6
+
+/* HCI controller types */
+#define HCI_BREDR	0x00
+#define HCI_AMP		0x01
+
+/* HCI device flags */
+enum {
+	HCI_UP,
+	HCI_INIT,
+	HCI_RUNNING,
+
+	HCI_PSCAN,
+	HCI_ISCAN,
+	HCI_AUTH,
+	HCI_ENCRYPT,
+	HCI_INQUIRY,
+
+	HCI_RAW,
+};
+
+/* LE address type */
+enum {
+	LE_PUBLIC_ADDRESS = 0x00,
+	LE_RANDOM_ADDRESS = 0x01
+};
+
+/* HCI ioctl defines */
+#define HCIDEVUP	_IOW('H', 201, int)
+#define HCIDEVDOWN	_IOW('H', 202, int)
+#define HCIDEVRESET	_IOW('H', 203, int)
+#define HCIDEVRESTAT	_IOW('H', 204, int)
+
+#define HCIGETDEVLIST	_IOR('H', 210, int)
+#define HCIGETDEVINFO	_IOR('H', 211, int)
+#define HCIGETCONNLIST	_IOR('H', 212, int)
+#define HCIGETCONNINFO	_IOR('H', 213, int)
+#define HCIGETAUTHINFO	_IOR('H', 215, int)
+
+#define HCISETRAW	_IOW('H', 220, int)
+#define HCISETSCAN	_IOW('H', 221, int)
+#define HCISETAUTH	_IOW('H', 222, int)
+#define HCISETENCRYPT	_IOW('H', 223, int)
+#define HCISETPTYPE	_IOW('H', 224, int)
+#define HCISETLINKPOL	_IOW('H', 225, int)
+#define HCISETLINKMODE	_IOW('H', 226, int)
+#define HCISETACLMTU	_IOW('H', 227, int)
+#define HCISETSCOMTU	_IOW('H', 228, int)
+
+#define HCIBLOCKADDR	_IOW('H', 230, int)
+#define HCIUNBLOCKADDR	_IOW('H', 231, int)
+
+#define HCIINQUIRY	_IOR('H', 240, int)
+
+#ifndef __NO_HCI_DEFS
+
+/* HCI Packet types */
+#define HCI_COMMAND_PKT		0x01
+#define HCI_ACLDATA_PKT		0x02
+#define HCI_SCODATA_PKT		0x03
+#define HCI_EVENT_PKT		0x04
+#define HCI_VENDOR_PKT		0xff
+
+/* HCI Packet types */
+#define HCI_2DH1	0x0002
+#define HCI_3DH1	0x0004
+#define HCI_DM1		0x0008
+#define HCI_DH1		0x0010
+#define HCI_2DH3	0x0100
+#define HCI_3DH3	0x0200
+#define HCI_DM3		0x0400
+#define HCI_DH3		0x0800
+#define HCI_2DH5	0x1000
+#define HCI_3DH5	0x2000
+#define HCI_DM5		0x4000
+#define HCI_DH5		0x8000
+
+#define HCI_HV1		0x0020
+#define HCI_HV2		0x0040
+#define HCI_HV3		0x0080
+
+#define HCI_EV3		0x0008
+#define HCI_EV4		0x0010
+#define HCI_EV5		0x0020
+#define HCI_2EV3	0x0040
+#define HCI_3EV3	0x0080
+#define HCI_2EV5	0x0100
+#define HCI_3EV5	0x0200
+
+#define SCO_PTYPE_MASK	(HCI_HV1 | HCI_HV2 | HCI_HV3)
+#define ACL_PTYPE_MASK	(HCI_DM1 | HCI_DH1 | HCI_DM3 | HCI_DH3 | HCI_DM5 | HCI_DH5)
+
+/* HCI Error codes */
+#define HCI_UNKNOWN_COMMAND			0x01
+#define HCI_NO_CONNECTION			0x02
+#define HCI_HARDWARE_FAILURE			0x03
+#define HCI_PAGE_TIMEOUT			0x04
+#define HCI_AUTHENTICATION_FAILURE		0x05
+#define HCI_PIN_OR_KEY_MISSING			0x06
+#define HCI_MEMORY_FULL				0x07
+#define HCI_CONNECTION_TIMEOUT			0x08
+#define HCI_MAX_NUMBER_OF_CONNECTIONS		0x09
+#define HCI_MAX_NUMBER_OF_SCO_CONNECTIONS	0x0a
+#define HCI_ACL_CONNECTION_EXISTS		0x0b
+#define HCI_COMMAND_DISALLOWED			0x0c
+#define HCI_REJECTED_LIMITED_RESOURCES		0x0d
+#define HCI_REJECTED_SECURITY			0x0e
+#define HCI_REJECTED_PERSONAL			0x0f
+#define HCI_HOST_TIMEOUT			0x10
+#define HCI_UNSUPPORTED_FEATURE			0x11
+#define HCI_INVALID_PARAMETERS			0x12
+#define HCI_OE_USER_ENDED_CONNECTION		0x13
+#define HCI_OE_LOW_RESOURCES			0x14
+#define HCI_OE_POWER_OFF			0x15
+#define HCI_CONNECTION_TERMINATED		0x16
+#define HCI_REPEATED_ATTEMPTS			0x17
+#define HCI_PAIRING_NOT_ALLOWED			0x18
+#define HCI_UNKNOWN_LMP_PDU			0x19
+#define HCI_UNSUPPORTED_REMOTE_FEATURE		0x1a
+#define HCI_SCO_OFFSET_REJECTED			0x1b
+#define HCI_SCO_INTERVAL_REJECTED		0x1c
+#define HCI_AIR_MODE_REJECTED			0x1d
+#define HCI_INVALID_LMP_PARAMETERS		0x1e
+#define HCI_UNSPECIFIED_ERROR			0x1f
+#define HCI_UNSUPPORTED_LMP_PARAMETER_VALUE	0x20
+#define HCI_ROLE_CHANGE_NOT_ALLOWED		0x21
+#define HCI_LMP_RESPONSE_TIMEOUT		0x22
+#define HCI_LMP_ERROR_TRANSACTION_COLLISION	0x23
+#define HCI_LMP_PDU_NOT_ALLOWED			0x24
+#define HCI_ENCRYPTION_MODE_NOT_ACCEPTED	0x25
+#define HCI_UNIT_LINK_KEY_USED			0x26
+#define HCI_QOS_NOT_SUPPORTED			0x27
+#define HCI_INSTANT_PASSED			0x28
+#define HCI_PAIRING_NOT_SUPPORTED		0x29
+#define HCI_TRANSACTION_COLLISION		0x2a
+#define HCI_QOS_UNACCEPTABLE_PARAMETER		0x2c
+#define HCI_QOS_REJECTED			0x2d
+#define HCI_CLASSIFICATION_NOT_SUPPORTED	0x2e
+#define HCI_INSUFFICIENT_SECURITY		0x2f
+#define HCI_PARAMETER_OUT_OF_RANGE		0x30
+#define HCI_ROLE_SWITCH_PENDING			0x32
+#define HCI_SLOT_VIOLATION			0x34
+#define HCI_ROLE_SWITCH_FAILED			0x35
+#define HCI_EIR_TOO_LARGE			0x36
+#define HCI_SIMPLE_PAIRING_NOT_SUPPORTED	0x37
+#define HCI_HOST_BUSY_PAIRING			0x38
+
+/* ACL flags */
+#define ACL_START_NO_FLUSH	0x00
+#define ACL_CONT		0x01
+#define ACL_START		0x02
+#define ACL_ACTIVE_BCAST	0x04
+#define ACL_PICO_BCAST		0x08
+
+/* Baseband links */
+#define SCO_LINK	0x00
+#define ACL_LINK	0x01
+#define ESCO_LINK	0x02
+
+/* LMP features */
+#define LMP_3SLOT	0x01
+#define LMP_5SLOT	0x02
+#define LMP_ENCRYPT	0x04
+#define LMP_SOFFSET	0x08
+#define LMP_TACCURACY	0x10
+#define LMP_RSWITCH	0x20
+#define LMP_HOLD	0x40
+#define LMP_SNIFF	0x80
+
+#define LMP_PARK	0x01
+#define LMP_RSSI	0x02
+#define LMP_QUALITY	0x04
+#define LMP_SCO		0x08
+#define LMP_HV2		0x10
+#define LMP_HV3		0x20
+#define LMP_ULAW	0x40
+#define LMP_ALAW	0x80
+
+#define LMP_CVSD	0x01
+#define LMP_PSCHEME	0x02
+#define LMP_PCONTROL	0x04
+#define LMP_TRSP_SCO	0x08
+#define LMP_BCAST_ENC	0x80
+
+#define LMP_EDR_ACL_2M	0x02
+#define LMP_EDR_ACL_3M	0x04
+#define LMP_ENH_ISCAN	0x08
+#define LMP_ILACE_ISCAN	0x10
+#define LMP_ILACE_PSCAN	0x20
+#define LMP_RSSI_INQ	0x40
+#define LMP_ESCO	0x80
+
+#define LMP_EV4		0x01
+#define LMP_EV5		0x02
+#define LMP_AFH_CAP_SLV	0x08
+#define LMP_AFH_CLS_SLV	0x10
+#define LMP_NO_BREDR	0x20
+#define LMP_LE		0x40
+#define LMP_EDR_3SLOT	0x80
+
+#define LMP_EDR_5SLOT	0x01
+#define LMP_SNIFF_SUBR	0x02
+#define LMP_PAUSE_ENC	0x04
+#define LMP_AFH_CAP_MST	0x08
+#define LMP_AFH_CLS_MST	0x10
+#define LMP_EDR_ESCO_2M	0x20
+#define LMP_EDR_ESCO_3M	0x40
+#define LMP_EDR_3S_ESCO	0x80
+
+#define LMP_EXT_INQ	0x01
+#define LMP_LE_BREDR	0x02
+#define LMP_SIMPLE_PAIR	0x08
+#define LMP_ENCAPS_PDU	0x10
+#define LMP_ERR_DAT_REP	0x20
+#define LMP_NFLUSH_PKTS	0x40
+
+#define LMP_LSTO	0x01
+#define LMP_INQ_TX_PWR	0x02
+#define LMP_EPC		0x04
+#define LMP_EXT_FEAT	0x80
+
+/* Extended LMP features */
+#define LMP_HOST_SSP		0x01
+#define LMP_HOST_LE		0x02
+#define LMP_HOST_LE_BREDR	0x04
+
+/* Link policies */
+#define HCI_LP_RSWITCH	0x0001
+#define HCI_LP_HOLD	0x0002
+#define HCI_LP_SNIFF	0x0004
+#define HCI_LP_PARK	0x0008
+
+/* Link mode */
+#define HCI_LM_ACCEPT	0x8000
+#define HCI_LM_MASTER	0x0001
+#define HCI_LM_AUTH	0x0002
+#define HCI_LM_ENCRYPT	0x0004
+#define HCI_LM_TRUSTED	0x0008
+#define HCI_LM_RELIABLE	0x0010
+#define HCI_LM_SECURE	0x0020
+
+/* Link Key types */
+#define HCI_LK_COMBINATION		0x00
+#define HCI_LK_LOCAL_UNIT		0x01
+#define HCI_LK_REMOTE_UNIT		0x02
+#define HCI_LK_DEBUG_COMBINATION	0x03
+#define HCI_LK_UNAUTH_COMBINATION	0x04
+#define HCI_LK_AUTH_COMBINATION		0x05
+#define HCI_LK_CHANGED_COMBINATION	0x06
+#define HCI_LK_INVALID			0xFF
+
+/* -----  HCI Commands ----- */
+
+/* Link Control */
+#define OGF_LINK_CTL		0x01
+
+#define OCF_INQUIRY			0x0001
+typedef struct {
+	uint8_t		lap[3];
+	uint8_t		length;		/* 1.28s units */
+	uint8_t		num_rsp;
+} __attribute__ ((packed)) inquiry_cp;
+#define INQUIRY_CP_SIZE 5
+
+typedef struct {
+	uint8_t b[6];
+} __attribute__((packed)) bdaddr_t;
+
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) status_bdaddr_rp;
+#define STATUS_BDADDR_RP_SIZE 7
+
+#define OCF_INQUIRY_CANCEL		0x0002
+
+#define OCF_PERIODIC_INQUIRY		0x0003
+typedef struct {
+	uint16_t	max_period;	/* 1.28s units */
+	uint16_t	min_period;	/* 1.28s units */
+	uint8_t		lap[3];
+	uint8_t		length;		/* 1.28s units */
+	uint8_t		num_rsp;
+} __attribute__ ((packed)) periodic_inquiry_cp;
+#define PERIODIC_INQUIRY_CP_SIZE 9
+
+#define OCF_EXIT_PERIODIC_INQUIRY	0x0004
+
+#define OCF_CREATE_CONN			0x0005
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint16_t	pkt_type;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_mode;
+	uint16_t	clock_offset;
+	uint8_t		role_switch;
+} __attribute__ ((packed)) create_conn_cp;
+#define CREATE_CONN_CP_SIZE 13
+
+#define OCF_DISCONNECT			0x0006
+typedef struct {
+	uint16_t	handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) disconnect_cp;
+#define DISCONNECT_CP_SIZE 3
+
+#define OCF_ADD_SCO			0x0007
+typedef struct {
+	uint16_t	handle;
+	uint16_t	pkt_type;
+} __attribute__ ((packed)) add_sco_cp;
+#define ADD_SCO_CP_SIZE 4
+
+#define OCF_CREATE_CONN_CANCEL		0x0008
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) create_conn_cancel_cp;
+#define CREATE_CONN_CANCEL_CP_SIZE 6
+
+#define OCF_ACCEPT_CONN_REQ		0x0009
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		role;
+} __attribute__ ((packed)) accept_conn_req_cp;
+#define ACCEPT_CONN_REQ_CP_SIZE	7
+
+#define OCF_REJECT_CONN_REQ		0x000A
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		reason;
+} __attribute__ ((packed)) reject_conn_req_cp;
+#define REJECT_CONN_REQ_CP_SIZE	7
+
+#define OCF_LINK_KEY_REPLY		0x000B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		link_key[16];
+} __attribute__ ((packed)) link_key_reply_cp;
+#define LINK_KEY_REPLY_CP_SIZE 22
+
+#define OCF_LINK_KEY_NEG_REPLY		0x000C
+
+#define OCF_PIN_CODE_REPLY		0x000D
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pin_len;
+	uint8_t		pin_code[16];
+} __attribute__ ((packed)) pin_code_reply_cp;
+#define PIN_CODE_REPLY_CP_SIZE 23
+
+#define OCF_PIN_CODE_NEG_REPLY		0x000E
+
+#define OCF_SET_CONN_PTYPE		0x000F
+typedef struct {
+	uint16_t	 handle;
+	uint16_t	 pkt_type;
+} __attribute__ ((packed)) set_conn_ptype_cp;
+#define SET_CONN_PTYPE_CP_SIZE 4
+
+#define OCF_AUTH_REQUESTED		0x0011
+typedef struct {
+	uint16_t	 handle;
+} __attribute__ ((packed)) auth_requested_cp;
+#define AUTH_REQUESTED_CP_SIZE 2
+
+#define OCF_SET_CONN_ENCRYPT		0x0013
+typedef struct {
+	uint16_t	handle;
+	uint8_t		encrypt;
+} __attribute__ ((packed)) set_conn_encrypt_cp;
+#define SET_CONN_ENCRYPT_CP_SIZE 3
+
+#define OCF_CHANGE_CONN_LINK_KEY	0x0015
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) change_conn_link_key_cp;
+#define CHANGE_CONN_LINK_KEY_CP_SIZE 2
+
+#define OCF_MASTER_LINK_KEY		0x0017
+typedef struct {
+	uint8_t		key_flag;
+} __attribute__ ((packed)) master_link_key_cp;
+#define MASTER_LINK_KEY_CP_SIZE 1
+
+#define OCF_REMOTE_NAME_REQ		0x0019
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_mode;
+	uint16_t	clock_offset;
+} __attribute__ ((packed)) remote_name_req_cp;
+#define REMOTE_NAME_REQ_CP_SIZE 10
+
+#define OCF_REMOTE_NAME_REQ_CANCEL	0x001A
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) remote_name_req_cancel_cp;
+#define REMOTE_NAME_REQ_CANCEL_CP_SIZE 6
+
+#define OCF_READ_REMOTE_FEATURES	0x001B
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_remote_features_cp;
+#define READ_REMOTE_FEATURES_CP_SIZE 2
+
+#define OCF_READ_REMOTE_EXT_FEATURES	0x001C
+typedef struct {
+	uint16_t	handle;
+	uint8_t		page_num;
+} __attribute__ ((packed)) read_remote_ext_features_cp;
+#define READ_REMOTE_EXT_FEATURES_CP_SIZE 3
+
+#define OCF_READ_REMOTE_VERSION		0x001D
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_remote_version_cp;
+#define READ_REMOTE_VERSION_CP_SIZE 2
+
+#define OCF_READ_CLOCK_OFFSET		0x001F
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_clock_offset_cp;
+#define READ_CLOCK_OFFSET_CP_SIZE 2
+
+#define OCF_READ_LMP_HANDLE		0x0020
+
+#define OCF_SETUP_SYNC_CONN		0x0028
+typedef struct {
+	uint16_t	handle;
+	uint32_t	tx_bandwith;
+	uint32_t	rx_bandwith;
+	uint16_t	max_latency;
+	uint16_t	voice_setting;
+	uint8_t		retrans_effort;
+	uint16_t	pkt_type;
+} __attribute__ ((packed)) setup_sync_conn_cp;
+#define SETUP_SYNC_CONN_CP_SIZE 17
+
+#define OCF_ACCEPT_SYNC_CONN_REQ	0x0029
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	tx_bandwith;
+	uint32_t	rx_bandwith;
+	uint16_t	max_latency;
+	uint16_t	voice_setting;
+	uint8_t		retrans_effort;
+	uint16_t	pkt_type;
+} __attribute__ ((packed)) accept_sync_conn_req_cp;
+#define ACCEPT_SYNC_CONN_REQ_CP_SIZE 21
+
+#define OCF_REJECT_SYNC_CONN_REQ	0x002A
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		reason;
+} __attribute__ ((packed)) reject_sync_conn_req_cp;
+#define REJECT_SYNC_CONN_REQ_CP_SIZE 7
+
+#define OCF_IO_CAPABILITY_REPLY		0x002B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		capability;
+	uint8_t		oob_data;
+	uint8_t		authentication;
+} __attribute__ ((packed)) io_capability_reply_cp;
+#define IO_CAPABILITY_REPLY_CP_SIZE 9
+
+#define OCF_USER_CONFIRM_REPLY		0x002C
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) user_confirm_reply_cp;
+#define USER_CONFIRM_REPLY_CP_SIZE 6
+
+#define OCF_USER_CONFIRM_NEG_REPLY	0x002D
+
+#define OCF_USER_PASSKEY_REPLY		0x002E
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	passkey;
+} __attribute__ ((packed)) user_passkey_reply_cp;
+#define USER_PASSKEY_REPLY_CP_SIZE 10
+
+#define OCF_USER_PASSKEY_NEG_REPLY	0x002F
+
+#define OCF_REMOTE_OOB_DATA_REPLY	0x0030
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		hash[16];
+	uint8_t		randomizer[16];
+} __attribute__ ((packed)) remote_oob_data_reply_cp;
+#define REMOTE_OOB_DATA_REPLY_CP_SIZE 38
+
+#define OCF_REMOTE_OOB_DATA_NEG_REPLY	0x0033
+
+#define OCF_IO_CAPABILITY_NEG_REPLY	0x0034
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		reason;
+} __attribute__ ((packed)) io_capability_neg_reply_cp;
+#define IO_CAPABILITY_NEG_REPLY_CP_SIZE 7
+
+#define OCF_CREATE_PHYSICAL_LINK		0x0035
+typedef struct {
+	uint8_t		handle;
+	uint8_t		key_length;
+	uint8_t		key_type;
+	uint8_t		key[32];
+} __attribute__ ((packed)) create_physical_link_cp;
+#define CREATE_PHYSICAL_LINK_CP_SIZE 35
+
+#define OCF_ACCEPT_PHYSICAL_LINK		0x0036
+
+#define OCF_DISCONNECT_PHYSICAL_LINK		0x0037
+typedef struct {
+	uint8_t		handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) disconnect_physical_link_cp;
+#define DISCONNECT_PHYSICAL_LINK_CP_SIZE 2
+
+#define OCF_CREATE_LOGICAL_LINK		0x0038
+typedef struct {
+	uint8_t		handle;
+	uint8_t		tx_flow[16];
+	uint8_t		rx_flow[16];
+} __attribute__ ((packed)) create_logical_link_cp;
+#define CREATE_LOGICAL_LINK_CP_SIZE 33
+
+#define OCF_ACCEPT_LOGICAL_LINK		0x0039
+
+#define OCF_DISCONNECT_LOGICAL_LINK		0x003A
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) disconnect_logical_link_cp;
+#define DISCONNECT_LOGICAL_LINK_CP_SIZE 2
+
+#define OCF_LOGICAL_LINK_CANCEL		0x003B
+typedef struct {
+	uint8_t		handle;
+	uint8_t		tx_flow_id;
+} __attribute__ ((packed)) cancel_logical_link_cp;
+#define LOGICAL_LINK_CANCEL_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+	uint8_t		tx_flow_id;
+} __attribute__ ((packed)) cancel_logical_link_rp;
+#define LOGICAL_LINK_CANCEL_RP_SIZE 3
+
+#define OCF_FLOW_SPEC_MODIFY		0x003C
+
+/* Link Policy */
+#define OGF_LINK_POLICY		0x02
+
+#define OCF_HOLD_MODE			0x0001
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_interval;
+	uint16_t	min_interval;
+} __attribute__ ((packed)) hold_mode_cp;
+#define HOLD_MODE_CP_SIZE 6
+
+#define OCF_SNIFF_MODE			0x0003
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_interval;
+	uint16_t	min_interval;
+	uint16_t	attempt;
+	uint16_t	timeout;
+} __attribute__ ((packed)) sniff_mode_cp;
+#define SNIFF_MODE_CP_SIZE 10
+
+#define OCF_EXIT_SNIFF_MODE		0x0004
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) exit_sniff_mode_cp;
+#define EXIT_SNIFF_MODE_CP_SIZE 2
+
+#define OCF_PARK_MODE			0x0005
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_interval;
+	uint16_t	min_interval;
+} __attribute__ ((packed)) park_mode_cp;
+#define PARK_MODE_CP_SIZE 6
+
+#define OCF_EXIT_PARK_MODE		0x0006
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) exit_park_mode_cp;
+#define EXIT_PARK_MODE_CP_SIZE 2
+
+#define OCF_QOS_SETUP			0x0007
+typedef struct {
+	uint8_t		service_type;		/* 1 = best effort */
+	uint32_t	token_rate;		/* Byte per seconds */
+	uint32_t	peak_bandwidth;		/* Byte per seconds */
+	uint32_t	latency;		/* Microseconds */
+	uint32_t	delay_variation;	/* Microseconds */
+} __attribute__ ((packed)) hci_qos;
+#define HCI_QOS_CP_SIZE 17
+typedef struct {
+	uint16_t 	handle;
+	uint8_t 	flags;			/* Reserved */
+	hci_qos 	qos;
+} __attribute__ ((packed)) qos_setup_cp;
+#define QOS_SETUP_CP_SIZE (3 + HCI_QOS_CP_SIZE)
+
+#define OCF_ROLE_DISCOVERY		0x0009
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) role_discovery_cp;
+#define ROLE_DISCOVERY_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		role;
+} __attribute__ ((packed)) role_discovery_rp;
+#define ROLE_DISCOVERY_RP_SIZE 4
+
+#define OCF_SWITCH_ROLE			0x000B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		role;
+} __attribute__ ((packed)) switch_role_cp;
+#define SWITCH_ROLE_CP_SIZE 7
+
+#define OCF_READ_LINK_POLICY		0x000C
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) read_link_policy_cp;
+#define READ_LINK_POLICY_CP_SIZE 2
+typedef struct {
+	uint8_t 	status;
+	uint16_t	handle;
+	uint16_t	policy;
+} __attribute__ ((packed)) read_link_policy_rp;
+#define READ_LINK_POLICY_RP_SIZE 5
+
+#define OCF_WRITE_LINK_POLICY		0x000D
+typedef struct {
+	uint16_t	handle;
+	uint16_t	policy;
+} __attribute__ ((packed)) write_link_policy_cp;
+#define WRITE_LINK_POLICY_CP_SIZE 4
+typedef struct {
+	uint8_t 	status;
+	uint16_t	handle;
+} __attribute__ ((packed)) write_link_policy_rp;
+#define WRITE_LINK_POLICY_RP_SIZE 3
+
+#define OCF_READ_DEFAULT_LINK_POLICY	0x000E
+
+#define OCF_WRITE_DEFAULT_LINK_POLICY	0x000F
+
+#define OCF_FLOW_SPECIFICATION		0x0010
+
+#define OCF_SNIFF_SUBRATING		0x0011
+typedef struct {
+	uint16_t	handle;
+	uint16_t	max_latency;
+	uint16_t	min_remote_timeout;
+	uint16_t	min_local_timeout;
+} __attribute__ ((packed)) sniff_subrating_cp;
+#define SNIFF_SUBRATING_CP_SIZE 8
+
+/* Host Controller and Baseband */
+#define OGF_HOST_CTL		0x03
+
+#define OCF_SET_EVENT_MASK		0x0001
+typedef struct {
+	uint8_t		mask[8];
+} __attribute__ ((packed)) set_event_mask_cp;
+#define SET_EVENT_MASK_CP_SIZE 8
+
+#define OCF_RESET			0x0003
+
+#define OCF_SET_EVENT_FLT		0x0005
+typedef struct {
+	uint8_t		flt_type;
+	uint8_t		cond_type;
+	uint8_t		condition[0];
+} __attribute__ ((packed)) set_event_flt_cp;
+#define SET_EVENT_FLT_CP_SIZE 2
+
+/* Filter types */
+#define FLT_CLEAR_ALL			0x00
+#define FLT_INQ_RESULT			0x01
+#define FLT_CONN_SETUP			0x02
+/* INQ_RESULT Condition types */
+#define INQ_RESULT_RETURN_ALL		0x00
+#define INQ_RESULT_RETURN_CLASS		0x01
+#define INQ_RESULT_RETURN_BDADDR	0x02
+/* CONN_SETUP Condition types */
+#define CONN_SETUP_ALLOW_ALL		0x00
+#define CONN_SETUP_ALLOW_CLASS		0x01
+#define CONN_SETUP_ALLOW_BDADDR		0x02
+/* CONN_SETUP Conditions */
+#define CONN_SETUP_AUTO_OFF		0x01
+#define CONN_SETUP_AUTO_ON		0x02
+
+#define OCF_FLUSH			0x0008
+
+#define OCF_READ_PIN_TYPE		0x0009
+typedef struct {
+	uint8_t		status;
+	uint8_t		pin_type;
+} __attribute__ ((packed)) read_pin_type_rp;
+#define READ_PIN_TYPE_RP_SIZE 2
+
+#define OCF_WRITE_PIN_TYPE		0x000A
+typedef struct {
+	uint8_t		pin_type;
+} __attribute__ ((packed)) write_pin_type_cp;
+#define WRITE_PIN_TYPE_CP_SIZE 1
+
+#define OCF_CREATE_NEW_UNIT_KEY		0x000B
+
+#define OCF_READ_STORED_LINK_KEY	0x000D
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		read_all;
+} __attribute__ ((packed)) read_stored_link_key_cp;
+#define READ_STORED_LINK_KEY_CP_SIZE 7
+typedef struct {
+	uint8_t		status;
+	uint16_t	max_keys;
+	uint16_t	num_keys;
+} __attribute__ ((packed)) read_stored_link_key_rp;
+#define READ_STORED_LINK_KEY_RP_SIZE 5
+
+#define OCF_WRITE_STORED_LINK_KEY	0x0011
+typedef struct {
+	uint8_t		num_keys;
+	/* variable length part */
+} __attribute__ ((packed)) write_stored_link_key_cp;
+#define WRITE_STORED_LINK_KEY_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+	uint8_t		num_keys;
+} __attribute__ ((packed)) write_stored_link_key_rp;
+#define READ_WRITE_LINK_KEY_RP_SIZE 2
+
+#define OCF_DELETE_STORED_LINK_KEY	0x0012
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		delete_all;
+} __attribute__ ((packed)) delete_stored_link_key_cp;
+#define DELETE_STORED_LINK_KEY_CP_SIZE 7
+typedef struct {
+	uint8_t		status;
+	uint16_t	num_keys;
+} __attribute__ ((packed)) delete_stored_link_key_rp;
+#define DELETE_STORED_LINK_KEY_RP_SIZE 3
+
+#define HCI_MAX_NAME_LENGTH		248
+
+#define OCF_CHANGE_LOCAL_NAME		0x0013
+typedef struct {
+	uint8_t		name[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) change_local_name_cp;
+#define CHANGE_LOCAL_NAME_CP_SIZE 248
+
+#define OCF_READ_LOCAL_NAME		0x0014
+typedef struct {
+	uint8_t		status;
+	uint8_t		name[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) read_local_name_rp;
+#define READ_LOCAL_NAME_RP_SIZE 249
+
+#define OCF_READ_CONN_ACCEPT_TIMEOUT	0x0015
+typedef struct {
+	uint8_t		status;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_conn_accept_timeout_rp;
+#define READ_CONN_ACCEPT_TIMEOUT_RP_SIZE 3
+
+#define OCF_WRITE_CONN_ACCEPT_TIMEOUT	0x0016
+typedef struct {
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_conn_accept_timeout_cp;
+#define WRITE_CONN_ACCEPT_TIMEOUT_CP_SIZE 2
+
+#define OCF_READ_PAGE_TIMEOUT		0x0017
+typedef struct {
+	uint8_t		status;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_page_timeout_rp;
+#define READ_PAGE_TIMEOUT_RP_SIZE 3
+
+#define OCF_WRITE_PAGE_TIMEOUT		0x0018
+typedef struct {
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_page_timeout_cp;
+#define WRITE_PAGE_TIMEOUT_CP_SIZE 2
+
+#define OCF_READ_SCAN_ENABLE		0x0019
+typedef struct {
+	uint8_t		status;
+	uint8_t		enable;
+} __attribute__ ((packed)) read_scan_enable_rp;
+#define READ_SCAN_ENABLE_RP_SIZE 2
+
+#define OCF_WRITE_SCAN_ENABLE		0x001A
+	#define SCAN_DISABLED		0x00
+	#define SCAN_INQUIRY		0x01
+	#define SCAN_PAGE		0x02
+
+#define OCF_READ_PAGE_ACTIVITY		0x001B
+typedef struct {
+	uint8_t		status;
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) read_page_activity_rp;
+#define READ_PAGE_ACTIVITY_RP_SIZE 5
+
+#define OCF_WRITE_PAGE_ACTIVITY		0x001C
+typedef struct {
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) write_page_activity_cp;
+#define WRITE_PAGE_ACTIVITY_CP_SIZE 4
+
+#define OCF_READ_INQ_ACTIVITY		0x001D
+typedef struct {
+	uint8_t		status;
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) read_inq_activity_rp;
+#define READ_INQ_ACTIVITY_RP_SIZE 5
+
+#define OCF_WRITE_INQ_ACTIVITY		0x001E
+typedef struct {
+	uint16_t	interval;
+	uint16_t	window;
+} __attribute__ ((packed)) write_inq_activity_cp;
+#define WRITE_INQ_ACTIVITY_CP_SIZE 4
+
+#define OCF_READ_AUTH_ENABLE		0x001F
+
+#define OCF_WRITE_AUTH_ENABLE		0x0020
+	#define AUTH_DISABLED		0x00
+	#define AUTH_ENABLED		0x01
+
+#define OCF_READ_ENCRYPT_MODE		0x0021
+
+#define OCF_WRITE_ENCRYPT_MODE		0x0022
+	#define ENCRYPT_DISABLED	0x00
+	#define ENCRYPT_P2P		0x01
+	#define ENCRYPT_BOTH		0x02
+
+#define OCF_READ_CLASS_OF_DEV		0x0023
+typedef struct {
+	uint8_t		status;
+	uint8_t		dev_class[3];
+} __attribute__ ((packed)) read_class_of_dev_rp;
+#define READ_CLASS_OF_DEV_RP_SIZE 4
+
+#define OCF_WRITE_CLASS_OF_DEV		0x0024
+typedef struct {
+	uint8_t		dev_class[3];
+} __attribute__ ((packed)) write_class_of_dev_cp;
+#define WRITE_CLASS_OF_DEV_CP_SIZE 3
+
+#define OCF_READ_VOICE_SETTING		0x0025
+typedef struct {
+	uint8_t		status;
+	uint16_t	voice_setting;
+} __attribute__ ((packed)) read_voice_setting_rp;
+#define READ_VOICE_SETTING_RP_SIZE 3
+
+#define OCF_WRITE_VOICE_SETTING		0x0026
+typedef struct {
+	uint16_t	voice_setting;
+} __attribute__ ((packed)) write_voice_setting_cp;
+#define WRITE_VOICE_SETTING_CP_SIZE 2
+
+#define OCF_READ_AUTOMATIC_FLUSH_TIMEOUT	0x0027
+
+#define OCF_WRITE_AUTOMATIC_FLUSH_TIMEOUT	0x0028
+
+#define OCF_READ_NUM_BROADCAST_RETRANS	0x0029
+
+#define OCF_WRITE_NUM_BROADCAST_RETRANS	0x002A
+
+#define OCF_READ_HOLD_MODE_ACTIVITY	0x002B
+
+#define OCF_WRITE_HOLD_MODE_ACTIVITY	0x002C
+
+#define OCF_READ_TRANSMIT_POWER_LEVEL	0x002D
+typedef struct {
+	uint16_t	handle;
+	uint8_t		type;
+} __attribute__ ((packed)) read_transmit_power_level_cp;
+#define READ_TRANSMIT_POWER_LEVEL_CP_SIZE 3
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	int8_t		level;
+} __attribute__ ((packed)) read_transmit_power_level_rp;
+#define READ_TRANSMIT_POWER_LEVEL_RP_SIZE 4
+
+#define OCF_READ_SYNC_FLOW_ENABLE	0x002E
+
+#define OCF_WRITE_SYNC_FLOW_ENABLE	0x002F
+
+#define OCF_SET_CONTROLLER_TO_HOST_FC	0x0031
+
+#define OCF_HOST_BUFFER_SIZE		0x0033
+typedef struct {
+	uint16_t	acl_mtu;
+	uint8_t		sco_mtu;
+	uint16_t	acl_max_pkt;
+	uint16_t	sco_max_pkt;
+} __attribute__ ((packed)) host_buffer_size_cp;
+#define HOST_BUFFER_SIZE_CP_SIZE 7
+
+#define OCF_HOST_NUM_COMP_PKTS		0x0035
+typedef struct {
+	uint8_t		num_hndl;
+	/* variable length part */
+} __attribute__ ((packed)) host_num_comp_pkts_cp;
+#define HOST_NUM_COMP_PKTS_CP_SIZE 1
+
+#define OCF_READ_LINK_SUPERVISION_TIMEOUT	0x0036
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_link_supervision_timeout_rp;
+#define READ_LINK_SUPERVISION_TIMEOUT_RP_SIZE 5
+
+#define OCF_WRITE_LINK_SUPERVISION_TIMEOUT	0x0037
+typedef struct {
+	uint16_t	handle;
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_link_supervision_timeout_cp;
+#define WRITE_LINK_SUPERVISION_TIMEOUT_CP_SIZE 4
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) write_link_supervision_timeout_rp;
+#define WRITE_LINK_SUPERVISION_TIMEOUT_RP_SIZE 3
+
+#define OCF_READ_NUM_SUPPORTED_IAC	0x0038
+
+#define MAX_IAC_LAP 0x40
+#define OCF_READ_CURRENT_IAC_LAP	0x0039
+typedef struct {
+	uint8_t		status;
+	uint8_t		num_current_iac;
+	uint8_t		lap[MAX_IAC_LAP][3];
+} __attribute__ ((packed)) read_current_iac_lap_rp;
+#define READ_CURRENT_IAC_LAP_RP_SIZE 2+3*MAX_IAC_LAP
+
+#define OCF_WRITE_CURRENT_IAC_LAP	0x003A
+typedef struct {
+	uint8_t		num_current_iac;
+	uint8_t		lap[MAX_IAC_LAP][3];
+} __attribute__ ((packed)) write_current_iac_lap_cp;
+#define WRITE_CURRENT_IAC_LAP_CP_SIZE 1+3*MAX_IAC_LAP
+
+#define OCF_READ_PAGE_SCAN_PERIOD_MODE	0x003B
+
+#define OCF_WRITE_PAGE_SCAN_PERIOD_MODE	0x003C
+
+#define OCF_READ_PAGE_SCAN_MODE		0x003D
+
+#define OCF_WRITE_PAGE_SCAN_MODE	0x003E
+
+#define OCF_SET_AFH_CLASSIFICATION	0x003F
+typedef struct {
+	uint8_t		map[10];
+} __attribute__ ((packed)) set_afh_classification_cp;
+#define SET_AFH_CLASSIFICATION_CP_SIZE 10
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) set_afh_classification_rp;
+#define SET_AFH_CLASSIFICATION_RP_SIZE 1
+
+#define OCF_READ_INQUIRY_SCAN_TYPE	0x0042
+typedef struct {
+	uint8_t		status;
+	uint8_t		type;
+} __attribute__ ((packed)) read_inquiry_scan_type_rp;
+#define READ_INQUIRY_SCAN_TYPE_RP_SIZE 2
+
+#define OCF_WRITE_INQUIRY_SCAN_TYPE	0x0043
+typedef struct {
+	uint8_t		type;
+} __attribute__ ((packed)) write_inquiry_scan_type_cp;
+#define WRITE_INQUIRY_SCAN_TYPE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_inquiry_scan_type_rp;
+#define WRITE_INQUIRY_SCAN_TYPE_RP_SIZE 1
+
+#define OCF_READ_INQUIRY_MODE		0x0044
+typedef struct {
+	uint8_t		status;
+	uint8_t		mode;
+} __attribute__ ((packed)) read_inquiry_mode_rp;
+#define READ_INQUIRY_MODE_RP_SIZE 2
+
+#define OCF_WRITE_INQUIRY_MODE		0x0045
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_inquiry_mode_cp;
+#define WRITE_INQUIRY_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_inquiry_mode_rp;
+#define WRITE_INQUIRY_MODE_RP_SIZE 1
+
+#define OCF_READ_PAGE_SCAN_TYPE		0x0046
+
+#define OCF_WRITE_PAGE_SCAN_TYPE	0x0047
+	#define PAGE_SCAN_TYPE_STANDARD		0x00
+	#define PAGE_SCAN_TYPE_INTERLACED	0x01
+
+#define OCF_READ_AFH_MODE		0x0048
+typedef struct {
+	uint8_t		status;
+	uint8_t		mode;
+} __attribute__ ((packed)) read_afh_mode_rp;
+#define READ_AFH_MODE_RP_SIZE 2
+
+#define OCF_WRITE_AFH_MODE		0x0049
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_afh_mode_cp;
+#define WRITE_AFH_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_afh_mode_rp;
+#define WRITE_AFH_MODE_RP_SIZE 1
+
+#define HCI_MAX_EIR_LENGTH		240
+
+#define OCF_READ_EXT_INQUIRY_RESPONSE	0x0051
+typedef struct {
+	uint8_t		status;
+	uint8_t		fec;
+	uint8_t		data[HCI_MAX_EIR_LENGTH];
+} __attribute__ ((packed)) read_ext_inquiry_response_rp;
+#define READ_EXT_INQUIRY_RESPONSE_RP_SIZE 242
+
+#define OCF_WRITE_EXT_INQUIRY_RESPONSE	0x0052
+typedef struct {
+	uint8_t		fec;
+	uint8_t		data[HCI_MAX_EIR_LENGTH];
+} __attribute__ ((packed)) write_ext_inquiry_response_cp;
+#define WRITE_EXT_INQUIRY_RESPONSE_CP_SIZE 241
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_ext_inquiry_response_rp;
+#define WRITE_EXT_INQUIRY_RESPONSE_RP_SIZE 1
+
+#define OCF_REFRESH_ENCRYPTION_KEY	0x0053
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) refresh_encryption_key_cp;
+#define REFRESH_ENCRYPTION_KEY_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) refresh_encryption_key_rp;
+#define REFRESH_ENCRYPTION_KEY_RP_SIZE 1
+
+#define OCF_READ_SIMPLE_PAIRING_MODE	0x0055
+typedef struct {
+	uint8_t		status;
+	uint8_t		mode;
+} __attribute__ ((packed)) read_simple_pairing_mode_rp;
+#define READ_SIMPLE_PAIRING_MODE_RP_SIZE 2
+
+#define OCF_WRITE_SIMPLE_PAIRING_MODE	0x0056
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_simple_pairing_mode_cp;
+#define WRITE_SIMPLE_PAIRING_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_simple_pairing_mode_rp;
+#define WRITE_SIMPLE_PAIRING_MODE_RP_SIZE 1
+
+#define OCF_READ_LOCAL_OOB_DATA		0x0057
+typedef struct {
+	uint8_t		status;
+	uint8_t		hash[16];
+	uint8_t		randomizer[16];
+} __attribute__ ((packed)) read_local_oob_data_rp;
+#define READ_LOCAL_OOB_DATA_RP_SIZE 33
+
+#define OCF_READ_INQ_RESPONSE_TX_POWER_LEVEL	0x0058
+typedef struct {
+	uint8_t		status;
+	int8_t		level;
+} __attribute__ ((packed)) read_inq_response_tx_power_level_rp;
+#define READ_INQ_RESPONSE_TX_POWER_LEVEL_RP_SIZE 2
+
+#define OCF_READ_INQUIRY_TRANSMIT_POWER_LEVEL	0x0058
+typedef struct {
+	uint8_t		status;
+	int8_t		level;
+} __attribute__ ((packed)) read_inquiry_transmit_power_level_rp;
+#define READ_INQUIRY_TRANSMIT_POWER_LEVEL_RP_SIZE 2
+
+#define OCF_WRITE_INQUIRY_TRANSMIT_POWER_LEVEL	0x0059
+typedef struct {
+	int8_t		level;
+} __attribute__ ((packed)) write_inquiry_transmit_power_level_cp;
+#define WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_inquiry_transmit_power_level_rp;
+#define WRITE_INQUIRY_TRANSMIT_POWER_LEVEL_RP_SIZE 1
+
+#define OCF_READ_DEFAULT_ERROR_DATA_REPORTING	0x005A
+typedef struct {
+	uint8_t		status;
+	uint8_t		reporting;
+} __attribute__ ((packed)) read_default_error_data_reporting_rp;
+#define READ_DEFAULT_ERROR_DATA_REPORTING_RP_SIZE 2
+
+#define OCF_WRITE_DEFAULT_ERROR_DATA_REPORTING	0x005B
+typedef struct {
+	uint8_t		reporting;
+} __attribute__ ((packed)) write_default_error_data_reporting_cp;
+#define WRITE_DEFAULT_ERROR_DATA_REPORTING_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_default_error_data_reporting_rp;
+#define WRITE_DEFAULT_ERROR_DATA_REPORTING_RP_SIZE 1
+
+#define OCF_ENHANCED_FLUSH		0x005F
+typedef struct {
+	uint16_t	handle;
+	uint8_t		type;
+} __attribute__ ((packed)) enhanced_flush_cp;
+#define ENHANCED_FLUSH_CP_SIZE 3
+
+#define OCF_SEND_KEYPRESS_NOTIFY	0x0060
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		type;
+} __attribute__ ((packed)) send_keypress_notify_cp;
+#define SEND_KEYPRESS_NOTIFY_CP_SIZE 7
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) send_keypress_notify_rp;
+#define SEND_KEYPRESS_NOTIFY_RP_SIZE 1
+
+#define OCF_READ_LOGICAL_LINK_ACCEPT_TIMEOUT	 0x0061
+typedef struct {
+	uint8_t		status;
+	uint16_t	timeout;
+} __attribute__ ((packed)) read_log_link_accept_timeout_rp;
+#define READ_LOGICAL_LINK_ACCEPT_TIMEOUT_RP_SIZE 3
+
+#define OCF_WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT	0x0062
+typedef struct {
+	uint16_t	timeout;
+} __attribute__ ((packed)) write_log_link_accept_timeout_cp;
+#define WRITE_LOGICAL_LINK_ACCEPT_TIMEOUT_CP_SIZE 2
+
+#define OCF_SET_EVENT_MASK_PAGE_2	0x0063
+
+#define OCF_READ_LOCATION_DATA		0x0064
+
+#define OCF_WRITE_LOCATION_DATA	0x0065
+
+#define OCF_READ_FLOW_CONTROL_MODE	0x0066
+
+#define OCF_WRITE_FLOW_CONTROL_MODE	0x0067
+
+#define OCF_READ_ENHANCED_TRANSMIT_POWER_LEVEL	0x0068
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	int8_t		level_gfsk;
+	int8_t		level_dqpsk;
+	int8_t		level_8dpsk;
+} __attribute__ ((packed)) read_enhanced_transmit_power_level_rp;
+#define READ_ENHANCED_TRANSMIT_POWER_LEVEL_RP_SIZE 6
+
+#define OCF_READ_BEST_EFFORT_FLUSH_TIMEOUT	0x0069
+typedef struct {
+	uint8_t		status;
+	uint32_t	timeout;
+} __attribute__ ((packed)) read_best_effort_flush_timeout_rp;
+#define READ_BEST_EFFORT_FLUSH_TIMEOUT_RP_SIZE 5
+
+#define OCF_WRITE_BEST_EFFORT_FLUSH_TIMEOUT	0x006A
+typedef struct {
+	uint16_t	handle;
+	uint32_t	timeout;
+} __attribute__ ((packed)) write_best_effort_flush_timeout_cp;
+#define WRITE_BEST_EFFORT_FLUSH_TIMEOUT_CP_SIZE 6
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_best_effort_flush_timeout_rp;
+#define WRITE_BEST_EFFORT_FLUSH_TIMEOUT_RP_SIZE 1
+
+#define OCF_READ_LE_HOST_SUPPORTED	0x006C
+typedef struct {
+	uint8_t		status;
+	uint8_t		le;
+	uint8_t		simul;
+} __attribute__ ((packed)) read_le_host_supported_rp;
+#define READ_LE_HOST_SUPPORTED_RP_SIZE 3
+
+#define OCF_WRITE_LE_HOST_SUPPORTED	0x006D
+typedef struct {
+	uint8_t		le;
+	uint8_t		simul;
+} __attribute__ ((packed)) write_le_host_supported_cp;
+#define WRITE_LE_HOST_SUPPORTED_CP_SIZE 2
+
+/* Informational Parameters */
+#define OGF_INFO_PARAM		0x04
+
+#define OCF_READ_LOCAL_VERSION		0x0001
+typedef struct {
+	uint8_t		status;
+	uint8_t		hci_ver;
+	uint16_t	hci_rev;
+	uint8_t		lmp_ver;
+	uint16_t	manufacturer;
+	uint16_t	lmp_subver;
+} __attribute__ ((packed)) read_local_version_rp;
+#define READ_LOCAL_VERSION_RP_SIZE 9
+
+#define OCF_READ_LOCAL_COMMANDS		0x0002
+typedef struct {
+	uint8_t		status;
+	uint8_t		commands[64];
+} __attribute__ ((packed)) read_local_commands_rp;
+#define READ_LOCAL_COMMANDS_RP_SIZE 65
+
+#define OCF_READ_LOCAL_FEATURES		0x0003
+typedef struct {
+	uint8_t		status;
+	uint8_t		features[8];
+} __attribute__ ((packed)) read_local_features_rp;
+#define READ_LOCAL_FEATURES_RP_SIZE 9
+
+#define OCF_READ_LOCAL_EXT_FEATURES	0x0004
+typedef struct {
+	uint8_t		page_num;
+} __attribute__ ((packed)) read_local_ext_features_cp;
+#define READ_LOCAL_EXT_FEATURES_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+	uint8_t		page_num;
+	uint8_t		max_page_num;
+	uint8_t		features[8];
+} __attribute__ ((packed)) read_local_ext_features_rp;
+#define READ_LOCAL_EXT_FEATURES_RP_SIZE 11
+
+#define OCF_READ_BUFFER_SIZE		0x0005
+typedef struct {
+	uint8_t		status;
+	uint16_t	acl_mtu;
+	uint8_t		sco_mtu;
+	uint16_t	acl_max_pkt;
+	uint16_t	sco_max_pkt;
+} __attribute__ ((packed)) read_buffer_size_rp;
+#define READ_BUFFER_SIZE_RP_SIZE 8
+
+#define OCF_READ_COUNTRY_CODE		0x0007
+
+#define OCF_READ_BD_ADDR		0x0009
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) read_bd_addr_rp;
+#define READ_BD_ADDR_RP_SIZE 7
+
+/* Status params */
+#define OGF_STATUS_PARAM	0x05
+
+#define OCF_READ_FAILED_CONTACT_COUNTER		0x0001
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		counter;
+} __attribute__ ((packed)) read_failed_contact_counter_rp;
+#define READ_FAILED_CONTACT_COUNTER_RP_SIZE 4
+
+#define OCF_RESET_FAILED_CONTACT_COUNTER	0x0002
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) reset_failed_contact_counter_rp;
+#define RESET_FAILED_CONTACT_COUNTER_RP_SIZE 4
+
+#define OCF_READ_LINK_QUALITY		0x0003
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		link_quality;
+} __attribute__ ((packed)) read_link_quality_rp;
+#define READ_LINK_QUALITY_RP_SIZE 4
+
+#define OCF_READ_RSSI			0x0005
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	int8_t		rssi;
+} __attribute__ ((packed)) read_rssi_rp;
+#define READ_RSSI_RP_SIZE 4
+
+#define OCF_READ_AFH_MAP		0x0006
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		mode;
+	uint8_t		map[10];
+} __attribute__ ((packed)) read_afh_map_rp;
+#define READ_AFH_MAP_RP_SIZE 14
+
+#define OCF_READ_CLOCK			0x0007
+typedef struct {
+	uint16_t	handle;
+	uint8_t		which_clock;
+} __attribute__ ((packed)) read_clock_cp;
+#define READ_CLOCK_CP_SIZE 3
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint32_t	clock;
+	uint16_t	accuracy;
+} __attribute__ ((packed)) read_clock_rp;
+#define READ_CLOCK_RP_SIZE 9
+
+#define OCF_READ_LOCAL_AMP_INFO	0x0009
+typedef struct {
+	uint8_t		status;
+	uint8_t		amp_status;
+	uint32_t	total_bandwidth;
+	uint32_t	max_guaranteed_bandwidth;
+	uint32_t	min_latency;
+	uint32_t	max_pdu_size;
+	uint8_t		controller_type;
+	uint16_t	pal_caps;
+	uint16_t	max_amp_assoc_length;
+	uint32_t	max_flush_timeout;
+	uint32_t	best_effort_flush_timeout;
+} __attribute__ ((packed)) read_local_amp_info_rp;
+#define READ_LOCAL_AMP_INFO_RP_SIZE 31
+
+#define OCF_READ_LOCAL_AMP_ASSOC	0x000A
+typedef struct {
+	uint8_t		handle;
+	uint16_t	len_so_far;
+	uint16_t	max_len;
+} __attribute__ ((packed)) read_local_amp_assoc_cp;
+
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+	uint16_t	rem_len;
+	uint8_t		frag[0];
+} __attribute__ ((packed)) read_local_amp_assoc_rp;
+
+#define OCF_WRITE_REMOTE_AMP_ASSOC	0x000B
+typedef struct {
+	uint8_t		handle;
+	uint16_t	length_so_far;
+	uint16_t	assoc_length;
+	uint8_t		fragment[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) write_remote_amp_assoc_cp;
+#define WRITE_REMOTE_AMP_ASSOC_CP_SIZE 253
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+} __attribute__ ((packed)) write_remote_amp_assoc_rp;
+#define WRITE_REMOTE_AMP_ASSOC_RP_SIZE 2
+
+/* Testing commands */
+#define OGF_TESTING_CMD		0x3e
+
+#define OCF_READ_LOOPBACK_MODE			0x0001
+
+#define OCF_WRITE_LOOPBACK_MODE			0x0002
+
+#define OCF_ENABLE_DEVICE_UNDER_TEST_MODE	0x0003
+
+#define OCF_WRITE_SIMPLE_PAIRING_DEBUG_MODE	0x0004
+typedef struct {
+	uint8_t		mode;
+} __attribute__ ((packed)) write_simple_pairing_debug_mode_cp;
+#define WRITE_SIMPLE_PAIRING_DEBUG_MODE_CP_SIZE 1
+typedef struct {
+	uint8_t		status;
+} __attribute__ ((packed)) write_simple_pairing_debug_mode_rp;
+#define WRITE_SIMPLE_PAIRING_DEBUG_MODE_RP_SIZE 1
+
+/* LE commands */
+#define OGF_LE_CTL		0x08
+
+#define OCF_LE_SET_EVENT_MASK			0x0001
+typedef struct {
+	uint8_t		mask[8];
+} __attribute__ ((packed)) le_set_event_mask_cp;
+#define LE_SET_EVENT_MASK_CP_SIZE 8
+
+#define OCF_LE_READ_BUFFER_SIZE			0x0002
+typedef struct {
+	uint8_t		status;
+	uint16_t	pkt_len;
+	uint8_t		max_pkt;
+} __attribute__ ((packed)) le_read_buffer_size_rp;
+#define LE_READ_BUFFER_SIZE_RP_SIZE 4
+
+#define OCF_LE_READ_LOCAL_SUPPORTED_FEATURES	0x0003
+typedef struct {
+	uint8_t		status;
+	uint8_t		features[8];
+} __attribute__ ((packed)) le_read_local_supported_features_rp;
+#define LE_READ_LOCAL_SUPPORTED_FEATURES_RP_SIZE 9
+
+#define OCF_LE_SET_RANDOM_ADDRESS		0x0005
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) le_set_random_address_cp;
+#define LE_SET_RANDOM_ADDRESS_CP_SIZE 6
+
+#define OCF_LE_SET_ADVERTISING_PARAMETERS	0x0006
+typedef struct {
+	uint16_t	min_interval;
+	uint16_t	max_interval;
+	uint8_t		advtype;
+	uint8_t		own_bdaddr_type;
+	uint8_t		direct_bdaddr_type;
+	bdaddr_t	direct_bdaddr;
+	uint8_t		chan_map;
+	uint8_t		filter;
+} __attribute__ ((packed)) le_set_advertising_parameters_cp;
+#define LE_SET_ADVERTISING_PARAMETERS_CP_SIZE 15
+
+#define OCF_LE_READ_ADVERTISING_CHANNEL_TX_POWER	0x0007
+typedef struct {
+	uint8_t		status;
+	uint8_t		level;
+} __attribute__ ((packed)) le_read_advertising_channel_tx_power_rp;
+#define LE_READ_ADVERTISING_CHANNEL_TX_POWER_RP_SIZE 2
+
+#define OCF_LE_SET_ADVERTISING_DATA		0x0008
+typedef struct {
+	uint8_t		length;
+	uint8_t		data[31];
+} __attribute__ ((packed)) le_set_advertising_data_cp;
+#define LE_SET_ADVERTISING_DATA_CP_SIZE 32
+
+#define OCF_LE_SET_SCAN_RESPONSE_DATA		0x0009
+typedef struct {
+	uint8_t		length;
+	uint8_t		data[31];
+} __attribute__ ((packed)) le_set_scan_response_data_cp;
+#define LE_SET_SCAN_RESPONSE_DATA_CP_SIZE 32
+
+#define OCF_LE_SET_ADVERTISE_ENABLE		0x000A
+typedef struct {
+	uint8_t		enable;
+} __attribute__ ((packed)) le_set_advertise_enable_cp;
+#define LE_SET_ADVERTISE_ENABLE_CP_SIZE 1
+
+#define OCF_LE_SET_SCAN_PARAMETERS		0x000B
+typedef struct {
+	uint8_t		type;
+	uint16_t	interval;
+	uint16_t	window;
+	uint8_t		own_bdaddr_type;
+	uint8_t		filter;
+} __attribute__ ((packed)) le_set_scan_parameters_cp;
+#define LE_SET_SCAN_PARAMETERS_CP_SIZE 7
+
+#define OCF_LE_SET_SCAN_ENABLE			0x000C
+typedef struct {
+	uint8_t		enable;
+	uint8_t		filter_dup;
+} __attribute__ ((packed)) le_set_scan_enable_cp;
+#define LE_SET_SCAN_ENABLE_CP_SIZE 2
+
+#define OCF_LE_CREATE_CONN			0x000D
+typedef struct {
+	uint16_t	interval;
+	uint16_t	window;
+	uint8_t		initiator_filter;
+	uint8_t		peer_bdaddr_type;
+	bdaddr_t	peer_bdaddr;
+	uint8_t		own_bdaddr_type;
+	uint16_t	min_interval;
+	uint16_t	max_interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+	uint16_t	min_ce_length;
+	uint16_t	max_ce_length;
+} __attribute__ ((packed)) le_create_connection_cp;
+#define LE_CREATE_CONN_CP_SIZE 25
+
+#define OCF_LE_CREATE_CONN_CANCEL		0x000E
+
+#define OCF_LE_READ_WHITE_LIST_SIZE		0x000F
+typedef struct {
+	uint8_t		status;
+	uint8_t		size;
+} __attribute__ ((packed)) le_read_white_list_size_rp;
+#define LE_READ_WHITE_LIST_SIZE_RP_SIZE 2
+
+#define OCF_LE_CLEAR_WHITE_LIST			0x0010
+
+#define OCF_LE_ADD_DEVICE_TO_WHITE_LIST		0x0011
+typedef struct {
+	uint8_t		bdaddr_type;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) le_add_device_to_white_list_cp;
+#define LE_ADD_DEVICE_TO_WHITE_LIST_CP_SIZE 7
+
+#define OCF_LE_REMOVE_DEVICE_FROM_WHITE_LIST	0x0012
+typedef struct {
+	uint8_t		bdaddr_type;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) le_remove_device_from_white_list_cp;
+#define LE_REMOVE_DEVICE_FROM_WHITE_LIST_CP_SIZE 7
+
+#define OCF_LE_CONN_UPDATE			0x0013
+typedef struct {
+	uint16_t	handle;
+	uint16_t	min_interval;
+	uint16_t	max_interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+	uint16_t	min_ce_length;
+	uint16_t	max_ce_length;
+} __attribute__ ((packed)) le_connection_update_cp;
+#define LE_CONN_UPDATE_CP_SIZE 14
+
+#define OCF_LE_SET_HOST_CHANNEL_CLASSIFICATION	0x0014
+typedef struct {
+	uint8_t		map[5];
+} __attribute__ ((packed)) le_set_host_channel_classification_cp;
+#define LE_SET_HOST_CHANNEL_CLASSIFICATION_CP_SIZE 5
+
+#define OCF_LE_READ_CHANNEL_MAP			0x0015
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) le_read_channel_map_cp;
+#define LE_READ_CHANNEL_MAP_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		map[5];
+} __attribute__ ((packed)) le_read_channel_map_rp;
+#define LE_READ_CHANNEL_MAP_RP_SIZE 8
+
+#define OCF_LE_READ_REMOTE_USED_FEATURES	0x0016
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) le_read_remote_used_features_cp;
+#define LE_READ_REMOTE_USED_FEATURES_CP_SIZE 2
+
+#define OCF_LE_ENCRYPT				0x0017
+typedef struct {
+	uint8_t		key[16];
+	uint8_t		plaintext[16];
+} __attribute__ ((packed)) le_encrypt_cp;
+#define LE_ENCRYPT_CP_SIZE 32
+typedef struct {
+	uint8_t		status;
+	uint8_t		data[16];
+} __attribute__ ((packed)) le_encrypt_rp;
+#define LE_ENCRYPT_RP_SIZE 17
+
+#define OCF_LE_RAND				0x0018
+typedef struct {
+	uint8_t		status;
+	uint64_t	random;
+} __attribute__ ((packed)) le_rand_rp;
+#define LE_RAND_RP_SIZE 9
+
+#define OCF_LE_START_ENCRYPTION			0x0019
+typedef struct {
+	uint16_t	handle;
+	uint64_t	random;
+	uint16_t	diversifier;
+	uint8_t		key[16];
+} __attribute__ ((packed)) le_start_encryption_cp;
+#define LE_START_ENCRYPTION_CP_SIZE 28
+
+#define OCF_LE_LTK_REPLY			0x001A
+typedef struct {
+	uint16_t	handle;
+	uint8_t		key[16];
+} __attribute__ ((packed)) le_ltk_reply_cp;
+#define LE_LTK_REPLY_CP_SIZE 18
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) le_ltk_reply_rp;
+#define LE_LTK_REPLY_RP_SIZE 3
+
+#define OCF_LE_LTK_NEG_REPLY			0x001B
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) le_ltk_neg_reply_cp;
+#define LE_LTK_NEG_REPLY_CP_SIZE 2
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) le_ltk_neg_reply_rp;
+#define LE_LTK_NEG_REPLY_RP_SIZE 3
+
+#define OCF_LE_READ_SUPPORTED_STATES		0x001C
+typedef struct {
+	uint8_t		status;
+	uint64_t	states;
+} __attribute__ ((packed)) le_read_supported_states_rp;
+#define LE_READ_SUPPORTED_STATES_RP_SIZE 9
+
+#define OCF_LE_RECEIVER_TEST			0x001D
+typedef struct {
+	uint8_t		frequency;
+} __attribute__ ((packed)) le_receiver_test_cp;
+#define LE_RECEIVER_TEST_CP_SIZE 1
+
+#define OCF_LE_TRANSMITTER_TEST			0x001E
+typedef struct {
+	uint8_t		frequency;
+	uint8_t		length;
+	uint8_t		payload;
+} __attribute__ ((packed)) le_transmitter_test_cp;
+#define LE_TRANSMITTER_TEST_CP_SIZE 3
+
+#define OCF_LE_TEST_END				0x001F
+typedef struct {
+	uint8_t		status;
+	uint16_t	num_pkts;
+} __attribute__ ((packed)) le_test_end_rp;
+#define LE_TEST_END_RP_SIZE 3
+
+/* Vendor specific commands */
+#define OGF_VENDOR_CMD		0x3f
+
+/* ---- HCI Events ---- */
+
+#define EVT_INQUIRY_COMPLETE		0x01
+
+#define EVT_INQUIRY_RESULT		0x02
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		pscan_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+} __attribute__ ((packed)) inquiry_info;
+#define INQUIRY_INFO_SIZE 14
+
+#define EVT_CONN_COMPLETE		0x03
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	bdaddr_t	bdaddr;
+	uint8_t		link_type;
+	uint8_t		encr_mode;
+} __attribute__ ((packed)) evt_conn_complete;
+#define EVT_CONN_COMPLETE_SIZE 13
+
+#define EVT_CONN_REQUEST		0x04
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		dev_class[3];
+	uint8_t		link_type;
+} __attribute__ ((packed)) evt_conn_request;
+#define EVT_CONN_REQUEST_SIZE 10
+
+#define EVT_DISCONN_COMPLETE		0x05
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) evt_disconn_complete;
+#define EVT_DISCONN_COMPLETE_SIZE 4
+
+#define EVT_AUTH_COMPLETE		0x06
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_auth_complete;
+#define EVT_AUTH_COMPLETE_SIZE 3
+
+#define EVT_REMOTE_NAME_REQ_COMPLETE	0x07
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+	uint8_t		name[HCI_MAX_NAME_LENGTH];
+} __attribute__ ((packed)) evt_remote_name_req_complete;
+#define EVT_REMOTE_NAME_REQ_COMPLETE_SIZE 255
+
+#define EVT_ENCRYPT_CHANGE		0x08
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		encrypt;
+} __attribute__ ((packed)) evt_encrypt_change;
+#define EVT_ENCRYPT_CHANGE_SIZE 5
+
+#define EVT_CHANGE_CONN_LINK_KEY_COMPLETE	0x09
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+}  __attribute__ ((packed)) evt_change_conn_link_key_complete;
+#define EVT_CHANGE_CONN_LINK_KEY_COMPLETE_SIZE 3
+
+#define EVT_MASTER_LINK_KEY_COMPLETE		0x0A
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		key_flag;
+} __attribute__ ((packed)) evt_master_link_key_complete;
+#define EVT_MASTER_LINK_KEY_COMPLETE_SIZE 4
+
+#define EVT_READ_REMOTE_FEATURES_COMPLETE	0x0B
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_read_remote_features_complete;
+#define EVT_READ_REMOTE_FEATURES_COMPLETE_SIZE 11
+
+#define EVT_READ_REMOTE_VERSION_COMPLETE	0x0C
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		lmp_ver;
+	uint16_t	manufacturer;
+	uint16_t	lmp_subver;
+} __attribute__ ((packed)) evt_read_remote_version_complete;
+#define EVT_READ_REMOTE_VERSION_COMPLETE_SIZE 8
+
+#define EVT_QOS_SETUP_COMPLETE		0x0D
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		flags;			/* Reserved */
+	hci_qos		qos;
+} __attribute__ ((packed)) evt_qos_setup_complete;
+#define EVT_QOS_SETUP_COMPLETE_SIZE (4 + HCI_QOS_CP_SIZE)
+
+#define EVT_CMD_COMPLETE 		0x0E
+typedef struct {
+	uint8_t		ncmd;
+	uint16_t	opcode;
+} __attribute__ ((packed)) evt_cmd_complete;
+#define EVT_CMD_COMPLETE_SIZE 3
+
+#define EVT_CMD_STATUS 			0x0F
+typedef struct {
+	uint8_t		status;
+	uint8_t		ncmd;
+	uint16_t	opcode;
+} __attribute__ ((packed)) evt_cmd_status;
+#define EVT_CMD_STATUS_SIZE 4
+
+#define EVT_HARDWARE_ERROR		0x10
+typedef struct {
+	uint8_t		code;
+} __attribute__ ((packed)) evt_hardware_error;
+#define EVT_HARDWARE_ERROR_SIZE 1
+
+#define EVT_FLUSH_OCCURRED		0x11
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_flush_occured;
+#define EVT_FLUSH_OCCURRED_SIZE 2
+
+#define EVT_ROLE_CHANGE			0x12
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+	uint8_t		role;
+} __attribute__ ((packed)) evt_role_change;
+#define EVT_ROLE_CHANGE_SIZE 8
+
+#define EVT_NUM_COMP_PKTS		0x13
+typedef struct {
+	uint8_t		num_hndl;
+	/* variable length part */
+} __attribute__ ((packed)) evt_num_comp_pkts;
+#define EVT_NUM_COMP_PKTS_SIZE 1
+
+#define EVT_MODE_CHANGE			0x14
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		mode;
+	uint16_t	interval;
+} __attribute__ ((packed)) evt_mode_change;
+#define EVT_MODE_CHANGE_SIZE 6
+
+#define EVT_RETURN_LINK_KEYS		0x15
+typedef struct {
+	uint8_t		num_keys;
+	/* variable length part */
+} __attribute__ ((packed)) evt_return_link_keys;
+#define EVT_RETURN_LINK_KEYS_SIZE 1
+
+#define EVT_PIN_CODE_REQ		0x16
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_pin_code_req;
+#define EVT_PIN_CODE_REQ_SIZE 6
+
+#define EVT_LINK_KEY_REQ		0x17
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_link_key_req;
+#define EVT_LINK_KEY_REQ_SIZE 6
+
+#define EVT_LINK_KEY_NOTIFY		0x18
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		link_key[16];
+	uint8_t		key_type;
+} __attribute__ ((packed)) evt_link_key_notify;
+#define EVT_LINK_KEY_NOTIFY_SIZE 23
+
+#define EVT_LOOPBACK_COMMAND		0x19
+
+#define EVT_DATA_BUFFER_OVERFLOW	0x1A
+typedef struct {
+	uint8_t		link_type;
+} __attribute__ ((packed)) evt_data_buffer_overflow;
+#define EVT_DATA_BUFFER_OVERFLOW_SIZE 1
+
+#define EVT_MAX_SLOTS_CHANGE		0x1B
+typedef struct {
+	uint16_t	handle;
+	uint8_t		max_slots;
+} __attribute__ ((packed)) evt_max_slots_change;
+#define EVT_MAX_SLOTS_CHANGE_SIZE 3
+
+#define EVT_READ_CLOCK_OFFSET_COMPLETE	0x1C
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	clock_offset;
+} __attribute__ ((packed)) evt_read_clock_offset_complete;
+#define EVT_READ_CLOCK_OFFSET_COMPLETE_SIZE 5
+
+#define EVT_CONN_PTYPE_CHANGED		0x1D
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	ptype;
+} __attribute__ ((packed)) evt_conn_ptype_changed;
+#define EVT_CONN_PTYPE_CHANGED_SIZE 5
+
+#define EVT_QOS_VIOLATION		0x1E
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_qos_violation;
+#define EVT_QOS_VIOLATION_SIZE 2
+
+#define EVT_PSCAN_REP_MODE_CHANGE	0x20
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+} __attribute__ ((packed)) evt_pscan_rep_mode_change;
+#define EVT_PSCAN_REP_MODE_CHANGE_SIZE 7
+
+#define EVT_FLOW_SPEC_COMPLETE		0x21
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		flags;
+	uint8_t		direction;
+	hci_qos		qos;
+} __attribute__ ((packed)) evt_flow_spec_complete;
+#define EVT_FLOW_SPEC_COMPLETE_SIZE (5 + HCI_QOS_CP_SIZE)
+
+#define EVT_INQUIRY_RESULT_WITH_RSSI	0x22
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+	int8_t		rssi;
+} __attribute__ ((packed)) inquiry_info_with_rssi;
+#define INQUIRY_INFO_WITH_RSSI_SIZE 14
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		pscan_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+	int8_t		rssi;
+} __attribute__ ((packed)) inquiry_info_with_rssi_and_pscan_mode;
+#define INQUIRY_INFO_WITH_RSSI_AND_PSCAN_MODE_SIZE 15
+
+#define EVT_READ_REMOTE_EXT_FEATURES_COMPLETE	0x23
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		page_num;
+	uint8_t		max_page_num;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_read_remote_ext_features_complete;
+#define EVT_READ_REMOTE_EXT_FEATURES_COMPLETE_SIZE 13
+
+#define EVT_SYNC_CONN_COMPLETE		0x2C
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	bdaddr_t	bdaddr;
+	uint8_t		link_type;
+	uint8_t		trans_interval;
+	uint8_t		retrans_window;
+	uint16_t	rx_pkt_len;
+	uint16_t	tx_pkt_len;
+	uint8_t		air_mode;
+} __attribute__ ((packed)) evt_sync_conn_complete;
+#define EVT_SYNC_CONN_COMPLETE_SIZE 17
+
+#define EVT_SYNC_CONN_CHANGED		0x2D
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		trans_interval;
+	uint8_t		retrans_window;
+	uint16_t	rx_pkt_len;
+	uint16_t	tx_pkt_len;
+} __attribute__ ((packed)) evt_sync_conn_changed;
+#define EVT_SYNC_CONN_CHANGED_SIZE 9
+
+#define EVT_SNIFF_SUBRATING		0x2E
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	max_tx_latency;
+	uint16_t	max_rx_latency;
+	uint16_t	min_remote_timeout;
+	uint16_t	min_local_timeout;
+} __attribute__ ((packed)) evt_sniff_subrating;
+#define EVT_SNIFF_SUBRATING_SIZE 11
+
+#define EVT_EXTENDED_INQUIRY_RESULT	0x2F
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		pscan_rep_mode;
+	uint8_t		pscan_period_mode;
+	uint8_t		dev_class[3];
+	uint16_t	clock_offset;
+	int8_t		rssi;
+	uint8_t		data[HCI_MAX_EIR_LENGTH];
+} __attribute__ ((packed)) extended_inquiry_info;
+#define EXTENDED_INQUIRY_INFO_SIZE 254
+
+#define EVT_ENCRYPTION_KEY_REFRESH_COMPLETE	0x30
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_encryption_key_refresh_complete;
+#define EVT_ENCRYPTION_KEY_REFRESH_COMPLETE_SIZE 3
+
+#define EVT_IO_CAPABILITY_REQUEST	0x31
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_io_capability_request;
+#define EVT_IO_CAPABILITY_REQUEST_SIZE 6
+
+#define EVT_IO_CAPABILITY_RESPONSE	0x32
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		capability;
+	uint8_t		oob_data;
+	uint8_t		authentication;
+} __attribute__ ((packed)) evt_io_capability_response;
+#define EVT_IO_CAPABILITY_RESPONSE_SIZE 9
+
+#define EVT_USER_CONFIRM_REQUEST	0x33
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	passkey;
+} __attribute__ ((packed)) evt_user_confirm_request;
+#define EVT_USER_CONFIRM_REQUEST_SIZE 10
+
+#define EVT_USER_PASSKEY_REQUEST	0x34
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_user_passkey_request;
+#define EVT_USER_PASSKEY_REQUEST_SIZE 6
+
+#define EVT_REMOTE_OOB_DATA_REQUEST	0x35
+typedef struct {
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_remote_oob_data_request;
+#define EVT_REMOTE_OOB_DATA_REQUEST_SIZE 6
+
+#define EVT_SIMPLE_PAIRING_COMPLETE	0x36
+typedef struct {
+	uint8_t		status;
+	bdaddr_t	bdaddr;
+} __attribute__ ((packed)) evt_simple_pairing_complete;
+#define EVT_SIMPLE_PAIRING_COMPLETE_SIZE 7
+
+#define EVT_LINK_SUPERVISION_TIMEOUT_CHANGED	0x38
+typedef struct {
+	uint16_t	handle;
+	uint16_t	timeout;
+} __attribute__ ((packed)) evt_link_supervision_timeout_changed;
+#define EVT_LINK_SUPERVISION_TIMEOUT_CHANGED_SIZE 4
+
+#define EVT_ENHANCED_FLUSH_COMPLETE	0x39
+typedef struct {
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_enhanced_flush_complete;
+#define EVT_ENHANCED_FLUSH_COMPLETE_SIZE 2
+
+#define EVT_USER_PASSKEY_NOTIFY		0x3B
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint32_t	passkey;
+} __attribute__ ((packed)) evt_user_passkey_notify;
+#define EVT_USER_PASSKEY_NOTIFY_SIZE 10
+
+#define EVT_KEYPRESS_NOTIFY		0x3C
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		type;
+} __attribute__ ((packed)) evt_keypress_notify;
+#define EVT_KEYPRESS_NOTIFY_SIZE 7
+
+#define EVT_REMOTE_HOST_FEATURES_NOTIFY	0x3D
+typedef struct {
+	bdaddr_t	bdaddr;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_remote_host_features_notify;
+#define EVT_REMOTE_HOST_FEATURES_NOTIFY_SIZE 14
+
+#define EVT_LE_META_EVENT	0x3E
+typedef struct {
+	uint8_t		subevent;
+	uint8_t		data[0];
+} __attribute__ ((packed)) evt_le_meta_event;
+#define EVT_LE_META_EVENT_SIZE 1
+
+#define EVT_LE_CONN_COMPLETE	0x01
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		role;
+	uint8_t		peer_bdaddr_type;
+	bdaddr_t	peer_bdaddr;
+	uint16_t	interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+	uint8_t		master_clock_accuracy;
+} __attribute__ ((packed)) evt_le_connection_complete;
+#define EVT_LE_CONN_COMPLETE_SIZE 18
+
+#define EVT_LE_ADVERTISING_REPORT	0x02
+typedef struct {
+	uint8_t		evt_type;
+	uint8_t		bdaddr_type;
+	bdaddr_t	bdaddr;
+	uint8_t		length;
+	uint8_t		data[0];
+} __attribute__ ((packed)) le_advertising_info;
+#define LE_ADVERTISING_INFO_SIZE 9
+
+#define EVT_LE_CONN_UPDATE_COMPLETE	0x03
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint16_t	interval;
+	uint16_t	latency;
+	uint16_t	supervision_timeout;
+} __attribute__ ((packed)) evt_le_connection_update_complete;
+#define EVT_LE_CONN_UPDATE_COMPLETE_SIZE 9
+
+#define EVT_LE_READ_REMOTE_USED_FEATURES_COMPLETE	0x04
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+	uint8_t		features[8];
+} __attribute__ ((packed)) evt_le_read_remote_used_features_complete;
+#define EVT_LE_READ_REMOTE_USED_FEATURES_COMPLETE_SIZE 11
+
+#define EVT_LE_LTK_REQUEST	0x05
+typedef struct {
+	uint16_t	handle;
+	uint64_t	random;
+	uint16_t	diversifier;
+} __attribute__ ((packed)) evt_le_long_term_key_request;
+#define EVT_LE_LTK_REQUEST_SIZE 12
+
+#define EVT_PHYSICAL_LINK_COMPLETE		0x40
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+} __attribute__ ((packed)) evt_physical_link_complete;
+#define EVT_PHYSICAL_LINK_COMPLETE_SIZE 2
+
+#define EVT_CHANNEL_SELECTED		0x41
+
+#define EVT_DISCONNECT_PHYSICAL_LINK_COMPLETE	0x42
+typedef struct {
+	uint8_t		status;
+	uint8_t		handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) evt_disconn_physical_link_complete;
+#define EVT_DISCONNECT_PHYSICAL_LINK_COMPLETE_SIZE 3
+
+#define EVT_PHYSICAL_LINK_LOSS_EARLY_WARNING	0x43
+typedef struct {
+	uint8_t		handle;
+	uint8_t		reason;
+} __attribute__ ((packed)) evt_physical_link_loss_warning;
+#define EVT_PHYSICAL_LINK_LOSS_WARNING_SIZE 2
+
+#define EVT_PHYSICAL_LINK_RECOVERY		0x44
+typedef struct {
+	uint8_t		handle;
+} __attribute__ ((packed)) evt_physical_link_recovery;
+#define EVT_PHYSICAL_LINK_RECOVERY_SIZE 1
+
+#define EVT_LOGICAL_LINK_COMPLETE		0x45
+typedef struct {
+	uint8_t		status;
+	uint16_t	log_handle;
+	uint8_t		handle;
+	uint8_t		tx_flow_id;
+} __attribute__ ((packed)) evt_logical_link_complete;
+#define EVT_LOGICAL_LINK_COMPLETE_SIZE 5
+
+#define EVT_DISCONNECT_LOGICAL_LINK_COMPLETE	0x46
+
+#define EVT_FLOW_SPEC_MODIFY_COMPLETE		0x47
+typedef struct {
+	uint8_t		status;
+	uint16_t	handle;
+} __attribute__ ((packed)) evt_flow_spec_modify_complete;
+#define EVT_FLOW_SPEC_MODIFY_COMPLETE_SIZE 3
+
+#define EVT_NUMBER_COMPLETED_BLOCKS		0x48
+
+#define EVT_AMP_STATUS_CHANGE			0x4D
+typedef struct {
+	uint8_t		status;
+	uint8_t		amp_status;
+} __attribute__ ((packed)) evt_amp_status_change;
+#define EVT_AMP_STATUS_CHANGE_SIZE 2
+
+#define EVT_TESTING			0xFE
+
+#define EVT_VENDOR			0xFF
+
+/* Internal events generated by BlueZ stack */
+#define EVT_STACK_INTERNAL		0xFD
+typedef struct {
+	uint16_t	type;
+	uint8_t		data[0];
+} __attribute__ ((packed)) evt_stack_internal;
+#define EVT_STACK_INTERNAL_SIZE 2
+
+#define EVT_SI_DEVICE	0x01
+typedef struct {
+	uint16_t	event;
+	uint16_t	dev_id;
+} __attribute__ ((packed)) evt_si_device;
+#define EVT_SI_DEVICE_SIZE 4
+
+/* --------  HCI Packet structures  -------- */
+#define HCI_TYPE_LEN	1
+
+typedef struct {
+	uint16_t	opcode;		/* OCF & OGF */
+	uint8_t		plen;
+} __attribute__ ((packed))	hci_command_hdr;
+#define HCI_COMMAND_HDR_SIZE 	3
+
+typedef struct {
+	uint8_t		evt;
+	uint8_t		plen;
+} __attribute__ ((packed))	hci_event_hdr;
+#define HCI_EVENT_HDR_SIZE 	2
+
+typedef struct {
+	uint16_t	handle;		/* Handle & Flags(PB, BC) */
+	uint16_t	dlen;
+} __attribute__ ((packed))	hci_acl_hdr;
+#define HCI_ACL_HDR_SIZE 	4
+
+typedef struct {
+	uint16_t	handle;
+	uint8_t		dlen;
+} __attribute__ ((packed))	hci_sco_hdr;
+#define HCI_SCO_HDR_SIZE 	3
+
+typedef struct {
+	uint16_t	device;
+	uint16_t	type;
+	uint16_t	plen;
+} __attribute__ ((packed))	hci_msg_hdr;
+#define HCI_MSG_HDR_SIZE	6
+
+/* Command opcode pack/unpack */
+#define cmd_opcode_pack(ogf, ocf)	(uint16_t)((ocf & 0x03ff)|(ogf << 10))
+#define cmd_opcode_ogf(op)		(op >> 10)
+#define cmd_opcode_ocf(op)		(op & 0x03ff)
+
+/* ACL handle and flags pack/unpack */
+#define acl_handle_pack(h, f)	(uint16_t)((h & 0x0fff)|(f << 12))
+#define acl_handle(h)		(h & 0x0fff)
+#define acl_flags(h)		(h >> 12)
+
+#endif /* _NO_HCI_DEFS */
+
+/* HCI Socket options */
+#define HCI_DATA_DIR	1
+#define HCI_FILTER	2
+#define HCI_TIME_STAMP	3
+
+/* HCI CMSG flags */
+#define HCI_CMSG_DIR	0x0001
+#define HCI_CMSG_TSTAMP	0x0002
+
+struct sockaddr_hci {
+	sa_family_t	hci_family;
+	unsigned short	hci_dev;
+	unsigned short  hci_channel;
+};
+#define HCI_DEV_NONE	0xffff
+
+#define HCI_CHANNEL_RAW		0
+#define HCI_CHANNEL_MONITOR	2
+#define HCI_CHANNEL_CONTROL	3
+
+struct hci_filter {
+	uint32_t type_mask;
+	uint32_t event_mask[2];
+	uint16_t opcode;
+};
+
+#define HCI_FLT_TYPE_BITS	31
+#define HCI_FLT_EVENT_BITS	63
+#define HCI_FLT_OGF_BITS	63
+#define HCI_FLT_OCF_BITS	127
+
+/* Ioctl requests structures */
+struct hci_dev_stats {
+	uint32_t err_rx;
+	uint32_t err_tx;
+	uint32_t cmd_tx;
+	uint32_t evt_rx;
+	uint32_t acl_tx;
+	uint32_t acl_rx;
+	uint32_t sco_tx;
+	uint32_t sco_rx;
+	uint32_t byte_rx;
+	uint32_t byte_tx;
+};
+
+struct hci_dev_info {
+	uint16_t dev_id;
+	char     name[8];
+
+	bdaddr_t bdaddr;
+
+	uint32_t flags;
+	uint8_t  type;
+
+	uint8_t  features[8];
+
+	uint32_t pkt_type;
+	uint32_t link_policy;
+	uint32_t link_mode;
+
+	uint16_t acl_mtu;
+	uint16_t acl_pkts;
+	uint16_t sco_mtu;
+	uint16_t sco_pkts;
+
+	struct   hci_dev_stats stat;
+};
+
+struct hci_conn_info {
+	uint16_t handle;
+	bdaddr_t bdaddr;
+	uint8_t  type;
+	uint8_t	 out;
+	uint16_t state;
+	uint32_t link_mode;
+};
+
+struct hci_dev_req {
+	uint16_t dev_id;
+	uint32_t dev_opt;
+};
+
+struct hci_dev_list_req {
+	uint16_t dev_num;
+	struct hci_dev_req dev_req[0];	/* hci_dev_req structures */
+};
+
+struct hci_conn_list_req {
+	uint16_t dev_id;
+	uint16_t conn_num;
+	struct hci_conn_info conn_info[0];
+};
+
+struct hci_conn_info_req {
+	bdaddr_t bdaddr;
+	uint8_t  type;
+	struct hci_conn_info conn_info[0];
+};
+
+struct hci_auth_info_req {
+	bdaddr_t bdaddr;
+	uint8_t  type;
+};
+
+struct hci_inquiry_req {
+	uint16_t dev_id;
+	uint16_t flags;
+	uint8_t  lap[3];
+	uint8_t  length;
+	uint8_t  num_rsp;
+};
+#define IREQ_CACHE_FLUSH 0x0001
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HCI_H */
diff --git a/libbt-ath3k/include/upio.h b/libbt-ath3k/include/upio.h
index a22f2fe..ebc8d60 100644
--- a/libbt-ath3k/include/upio.h
+++ b/libbt-ath3k/include/upio.h
@@ -1,20 +1,21 @@
-/*
- * Copyright 2012 The Android Open Source Project
+/******************************************************************************
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ *  Copyright (C) 2009-2012 Broadcom Corporation
+ *  Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
 
 /******************************************************************************
  *
@@ -34,6 +35,21 @@
 #define UPIO_BT_POWER_OFF 0
 #define UPIO_BT_POWER_ON  1
 
+/* UPIO signals */
+enum {
+    UPIO_BT_WAKE = 0,
+    UPIO_HOST_WAKE,
+    UPIO_LPM_MODE,
+    UPIO_MAX_COUNT
+};
+
+/* UPIO assertion/deassertion */
+enum {
+    UPIO_UNKNOWN = 0,
+    UPIO_DEASSERT,
+    UPIO_ASSERT
+};
+
 /******************************************************************************
 **  Extern variables and functions
 ******************************************************************************/
@@ -44,6 +60,28 @@
 
 /*******************************************************************************
 **
+** Function        upio_init
+**
+** Description     Initialization
+**
+** Returns         None
+**
+*******************************************************************************/
+void upio_init(void);
+
+/*******************************************************************************
+**
+** Function        upio_cleanup
+**
+** Description     Clean up
+**
+** Returns         None
+**
+*******************************************************************************/
+void upio_cleanup(void);
+
+/*******************************************************************************
+**
 ** Function        upio_set_bluetooth_power
 **
 ** Description     Interact with low layer driver to set Bluetooth power
@@ -55,5 +93,16 @@
 *******************************************************************************/
 int upio_set_bluetooth_power(int on);
 
+/*******************************************************************************
+**
+** Function        upio_set
+**
+** Description     Set i/o based on polarity
+**
+** Returns         None
+**
+*******************************************************************************/
+void upio_set(uint8_t pio, uint8_t action, uint8_t polarity);
+
 #endif /* UPIO_H */
 
diff --git a/libbt-ath3k/include/userial_vendor.h b/libbt-ath3k/include/userial_vendor.h
deleted file mode 100644
index 4b999cf..0000000
--- a/libbt-ath3k/include/userial_vendor.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
-
-/******************************************************************************
- *
- *  Filename:      userial_vendor.h
- *
- *  Description:   Contains vendor-specific definitions used in serial port
- *                 controls
- *
- ******************************************************************************/
-
-#ifndef USERIAL_VENDOR_H
-#define USERIAL_VENDOR_H
-
-#include "bt_vendor_ath3k.h"
-#include "userial.h"
-
-/******************************************************************************
-**  Constants & Macros
-******************************************************************************/
-
-/**** baud rates ****/
-#define USERIAL_BAUD_300        0
-#define USERIAL_BAUD_600        1
-#define USERIAL_BAUD_1200       2
-#define USERIAL_BAUD_2400       3
-#define USERIAL_BAUD_9600       4
-#define USERIAL_BAUD_19200      5
-#define USERIAL_BAUD_57600      6
-#define USERIAL_BAUD_115200     7
-#define USERIAL_BAUD_230400     8
-#define USERIAL_BAUD_460800     9
-#define USERIAL_BAUD_921600     10
-#define USERIAL_BAUD_1M         11
-#define USERIAL_BAUD_1_5M       12
-#define USERIAL_BAUD_2M         13
-#define USERIAL_BAUD_3M         14
-#define USERIAL_BAUD_4M         15
-#define USERIAL_BAUD_AUTO       16
-
-/**** Data Format ****/
-/* Stop Bits */
-#define USERIAL_STOPBITS_1      1
-#define USERIAL_STOPBITS_1_5    (1<<1)
-#define USERIAL_STOPBITS_2      (1<<2)
-
-/* Parity Bits */
-#define USERIAL_PARITY_NONE     (1<<3)
-#define USERIAL_PARITY_EVEN     (1<<4)
-#define USERIAL_PARITY_ODD      (1<<5)
-
-/* Data Bits */
-#define USERIAL_DATABITS_5      (1<<6)
-#define USERIAL_DATABITS_6      (1<<7)
-#define USERIAL_DATABITS_7      (1<<8)
-#define USERIAL_DATABITS_8      (1<<9)
-
-
-#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-/* These are the ioctl values used for bt_wake ioctl via UART driver. you may
- * need to redefine them on you platform!
- * Logically they need to be unique and not colide with existing uart ioctl's.
- */
-#ifndef USERIAL_IOCTL_BT_WAKE_ASSERT
-#define USERIAL_IOCTL_BT_WAKE_ASSERT   0x8003
-#endif
-#ifndef USERIAL_IOCTL_BT_WAKE_DEASSERT
-#define USERIAL_IOCTL_BT_WAKE_DEASSERT 0x8004
-#endif
-#ifndef USERIAL_IOCTL_BT_WAKE_GET_ST
-#define USERIAL_IOCTL_BT_WAKE_GET_ST   0x8005
-#endif
-#endif // (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-
-/******************************************************************************
-**  Type definitions
-******************************************************************************/
-
-/* Structure used to configure serial port during open */
-typedef struct
-{
-    uint16_t fmt;       /* Data format */
-    uint8_t  baud;      /* Baud rate */
-} tUSERIAL_CFG;
-
-typedef enum {
-#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-    USERIAL_OP_ASSERT_BT_WAKE,
-    USERIAL_OP_DEASSERT_BT_WAKE,
-    USERIAL_OP_GET_BT_WAKE_STATE,
-#endif
-    USERIAL_OP_NOP,
-} userial_vendor_ioctl_op_t;
-
-/******************************************************************************
-**  Extern variables and functions
-******************************************************************************/
-
-/******************************************************************************
-**  Functions
-******************************************************************************/
-
-/*******************************************************************************
-**
-** Function        userial_vendor_init
-**
-** Description     Initialize userial vendor-specific control block
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_init(void);
-
-/*******************************************************************************
-**
-** Function        userial_vendor_open
-**
-** Description     Open the serial port with the given configuration
-**
-** Returns         device fd
-**
-*******************************************************************************/
-int userial_vendor_open(tUSERIAL_CFG *p_cfg);
-
-/*******************************************************************************
-**
-** Function        userial_vendor_close
-**
-** Description     Conduct vendor-specific close work
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_close(void);
-
-/*******************************************************************************
-**
-** Function        userial_vendor_set_baud
-**
-** Description     Set new baud rate
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_set_baud(uint8_t userial_baud);
-
-/*******************************************************************************
-**
-** Function        userial_vendor_ioctl
-**
-** Description     ioctl inteface
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_ioctl(userial_vendor_ioctl_op_t op, void *p_data);
-
-#endif /* USERIAL_VENDOR_H */
-
diff --git a/libbt-ath3k/include/userial_vendor_QCA3002.h b/libbt-ath3k/include/userial_vendor_QCA3002.h
new file mode 100644
index 0000000..dc14b97
--- /dev/null
+++ b/libbt-ath3k/include/userial_vendor_QCA3002.h
@@ -0,0 +1,176 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2009-2012 Broadcom Corporation
+ *  Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Filename:      userial_vendor.h
+ *
+ *  Description:   Contains vendor-specific definitions used in serial port
+ *                 controls
+ *
+ ******************************************************************************/
+
+#ifndef USERIAL_VENDOR_QCA3002_H
+#define USERIAL_VENDOR_QCA3002_H
+
+#include "bt_vendor_QCA3002.h"
+#include "userial.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+/**** baud rates ****/
+#define USERIAL_BAUD_300        0
+#define USERIAL_BAUD_600        1
+#define USERIAL_BAUD_1200       2
+#define USERIAL_BAUD_2400       3
+#define USERIAL_BAUD_9600       4
+#define USERIAL_BAUD_19200      5
+#define USERIAL_BAUD_57600      6
+#define USERIAL_BAUD_115200     7
+#define USERIAL_BAUD_230400     8
+#define USERIAL_BAUD_460800     9
+#define USERIAL_BAUD_921600     10
+#define USERIAL_BAUD_1M         11
+#define USERIAL_BAUD_1_5M       12
+#define USERIAL_BAUD_2M         13
+#define USERIAL_BAUD_3M         14
+#define USERIAL_BAUD_4M         15
+#define USERIAL_BAUD_AUTO       16
+
+/**** Data Format ****/
+/* Stop Bits */
+#define USERIAL_STOPBITS_1      1
+#define USERIAL_STOPBITS_1_5    (1<<1)
+#define USERIAL_STOPBITS_2      (1<<2)
+
+/* Parity Bits */
+#define USERIAL_PARITY_NONE     (1<<3)
+#define USERIAL_PARITY_EVEN     (1<<4)
+#define USERIAL_PARITY_ODD      (1<<5)
+
+/* Data Bits */
+#define USERIAL_DATABITS_5      (1<<6)
+#define USERIAL_DATABITS_6      (1<<7)
+#define USERIAL_DATABITS_7      (1<<8)
+#define USERIAL_DATABITS_8      (1<<9)
+
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+/* These are the ioctl values used for bt_wake ioctl via UART driver. you may
+ * need to redefine them on you platform!
+ * Logically they need to be unique and not colide with existing uart ioctl's.
+ */
+#ifndef USERIAL_IOCTL_BT_WAKE_ASSERT
+#define USERIAL_IOCTL_BT_WAKE_ASSERT   0x8003
+#endif
+#ifndef USERIAL_IOCTL_BT_WAKE_DEASSERT
+#define USERIAL_IOCTL_BT_WAKE_DEASSERT 0x8004
+#endif
+#ifndef USERIAL_IOCTL_BT_WAKE_GET_ST
+#define USERIAL_IOCTL_BT_WAKE_GET_ST   0x8005
+#endif
+#endif // (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+
+/******************************************************************************
+**  Type definitions
+******************************************************************************/
+
+/* Structure used to configure serial port during open */
+typedef struct
+{
+    uint16_t fmt;       /* Data format */
+    uint8_t  baud;      /* Baud rate */
+} tUSERIAL_CFG;
+
+typedef enum {
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    USERIAL_OP_ASSERT_BT_WAKE,
+    USERIAL_OP_DEASSERT_BT_WAKE,
+    USERIAL_OP_GET_BT_WAKE_STATE,
+#endif
+    USERIAL_OP_NOP,
+} userial_vendor_ioctl_op_t;
+
+/******************************************************************************
+**  Extern variables and functions
+******************************************************************************/
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+
+/*******************************************************************************
+**
+** Function        userial_vendor_init
+**
+** Description     Initialize userial vendor-specific control block
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_init(void);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_open
+**
+** Description     Open the serial port with the given configuration
+**
+** Returns         device fd
+**
+*******************************************************************************/
+int userial_vendor_open(tUSERIAL_CFG *p_cfg);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_close
+**
+** Description     Conduct vendor-specific close work
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_close(void);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_set_baud
+**
+** Description     Set new baud rate
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_set_baud(uint8_t userial_baud);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_ioctl
+**
+** Description     ioctl inteface
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_ioctl(userial_vendor_ioctl_op_t op, void *p_data);
+
+#endif /* USERIAL_VENDOR_H */
+
diff --git a/libbt-ath3k/include/vnd_generic.txt b/libbt-ath3k/include/vnd_generic.txt
index 9c43132..18964f2 100644
--- a/libbt-ath3k/include/vnd_generic.txt
+++ b/libbt-ath3k/include/vnd_generic.txt
@@ -1,6 +1,8 @@
-BLUETOOTH_UART_DEVICE_PORT = "/dev/ttymxc4"
+BLUETOOTH_UART_DEVICE_PORT = "/dev/ttyO1"
 FW_PATCHFILE_LOCATION = "/vendor/firmware/"
+LPM_IDLE_TIMEOUT_MULTIPLE = 5
+SCO_USE_I2S_INTERFACE = TRUE
 BTVND_DBG = FALSE
-BTHW_DBG = FALSE
+BTHW_DBG = TRUE
 VNDUSERIAL_DBG = FALSE
 UPIO_DBG = FALSE
diff --git a/libbt-ath3k/include/vnd_imx53_smd.txt b/libbt-ath3k/include/vnd_imx53_smd.txt
new file mode 100644
index 0000000..642fc54
--- /dev/null
+++ b/libbt-ath3k/include/vnd_imx53_smd.txt
@@ -0,0 +1,8 @@
+BLUETOOTH_UART_DEVICE_PORT = "/dev/ttymxc2"
+FW_PATCHFILE_LOCATION = "/system/etc/firmware/ar3k/"
+LPM_IDLE_TIMEOUT_MULTIPLE = 5
+SCO_USE_I2S_INTERFACE = TRUE
+BTVND_DBG = FALSE
+BTHW_DBG = TRUE
+VNDUSERIAL_DBG = FALSE
+UPIO_DBG = FALSE
diff --git a/libbt-ath3k/include/vnd_mako.txt b/libbt-ath3k/include/vnd_mako.txt
new file mode 100644
index 0000000..18964f2
--- /dev/null
+++ b/libbt-ath3k/include/vnd_mako.txt
@@ -0,0 +1,8 @@
+BLUETOOTH_UART_DEVICE_PORT = "/dev/ttyO1"
+FW_PATCHFILE_LOCATION = "/vendor/firmware/"
+LPM_IDLE_TIMEOUT_MULTIPLE = 5
+SCO_USE_I2S_INTERFACE = TRUE
+BTVND_DBG = FALSE
+BTHW_DBG = TRUE
+VNDUSERIAL_DBG = FALSE
+UPIO_DBG = FALSE
diff --git a/libbt-ath3k/include/vnd_sabresd_6dq.txt b/libbt-ath3k/include/vnd_sabresd_6dq.txt
new file mode 100644
index 0000000..6600e3e
--- /dev/null
+++ b/libbt-ath3k/include/vnd_sabresd_6dq.txt
@@ -0,0 +1,8 @@
+BLUETOOTH_UART_DEVICE_PORT = "/dev/ttymxc4"
+FW_PATCHFILE_LOCATION = "/system/etc/firmware/ar3k/"
+LPM_IDLE_TIMEOUT_MULTIPLE = 5
+SCO_USE_I2S_INTERFACE = TRUE
+BTVND_DBG = FALSE
+BTHW_DBG = TRUE
+VNDUSERIAL_DBG = FALSE
+UPIO_DBG = FALSE
diff --git a/libbt-ath3k/src/bt_vendor_QCA3002.c b/libbt-ath3k/src/bt_vendor_QCA3002.c
new file mode 100644
index 0000000..d9908eb
--- /dev/null
+++ b/libbt-ath3k/src/bt_vendor_QCA3002.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Filename:      bt_vendor_qcom_AR3002.c
+ *
+ *  Description:   QCOM vendor specific library implementation
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_vendor"
+
+#include <utils/Log.h>
+#include <fcntl.h>
+#include <termios.h>
+#include "bt_vendor_QCA3002.h"
+#include "userial_vendor_QCA3002.h"
+#include "upio.h"
+
+#define UPIO_BT_POWER_OFF 0
+#define UPIO_BT_POWER_ON 1
+/******************************************************************************
+**  Static Variables
+******************************************************************************/
+
+static const tUSERIAL_CFG userial_init_cfg =
+{
+    (USERIAL_DATABITS_8 | USERIAL_PARITY_NONE | USERIAL_STOPBITS_1),
+    USERIAL_BAUD_115200
+};
+
+/******************************************************************************
+**  Externs
+******************************************************************************/
+
+
+/******************************************************************************
+**  Variables
+******************************************************************************/
+int pFd[2] = {0,};
+//bt_hci_transport_device_type bt_hci_transport_device;
+
+bt_vendor_callbacks_t *bt_vendor_cbacks = NULL;
+uint8_t vnd_local_bd_addr[6]={0x11, 0x22, 0x33, 0x44, 0x55, 0xFF};
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+
+/*****************************************************************************
+**
+**   BLUETOOTH VENDOR INTERFACE LIBRARY FUNCTIONS
+**
+*****************************************************************************/
+
+static int init(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr)
+{
+    ALOGI("bt-vendor : init");
+
+    if (p_cb == NULL)
+    {
+        ALOGE("init failed with no user callbacks!");
+        return -1;
+    }
+
+    userial_vendor_init();
+    //upio_init();
+
+    //vnd_load_conf(VENDOR_LIB_CONF_FILE);
+
+    /* store reference to user callbacks */
+    bt_vendor_cbacks = (bt_vendor_callbacks_t *) p_cb;
+
+    /* This is handed over from the stack */
+    memcpy(vnd_local_bd_addr, local_bdaddr, 6);
+
+    return 0;
+}
+
+
+/** Requested operations */
+static int op(bt_vendor_opcode_t opcode, void *param)
+{
+    int retval = 0;
+    int nCnt = 0;
+    int nState = -1;
+
+    ALOGV("%s : bt-vendor : op for %d", __FUNCTION__, opcode);
+
+    switch(opcode)
+    {
+        case BT_VND_OP_POWER_CTRL:
+            {
+                ALOGV("AR3002 ::BT_VND_OP_POWER_CTRL");
+                int *state = (int *) param;
+				if (*state == BT_VND_PWR_OFF){
+                    ALOGI("[//]AR3002 UPIO_BT_POWER_OFF");
+					upio_set_bluetooth_power(UPIO_BT_POWER_OFF);
+				}
+                else if (*state == BT_VND_PWR_ON){
+                    ALOGI("[//]AR3002 UPIO_BT_POWER_ON");
+					upio_set_bluetooth_power(UPIO_BT_POWER_ON);
+                }
+                retval = 0;
+            }
+            break;
+
+        case BT_VND_OP_FW_CFG:
+            {
+				ALOGI("AR3002 ::BT_VND_OP_FW_CFG");
+
+                if(bt_vendor_cbacks){
+                   ALOGI("AR3002 ::Bluetooth Firmware download");
+                   bt_vendor_cbacks->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+                }
+                else{
+                   ALOGE("AR3002 ::Error : AR3002 Bluetooth Firmware download");
+                   bt_vendor_cbacks->fwcfg_cb(BT_VND_OP_RESULT_FAIL);
+                }
+            }
+            break;
+
+        case BT_VND_OP_SCO_CFG:
+            {
+                bt_vendor_cbacks->scocfg_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
+            }
+            break;
+
+        case BT_VND_OP_USERIAL_OPEN:
+            {
+                ALOGI("AR3002 ::BT_VND_OP_USERIAL_OPEN ");
+                int (*fd_array)[] = (int (*)[]) param;
+                int fd,idx;
+                fd = userial_vendor_open((tUSERIAL_CFG *) &userial_init_cfg);
+                if (fd != -1)
+                {
+                    for (idx=0; idx < CH_MAX; idx++)
+                        (*fd_array)[idx] = fd;
+
+                    retval = 1;
+                }
+
+            }
+            break;
+
+        case BT_VND_OP_USERIAL_CLOSE:
+            {
+                ALOGI("AR3002 ::BT_VND_OP_USERIAL_CLOSE ");
+                userial_vendor_close();
+            }
+            break;
+
+        case BT_VND_OP_GET_LPM_IDLE_TIMEOUT:
+            ALOGI("AR3002 ::BT_VND_OP_GET_LPM_IDLE_TIMEOUT (timeout_ms = 3000;)");
+            uint32_t *timeout_ms = (uint32_t *) param;
+            *timeout_ms = 3000;
+            break;
+
+        case BT_VND_OP_LPM_SET_MODE:
+            {
+                ALOGI("AR3002 ::BT_VND_OP_LPM_SET_MODE ()");
+                bt_vendor_cbacks->lpm_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
+            }
+            break;
+
+        case BT_VND_OP_LPM_WAKE_SET_STATE:
+			{
+				ALOGI("AR3002 ::BT_VND_OP_LPM_WAKE_SET_STATE ()");
+				bt_vendor_cbacks->lpm_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
+        	}			
+            break;
+    }
+
+    return retval;
+}
+
+/** Closes the interface */
+static void cleanup( void )
+{
+    ALOGI("cleanup");
+    //upio_cleanup();
+    bt_vendor_cbacks = NULL;
+}
+
+// Entry point of DLib
+const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {
+    sizeof(bt_vendor_interface_t),
+    init,
+    op,
+    cleanup
+};
diff --git a/libbt-ath3k/src/bt_vendor_ath3k.c b/libbt-ath3k/src/bt_vendor_ath3k.c
deleted file mode 100644
index 9289b3f..0000000
--- a/libbt-ath3k/src/bt_vendor_ath3k.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * Copyright 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
-
-/******************************************************************************
- *
- *  Filename:      bt_vendor_ar3k.c
- *
- *  Description:   QCOM/Atheros vendor specific library implementation
- *
- ******************************************************************************/
-
-#define LOG_TAG "bt_vendor"
-
-#include <utils/Log.h>
-#include "bt_vendor_ath3k.h"
-#include "upio.h"
-#include "userial_vendor.h"
-
-#ifndef BTVND_DBG
-#define BTVND_DBG FALSE
-#endif
-
-#if (BTVND_DBG == TRUE)
-#define BTVNDDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
-#else
-#define BTVNDDBG(param, ...) {}
-#endif
-
-/******************************************************************************
-**  Static Variables
-******************************************************************************/
-
-static const tUSERIAL_CFG userial_init_cfg =
-{
-    (USERIAL_DATABITS_8 | USERIAL_PARITY_NONE | USERIAL_STOPBITS_1),
-    USERIAL_BAUD_115200
-};
-
-/******************************************************************************
-**  Externs
-******************************************************************************/
-extern void hw_config_start(void);
-extern void vnd_load_conf(const char *p_path);
-
-/******************************************************************************
-**  Variables
-******************************************************************************/
-bt_vendor_callbacks_t *bt_vendor_cbacks = NULL;
-uint8_t vnd_local_bd_addr[6]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-/******************************************************************************
-**  Local type definitions
-******************************************************************************/
-
-
-/******************************************************************************
-**  Functions
-******************************************************************************/
-
-/*****************************************************************************
-**
-**   BLUETOOTH VENDOR INTERFACE LIBRARY FUNCTIONS
-**
-*****************************************************************************/
-
-static int init(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr)
-{
-    BTVNDDBG("init");
-
-    if (p_cb == NULL)
-    {
-        ALOGE("init failed with no user callbacks!");
-        return -1;
-    }
-
-    userial_vendor_init();
-
-    vnd_load_conf(VENDOR_LIB_CONF_FILE);
-
-    /* store reference to user callbacks */
-    bt_vendor_cbacks = (bt_vendor_callbacks_t *) p_cb;
-
-    /* This is handed over from the stack, when to use it? */
-    memcpy(vnd_local_bd_addr, local_bdaddr, 6);
-
-    return 0;
-}
-
-/** Requested operations */
-static int op(bt_vendor_opcode_t opcode, void *param)
-{
-    int retval = 0;
-
-    BTVNDDBG("op for %d", opcode);
-
-    switch(opcode)
-    {
-        case BT_VND_OP_POWER_CTRL:
-            {
-                int *state = (int *) param;
-
-                if (*state == BT_VND_PWR_OFF)
-                    upio_set_bluetooth_power(UPIO_BT_POWER_OFF);
-                else if (*state == BT_VND_PWR_ON)
-                    upio_set_bluetooth_power(UPIO_BT_POWER_ON);
-
-                retval = 0;
-
-            }
-            break;
-
-        case BT_VND_OP_FW_CFG:
-            {
-                if (bt_vendor_cbacks) {
-                   BTVNDDBG("Bluetooth hw config start");
-
-                   hw_config_start();
-
-                } else {
-                   ALOGE("Bluetooth bt_vendor_cbacks is NULL ");
-                }
-            }
-            break;
-
-        case BT_VND_OP_SCO_CFG:
-            {
-                bt_vendor_cbacks->scocfg_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
-                retval = -1;
-            }
-            break;
-
-        case BT_VND_OP_USERIAL_OPEN:
-            {
-                int (*fd_array)[] = (int (*)[]) param;
-                int fd, idx;
-                fd = userial_vendor_open((tUSERIAL_CFG *) &userial_init_cfg);
-                if (fd != -1)
-                {
-                    for (idx=0; idx < CH_MAX; idx++)
-                        (*fd_array)[idx] = fd;
-
-                    retval = 1;
-                }
-
-            }
-            break;
-
-        case BT_VND_OP_USERIAL_CLOSE:
-            {
-                 userial_vendor_close();
-            }
-            break;
-
-        case BT_VND_OP_GET_LPM_IDLE_TIMEOUT:
-            {
-                uint32_t *timeout_ms = (uint32_t *) param;
-                *timeout_ms = 50;
-            }
-            break;
-
-        case BT_VND_OP_LPM_SET_MODE:
-            {
-                bt_vendor_cbacks->lpm_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
-            }
-            break;
-
-        case BT_VND_OP_LPM_WAKE_SET_STATE:
-            /*{
-                uint8_t *state = (uint8_t *) param;
-                uint8_t wake_assert = (*state == BT_VND_LPM_WAKE_ASSERT) ? \
-                                        TRUE : FALSE;
-            }*/
-            break;
-    }
-
-    return retval;
-}
-
-/** Closes the interface */
-static void cleanup( void )
-{
-    BTVNDDBG("cleanup");
-
-    bt_vendor_cbacks = NULL;
-}
-
-// Entry point of DLib
-const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {
-    sizeof(bt_vendor_interface_t),
-    init,
-    op,
-    cleanup
-};
diff --git a/libbt-ath3k/src/conf.c b/libbt-ath3k/src/conf.c
deleted file mode 100644
index ba73964..0000000
--- a/libbt-ath3k/src/conf.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
-
-/******************************************************************************
- *
- *  Filename:      conf.c
- *
- *  Description:   Contains functions to conduct run-time module configuration
- *                 based on entries present in the .conf file
- *
- ******************************************************************************/
-
-#define LOG_TAG "bt_vnd_conf"
-
-#include <utils/Log.h>
-#include <string.h>
-#include "bt_vendor_ath3k.h"
-
-/******************************************************************************
-**  Externs
-******************************************************************************/
-int userial_set_port(char *p_conf_name, char *p_conf_value, int param);
-int hw_set_patch_file_path(char *p_conf_name, char *p_conf_value, int param);
-
-
-/******************************************************************************
-**  Local type definitions
-******************************************************************************/
-
-#define CONF_COMMENT '#'
-#define CONF_DELIMITERS " =\n\r\t"
-#define CONF_VALUES_DELIMITERS "=\n\r\t"
-#define CONF_MAX_LINE_LEN 255
-
-typedef int (conf_action_t)(char *p_conf_name, char *p_conf_value, int param);
-
-typedef struct {
-    const char *conf_entry;
-    conf_action_t *p_action;
-    int param;
-} conf_entry_t;
-
-/******************************************************************************
-**  Static variables
-******************************************************************************/
-
-/*
- * Current supported entries and corresponding action functions
- */
-static const conf_entry_t conf_table[] = {
-    {"UartPort", userial_set_port, 0},
-    {"FwPatchFilePath", hw_set_patch_file_path, 0},
-    {(const char *) NULL, NULL, 0}
-};
-
-/*****************************************************************************
-**   CONF INTERFACE FUNCTIONS
-*****************************************************************************/
-
-/*******************************************************************************
-**
-** Function        vnd_load_conf
-**
-** Description     Read conf entry from p_path file one by one and call
-**                 the corresponding config function
-**
-** Returns         None
-**
-*******************************************************************************/
-void vnd_load_conf(const char *p_path)
-{
-    FILE    *p_file;
-    char    *p_name;
-    char    *p_value;
-    conf_entry_t    *p_entry;
-    char    line[CONF_MAX_LINE_LEN+1]; /* add 1 for \0 char */
-
-    ALOGI("Attempt to load conf from %s", p_path);
-
-    if ((p_file = fopen(p_path, "r")) != NULL)
-    {
-        /* read line by line */
-        while (fgets(line, CONF_MAX_LINE_LEN+1, p_file) != NULL)
-        {
-            if (line[0] == CONF_COMMENT)
-                continue;
-
-            p_name = strtok(line, CONF_DELIMITERS);
-
-            if (NULL == p_name)
-            {
-                continue;
-            }
-
-            p_value = strtok(NULL, CONF_DELIMITERS);
-
-            if (NULL == p_value)
-            {
-                ALOGW("vnd_load_conf: missing value for name: %s", p_name);
-                continue;
-            }
-
-            p_entry = (conf_entry_t *)conf_table;
-
-            while (p_entry->conf_entry != NULL)
-            {
-                if (strcmp(p_entry->conf_entry, (const char *)p_name) == 0)
-                {
-                    p_entry->p_action(p_name, p_value, p_entry->param);
-                    break;
-                }
-
-                p_entry++;
-            }
-        }
-
-        fclose(p_file);
-    }
-    else
-    {
-        ALOGI( "vnd_load_conf file >%s< not found", p_path);
-    }
-}
-
diff --git a/libbt-ath3k/src/hardware.c b/libbt-ath3k/src/hardware.c
deleted file mode 100644
index 1f4ec0c..0000000
--- a/libbt-ath3k/src/hardware.c
+++ /dev/null
@@ -1,1253 +0,0 @@
-/*
- * Copyright 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
-
-/******************************************************************************
- *
- *  Filename:      hardware.c
- *
- *  Description:   Contains ath3k controller-specific functions, like
- *                      firmware patch download
- *                      low power mode operations
- *
- ******************************************************************************/
-
-#define LOG_TAG "bt_hwcfg"
-
-#include <utils/Log.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <signal.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <dirent.h>
-#include <ctype.h>
-#include <cutils/properties.h>
-#include <stdlib.h>
-
-#include "bt_hci_bdroid.h"
-#include "bt_vendor_ath3k.h"
-#include "userial_vendor.h"
-
-/******************************************************************************
-**  Constants & Macros
-******************************************************************************/
-
-#ifndef BTHW_DBG
-#define BTHW_DBG FALSE
-#endif
-
-#if (BTHW_DBG == TRUE)
-#define BTHWDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
-#else
-#define BTHWDBG(param, ...) {}
-#endif
-
-#define HCI_SLEEP_CMD_OCF       0x04
-#define GET_DEV_TYPE_OCF        0x05
-#define HCI_PS_CMD_OCF          0x0B
-#define HCI_CHG_BAUD_CMD_OCF    0x0C
-#define GET_VERSION_OCF         0x1E
-
-/* AR3k Vendor Specific commands */
-#define HCI_GRP_VENDOR_SPECIFIC (0x3F << 10)            /* 0xFC00 */
-#define HCI_VSC_SLEEP_CMD       (HCI_GRP_VENDOR_SPECIFIC | HCI_SLEEP_CMD_OCF)
-#define HCI_VSC_GET_DEV_TYPE    (HCI_GRP_VENDOR_SPECIFIC | GET_DEV_TYPE_OCF)
-#define HCI_VSC_PS_CMD          (HCI_GRP_VENDOR_SPECIFIC | HCI_PS_CMD_OCF)
-#define HCI_VSC_CHG_BAUD_CMD    (HCI_GRP_VENDOR_SPECIFIC | HCI_CHG_BAUD_CMD_OCF)
-#define HCI_VSC_GET_VERSION     (HCI_GRP_VENDOR_SPECIFIC | GET_VERSION_OCF)
-#define HCI_RESET               0x0C03
-
-#define HCI_CMD_MAX_LEN                         258
-#define HCI_EVT_CMD_CMPL_OPCODE                 3
-#define HCI_EVT_CMD_CMPL_STATUS_RET_BYTE        5
-#define HCI_EVT_CMD_CMPL_RESPONSE               6
-#define HCI_CMD_PREAMBLE_SIZE                   3
-#define GET_DEV_TYPE_CMD_PARAM_SIZE             5
-#define PS_CMD_GET_CRC_PARAM_SIZE               4
-#define PS_CMD_WRITE_BDADDR_PARAM_SIZE          10
-#define PS_CMD_WRITE_PATCH_PARAM_SIZE           4
-#define CHG_BAUD_CMD_PARAM_SIZE                 2
-#define PS_RESET_PARAM_LEN                      6
-
-#define DEV_REGISTER            0x4FFC
-#define PS_ASIC_FILE            "PS_ASIC.pst"
-#define PS_FPGA_FILE            "PS_FPGA.pst"
-#define MAXPATHLEN              4096
-#define PATCH_FILE              "RamPatch.txt"
-#define BDADDR_FILE             "ar3kbdaddr.pst"
-#define FPGA_ROM_VERSION        0x99999999
-#define ROM_DEV_TYPE            0xdeadc0de
-#define PS_HEX                  0
-#define PS_DEC                  1
-#define UNDEFINED               0xFFFF
-#define ARRAY                   'A'
-#define STRING                  'S'
-#define DECIMAL                 'D'
-#define BINARY                  'B'
-#define PS_UNDEF                0
-#define PS_ID                   1
-#define PS_LEN                  2
-#define PS_DATA                 3
-#define PS_MAX_LEN              500
-#define LINE_SIZE_MAX           (PS_MAX_LEN * 2)
-#define ENTRY_PER_LINE          16
-#define MAX_PREAMBLE_LEN        4
-#define PATCH_LOC_KEY           "DA:"
-#define MAX_BD_ADDR_LEN         20
-#define SET_PATCH_RAM_ID        0x0D
-#define SET_PATCH_RAM_CMD_SIZE  11
-#define ADDRESS_LEN             4
-#define MAX_TAGS                50
-#define PS_HDR_LEN              4
-#define VERIFY_CRC              9
-#define PS_REGION               1
-#define PATCH_REGION            2
-#define MAX_PATCH_CMD           244
-#define PS_WRITE                1
-#define PS_RESET                2
-#define WRITE_PATCH             8
-#define ENABLE_PATCH            11
-#define PS_ID_MASK              0xFF
-
-#define __check_comment(buf) (((buf)[0] == '/') && ((buf)[1] == '/'))
-#define __skip_space(str)      while (*(str) == ' ') ((str)++)
-#define __is_delim(ch) ((ch) == ':')
-
-#define STREAM_TO_UINT16(u16, p) {u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); (p) += 2;}
-#define UINT16_TO_STREAM(p, u16) {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8);}
-
-struct patch_entry {
-    int16_t len;
-    uint8_t data[MAX_PATCH_CMD];
-};
-
-#define HCI_PS_CMD_HDR_LEN HCI_CMD_PREAMBLE_SIZE + PS_HDR_LEN
-#define PS_RESET_CMD_LEN   (HCI_PS_CMD_HDR_LEN + PS_RESET_PARAM_LEN)
-
-#define LOCAL_NAME_BUFFER_LEN                   32
-
-void hw_config_cback(void *p_mem);
-#define PATCH_LOC_STRING_LEN   8
-
-/******************************************************************************
-**  Static variables
-******************************************************************************/
-
-/* h/w config control block */
-typedef struct
-{
-    uint8_t state;                          /* Hardware configuration state */
-    int     fw_fd;                          /* FW patch file fd */
-    uint8_t f_set_baud_2;                   /* Baud rate switch state */
-    char    local_chip_name[LOCAL_NAME_BUFFER_LEN];
-} bt_hw_cfg_cb_t;
-
-static bt_hw_cfg_cb_t hw_cfg_cb;
-
-static char patch_file[PATH_MAX];
-static char ps_file[PATH_MAX];
-static FILE *rampatch_fd;
-static int tag_count=0;
-static int current_tag_idx=0;
-static uint32_t dev_type = 0xdeadc0de;
-static uint32_t rom_version = 0x30101;
-static uint32_t bld_version = 0x9d6a2;
-char ARbyte[3];
-char ARptr[MAX_PATCH_CMD + 1];
-int byte_cnt;
-int segment_idx = 0;
-char patch_loc[PATCH_LOC_STRING_LEN + 1];
-int ps_counter=0;
-static char fw_patchfile_path[MAXPATHLEN] = FW_PATCHFILE_LOCATION;
-
-struct tag_info {
-    unsigned section;
-    unsigned line_count;
-    unsigned char_cnt;
-    unsigned byte_count;
-};
-
-struct ps_cfg_entry {
-    uint32_t id;
-    uint32_t len;
-    uint8_t *data;
-};
-
-struct ps_entry_type {
-    unsigned char type;
-    unsigned char array;
-};
-
-struct ps_cfg_entry ps_list[MAX_TAGS];
-
-struct hci_command_hdr {
-    uint16_t    opcode;     /* OCF & OGF */
-    uint8_t     plen;
-};
-
-/* Hardware Configuration State */
-enum {
-    HW_CFG_START = 1,
-    HW_CFG_SET_CNTRLR_BAUD,
-    HW_CFG_GET_DEVICE_TYPE,
-    HW_CFG_GET_ATH3K_VERSION,
-    HW_CFG_GET_ATH3K_CRC,
-    HW_CFG_PSPATCH_START_DOWNLOAD,
-    HW_CFG_PSPATCH_DOWNLOAD,
-    HW_CFG_PSPATCH_DOWNLOADING,
-    HW_CFG_PSPATCH_DOWNLOADED,
-    HW_CFG_CONFIG_RESET,
-    HW_CFG_CONFIG_DOWNLOADING,
-    HW_CFG_WRITE_BDADDRESS,
-    HW_CFG_WRITE_BDADDRESS_DONE,
-    HW_CFG_HCI_RESET,
-    HW_CFG_CNTRLR_BAUD,
-    HW_CFG_CNTRLR_BAUD_UPDATE,
-};
-
-static int send_cmd(HC_BT_HDR *p_buf, uint8_t *buffer, int len)
-{
-    uint8_t     *p;
-
-    BTHWDBG("%s", __func__);
-
-    if (p_buf)
-    {
-        struct hci_command_hdr *ch = (void *)buffer;
-
-        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-        p_buf->offset = 0;
-        p_buf->len = len;
-        p_buf->layer_specific = 0;
-
-        p = (uint8_t *) (p_buf + 1);
-        memcpy(p, buffer, len);
-
-        bt_vendor_cbacks->xmit_cb(ch->opcode, p_buf, hw_config_cback);
-    }
-    return 0;
-}
-
-static void load_hci_ps_hdr(uint8_t *cmd, uint8_t ps_op, int len, int index)
-{
-    BTHWDBG("%s ps_op = 0x%x", __func__, ps_op);
-
-    UINT16_TO_STREAM(cmd, HCI_VSC_PS_CMD);
-    *cmd++ = len + PS_HDR_LEN;
-    *cmd++ = ps_op;
-    *cmd++ = index;
-    *cmd++ = index >> 8;
-    *cmd = len;
-}
-
-/* Sends PS commands using vendor specficic HCI commands */
-static int write_ps_cmd(HC_BT_HDR *p_buf, uint8_t opcode, uint32_t ps_param)
-{
-    uint8_t cmd[HCI_CMD_MAX_LEN];
-
-    BTHWDBG("%s opcode %d", __func__, opcode);
-
-    switch (opcode) {
-        case PS_WRITE:
-            {
-                load_hci_ps_hdr(cmd, opcode, ps_list[ps_param].len,
-                                ps_list[ps_param].id);
-
-                memcpy(&cmd[HCI_PS_CMD_HDR_LEN], ps_list[ps_param].data,
-                                        ps_list[ps_param].len);
-
-                if (send_cmd(p_buf, cmd, ps_list[ps_param].len +
-                                            HCI_PS_CMD_HDR_LEN) < 0)
-                    return -EILSEQ;
-            }
-            break;
-        case ENABLE_PATCH:
-            {
-                load_hci_ps_hdr(cmd, opcode, 0, 0x00);
-
-                if (send_cmd(p_buf, cmd, HCI_PS_CMD_HDR_LEN) < 0)
-                    return -EILSEQ;
-            }
-            break;
-
-        case PS_RESET:
-            {
-                load_hci_ps_hdr(cmd, opcode, PS_RESET_PARAM_LEN, 0x00);
-
-                cmd[7] = 0x00;
-                cmd[8] = 0x00;
-                cmd[9] = 0x00;
-                cmd[10] = 0x00;
-
-                cmd[PS_RESET_CMD_LEN - 2] = ps_param & PS_ID_MASK;
-                cmd[PS_RESET_CMD_LEN - 1] = (ps_param >> 8) & PS_ID_MASK;
-
-                if (send_cmd(p_buf, cmd, PS_RESET_CMD_LEN) < 0)
-                    return -EILSEQ;
-            }
-            break;
-    }
-    return 0;
-}
-
-/* Parse PS entry preamble of format [X:X] for main type and subtype */
-static int get_ps_type(char *ptr, int index, char *type, char *sub_type)
-{
-    int i;
-    int delim = FALSE;
-
-    BTHWDBG("%s ", __func__);
-
-    if (index > MAX_PREAMBLE_LEN)
-        return -EILSEQ;
-
-    for (i = 1; i < index; i++) {
-        if (__is_delim(ptr[i])) {
-            delim = TRUE;
-            continue;
-        }
-
-        if (isalpha(ptr[i])) {
-            if (delim == FALSE)
-                (*type) = toupper(ptr[i]);
-            else
-                (*sub_type) = toupper(ptr[i]);
-        }
-    }
-    return 0;
-}
-
-static int get_input_format(char *buf, struct ps_entry_type *format)
-{
-    char *ptr = NULL;
-    char type = '\0';
-    char sub_type = '\0';
-
-    format->type = PS_HEX;
-    format->array = TRUE;
-
-    if (strstr(buf, "[") != buf)
-        return 0;
-
-    ptr = strstr(buf, "]");
-    if (!ptr)
-        return -EILSEQ;
-
-    if (get_ps_type(buf, ptr - buf, &type, &sub_type) < 0)
-        return -EILSEQ;
-
-    /* Check is data type is of array */
-    if (type == ARRAY || sub_type == ARRAY)
-        format->array = TRUE;
-
-    if (type == STRING || sub_type == STRING)
-        format->array = FALSE;
-
-    if (type == DECIMAL || type == BINARY)
-        format->type = PS_DEC;
-    else
-        format->type = PS_HEX;
-
-    return 0;
-}
-
-static unsigned int read_data_in_section(char *buf, struct ps_entry_type type)
-{
-    char *ptr = buf;
-
-    if (!buf)
-        return UNDEFINED;
-
-    if (buf == strstr(buf, "[")) {
-        ptr = strstr(buf, "]");
-        if (!ptr)
-            return UNDEFINED;
-
-        ptr++;
-    }
-
-    if (type.type == PS_HEX && type.array != TRUE)
-        return strtol(ptr, NULL, 16);
-
-    return UNDEFINED;
-}
-
-/* Read PS entries as string, convert and add to Hex array */
-static void update_tag_data(struct ps_cfg_entry *tag,
-                    struct tag_info *info, const char *ptr)
-{
-    char buf[3];
-
-    buf[2] = '\0';
-
-    strncpy(buf, &ptr[info->char_cnt], 2);
-    tag->data[info->byte_count] = strtol(buf, NULL, 16);
-    info->char_cnt += 3;
-    info->byte_count++;
-
-    strncpy(buf, &ptr[info->char_cnt], 2);
-    tag->data[info->byte_count] = strtol(buf, NULL, 16);
-    info->char_cnt += 3;
-    info->byte_count++;
-}
-
-static inline int update_char_count(const char *buf)
-{
-    char *end_ptr;
-
-    if (strstr(buf, "[") == buf) {
-        end_ptr = strstr(buf, "]");
-        if (!end_ptr)
-            return 0;
-        else
-            return (end_ptr - buf) + 1;
-    }
-
-    return 0;
-}
-
-static int ath_parse_ps(FILE *ps_stream)
-{
-    char buf[LINE_SIZE_MAX + 1];
-    char *ptr;
-    uint8_t tag_cnt = 0;
-    int16_t byte_count = 0;
-    struct ps_entry_type format;
-    struct tag_info status = { 0, 0, 0, 0 };
-
-    do{
-        int read_count;
-        struct ps_cfg_entry *tag;
-
-        ptr = fgets(buf, LINE_SIZE_MAX, ps_stream);
-        if (!ptr)
-            break;
-
-        __skip_space(ptr);
-        if (__check_comment(ptr))
-            continue;
-
-        /* Lines with a '#' will be followed by new PS entry */
-        if (ptr == strstr(ptr, "#")) {
-            if (status.section != PS_UNDEF) {
-                return -EILSEQ;
-            } else {
-                status.section = PS_ID;
-                continue;
-            }
-        }
-
-        tag = &ps_list[tag_cnt];
-
-        switch (status.section) {
-        case PS_ID:
-            if (get_input_format(ptr, &format) < 0)
-                return -EILSEQ;
-
-            tag->id = read_data_in_section(ptr, format);
-            status.section = PS_LEN;
-            break;
-
-        case PS_LEN:
-            if (get_input_format(ptr, &format) < 0)
-                return -EILSEQ;
-
-            byte_count = read_data_in_section(ptr, format);
-            if (byte_count > PS_MAX_LEN)
-                return -EILSEQ;
-
-            tag->len = byte_count;
-            tag->data = (uint8_t *)malloc(byte_count);
-
-            status.section = PS_DATA;
-            status.line_count = 0;
-            break;
-
-        case PS_DATA:
-            if (status.line_count == 0)
-                if (get_input_format(ptr, &format) < 0)
-                    return -EILSEQ;
-
-            __skip_space(ptr);
-
-            status.char_cnt = update_char_count(ptr);
-
-            read_count = (byte_count > ENTRY_PER_LINE) ?
-                    ENTRY_PER_LINE : byte_count;
-
-            if (format.type == PS_HEX && format.array == TRUE) {
-                while (read_count > 0) {
-                    update_tag_data(tag, &status, ptr);
-                    read_count -= 2;
-                }
-
-                if (byte_count > ENTRY_PER_LINE)
-                    byte_count -= ENTRY_PER_LINE;
-                else
-                    byte_count = 0;
-            }
-
-            status.line_count++;
-
-            if (byte_count == 0)
-                memset(&status, 0x00, sizeof(struct tag_info));
-
-            if (status.section == PS_UNDEF)
-                tag_cnt++;
-
-            if (tag_cnt == MAX_TAGS)
-                return -EILSEQ;
-            break;
-        }
-    } while (ptr);
-
-    return tag_cnt;
-}
-
-
-static int ps_reset_config(HC_BT_HDR *p_buf)
-{
-#define PS_RAM_SIZE 2048
-
-    if (write_ps_cmd(p_buf, PS_RESET, PS_RAM_SIZE) < 0)
-        return -1;
-    else
-        return 0;
-}
-
-static int ps_config_download(HC_BT_HDR *p_buf, int tag_count)
-{
-    if (write_ps_cmd(p_buf, PS_WRITE, tag_count) < 0)
-        return -1;
-    else
-        return 0;
-}
-
-static int set_patch_ram(HC_BT_HDR *p_buf, char *patch_loc)
-{
-    int err;
-    int i;
-    char loc_byte[3];
-    uint8_t *p;
-
-    if (!patch_loc)
-        return -1;
-
-    loc_byte[2] = '\0';
-
-    if (p_buf)
-    {
-        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-        p_buf->offset = 0;
-        p_buf->len = HCI_CMD_PREAMBLE_SIZE + PS_HDR_LEN + ADDRESS_LEN;
-        p_buf->layer_specific = 0;
-
-        p = (uint8_t *) (p_buf + 1);
-
-        UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
-        *p++ = PS_HDR_LEN + ADDRESS_LEN;
-        *p++ = SET_PATCH_RAM_ID;
-        *p++ = 0;
-        *p++ = 0 >> 8;
-        *p++ = ADDRESS_LEN;
-
-        for (i = 3; i >= 0; i--) {
-            loc_byte[0] = patch_loc[0];
-            loc_byte[1] = patch_loc[1];
-            *p++ = strtol(loc_byte, NULL, 16);
-            patch_loc += 2;
-        }
-
-        hw_cfg_cb.state = HW_CFG_PSPATCH_START_DOWNLOAD;
-        bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
-    }
-    return err;
-}
-
-
-static int enable_patch(HC_BT_HDR *p_buf)
-{
-    BTHWDBG("%s ", __func__);
-
-    if (write_ps_cmd(p_buf, ENABLE_PATCH, 0) < 0)
-        return -1;
-
-    return 0;
-}
-
-static int write_patch(HC_BT_HDR *p_buf)
-{
-    uint8_t ret = -1;
-    uint8_t *p;
-    int i;
-    BTHWDBG("%s ", __func__);
-
-    if (ps_counter==1)
-    {
-        ps_counter=2;
-        byte_cnt = strtol(ARptr, NULL, 16);
-    }
-
-    if (byte_cnt > 0) {
-        struct patch_entry patch;
-
-        if (byte_cnt > MAX_PATCH_CMD)
-            patch.len = MAX_PATCH_CMD;
-        else
-            patch.len = byte_cnt;
-
-        /* Read 2 bytes from the stream */
-        for (i = 0; i < patch.len; i++) {
-            if (!fgets(ARbyte, 3, rampatch_fd)) {
-                return -1;
-            }
-            /* Convert to integer */
-            patch.data[i] = strtoul(ARbyte, NULL, 16);
-        }
-
-        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-        p_buf->offset = 0;
-        p_buf->len = patch.len + HCI_CMD_PREAMBLE_SIZE + PS_CMD_WRITE_PATCH_PARAM_SIZE;
-        p_buf->layer_specific = 0;
-
-        p = (uint8_t *) (p_buf + 1);
-
-        /* Set opcode */
-        UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
-
-        /* Set length */
-        *p++ = patch.len + PS_CMD_WRITE_PATCH_PARAM_SIZE;
-        *p++ = WRITE_PATCH;
-        /* LSB, MSB of segment index */
-        *p++ = segment_idx;
-        *p++ = segment_idx >> 8;
-        /* Segment length */
-        *p++ = patch.len;
-
-        memcpy(p, patch.data, patch.len);
-
-        hw_cfg_cb.state = HW_CFG_PSPATCH_DOWNLOADING;
-        ret = bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
-
-        segment_idx++;
-        byte_cnt = byte_cnt - patch.len;
-
-    }
-    else {
-        /* Rampatch download complete, enable patch */
-        hw_cfg_cb.state = HW_CFG_PSPATCH_DOWNLOADED;
-        ret = enable_patch(p_buf);
-    }
-
-    return ret;
-}
-
-
-static int set_patch_ram_id(HC_BT_HDR *p_buf)
-{
-    int ret = 0;
-    BTHWDBG("%s ", __func__);
-
-    if (ps_counter == 0)
-    {
-        ps_counter = 1;
-        ARbyte[2] = '\0';
-    }
-
-    /* Get first token before newline */
-    while (fgets(ARptr, MAX_PATCH_CMD, rampatch_fd) != NULL) {
-        if (strlen(ARptr) <= 1) {
-            continue;
-        }
-        else if (strstr(ARptr, PATCH_LOC_KEY) == ARptr) {
-            strncpy(patch_loc, &ARptr[sizeof(PATCH_LOC_KEY) - 1],PATCH_LOC_STRING_LEN);
-            set_patch_ram(p_buf, patch_loc);
-            break; //wait for next time be called from cal back function.
-        } else if (isxdigit(ARptr[0])) {
-            if (write_patch(p_buf) < 0)
-                ret = -1;
-            break;
-        }
-        else
-            break;
-    }
-    return ret;
-}
-
-static void convert_bdaddr(char *bdaddr, char *p)
-{
-    char bdbyte[3];
-    char *str_byte = bdaddr;
-    int i;
-    int colon_present = 0;
-
-    if (strstr(bdaddr, ":"))
-        colon_present = 1;
-
-    bdbyte[2] = '\0';
-
-    /* Reverse the BDADDR to LSB first */
-    for (i = 5; i >= 0; i--) {
-        bdbyte[0] = str_byte[0];
-        bdbyte[1] = str_byte[1];
-        p[i] = strtol(bdbyte, NULL, 16);
-
-        if (colon_present == 1)
-            str_byte += 3;
-        else
-            str_byte += 2;
-    }
-}
-
-
-static int write_bdaddr(HC_BT_HDR *p_buf, char *bdaddr)
-{
-    uint8_t  *p = NULL;
-
-    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-    p_buf->offset = 0;
-    p_buf->layer_specific = 0;
-    p_buf->len = HCI_CMD_PREAMBLE_SIZE + PS_CMD_WRITE_BDADDR_PARAM_SIZE;
-    p = (uint8_t *) (p_buf + 1);
-
-    /* Set PS cmd opcode */
-    UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
-
-    *p++ = PS_CMD_WRITE_BDADDR_PARAM_SIZE;
-    /* PS_WRITE */
-    *p++ = 0x01;
-    /* LSB, MSB of PS tag ID */
-    *p++ = 0x01;
-    *p++ = 0x00;
-    /* Length of BDAddress */
-    *p++ = 0x06;
-    /* Convert and copy the bdaddr */
-    convert_bdaddr(bdaddr, (char *)p);
-
-    //Next one is HW_CFG_WRITE_BDADDRESS_DONE
-    bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
-
-    return 0;
-}
-
-static void write_bdaddr_from_file(HC_BT_HDR *p_buf, int rom_version)
-{
-    FILE *fd;
-    char bdaddr[MAX_BD_ADDR_LEN];
-    char bdaddr_file[PATH_MAX];
-
-    snprintf(bdaddr_file, MAXPATHLEN, "%s%x/%s",
-            fw_patchfile_path, rom_version, BDADDR_FILE);
-
-    fd = fopen(bdaddr_file, "r");
-    if (!fd) {
-        ALOGE("Cannot open bdaddr file %s", bdaddr_file);
-        /* Set BDAddr to 0 */
-        memset(bdaddr, 0, sizeof(bdaddr));
-        write_bdaddr(p_buf, bdaddr);
-        return;
-    }
-
-    /* Get the first token before newline in BD Address file */
-    if (fgets(bdaddr, MAX_BD_ADDR_LEN, fd))
-        write_bdaddr(p_buf, bdaddr);
-
-    fclose(fd);
-}
-
-static void get_ps_file_name(uint32_t devtype, uint32_t rom_version,
-                                char *path)
-{
-    char *filename;
-
-    if (devtype == 0xdeadc0de)
-        filename = PS_ASIC_FILE;
-    else
-        filename = PS_FPGA_FILE;
-
-    snprintf(path, MAXPATHLEN, "%s%x/%s",
-                fw_patchfile_path, rom_version, filename);
-}
-
-static void get_patch_file_name(uint32_t dev_type, uint32_t rom_version,
-                                uint32_t bld_version, char *path)
-{
-    if ((rom_version == FPGA_ROM_VERSION) && (dev_type != ROM_DEV_TYPE) &&
-                (dev_type != 0) && (bld_version == 1))
-        path[0] = '\0';
-    else
-        snprintf(path, MAXPATHLEN, "%s%x/%s",
-                    fw_patchfile_path, rom_version, PATCH_FILE);
-}
-
-/*******************************************************************************
-**
-** Function        line_speed_to_userial_baud
-**
-** Description     helper function converts line speed number into USERIAL baud
-**                 rate symbol
-**
-** Returns         unit8_t (USERIAL baud symbol)
-**
-*******************************************************************************/
-uint8_t line_speed_to_userial_baud(uint32_t line_speed)
-{
-    uint8_t baud;
-
-    if (line_speed == 4000000)
-        baud = USERIAL_BAUD_4M;
-    else if (line_speed == 3000000)
-        baud = USERIAL_BAUD_3M;
-    else if (line_speed == 2000000)
-        baud = USERIAL_BAUD_2M;
-    else if (line_speed == 1000000)
-        baud = USERIAL_BAUD_1M;
-    else if (line_speed == 921600)
-        baud = USERIAL_BAUD_921600;
-    else if (line_speed == 460800)
-        baud = USERIAL_BAUD_460800;
-    else if (line_speed == 230400)
-        baud = USERIAL_BAUD_230400;
-    else if (line_speed == 115200)
-        baud = USERIAL_BAUD_115200;
-    else if (line_speed == 57600)
-        baud = USERIAL_BAUD_57600;
-    else if (line_speed == 19200)
-        baud = USERIAL_BAUD_19200;
-    else if (line_speed == 9600)
-        baud = USERIAL_BAUD_9600;
-    else if (line_speed == 1200)
-        baud = USERIAL_BAUD_1200;
-    else if (line_speed == 600)
-        baud = USERIAL_BAUD_600;
-    else
-    {
-        ALOGE( "userial vendor: unsupported baud speed %d", line_speed);
-        baud = USERIAL_BAUD_115200;
-    }
-
-    return baud;
-}
-
-static void set_cntrlr_baud(HC_BT_HDR *p_buf, int speed)
-{
-    BTHWDBG(" %s ", __FUNCTION__);
-
-    int baud;
-    uint8_t *p;
-
-    /* set controller baud rate to user specified value */
-
-    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-    p_buf->offset = 0;
-    p_buf->layer_specific = 0;
-    p_buf->len = HCI_CMD_PREAMBLE_SIZE + CHG_BAUD_CMD_PARAM_SIZE;
-
-    p = (uint8_t *)(p_buf + 1);
-
-    /* Set opcode */
-    UINT16_TO_STREAM(p, HCI_VSC_CHG_BAUD_CMD);
-    /* Set length */
-    *p++ = CHG_BAUD_CMD_PARAM_SIZE;
-
-    /* baud should be set as real baud/100 */
-    baud = speed/100;
-    /* Set baud LSB */
-    *p++ = baud & 0xff;
-    /* Set baud MSB */
-    *p = (baud >> 8) & 0xff;
-
-    bt_vendor_cbacks->xmit_cb(HCI_VSC_CHG_BAUD_CMD, p_buf, hw_config_cback);
-}
-
-void hw_config_start(void)
-{
-    HC_BT_HDR  *p_buf = NULL;
-    uint8_t     *p;
-
-    hw_cfg_cb.state = 0;
-    hw_cfg_cb.fw_fd = -1;
-    hw_cfg_cb.f_set_baud_2 = FALSE;
-    ps_counter=0;
-    current_tag_idx=0;
-    segment_idx=0;
-
-    BTHWDBG("%s ", __func__);
-
-    /* Start from sending HCI_RESET */
-
-    if (bt_vendor_cbacks)
-    {
-        p_buf = (HC_BT_HDR *) bt_vendor_cbacks->alloc(BT_HC_HDR_SIZE + \
-                                                       HCI_CMD_PREAMBLE_SIZE);
-    }
-
-    if (p_buf)
-    {
-        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-        p_buf->offset = 0;
-        p_buf->layer_specific = 0;
-        p_buf->len = HCI_CMD_PREAMBLE_SIZE;
-
-        p = (uint8_t *) (p_buf + 1);
-        UINT16_TO_STREAM(p, HCI_RESET);
-        *p = 0; /* parameter length */
-
-        hw_cfg_cb.state = HW_CFG_START;
-
-        bt_vendor_cbacks->xmit_cb(HCI_RESET, p_buf, hw_config_cback);
-    }
-    else
-    {
-        if (bt_vendor_cbacks)
-        {
-            ALOGE("vendor lib fw conf aborted [no buffer]");
-            bt_vendor_cbacks->fwcfg_cb(BT_VND_OP_RESULT_FAIL);
-        }
-    }
-}
-
-/*******************************************************************************
-**
-** Function         hw_config_cback
-**
-** Description      Callback function for controller configuration
-**
-** Returns          None
-**
-*******************************************************************************/
-void hw_config_cback(void *p_mem)
-{
-    HC_BT_HDR *p_evt_buf = (HC_BT_HDR *) p_mem;
-    char *p_tmp;
-    uint8_t *p, status;
-    uint16_t opcode;
-    HC_BT_HDR *p_buf=NULL;
-
-    status = *((uint8_t *)(p_evt_buf + 1) + HCI_EVT_CMD_CMPL_STATUS_RET_BYTE);
-    p = (uint8_t *)(p_evt_buf + 1) + HCI_EVT_CMD_CMPL_OPCODE;
-    STREAM_TO_UINT16(opcode,p);
-
-    BTHWDBG("Call back state %d status 0x%x, with opcode 0x%x", hw_cfg_cb.state, status, opcode);
-
-    /* Ask a new buffer big enough to hold any HCI commands sent in here */
-    /* HW_CFG_GET_ATH3K_CRC return non-zero if controller has no ram patch or PS config  */
-    if (((status == 0)&& bt_vendor_cbacks) ||
-        ((status != 0)&& bt_vendor_cbacks && (opcode == 0xfc0b) && (hw_cfg_cb.state == HW_CFG_GET_ATH3K_CRC)))
-        p_buf = (HC_BT_HDR *) bt_vendor_cbacks->alloc(BT_HC_HDR_SIZE + HCI_CMD_MAX_LEN);
-
-    if (p_buf != NULL)
-    {
-        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-        p_buf->offset = 0;
-        p_buf->len = 0;
-        p_buf->layer_specific = 0;
-        p = (uint8_t *) (p_buf + 1);
-
-        switch (hw_cfg_cb.state)
-        {
-            case HW_CFG_START:
-                {
-                    hw_cfg_cb.state = HW_CFG_SET_CNTRLR_BAUD;
-                    set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                }
-                break;
-
-            case HW_CFG_SET_CNTRLR_BAUD:
-                {
-                    /* Set UART Baud after Ctrl Baud is set */
-                    userial_vendor_set_baud(line_speed_to_userial_baud(UART_TARGET_BAUD_RATE));
-
-
-                    //Next one is HW_CFG_GET_DEVICE_TYPE
-
-                    //*  --------------------------------------------
-                    //*  |  HC_BT_HDR  |  HCI command         |
-                    //*  --------------------------------------------
-                    //*
-                    //*     AR3002 HCI command
-                    //*  --------------------------------------------------------
-                    //*  |  packet type(1) | opcode (2)  | length(1) | command parameter |
-                    //*  --------------------------------------------------------
-                    //*
-                    //* So, the packet format will be:
-                    //*  ------------------------------------------------------------------------
-                    //*  |  HC_BT_HDR  | packet type(1) | opcode (2)  | length(1) | command parameter |
-                    //*  ------------------------------------------------------------------------
-
-                    p_buf->len = HCI_CMD_PREAMBLE_SIZE + GET_DEV_TYPE_CMD_PARAM_SIZE;
-
-                    /* Set opcode */
-                    UINT16_TO_STREAM(p, HCI_VSC_GET_DEV_TYPE);
-                    /* Set length */
-                    *p++ = GET_DEV_TYPE_CMD_PARAM_SIZE;
-
-                    /* Set Register Address */
-                    *p++ = (uint8_t)DEV_REGISTER;
-                    *p++ = (uint8_t)(DEV_REGISTER >> 8);
-                    *p++ = (uint8_t)(DEV_REGISTER >> 16);
-                    *p++ = (uint8_t)(DEV_REGISTER >> 24);
-                    /* Set length to read */
-                    *p = 0x04;
-
-                    hw_cfg_cb.state = HW_CFG_GET_DEVICE_TYPE;
-                    bt_vendor_cbacks->xmit_cb(HCI_VSC_GET_DEV_TYPE, p_buf, hw_config_cback);
-                }
-                break;
-            case HW_CFG_GET_DEVICE_TYPE:
-                {
-                    p_tmp = (char *) (p_evt_buf + 1 ) + HCI_EVT_CMD_CMPL_RESPONSE;
-
-                    /* MSB of device type */
-                    dev_type = *(p_tmp + 3);
-                    dev_type = (dev_type << 8) | *(p_tmp + 2);
-                    /* LSB of device type */
-                    dev_type = (dev_type << 8) | *(p_tmp + 1);
-                    dev_type = (dev_type << 8) | *(p_tmp );
-
-                    ALOGI("AR3002 dev_type %x", dev_type);
-
-                    //Next one is  HW_CFG_GET_ATH3K_VERSION
-
-                    p_buf->len = HCI_CMD_PREAMBLE_SIZE;
-
-                    /* Set opcode */
-                    UINT16_TO_STREAM(p, HCI_VSC_GET_VERSION);
-                    *p = 0;
-
-                    hw_cfg_cb.state = HW_CFG_GET_ATH3K_VERSION;
-                    bt_vendor_cbacks->xmit_cb(HCI_VSC_GET_VERSION, p_buf, hw_config_cback);
-
-                }
-                break;
-            case HW_CFG_GET_ATH3K_VERSION:
-                {
-                    p_tmp = (char *) (p_evt_buf +1 ) + HCI_EVT_CMD_CMPL_RESPONSE;
-
-                    /* Assemble ROM version from response */
-                    rom_version = *(p_tmp + 3);
-                    rom_version = (rom_version << 8) | *(p_tmp + 2);
-                    rom_version = (rom_version << 8) | *(p_tmp + 1);
-                    rom_version = (rom_version << 8) | *(p_tmp);
-
-                    /* Assemble Build version from response */
-                    bld_version = *(p_tmp + 7);
-                    bld_version = (bld_version << 8) | *(p_tmp + 6);
-                    bld_version = (bld_version << 8) | *(p_tmp + 5);
-                    bld_version = (bld_version << 8) | *(p_tmp + 4);
-
-                    ALOGI("AR3002 rom_version %x ,bld_version %x ", rom_version, bld_version);
-
-                    //Next one is HW_CFG_GET_ATH3K_CRC
-                    p_buf->len = HCI_CMD_PREAMBLE_SIZE + PS_CMD_GET_CRC_PARAM_SIZE;
-
-                    /* Set opcode */
-                    UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
-                    /* Set length */
-                    *p++ = PS_CMD_GET_CRC_PARAM_SIZE;
-                    *p++ = VERIFY_CRC;
-                    /* Memory region LSB, MSB */
-                    *p++ = PS_REGION|PATCH_REGION;
-                    *p++ = (PS_REGION|PATCH_REGION) >> 8;
-                    *p   = 0; /* Length */
-
-                    hw_cfg_cb.state = HW_CFG_GET_ATH3K_CRC;
-
-                    bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
-                }
-                break;
-            case HW_CFG_GET_ATH3K_CRC:
-                {
-                    FILE *fd = 0;
-
-                    if  ( status == 0 )
-                    {
-                        ALOGI("bt vendor lib: AR3K already has ram patch and PS configuration;\
-                                                        there is no need to download them. ");
-                        /* Set bdaddr, Next one is HW_CFG_WRITE_BDADDRESS_DONE */
-                        hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS_DONE;
-                        write_bdaddr_from_file(p_buf, rom_version);
-                        break;
-                    }
-
-                    /* Get PS config file name */
-                    get_ps_file_name(dev_type, rom_version, ps_file);
-                    /* Get Ram Patch file name */
-                    get_patch_file_name(dev_type, rom_version, bld_version, patch_file);
-
-                    /* Open PS config file */
-                    fd = fopen(ps_file, "r");
-                    if (!fd) {
-                        ALOGE("PS config file open error");
-                        /* No PS config file, Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
-                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                        break;
-                    }
-
-                    /* Parse the PS config file and get number of tags */
-                    tag_count = ath_parse_ps(fd);
-
-                    /* Close PS config file */
-                    fclose(fd);
-
-                    if (tag_count < 0) {
-                        ALOGE("tag_count < 0\n");
-                        /* Set bdaddr, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
-                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                        break;
-                    }
-
-                    rampatch_fd = fopen(patch_file, "r");
-                    if (!rampatch_fd) {
-                        ALOGE("Rampatch file open error");
-                        /* No RamPatchfile, Set bdaddr, Next one is HW_CFG_WRITE_BDADDRESS_DONE */
-                        hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS_DONE;
-                        write_bdaddr_from_file(p_buf, rom_version);
-                        break;
-                    }
-                    else {
-                        if (set_patch_ram_id(p_buf) < 0) {
-                            ALOGE("PS patch write error");
-                            /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
-                            hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-                            set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                            break;
-                        }
-                    }
-                }
-                break;
-            case HW_CFG_PSPATCH_START_DOWNLOAD:
-            case HW_CFG_PSPATCH_DOWNLOADING:
-                {
-                    if (write_patch(p_buf) < 0) {
-                        ALOGE("PS patch write error");
-                        /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
-                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                        break;
-                    }
-                }
-                break;
-            case HW_CFG_PSPATCH_DOWNLOADED:
-                {
-                    /* RamPatch download finished, close the file */
-                    fclose(rampatch_fd);
-
-                    if (segment_idx < 0) {
-                        ALOGE("segment_idx < 0\n");
-                    }
-                    hw_cfg_cb.state = HW_CFG_CONFIG_RESET;
-                    if (ps_reset_config(p_buf) < 0) {
-                        ALOGE("PS patch write error");
-                        /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
-                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                        break;
-                    }
-                }
-                break;
-            case HW_CFG_CONFIG_RESET:
-            case HW_CFG_CONFIG_DOWNLOADING:
-                {
-                    if (ps_config_download(p_buf, current_tag_idx) < 0) {
-                        ALOGE("PS config write error");
-                        /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
-                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                        break;
-                    }
-                    current_tag_idx++;
-                    if(tag_count == current_tag_idx) {
-                        hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS;
-                    }
-                    else
-                        hw_cfg_cb.state = HW_CFG_CONFIG_DOWNLOADING;
-                }
-                break;
-            case HW_CFG_WRITE_BDADDRESS:
-                {
-                    /* Write BDADDR */
-                    hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS_DONE;
-                    write_bdaddr_from_file(p_buf, rom_version);
-                }
-                break;
-            case HW_CFG_WRITE_BDADDRESS_DONE:
-                {
-                    /* Send HCI_RESET to enable patch */
-                    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
-                    p_buf->offset = 0;
-                    p_buf->layer_specific = 0;
-                    p_buf->len = HCI_CMD_PREAMBLE_SIZE;
-
-                    p = (uint8_t *) (p_buf + 1);
-                    UINT16_TO_STREAM(p, HCI_RESET);
-                    *p = 0; /* parameter length */
-
-                    hw_cfg_cb.state = HW_CFG_HCI_RESET;
-
-                    bt_vendor_cbacks->xmit_cb(HCI_RESET, p_buf, hw_config_cback);
-                }
-                break;
-            case HW_CFG_HCI_RESET:
-                {
-                    /* Set BT controller baud */
-                    hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
-
-                    set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
-                }
-                break;
-            case HW_CFG_CNTRLR_BAUD_UPDATE:
-                {
-                    /* Set the UART port Baud */
-                    userial_vendor_set_baud(line_speed_to_userial_baud(UART_TARGET_BAUD_RATE));
-
-                    hw_cfg_cb.state = 0;
-                    bt_vendor_cbacks->dealloc(p_buf);
-                    bt_vendor_cbacks->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
-                }
-                break;
-            default:
-                break;
-        } // switch(hw_cfg_cb.state)
-    } // if (p_buf != NULL)
-
-    /* Free the RX event buffer */
-    if (bt_vendor_cbacks)
-        bt_vendor_cbacks->dealloc(p_evt_buf);
-}
-
-/*******************************************************************************
-**
-** Function        hw_set_patch_file_path
-**
-** Description     Set the location of firmware patch file
-**
-** Returns         0 : Success
-**                 Otherwise : Fail
-**
-*******************************************************************************/
-int hw_set_patch_file_path(char *p_conf_name, char *p_conf_value, int param)
-{
-    strcpy(fw_patchfile_path, p_conf_value);
-
-    return 0;
-}
-
diff --git a/libbt-ath3k/src/hardware_QCA3002.c b/libbt-ath3k/src/hardware_QCA3002.c
new file mode 100644
index 0000000..e39e43b
--- /dev/null
+++ b/libbt-ath3k/src/hardware_QCA3002.c
@@ -0,0 +1,1465 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Filename:      hardware.c
+ *
+ *  Description:   Contains controller-specific functions, like
+ *                      firmware patch download
+ *                      low power mode operations
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_hwcfg"
+
+#include <utils/Log.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include <time.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <ctype.h>
+#include <cutils/properties.h>
+#include <stdlib.h>
+#include <termios.h>
+
+#include "hci.h"
+#include "bt_hci_bdroid.h"
+#include "bt_vendor_QCA3002.h"
+
+#define MAX_CNT_RETRY 100
+
+/* HCI Packet types */
+#define HCI_COMMAND_PKT		0x01
+#define HCI_ACLDATA_PKT		0x02
+#define HCI_SCODATA_PKT		0x03
+#define HCI_EVENT_PKT		0x04
+#define HCI_VENDOR_PKT		0xff
+
+#define HCI_MAX_EVENT_SIZE	260
+#define HCI_CHG_BAUD_CMD_OCF 0x0C
+#define HCI_VENDOR_CMD_OGF 0x3F
+#define WRITE_BDADDR_CMD_LEN 14
+#define WRITE_BAUD_CMD_LEN   6
+#define MAX_CMD_LEN WRITE_BDADDR_CMD_LEN
+#define GET_VERSION_OCF 0x1E
+/* Byte order conversions */
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define htobs(d)  (d)
+#define htobl(d)  (d)
+#define btohs(d)  (d)
+#define btohl(d)  (d)
+#elif __BYTE_ORDER == __BIG_ENDIAN
+#define htobs(d)  bswap_16(d)
+#define htobl(d)  bswap_32(d)
+#define btohs(d)  bswap_16(d)
+#define btohl(d)  bswap_32(d)
+#else
+#error "Unknown byte order"
+#endif
+
+#define HCI_RESET                               0x0C03
+
+ 
+#define STREAM_TO_UINT16(u16, p) {u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); (p) += 2;}
+#define UINT16_TO_STREAM(p, u16) {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8);}
+#define UINT32_TO_STREAM(p, u32) {*(p)++ = (uint8_t)(u32); *(p)++ = (uint8_t)((u32) >> 8); *(p)++ = (uint8_t)((u32) >> 16); *(p)++ = (uint8_t)((u32) >> 24);}
+
+#define MAX_TAGS              50
+#define PS_HDR_LEN            4
+#define HCI_VENDOR_CMD_OGF    0x3F
+#define HCI_PS_CMD_OCF        0x0B
+
+#define VERIFY_CRC   9
+#define PS_REGION    1
+#define PATCH_REGION 2
+#define BDADDR_FILE "ar3kbdaddr.pst"
+
+
+#define MAX_PATCH_CMD 244
+struct patch_entry {
+	int16_t len;
+	uint8_t data[MAX_PATCH_CMD];
+};
+#define HCI_UART_RAW_DEVICE	0
+#define HCI_COMMAND_HDR_SIZE 3
+#define PS_WRITE           1
+#define PS_RESET           2
+#define WRITE_PATCH        8
+#define ENABLE_PATCH       11
+
+#define HCI_PS_CMD_HDR_LEN 7
+#define HCI_CMD_MAX_LEN             258
+#define PS_RESET_PARAM_LEN 6
+#define HCI_MAX_CMD_SIZE   260
+#define PS_RESET_CMD_LEN   (HCI_PS_CMD_HDR_LEN + PS_RESET_PARAM_LEN)
+
+#define PS_ID_MASK         0xFF
+
+
+#define LOCAL_NAME_BUFFER_LEN                   32
+#define DEV_REGISTER      0x4FFC
+#define GET_DEV_TYPE_OCF  0x05
+
+#define HCI_EV_SUCCESS        0x00
+int cbstat = 0;
+#define PATCH_LOC_STRING_LEN   8
+char ARbyte[3];
+char ARptr[MAX_PATCH_CMD + 1];
+int byte_cnt;
+int patch_count = 0;
+char patch_loc[PATCH_LOC_STRING_LEN + 1];
+int PSCounter=0;
+
+uint32_t dev_type = 0;
+uint32_t rom_version = 0;
+uint32_t build_version = 0;
+
+char patch_file[PATH_MAX];
+char ps_file[PATH_MAX];
+FILE *stream;
+int tag_count=0;
+struct tag_info {
+	unsigned section;
+	unsigned line_count;
+	unsigned char_cnt;
+	unsigned byte_count;
+};
+
+struct ps_cfg_entry {
+	uint32_t id;
+	uint32_t len;
+	uint8_t *data;
+};
+
+struct ps_entry_type {
+	unsigned char type;
+	unsigned char array;
+};
+
+struct uart_t {
+	char *type;
+	int  m_id;
+	int  p_id;
+	int  proto;
+	int  init_speed;
+	int  speed;
+	int  flags;
+	int  pm;
+	char *bdaddr;
+	int  (*init) (int fd, struct uart_t *u, struct termios *ti);
+	int  (*post) (int fd, struct uart_t *u, struct termios *ti);
+};
+
+struct ps_cfg_entry ps_list[MAX_TAGS];
+
+#define PS_EVENT_LEN 100
+
+/*
+ * Read an HCI event from the given file descriptor.
+ */
+int read_hci_event(int fd, unsigned char* buf, int size)
+{
+    int remain, r;
+    int count = 0;
+
+    if (size <= 0)
+        return -1;
+
+    /* The first byte identifies the packet type. For HCI event packets, it
+     * should be 0x04, so we read until we get to the 0x04. */
+    while (1) {
+        r = read(fd, buf, 1);
+        if (r <= 0)
+            return -1;
+        if (buf[0] == 0x04)
+            break;
+    }
+    count++;
+
+    /* The next two bytes are the event code and parameter total length. */
+        while (count < 3) {
+                r = read(fd, buf + count, 3 - count);
+                if (r <= 0)
+                        return -1;
+                count += r;
+        }
+
+        /* Now we read the parameters. */
+        if (buf[2] < (size - 3))
+                remain = buf[2];
+        else
+                remain = size - 3;
+
+        while ((count - 3) < remain) {
+                r = read(fd, buf + count, remain - (count - 3));
+                if (r <= 0)
+                        return -1;
+                count += r;
+        }
+
+        return count;
+}
+/*
+ * Send HCI command and wait for command complete event.
+ * The event buffer has to be freed by the caller.
+ */
+static int send_hci_cmd_sync(int dev, uint8_t *cmd, int len, uint8_t **event)
+{
+    int err;
+    uint8_t *hci_event;
+    uint8_t pkt_type = HCI_COMMAND_PKT;
+
+    if (len == 0)
+        return len;
+
+    if (write(dev, &pkt_type, 1) != 1)
+        return -EILSEQ;
+    if (write(dev, (unsigned char *)cmd, len) != len)
+        return -EILSEQ;
+
+    hci_event = (uint8_t *)malloc(PS_EVENT_LEN);
+    if (!hci_event)
+        return -ENOMEM;
+
+    err = read_hci_event(dev, (unsigned char *)hci_event, PS_EVENT_LEN);
+    if (err > 0) {
+        *event = hci_event;
+    } else {
+        free(hci_event);
+        return -EILSEQ;
+    }
+
+    return len;
+}
+
+static void convert_bdaddr(char *str_bdaddr, char *bdaddr)
+{
+    char bdbyte[3];
+    char *str_byte = str_bdaddr;
+    int i, j;
+    int colon_present = 0;
+
+    if (strstr(str_bdaddr, ":"))
+        colon_present = 1;
+
+    bdbyte[2] = '\0';
+
+    /* Reverse the BDADDR to LSB first */
+    for (i = 0, j = 5; i < 6; i++, j--) {
+        bdbyte[0] = str_byte[0];
+        bdbyte[1] = str_byte[1];
+        bdaddr[j] = strtol(bdbyte, NULL, 16);
+
+        if (colon_present == 1)
+            str_byte += 3;
+        else
+            str_byte += 2;
+    }
+}
+
+static int uart_speed(int s)
+{
+    switch (s) {
+        case 9600:
+            return B9600;
+        case 19200:
+            return B19200;
+        case 38400:
+            return B38400;
+        case 57600:
+            return B57600;
+        case 115200:
+            return B115200;
+        case 230400:
+            return B230400;
+        case 460800:
+            return B460800;
+        case 500000:
+            return B500000;
+        case 576000:
+            return B576000;
+        case 921600:
+            return B921600;
+        case 1000000:
+            return B1000000;
+        case 1152000:
+            return B1152000;
+        case 1500000:
+            return B1500000;
+        case 2000000:
+            return B2000000;
+#ifdef B2500000
+        case 2500000:
+            return B2500000;
+#endif
+#ifdef B3000000
+        case 3000000:
+            return B3000000;
+#endif
+#ifdef B3500000
+        case 3500000:
+            return B3500000;
+#endif
+#ifdef B4000000
+        case 4000000:
+            return B4000000;
+#endif
+        default:
+            return B57600;
+    }
+}
+
+int set_speed(int fd, struct termios *ti, int speed)
+{
+    if (cfsetospeed(ti, uart_speed(speed)) < 0)
+        return -errno;
+
+    if (cfsetispeed(ti, uart_speed(speed)) < 0)
+        return -errno;
+
+    if (tcsetattr(fd, TCSANOW, ti) < 0)
+        return -errno;
+
+    return 0;
+}
+
+static void load_hci_ps_hdr(uint8_t *cmd, uint8_t ps_op, int len, int index)
+{
+    hci_command_hdr *ch = (void *)cmd;
+
+    ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
+                HCI_PS_CMD_OCF));
+    ch->plen = len + PS_HDR_LEN;
+    cmd += HCI_COMMAND_HDR_SIZE;
+
+    cmd[0] = ps_op;
+    cmd[1] = index;
+    cmd[2] = index >> 8;
+    cmd[3] = len;
+}
+
+
+static int read_ps_event(uint8_t *event, uint16_t ocf)
+{
+    hci_event_hdr *eh;
+    uint16_t opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF, ocf));
+
+    event++;
+
+    eh = (void *)event;
+    event += HCI_EVENT_HDR_SIZE;
+
+    if (eh->evt == EVT_CMD_COMPLETE) {
+        evt_cmd_complete *cc = (void *)event;
+
+        event += EVT_CMD_COMPLETE_SIZE;
+
+        if (cc->opcode == opcode && event[0] == HCI_EV_SUCCESS)
+            return 0;
+        else
+            return -EILSEQ;
+    }
+
+    return -EILSEQ;
+}
+
+#define PS_WRITE           1
+#define PS_RESET           2
+#define WRITE_PATCH        8
+#define ENABLE_PATCH       11
+
+#define HCI_PS_CMD_HDR_LEN 7
+
+static int write_cmd(int fd, uint8_t *buffer, int len)
+{
+    uint8_t *event;
+    int err;
+
+    err = send_hci_cmd_sync(fd, buffer, len, &event);
+    if (err < 0)
+        return err;
+
+    err = read_ps_event(event, HCI_PS_CMD_OCF);
+
+    free(event);
+
+    return err;
+}
+
+#define PS_RESET_PARAM_LEN 6
+#define HCI_MAX_CMD_SIZE   260
+#define PS_RESET_CMD_LEN   (HCI_PS_CMD_HDR_LEN + PS_RESET_PARAM_LEN)
+
+#define PS_ID_MASK         0xFF
+
+/* Sends PS commands using vendor specficic HCI commands */
+static int write_ps_cmd(int fd, uint8_t opcode, uint32_t ps_param)
+{
+    uint8_t cmd[HCI_MAX_CMD_SIZE];
+    uint32_t i;
+
+    switch (opcode) {
+        case ENABLE_PATCH:
+            load_hci_ps_hdr(cmd, opcode, 0, 0x00);
+
+            if (write_cmd(fd, cmd, HCI_PS_CMD_HDR_LEN) < 0)
+                return -EILSEQ;
+            break;
+
+        case PS_RESET:
+            load_hci_ps_hdr(cmd, opcode, PS_RESET_PARAM_LEN, 0x00);
+
+            cmd[7] = 0x00;
+            cmd[PS_RESET_CMD_LEN - 2] = ps_param & PS_ID_MASK;
+            cmd[PS_RESET_CMD_LEN - 1] = (ps_param >> 8) & PS_ID_MASK;
+
+            if (write_cmd(fd, cmd, PS_RESET_CMD_LEN) < 0)
+                return -EILSEQ;
+            break;
+
+        case PS_WRITE:
+            for (i = 0; i < ps_param; i++) {
+                load_hci_ps_hdr(cmd, opcode, ps_list[i].len,
+                        ps_list[i].id);
+
+                memcpy(&cmd[HCI_PS_CMD_HDR_LEN], ps_list[i].data,
+                        ps_list[i].len);
+
+                if (write_cmd(fd, cmd, ps_list[i].len +
+                            HCI_PS_CMD_HDR_LEN) < 0)
+                    return -EILSEQ;
+            }
+            break;
+    }
+
+    return 0;
+}
+
+
+
+
+#define PS_ASIC_FILE			"PS_ASIC.pst"
+#define PS_FPGA_FILE			"PS_FPGA.pst"
+#define MAXPATHLEN			4096
+static void get_ps_file_name(uint32_t devtype, uint32_t rom_version,char *path)
+{
+    char *filename;
+
+    if (devtype == 0xdeadc0de)
+        filename = PS_ASIC_FILE;
+    else
+        filename = PS_FPGA_FILE;
+
+    snprintf(path, MAXPATHLEN, "%s%x/%s", FW_PATCHFILE_LOCATION, rom_version, filename);
+}
+
+#define PATCH_FILE        "RamPatch.txt"
+#define FPGA_ROM_VERSION  0x99999999
+#define ROM_DEV_TYPE      0xdeadc0de
+
+static void get_patch_file_name(uint32_t dev_type, uint32_t rom_version,
+        uint32_t build_version, char *path)
+{
+    if (rom_version == FPGA_ROM_VERSION && dev_type != ROM_DEV_TYPE &&dev_type != 0 && build_version == 1)
+        path[0] = '\0';
+    else
+        snprintf(path, MAXPATHLEN, "%s%x/%s",
+                FW_PATCHFILE_LOCATION, rom_version, PATCH_FILE);
+}
+
+
+
+static int set_cntrlr_baud(int fd, int speed)
+{
+    int baud;
+    struct timespec tm = { 0, 500000 };
+    unsigned char cmd[MAX_CMD_LEN], rsp[HCI_MAX_EVENT_SIZE];
+    unsigned char *ptr = cmd + 1;
+    hci_command_hdr *ch = (void *)ptr;
+
+    cmd[0] = HCI_COMMAND_PKT;
+
+    /* set controller baud rate to user specified value */
+    ptr = cmd + 1;
+    ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
+                HCI_CHG_BAUD_CMD_OCF));
+    ch->plen = 2;
+    ptr += HCI_COMMAND_HDR_SIZE;
+
+    baud = speed/100;
+    ptr[0] = (char)baud;
+    ptr[1] = (char)(baud >> 8);
+
+    if (write(fd, cmd, WRITE_BAUD_CMD_LEN) != WRITE_BAUD_CMD_LEN) {
+        ALOGI("Failed to write change baud rate command");
+        return -ETIMEDOUT;
+    }
+
+    nanosleep(&tm, NULL);
+
+    if (read_hci_event(fd, rsp, sizeof(rsp)) < 0)
+        return -ETIMEDOUT;
+
+    return 0;
+}
+
+#define PS_UNDEF   0
+#define PS_ID      1
+#define PS_LEN     2
+#define PS_DATA    3
+
+#define PS_MAX_LEN         500
+#define LINE_SIZE_MAX      (PS_MAX_LEN * 2)
+#define ENTRY_PER_LINE     16
+
+#define __check_comment(buf) (((buf)[0] == '/') && ((buf)[1] == '/'))
+#define __skip_space(str)      while (*(str) == ' ') ((str)++)
+
+
+#define __is_delim(ch) ((ch) == ':')
+#define MAX_PREAMBLE_LEN 4
+
+/* Parse PS entry preamble of format [X:X] for main type and subtype */
+static int get_ps_type(char *ptr, int index, char *type, char *sub_type)
+{
+    int i;
+    int delim = FALSE;
+
+    if (index > MAX_PREAMBLE_LEN)
+        return -EILSEQ;
+
+    for (i = 1; i < index; i++) {
+        if (__is_delim(ptr[i])) {
+            delim = TRUE;
+            continue;
+        }
+
+        if (isalpha(ptr[i])) {
+            if (delim == FALSE)
+                (*type) = toupper(ptr[i]);
+            else
+                (*sub_type) = toupper(ptr[i]);
+        }
+    }
+
+    return 0;
+}
+
+#define ARRAY   'A'
+#define STRING  'S'
+#define DECIMAL 'D'
+#define BINARY  'B'
+
+#define PS_HEX           0
+#define PS_DEC           1
+
+static int get_input_format(char *buf, struct ps_entry_type *format)
+{
+    char *ptr = NULL;
+    char type = '\0';
+    char sub_type = '\0';
+
+    format->type = PS_HEX;
+    format->array = TRUE;
+
+    if (strstr(buf, "[") != buf)
+        return 0;
+
+    ptr = strstr(buf, "]");
+    if (!ptr)
+        return -EILSEQ;
+
+    if (get_ps_type(buf, ptr - buf, &type, &sub_type) < 0)
+        return -EILSEQ;
+
+    /* Check is data type is of array */
+    if (type == ARRAY || sub_type == ARRAY)
+        format->array = TRUE;
+
+    if (type == STRING || sub_type == STRING)
+        format->array = FALSE;
+
+    if (type == DECIMAL || type == BINARY)
+        format->type = PS_DEC;
+    else
+        format->type = PS_HEX;
+
+    return 0;
+}
+
+
+
+#define UNDEFINED 0xFFFF
+
+static unsigned int read_data_in_section(char *buf, struct ps_entry_type type)
+{
+    char *ptr = buf;
+
+    if (!buf)
+        return UNDEFINED;
+
+    if (buf == strstr(buf, "[")) {
+        ptr = strstr(buf, "]");
+        if (!ptr)
+            return UNDEFINED;
+
+        ptr++;
+    }
+
+    if (type.type == PS_HEX && type.array != TRUE)
+        return strtol(ptr, NULL, 16);
+
+    return UNDEFINED;
+}
+
+
+/* Read PS entries as string, convert and add to Hex array */
+static void update_tag_data(struct ps_cfg_entry *tag,
+        struct tag_info *info, const char *ptr)
+{
+    char buf[3];
+
+    buf[2] = '\0';
+
+    strncpy(buf, &ptr[info->char_cnt], 2);
+    tag->data[info->byte_count] = strtol(buf, NULL, 16);
+    info->char_cnt += 3;
+    info->byte_count++;
+
+    strncpy(buf, &ptr[info->char_cnt], 2);
+    tag->data[info->byte_count] = strtol(buf, NULL, 16);
+    info->char_cnt += 3;
+    info->byte_count++;
+}
+
+static inline int update_char_count(const char *buf)
+{
+    char *end_ptr;
+
+    if (strstr(buf, "[") == buf) {
+        end_ptr = strstr(buf, "]");
+        if (!end_ptr)
+            return 0;
+        else
+            return (end_ptr - buf) + 1;
+    }
+
+    return 0;
+}
+#define PS_HEX           0
+#define PS_DEC           1
+
+static int ath_parse_ps(FILE *stream)
+{
+    char buf[LINE_SIZE_MAX + 1];
+    char *ptr;
+    uint8_t tag_cnt = 0;
+    int16_t byte_count = 0;
+    struct ps_entry_type format;
+    struct tag_info status = { 0, 0, 0, 0 };
+
+    do {
+        int read_count;
+        struct ps_cfg_entry *tag;
+
+        ptr = fgets(buf, LINE_SIZE_MAX, stream);
+        if (!ptr)
+            break;
+
+        __skip_space(ptr);
+        if (__check_comment(ptr))
+            continue;
+
+        /* Lines with a '#' will be followed by new PS entry */
+        if (ptr == strstr(ptr, "#")) {
+            if (status.section != PS_UNDEF) {
+                return -EILSEQ;
+            } else {
+                status.section = PS_ID;
+                continue;
+            }
+        }
+
+        tag = &ps_list[tag_cnt];
+
+        switch (status.section) {
+            case PS_ID:
+                if (get_input_format(ptr, &format) < 0)
+                    return -EILSEQ;
+
+                tag->id = read_data_in_section(ptr, format);
+                status.section = PS_LEN;
+                break;
+
+            case PS_LEN:
+                if (get_input_format(ptr, &format) < 0)
+                    return -EILSEQ;
+
+                byte_count = read_data_in_section(ptr, format);
+                if (byte_count > PS_MAX_LEN)
+                    return -EILSEQ;
+
+                tag->len = byte_count;
+                tag->data = (uint8_t *)malloc(byte_count);
+
+                status.section = PS_DATA;
+                status.line_count = 0;
+                break;
+
+            case PS_DATA:
+                if (status.line_count == 0)
+                    if (get_input_format(ptr, &format) < 0)
+                        return -EILSEQ;
+
+                __skip_space(ptr);
+
+                status.char_cnt = update_char_count(ptr);
+
+                read_count = (byte_count > ENTRY_PER_LINE) ?
+                    ENTRY_PER_LINE : byte_count;
+
+                if (format.type == PS_HEX && format.array == TRUE) {
+                    while (read_count > 0) {
+                        update_tag_data(tag, &status, ptr);
+                        read_count -= 2;
+                    }
+
+                    if (byte_count > ENTRY_PER_LINE)
+                        byte_count -= ENTRY_PER_LINE;
+                    else
+                        byte_count = 0;
+                }
+
+                status.line_count++;
+
+                if (byte_count == 0)
+                    memset(&status, 0x00, sizeof(struct tag_info));
+
+                if (status.section == PS_UNDEF)
+                    tag_cnt++;
+
+                if (tag_cnt == MAX_TAGS)
+                    return -EILSEQ;
+                break;
+        }
+    } while (ptr);
+
+    return tag_cnt;
+}
+
+#define PS_RAM_SIZE 2048
+
+static int ps_config_download(int fd, int tag_count)
+{
+
+    if (write_ps_cmd(fd, PS_RESET, PS_RAM_SIZE) < 0)
+        return -1;
+    if (tag_count > 0)
+        if (write_ps_cmd(fd, PS_WRITE, tag_count) < 0)
+            return -1;
+    return 0;
+}
+
+static int write_bdaddr(int pConfig, char *bdaddr)
+{
+    uint8_t *event;
+    int err;
+    uint8_t cmd[13];
+    uint8_t *ptr = cmd;
+    hci_command_hdr *ch = (void *)cmd;
+
+    memset(cmd, 0, sizeof(cmd));
+
+    ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
+                HCI_PS_CMD_OCF));
+    ch->plen = 10;
+    ptr += HCI_COMMAND_HDR_SIZE;
+
+    ptr[0] = 0x01;
+    ptr[1] = 0x01;
+    ptr[2] = 0x00;
+    ptr[3] = 0x06;
+
+    convert_bdaddr(bdaddr, (char *)&ptr[4]);
+
+    err = send_hci_cmd_sync(pConfig, cmd, sizeof(cmd), &event);
+    if (err < 0)
+        return err;
+
+    err = read_ps_event(event, HCI_PS_CMD_OCF);
+
+    free(event);
+
+    return err;
+}
+
+static void write_bdaddr_from_file(int rom_version, int fd)
+{
+    FILE *stream;
+    char bdaddr[PATH_MAX];
+    char bdaddr_file[PATH_MAX];
+
+    snprintf(bdaddr_file, MAXPATHLEN, "%s%x/%s",
+            FW_PATCHFILE_LOCATION, rom_version, BDADDR_FILE);
+
+    stream = fopen(bdaddr_file, "r");
+    if (!stream)
+        return;
+
+    if (fgets(bdaddr, PATH_MAX - 1, stream))
+        write_bdaddr(fd, bdaddr);
+
+    fclose(stream);
+}
+
+#define HCI_EVT_CMD_CMPL_OPCODE                 3
+#define HCI_EVT_CMD_CMPL_STATUS_RET_BYTE        5
+
+void baswap(bdaddr_t *dst, const bdaddr_t *src)
+{
+    register unsigned char *d = (unsigned char *) dst;
+    register const unsigned char *s = (const unsigned char *) src;
+    register int i;
+    for (i = 0; i < 6; i++)
+        d[i] = s[5-i];
+}
+
+
+int str2ba(const char *str, bdaddr_t *ba)
+{
+    uint8_t b[6];
+    const char *ptr = str;
+    int i;
+
+    for (i = 0; i < 6; i++) {
+        b[i] = (uint8_t) strtol(ptr, NULL, 16);
+        if (i != 5 && !(ptr = strchr(ptr, ':')))
+            ptr = ":00:00:00:00:00";
+        ptr++;
+    }
+    baswap(ba, (bdaddr_t *) b);
+    return 0;
+}
+
+#define DEV_REGISTER      0x4FFC
+#define GET_DEV_TYPE_OCF  0x05
+
+static int get_device_type(int dev, uint32_t *code)
+{
+    uint8_t cmd[8];
+    uint8_t *event;
+    uint32_t reg;
+    int err;
+    uint8_t *ptr = cmd;
+    hci_command_hdr *ch = (void *)cmd;
+
+    ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
+                GET_DEV_TYPE_OCF));
+    ch->plen = 5;
+    ptr += HCI_COMMAND_HDR_SIZE;
+
+    ptr[0] = (uint8_t)DEV_REGISTER;
+    ptr[1] = (uint8_t)DEV_REGISTER >> 8;
+    ptr[2] = (uint8_t)DEV_REGISTER >> 16;
+    ptr[3] = (uint8_t)DEV_REGISTER >> 24;
+    ptr[4] = 0x04;
+
+    err = send_hci_cmd_sync(dev, cmd, sizeof(cmd), &event);
+    if (err < 0)
+        return err;
+
+    err = read_ps_event(event, GET_DEV_TYPE_OCF);
+    if (err < 0)
+        goto cleanup;
+
+    reg = event[10];
+    reg = (reg << 8) | event[9];
+    reg = (reg << 8) | event[8];
+    reg = (reg << 8) | event[7];
+    *code = reg;
+
+cleanup:
+    free(event);
+
+    return err;
+}
+
+#define GET_VERSION_OCF 0x1E
+
+static int read_ath3k_version(int pConfig, uint32_t *rom_version,
+        uint32_t *build_version)
+{
+    uint8_t cmd[3];
+    uint8_t *event;
+    int err;
+    int status;
+    hci_command_hdr *ch = (void *)cmd;
+
+    ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
+                GET_VERSION_OCF));
+    ch->plen = 0;
+
+    err = send_hci_cmd_sync(pConfig, cmd, sizeof(cmd), &event);
+    if (err < 0)
+        return err;
+
+    err = read_ps_event(event, GET_VERSION_OCF);
+    if (err < 0)
+        goto cleanup;
+
+    status = event[10];
+    status = (status << 8) | event[9];
+    status = (status << 8) | event[8];
+    status = (status << 8) | event[7];
+    *rom_version = status;
+
+    status = event[14];
+    status = (status << 8) | event[13];
+    status = (status << 8) | event[12];
+    status = (status << 8) | event[11];
+    *build_version = status;
+
+cleanup:
+    free(event);
+
+    return err;
+}
+
+#define VERIFY_CRC   9
+#define PS_REGION    1
+#define PATCH_REGION 2
+
+static int get_ath3k_crc(int dev)
+{
+    uint8_t cmd[7];
+    uint8_t *event;
+    int err;
+
+    load_hci_ps_hdr(cmd, VERIFY_CRC, 0, PS_REGION | PATCH_REGION);
+
+    err = send_hci_cmd_sync(dev, cmd, sizeof(cmd), &event);
+    if (err < 0)
+        return err;
+    /* Send error code if CRC check patched */
+    if (read_ps_event(event, HCI_PS_CMD_OCF) >= 0)
+        err = -EILSEQ;
+
+    free(event);
+
+    return err;
+}
+
+#define SET_PATCH_RAM_ID        0x0D
+#define SET_PATCH_RAM_CMD_SIZE  11
+#define ADDRESS_LEN             4
+static int set_patch_ram(int dev, char *patch_loc, int len)
+{
+    int err;
+    uint8_t cmd[20];
+    int i, j;
+    char loc_byte[3];
+    uint8_t *event;
+    uint8_t *loc_ptr = &cmd[7];
+
+    if (!patch_loc)
+        return -1;
+
+    loc_byte[2] = '\0';
+
+    load_hci_ps_hdr(cmd, SET_PATCH_RAM_ID, ADDRESS_LEN, 0);
+
+    for (i = 0, j = 3; i < 4; i++, j--) {
+        loc_byte[0] = patch_loc[0];
+        loc_byte[1] = patch_loc[1];
+        loc_ptr[j] = strtol(loc_byte, NULL, 16);
+        patch_loc += 2;
+    }
+
+    err = send_hci_cmd_sync(dev, cmd, SET_PATCH_RAM_CMD_SIZE, &event);
+    if (err < 0)
+        return err;
+
+    err = read_ps_event(event, HCI_PS_CMD_OCF);
+
+    free(event);
+
+    return err;
+}
+
+#define PATCH_LOC_KEY    "DA:"
+#define PATCH_LOC_STRING_LEN    8
+static int ps_patch_download(int fd, FILE *stream)
+{
+    char byte[3];
+    char ptr[MAX_PATCH_CMD + 1];
+    int byte_cnt;
+    int patch_count = 0;
+    char patch_loc[PATCH_LOC_STRING_LEN + 1];
+
+    byte[2] = '\0';
+
+    while (fgets(ptr, MAX_PATCH_CMD, stream)) {
+        if (strlen(ptr) <= 1)
+            continue;
+        else if (strstr(ptr, PATCH_LOC_KEY) == ptr) {
+            strncpy(patch_loc, &ptr[sizeof(PATCH_LOC_KEY) - 1],
+                    PATCH_LOC_STRING_LEN);
+            if (set_patch_ram(fd, patch_loc, sizeof(patch_loc)) < 0)
+                return -1;
+        } else if (isxdigit(ptr[0]))
+            break;
+        else
+            return -1;
+    }
+
+    byte_cnt = strtol(ptr, NULL, 16);
+
+    while (byte_cnt > 0) {
+        int i;
+        uint8_t cmd[HCI_MAX_CMD_SIZE];
+        struct patch_entry patch;
+
+        if (byte_cnt > MAX_PATCH_CMD)
+            patch.len = MAX_PATCH_CMD;
+        else
+            patch.len = byte_cnt;
+
+        for (i = 0; i < patch.len; i++) {
+            if (!fgets(byte, 3, stream))
+                return -1;
+
+            patch.data[i] = strtoul(byte, NULL, 16);
+        }
+
+        load_hci_ps_hdr(cmd, WRITE_PATCH, patch.len, patch_count);
+        memcpy(&cmd[HCI_PS_CMD_HDR_LEN], patch.data, patch.len);
+
+        if (write_cmd(fd, cmd, patch.len + HCI_PS_CMD_HDR_LEN) < 0)
+            return -1;
+
+        patch_count++;
+        byte_cnt = byte_cnt - MAX_PATCH_CMD;
+    }
+
+    if (write_ps_cmd(fd, ENABLE_PATCH, 0) < 0)
+        return -1;
+
+    return patch_count;
+}
+
+static int ath_ps_download(int fd)
+{
+    int err = 0;
+    int tag_count;
+    int patch_count = 0;
+    uint32_t rom_version = 0;
+    uint32_t build_version = 0;
+    uint32_t dev_type = 0;
+    char patch_file[PATH_MAX];
+    char ps_file[PATH_MAX];
+    FILE *stream;
+
+    /*
+     * Verfiy firmware version. depending on it select the PS
+     * config file to download.
+     */
+    if (get_device_type(fd, &dev_type) < 0) {
+        err = -EILSEQ;
+        goto download_cmplete;
+    }
+
+    if (read_ath3k_version(fd, &rom_version, &build_version) < 0) {
+        err = -EILSEQ;
+        goto download_cmplete;
+    }
+
+    /* Do not download configuration if CRC passes */
+    if (get_ath3k_crc(fd) < 0) {
+        err = 0;
+        goto download_cmplete;
+    }
+
+    get_ps_file_name(dev_type, rom_version, ps_file);
+    get_patch_file_name(dev_type, rom_version, build_version, patch_file);
+
+    stream = fopen(ps_file, "r");
+    if (!stream) {
+        ALOGI("firmware file open error:%s, ver:%x\n",ps_file, rom_version);
+        if (rom_version == 0x1020201)
+            err = 0;
+        else
+            err = -EILSEQ;
+        goto download_cmplete;
+    }
+    tag_count = ath_parse_ps(stream);
+
+    fclose(stream);
+
+    if (tag_count < 0) {
+        err = -EILSEQ;
+        goto download_cmplete;
+    }
+
+    /*
+     * It is not necessary that Patch file be available,
+     * continue with PS Operations if patch file is not available.
+     */
+    if (patch_file[0] == '\0')
+        err = 0;
+    stream = fopen(patch_file, "r");
+    if (!stream)
+        err = 0;
+    else {
+        patch_count = ps_patch_download(fd, stream);
+        fclose(stream);
+
+        if (patch_count < 0) {
+            err = -EILSEQ;
+            goto download_cmplete;
+        }
+    }
+    err = ps_config_download(fd, tag_count);
+
+download_cmplete:
+    if (!err)
+        write_bdaddr_from_file(rom_version, fd);
+
+    return err;
+}
+
+int ath3k_init(int fd, int speed, int init_speed, char *bdaddr,	struct termios *ti)
+{
+    ALOGI(" %s ", __FUNCTION__);
+
+    int r;
+    int err = 0;
+    struct timespec tm = { 0, 5000000 };
+    unsigned char cmd[MAX_CMD_LEN], rsp[HCI_MAX_EVENT_SIZE];
+    unsigned char *ptr = cmd + 1;
+    hci_command_hdr *ch = (void *)ptr;
+    int flags = 0;
+
+    if (ioctl(fd, TIOCMGET, &flags) < 0) {
+        ALOGI("TIOCMGET failed in init\n");
+        return -1;
+    }
+    flags |= TIOCM_RTS;
+    if (ioctl(fd, TIOCMSET, &flags) < 0) {
+        ALOGI("TIOCMSET failed in init: HW Flow-on error\n");
+        return -1;
+    }
+
+    /* set both controller and host baud rate to maximum possible value */
+    err = set_cntrlr_baud(fd, speed);
+    ALOGI("set_cntrlr_baud : ret:%d \n", err);
+    if (err < 0)
+        return err;
+
+    err = set_speed(fd, ti, speed);
+    if (err < 0) {
+        ALOGI("Can't set required baud rate");
+        return err;
+    }
+
+    /* Download PS and patch */
+    r = ath_ps_download(fd);
+    if (r < 0) {
+        ALOGI("Failed to Download configuration");
+        err = -ETIMEDOUT;
+        goto failed;
+    }
+
+    ALOGI("ath_ps_download is done\n");
+    usleep(2000);
+    cmd[0] = HCI_COMMAND_PKT;
+    /* Write BDADDR */
+    if (bdaddr) {
+        ch->opcode = htobs(cmd_opcode_pack(HCI_VENDOR_CMD_OGF,
+                    HCI_PS_CMD_OCF));
+        ch->plen = 10;
+        ptr += HCI_COMMAND_HDR_SIZE;
+
+        ptr[0] = 0x01;
+        ptr[1] = 0x01;
+        ptr[2] = 0x00;
+        ptr[3] = 0x06;
+        str2ba(bdaddr, (bdaddr_t *)(ptr + 4));
+
+        if (write(fd, cmd, WRITE_BDADDR_CMD_LEN) !=
+                WRITE_BDADDR_CMD_LEN) {
+            ALOGI("Failed to write BD_ADDR command\n");
+            err = -ETIMEDOUT;
+            goto failed;
+        }
+
+        if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
+            ALOGI("Failed to set BD_ADDR\n");
+            err = -ETIMEDOUT;
+            goto failed;
+        }
+    }
+
+    /* Send HCI Reset */
+    cmd[1] = 0x03;
+    cmd[2] = 0x0C;
+    cmd[3] = 0x00;
+
+    r = write(fd, cmd, 4);
+    if (r != 4) {
+        err = -ETIMEDOUT;
+        goto failed;
+    }
+
+    nanosleep(&tm, NULL);
+    if (read_hci_event(fd, rsp, sizeof(rsp)) < 0) {
+        err = -ETIMEDOUT;
+        goto failed;
+    }
+
+    err = set_cntrlr_baud(fd, speed);
+    if (err < 0) 
+        ALOGI("set_cntrlr_baud0:%d,%d\n", speed, err);
+
+failed:
+    if (err < 0) {
+        set_cntrlr_baud(fd, init_speed);
+        set_speed(fd, ti, init_speed);
+    }
+    usleep(2000);
+    return err;
+
+}
+#define BTPROTO_HCI 1
+
+/* Open HCI device.
+ * Returns device descriptor (dd). */
+int hci_open_dev(int dev_id)
+{
+    struct sockaddr_hci a;
+    int dd, err;
+
+    /* Create HCI socket */
+    dd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+    if (dd < 0)
+        return dd;
+
+    /* Bind socket to the HCI device */
+    memset(&a, 0, sizeof(a));
+    a.hci_family = AF_BLUETOOTH;
+    a.hci_dev = dev_id;
+    if (bind(dd, (struct sockaddr *) &a, sizeof(a)) < 0)
+        goto failed;
+
+	return dd;
+
+failed:
+	err = errno;
+	close(dd);
+	errno = err;
+
+	return -1;
+}
+
+int hci_close_dev(int dd)
+{
+	return close(dd);
+}
+
+/* HCI functions that require open device
+ * dd - Device descriptor returned by hci_open_dev. */
+
+int hci_send_cmd(int dd, uint16_t ogf, uint16_t ocf, uint8_t plen, void *param)
+{
+	uint8_t type = HCI_COMMAND_PKT;
+	hci_command_hdr hc;
+	struct iovec iv[3];
+	int ivn;
+
+	hc.opcode = htobs(cmd_opcode_pack(ogf, ocf));
+	hc.plen= plen;
+
+	iv[0].iov_base = &type;
+	iv[0].iov_len  = 1;
+	iv[1].iov_base = &hc;
+	iv[1].iov_len  = HCI_COMMAND_HDR_SIZE;
+	ivn = 2;
+
+	if (plen) {
+		iv[2].iov_base = param;
+		iv[2].iov_len  = plen;
+		ivn = 3;
+	}
+
+	while (writev(dd, iv, ivn) < 0) {
+		if (errno == EAGAIN || errno == EINTR)
+			continue;
+		return -1;
+	}
+	return 0;
+}
+
+#define HCI_SLEEP_CMD_OCF     0x04
+#define TIOCSETD 0x5423
+#define HCIUARTSETFLAGS _IOW('U', 204, int)
+#define HCIUARTSETPROTO _IOW('U', 200, int)
+#define HCIUARTGETDEVICE _IOW('U', 202, int)
+/*
+ * Atheros AR300x specific initialization post callback
+ */
+int ath3k_post(int fd, int pm)
+{
+	int dev_id, dd;
+	struct timespec tm = { 0, 50000 };
+
+	sleep(1);
+
+	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
+	if (dev_id < 0) {
+		perror("cannot get device id");
+		return dev_id;
+	}
+
+	dd = hci_open_dev(dev_id);
+	if (dd < 0) {
+		perror("HCI device open failed");
+		return dd;
+	}
+
+	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {
+		perror("hci down:Power management Disabled");
+		hci_close_dev(dd);
+		return -1;
+	}
+
+	/* send vendor specific command with Sleep feature Enabled */
+	if (hci_send_cmd(dd, OGF_VENDOR_CMD, HCI_SLEEP_CMD_OCF,	1, &pm) < 0)
+		perror("PM command failed, power management Disabled");
+
+	nanosleep(&tm, NULL);
+	hci_close_dev(dd);
+
+	return 0;
+}
+
+
+
+#define FLOW_CTL	0x0001
+#define ENABLE_PM	1
+#define DISABLE_PM	0
+
+/* Initialize UART driver */
+static int init_uart(char *dev, struct uart_t *u, int send_break, int raw)
+{
+	ALOGI(" %s ", __FUNCTION__);
+
+	struct termios ti;
+
+	int i, fd;
+	unsigned long flags = 0;
+
+	if (raw)
+		flags |= 1 << HCI_UART_RAW_DEVICE;
+
+
+        fd = open(dev, O_RDWR | O_NOCTTY);
+
+        if (fd < 0) {
+                ALOGI("Can't open serial port");
+                return -1;
+        }
+	usleep(5000);
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		ALOGI("Can't get port settings: %d\n", errno);
+		return -1;
+	}
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |= CLOCAL;
+	if (u->flags & FLOW_CTL)
+    {
+		ti.c_cflag |= CRTSCTS;
+    }else
+		ti.c_cflag &= ~CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		ALOGI("Can't set port settings");
+		return -1;
+	}
+
+	if (set_speed(fd, &ti, u->init_speed) < 0) {
+		ALOGI("Can't set initial baud rate");
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (send_break) {
+		tcsendbreak(fd, 0);
+		usleep(500000);
+	}
+
+    ath3k_init(fd,u->speed,u->init_speed,u->bdaddr, &ti);   
+
+	ALOGI("Device setup complete\n");
+
+
+	tcflush(fd, TCIOFLUSH);
+
+	// Set actual baudrate 
+	if (set_speed(fd, &ti, u->speed) < 0) {
+		ALOGE("Can't set baud rate");
+		return -1;
+	}
+
+	if (flags && ioctl(fd, HCIUARTSETFLAGS, flags) < 0) {
+		ALOGE("Can't set UART flags");
+		return -1;
+	}
+	return fd;
+}
+
+
+int hw_config(char *port_name)
+{
+    ALOGI(" %s ", __FUNCTION__);
+	PSCounter=0;
+    struct sigaction sa;
+	struct uart_t u ;
+	int n=0,send_break=0,raw=0;
+
+	memset(&u, 0, sizeof(u));
+	u.init_speed =115200;
+	u.speed = 3000000;
+	//u.speed =115200;
+	u.flags |= FLOW_CTL; 
+	u.pm = DISABLE_PM;
+    u.proto = 0;
+	n = init_uart(port_name, &u, send_break, raw);
+	if (n < 0) {
+		ALOGI("Can't initialize device");
+	}
+
+    	return n;
+}
diff --git a/libbt-ath3k/src/upio.c b/libbt-ath3k/src/upio.c
index 12a2e75..99638e4 100644
--- a/libbt-ath3k/src/upio.c
+++ b/libbt-ath3k/src/upio.c
@@ -1,20 +1,21 @@
-/*
- * Copyright 2012 The Android Open Source Project
+/******************************************************************************
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ *  Copyright (C) 2009-2012 Broadcom Corporation
+ *  Copyright (C) 2013 Freescale Semiconductor, Inc.
  *
- *      http://www.apache.org/licenses/LICENSE-2.0
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
 
 /******************************************************************************
  *
@@ -32,8 +33,9 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <cutils/properties.h>
-#include "bt_vendor_ath3k.h"
+#include "bt_vendor_QCA3002.h"
 #include "upio.h"
+#include "userial_vendor_QCA3002.h"
 
 /******************************************************************************
 **  Constants & Macros
@@ -44,7 +46,7 @@
 #endif
 
 #if (UPIO_DBG == TRUE)
-#define UPIODBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
+#define UPIODBG(param, ...) {ALOGI(param, ## __VA_ARGS__);}
 #else
 #define UPIODBG(param, ...) {}
 #endif
@@ -53,10 +55,44 @@
 **  Local type definitions
 ******************************************************************************/
 
+#if (BT_WAKE_VIA_PROC == TRUE)
+
+/* proc fs node for enable/disable lpm mode */
+#ifndef VENDOR_LPM_PROC_NODE
+#define VENDOR_LPM_PROC_NODE "/proc/bluetooth/sleep/lpm"
+#endif
+
+/* proc fs node for notifying write request */
+#ifndef VENDOR_BTWRITE_PROC_NODE
+#define VENDOR_BTWRITE_PROC_NODE "/proc/bluetooth/sleep/btwrite"
+#endif
+
+/*
+ * Maximum btwrite assertion holding time without consecutive btwrite kicking.
+ * This value is correlative(shorter) to the in-activity timeout period set in
+ * the bluesleep LPM code. The current value used in bluesleep is 10sec.
+ */
+#ifndef PROC_BTWRITE_TIMER_TIMEOUT_MS
+#define PROC_BTWRITE_TIMER_TIMEOUT_MS   8000
+#endif
+
+/* lpm proc control block */
+typedef struct
+{
+    uint8_t btwrite_active;
+    uint8_t timer_created;
+    timer_t timer_id;
+    uint32_t timeout_ms;
+} vnd_lpm_proc_cb_t;
+
+static vnd_lpm_proc_cb_t lpm_proc_cb;
+#endif
+
 /******************************************************************************
 **  Static variables
 ******************************************************************************/
 
+static uint8_t upio_state[UPIO_MAX_COUNT];
 static int rfkill_id = -1;
 static int bt_emul_enable = 0;
 static char *rfkill_state_path = NULL;
@@ -65,6 +101,19 @@ static char *rfkill_state_path = NULL;
 **  Static functions
 ******************************************************************************/
 
+/* for friendly debugging outpout string */
+static char *lpm_mode[] = {
+    "UNKNOWN",
+    "disabled",
+    "enabled"
+};
+
+static char *lpm_state[] = {
+    "UNKNOWN",
+    "de-asserted",
+    "asserted"
+};
+
 /*****************************************************************************
 **   Bluetooth On/Off Static Functions
 *****************************************************************************/
@@ -96,6 +145,7 @@ static int is_rfkill_disabled(void)
 
 static int init_rfkill()
 {
+    UPIODBG("Entered init_rfkill");
     char path[64];
     char buf[16];
     int fd, sz, id;
@@ -106,6 +156,7 @@ static int init_rfkill()
     for (id = 0; ; id++)
     {
         snprintf(path, sizeof(path), "/sys/class/rfkill/rfkill%d/type", id);
+		UPIODBG("path is %s ", path);
         fd = open(path, O_RDONLY);
         if (fd < 0)
         {
@@ -129,11 +180,68 @@ static int init_rfkill()
 }
 
 /*****************************************************************************
+**   LPM Static Functions
+*****************************************************************************/
+
+#if (BT_WAKE_VIA_PROC == TRUE)
+/*******************************************************************************
+**
+** Function        proc_btwrite_timeout
+**
+** Description     Timeout thread of proc/.../btwrite assertion holding timer
+**
+** Returns         None
+**
+*******************************************************************************/
+static void proc_btwrite_timeout(union sigval arg)
+{
+    UPIODBG("..%s..", __FUNCTION__);
+    lpm_proc_cb.btwrite_active = FALSE;
+}
+#endif
+
+/*****************************************************************************
 **   UPIO Interface Functions
 *****************************************************************************/
 
 /*******************************************************************************
 **
+** Function        upio_init
+**
+** Description     Initialization
+**
+** Returns         None
+**
+*******************************************************************************/
+void upio_init(void)
+{
+    memset(upio_state, UPIO_UNKNOWN, UPIO_MAX_COUNT);
+#if (BT_WAKE_VIA_PROC == TRUE)
+    memset(&lpm_proc_cb, 0, sizeof(vnd_lpm_proc_cb_t));
+#endif
+}
+
+/*******************************************************************************
+**
+** Function        upio_cleanup
+**
+** Description     Clean up
+**
+** Returns         None
+**
+*******************************************************************************/
+void upio_cleanup(void)
+{
+#if (BT_WAKE_VIA_PROC == TRUE)
+    if (lpm_proc_cb.timer_created == TRUE)
+        timer_delete(lpm_proc_cb.timer_id);
+
+    lpm_proc_cb.timer_created = FALSE;
+#endif
+}
+
+/*******************************************************************************
+**
 ** Function        upio_set_bluetooth_power
 **
 ** Description     Interact with low layer driver to set Bluetooth power
@@ -144,7 +252,7 @@ static int init_rfkill()
 **
 *******************************************************************************/
 int upio_set_bluetooth_power(int on)
-{
+{   
     int sz;
     int fd = -1;
     int ret = -1;
@@ -173,33 +281,42 @@ int upio_set_bluetooth_power(int on)
         return 0;
     }
 
+	ALOGI("check if we have rfkill interface?");
+
+
     /* check if we have rfkill interface */
     if (is_rfkill_disabled())
         return 0;
 
+	ALOGI("Check rfkill_id == -1?");
+	
     if (rfkill_id == -1)
     {
         if (init_rfkill())
             return ret;
     }
-
     fd = open(rfkill_state_path, O_WRONLY);
 
     if (fd < 0)
     {
-        ALOGE("set_bluetooth_power : open(%s) for write failed: %s (%d)",
+        ALOGI("set_bluetooth_power : open(%s) for write failed: %s (%d)",
             rfkill_state_path, strerror(errno), errno);
         return ret;
     }
-
+	else
+		ALOGI("open set_bluetooth_power success");
+	
     sz = write(fd, &buffer, 1);
 
     if (sz < 0) {
-        ALOGE("set_bluetooth_power : write(%s) failed: %s (%d)",
+        ALOGI("set_bluetooth_power : write(%s) failed: %s (%d)",
             rfkill_state_path, strerror(errno),errno);
     }
     else
-        ret = 0;
+    {
+    	ret = 0;
+		ALOGI("write bluetooth_power success");
+    }
 
     if (fd >= 0)
         close(fd);
@@ -208,3 +325,175 @@ int upio_set_bluetooth_power(int on)
 }
 
 
+/*******************************************************************************
+**
+** Function        upio_set
+**
+** Description     Set i/o based on polarity
+**
+** Returns         None
+**
+*******************************************************************************/
+void upio_set(uint8_t pio, uint8_t action, uint8_t polarity)
+{
+    int rc;
+#if (BT_WAKE_VIA_PROC == TRUE)
+    int fd = -1;
+    char buffer;
+#endif
+
+    switch (pio)
+    {
+        case UPIO_LPM_MODE:
+            if (upio_state[UPIO_LPM_MODE] == action)
+            {
+                UPIODBG("LPM is %s already", lpm_mode[action]);
+                return;
+            }
+
+            upio_state[UPIO_LPM_MODE] = action;
+
+#if (BT_WAKE_VIA_PROC == TRUE)
+            fd = open(VENDOR_LPM_PROC_NODE, O_WRONLY);
+
+            if (fd < 0)
+            {
+                ALOGE("upio_set : open(%s) for write failed: %s (%d)",
+                        VENDOR_LPM_PROC_NODE, strerror(errno), errno);
+                return;
+            }
+
+            if (action == UPIO_ASSERT)
+            {
+                buffer = '1';
+            }
+            else
+            {
+                buffer = '0';
+
+                // delete btwrite assertion holding timer
+                if (lpm_proc_cb.timer_created == TRUE)
+                {
+                    timer_delete(lpm_proc_cb.timer_id);
+                    lpm_proc_cb.timer_created = FALSE;
+                }
+            }
+
+            if (write(fd, &buffer, 1) < 0)
+            {
+                ALOGE("upio_set : write(%s) failed: %s (%d)",
+                        VENDOR_LPM_PROC_NODE, strerror(errno),errno);
+            }
+            else
+            {
+                if (action == UPIO_ASSERT)
+                {
+                    // create btwrite assertion holding timer
+                    if (lpm_proc_cb.timer_created == FALSE)
+                    {
+                        int status;
+                        struct sigevent se;
+
+                        se.sigev_notify = SIGEV_THREAD;
+                        se.sigev_value.sival_ptr = &lpm_proc_cb.timer_id;
+                        se.sigev_notify_function = proc_btwrite_timeout;
+                        se.sigev_notify_attributes = NULL;
+
+                        status = timer_create(CLOCK_MONOTONIC, &se,
+                                                &lpm_proc_cb.timer_id);
+
+                        if (status == 0)
+                            lpm_proc_cb.timer_created = TRUE;
+                    }
+                }
+            }
+
+            if (fd >= 0)
+                close(fd);
+#endif
+            break;
+
+        case UPIO_BT_WAKE:
+            if (upio_state[UPIO_BT_WAKE] == action)
+            {
+                UPIODBG("BT_WAKE is %s already", lpm_state[action]);
+
+#if (BT_WAKE_VIA_PROC == TRUE)
+                if (lpm_proc_cb.btwrite_active == TRUE)
+                    /*
+                     * The proc btwrite node could have not been updated for
+                     * certain time already due to heavy downstream path flow.
+                     * In this case, we want to explicity touch proc btwrite
+                     * node to keep the bt_wake assertion in the LPM kernel
+                     * driver. The current kernel bluesleep LPM code starts
+                     * a 10sec internal in-activity timeout timer before it
+                     * attempts to deassert BT_WAKE line.
+                     */
+#endif
+                return;
+            }
+
+            upio_state[UPIO_BT_WAKE] = action;
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL == TRUE)
+
+            userial_vendor_ioctl( ( (action==UPIO_ASSERT) ? \
+                      USERIAL_OP_ASSERT_BT_WAKE : USERIAL_OP_DEASSERT_BT_WAKE),\
+                      NULL);
+
+#elif (BT_WAKE_VIA_PROC == TRUE)
+
+            /*
+             *  Kick proc btwrite node only at UPIO_ASSERT
+             */
+            if (action == UPIO_DEASSERT)
+                return;
+
+            fd = open(VENDOR_BTWRITE_PROC_NODE, O_WRONLY);
+
+            if (fd < 0)
+            {
+                ALOGE("upio_set : open(%s) for write failed: %s (%d)",
+                        VENDOR_BTWRITE_PROC_NODE, strerror(errno), errno);
+                return;
+            }
+
+            buffer = '1';
+
+            if (write(fd, &buffer, 1) < 0)
+            {
+                ALOGE("upio_set : write(%s) failed: %s (%d)",
+                        VENDOR_BTWRITE_PROC_NODE, strerror(errno),errno);
+            }
+            else
+            {
+                lpm_proc_cb.btwrite_active = TRUE;
+
+                if (lpm_proc_cb.timer_created == TRUE)
+                {
+                    struct itimerspec ts;
+
+                    ts.it_value.tv_sec = PROC_BTWRITE_TIMER_TIMEOUT_MS/1000;
+                    ts.it_value.tv_nsec = 1000*(PROC_BTWRITE_TIMER_TIMEOUT_MS%1000);
+                    ts.it_interval.tv_sec = 0;
+                    ts.it_interval.tv_nsec = 0;
+
+                    timer_settime(lpm_proc_cb.timer_id, 0, &ts, 0);
+                }
+            }
+
+            UPIODBG("proc btwrite assertion");
+
+            if (fd >= 0)
+                close(fd);
+#endif
+
+            break;
+
+        case UPIO_HOST_WAKE:
+            UPIODBG("upio_set: UPIO_HOST_WAKE");
+            break;
+    }
+}
+
+
diff --git a/libbt-ath3k/src/userial_vendor.c b/libbt-ath3k/src/userial_vendor.c
deleted file mode 100644
index 033a736..0000000
--- a/libbt-ath3k/src/userial_vendor.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
-
-/******************************************************************************
- *
- *  Filename:      userial_vendor.c
- *
- *  Description:   Contains vendor-specific userial functions
- *
- ******************************************************************************/
-
-#define LOG_TAG "bt_userial_vendor"
-
-#include <utils/Log.h>
-#include <termios.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <stdio.h>
-#include "bt_vendor_ath3k.h"
-#include "userial_vendor.h"
-
-/******************************************************************************
-**  Constants & Macros
-******************************************************************************/
-
-#ifndef VNDUSERIAL_DBG
-#define VNDUSERIAL_DBG FALSE
-#endif
-
-#if (VNDUSERIAL_DBG == TRUE)
-#define VNDUSERIALDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
-#else
-#define VNDUSERIALDBG(param, ...) {}
-#endif
-
-#define VND_PORT_NAME_MAXLEN    256
-
-/******************************************************************************
-**  Local type definitions
-******************************************************************************/
-
-/* vendor serial control block */
-typedef struct
-{
-    int fd;                     /* fd to Bluetooth device */
-    struct termios termios;     /* serial terminal of BT port */
-    char port_name[VND_PORT_NAME_MAXLEN];
-} vnd_userial_cb_t;
-
-/******************************************************************************
-**  Static variables
-******************************************************************************/
-
-static vnd_userial_cb_t vnd_userial;
-
-/*****************************************************************************
-**   Helper Functions
-*****************************************************************************/
-
-/*******************************************************************************
-**
-** Function        userial_to_tcio_baud
-**
-** Description     helper function converts USERIAL baud rates into TCIO
-**                  conforming baud rates
-**
-** Returns         TRUE/FALSE
-**
-*******************************************************************************/
-uint8_t userial_to_tcio_baud(uint8_t cfg_baud, uint32_t *baud)
-{
-    if (cfg_baud == USERIAL_BAUD_115200)
-        *baud = B115200;
-    else if (cfg_baud == USERIAL_BAUD_4M)
-        *baud = B4000000;
-    else if (cfg_baud == USERIAL_BAUD_3M)
-        *baud = B3000000;
-    else if (cfg_baud == USERIAL_BAUD_2M)
-        *baud = B2000000;
-    else if (cfg_baud == USERIAL_BAUD_1M)
-        *baud = B1000000;
-    else if (cfg_baud == USERIAL_BAUD_921600)
-        *baud = B921600;
-    else if (cfg_baud == USERIAL_BAUD_460800)
-        *baud = B460800;
-    else if (cfg_baud == USERIAL_BAUD_230400)
-        *baud = B230400;
-    else if (cfg_baud == USERIAL_BAUD_57600)
-        *baud = B57600;
-    else if (cfg_baud == USERIAL_BAUD_19200)
-        *baud = B19200;
-    else if (cfg_baud == USERIAL_BAUD_9600)
-        *baud = B9600;
-    else if (cfg_baud == USERIAL_BAUD_1200)
-        *baud = B1200;
-    else if (cfg_baud == USERIAL_BAUD_600)
-        *baud = B600;
-    else
-    {
-        ALOGE( "userial vendor open: unsupported baud idx %i", cfg_baud);
-        *baud = B115200;
-        return FALSE;
-    }
-
-    return TRUE;
-}
-
-#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-/*******************************************************************************
-**
-** Function        userial_ioctl_init_bt_wake
-**
-** Description     helper function to set the open state of the bt_wake if ioctl
-**                  is used. it should not hurt in the rfkill case but it might
-**                  be better to compile it out.
-**
-** Returns         none
-**
-*******************************************************************************/
-void userial_ioctl_init_bt_wake(int fd)
-{
-    uint32_t bt_wake_state;
-
-    /* assert BT_WAKE through ioctl */
-    ioctl(fd, USERIAL_IOCTL_BT_WAKE_ASSERT, NULL);
-    ioctl(fd, USERIAL_IOCTL_BT_WAKE_GET_ST, &bt_wake_state);
-    VNDUSERIALDBG("userial_ioctl_init_bt_wake read back BT_WAKE state=%i", \
-               bt_wake_state);
-}
-#endif // (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-
-
-/*****************************************************************************
-**   Userial Vendor API Functions
-*****************************************************************************/
-
-/*******************************************************************************
-**
-** Function        userial_vendor_init
-**
-** Description     Initialize userial vendor-specific control block
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_init(void)
-{
-    vnd_userial.fd = -1;
-    snprintf(vnd_userial.port_name, VND_PORT_NAME_MAXLEN, "%s", \
-            BLUETOOTH_UART_DEVICE_PORT);
-}
-
-/*******************************************************************************
-**
-** Function        userial_vendor_open
-**
-** Description     Open the serial port with the given configuration
-**
-** Returns         device fd
-**
-*******************************************************************************/
-int userial_vendor_open(tUSERIAL_CFG *p_cfg)
-{
-    uint32_t baud;
-    uint8_t data_bits;
-    uint16_t parity;
-    uint8_t stop_bits;
-
-    vnd_userial.fd = -1;
-
-    if (!userial_to_tcio_baud(p_cfg->baud, &baud))
-    {
-        return -1;
-    }
-
-    if(p_cfg->fmt & USERIAL_DATABITS_8)
-        data_bits = CS8;
-    else if(p_cfg->fmt & USERIAL_DATABITS_7)
-        data_bits = CS7;
-    else if(p_cfg->fmt & USERIAL_DATABITS_6)
-        data_bits = CS6;
-    else if(p_cfg->fmt & USERIAL_DATABITS_5)
-        data_bits = CS5;
-    else
-    {
-        ALOGE("userial vendor open: unsupported data bits");
-        return -1;
-    }
-
-    if(p_cfg->fmt & USERIAL_PARITY_NONE)
-        parity = 0;
-    else if(p_cfg->fmt & USERIAL_PARITY_EVEN)
-        parity = PARENB;
-    else if(p_cfg->fmt & USERIAL_PARITY_ODD)
-        parity = (PARENB | PARODD);
-    else
-    {
-        ALOGE("userial vendor open: unsupported parity bit mode");
-        return -1;
-    }
-
-    if(p_cfg->fmt & USERIAL_STOPBITS_1)
-        stop_bits = 0;
-    else if(p_cfg->fmt & USERIAL_STOPBITS_2)
-        stop_bits = CSTOPB;
-    else
-    {
-        ALOGE("userial vendor open: unsupported stop bits");
-        return -1;
-    }
-
-    ALOGI("userial vendor open: opening %s", vnd_userial.port_name);
-
-    if ((vnd_userial.fd = open(vnd_userial.port_name, O_RDWR)) == -1)
-    {
-        ALOGE("userial vendor open: unable to open %s", vnd_userial.port_name);
-        return -1;
-    }
-
-    tcflush(vnd_userial.fd, TCIOFLUSH);
-
-    tcgetattr(vnd_userial.fd, &vnd_userial.termios);
-    cfmakeraw(&vnd_userial.termios);
-    vnd_userial.termios.c_cflag |= (CRTSCTS | stop_bits);
-    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
-    tcflush(vnd_userial.fd, TCIOFLUSH);
-
-    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
-    tcflush(vnd_userial.fd, TCIOFLUSH);
-    tcflush(vnd_userial.fd, TCIOFLUSH);
-
-    /* set input/output baudrate */
-    cfsetospeed(&vnd_userial.termios, baud);
-    cfsetispeed(&vnd_userial.termios, baud);
-    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
-
-#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-    userial_ioctl_init_bt_wake(vnd_userial.fd);
-#endif
-
-    ALOGI("device fd = %d open", vnd_userial.fd);
-
-    return vnd_userial.fd;
-}
-
-/*******************************************************************************
-**
-** Function        userial_vendor_close
-**
-** Description     Conduct vendor-specific close work
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_close(void)
-{
-    int result;
-
-    if (vnd_userial.fd == -1)
-        return;
-
-#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-    /* de-assert bt_wake BEFORE closing port */
-    ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_DEASSERT, NULL);
-#endif
-
-    ALOGI("device fd = %d close", vnd_userial.fd);
-
-    if ((result = close(vnd_userial.fd)) < 0)
-        ALOGE( "close(fd:%d) FAILED result:%d", vnd_userial.fd, result);
-
-    vnd_userial.fd = -1;
-}
-
-/*******************************************************************************
-**
-** Function        userial_vendor_set_baud
-**
-** Description     Set new baud rate
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_set_baud(uint8_t userial_baud)
-{
-    uint32_t tcio_baud;
-
-    userial_to_tcio_baud(userial_baud, &tcio_baud);
-
-    cfsetospeed(&vnd_userial.termios, tcio_baud);
-    cfsetispeed(&vnd_userial.termios, tcio_baud);
-    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
-}
-
-/*******************************************************************************
-**
-** Function        userial_vendor_ioctl
-**
-** Description     ioctl inteface
-**
-** Returns         None
-**
-*******************************************************************************/
-void userial_vendor_ioctl(userial_vendor_ioctl_op_t op, void *p_data)
-{
-    switch(op)
-    {
-#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-        case USERIAL_OP_ASSERT_BT_WAKE:
-            VNDUSERIALDBG("## userial_vendor_ioctl: Asserting BT_Wake ##");
-            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_ASSERT, NULL);
-            break;
-
-        case USERIAL_OP_DEASSERT_BT_WAKE:
-            VNDUSERIALDBG("## userial_vendor_ioctl: De-asserting BT_Wake ##");
-            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_DEASSERT, NULL);
-            break;
-
-        case USERIAL_OP_GET_BT_WAKE_STATE:
-            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_GET_ST, p_data);
-            break;
-#endif  //  (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
-
-        default:
-            break;
-    }
-}
-
-/*******************************************************************************
-**
-** Function        userial_set_port
-**
-** Description     Configure UART port name
-**
-** Returns         0 : Success
-**                 Otherwise : Fail
-**
-*******************************************************************************/
-int userial_set_port(char *p_conf_name, char *p_conf_value, int param)
-{
-    strcpy(vnd_userial.port_name, p_conf_value);
-
-    return 0;
-}
-
diff --git a/libbt-ath3k/src/userial_vendor_QCA3002.c b/libbt-ath3k/src/userial_vendor_QCA3002.c
new file mode 100644
index 0000000..53e7e0f
--- /dev/null
+++ b/libbt-ath3k/src/userial_vendor_QCA3002.c
@@ -0,0 +1,292 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2009-2012 Broadcom Corporation
+ *  Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Filename:      userial_vendor.c
+ *
+ *  Description:   Contains vendor-specific userial functions
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_userial_vendor"
+
+#include <utils/Log.h>
+#include <termios.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include "bt_vendor_QCA3002.h"
+#include "userial_vendor_QCA3002.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#ifndef VNDUSERIAL_DBG
+#define VNDUSERIAL_DBG FALSE
+#endif
+
+#if (VNDUSERIAL_DBG == TRUE)
+#define VNDUSERIALDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
+#else
+#define VNDUSERIALDBG(param, ...) {}
+#endif
+
+#define VND_PORT_NAME_MAXLEN    256
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+/* vendor serial control block */
+typedef struct
+{
+    int fd;                     /* fd to Bluetooth device */
+    struct termios termios;     /* serial terminal of BT port */
+    char port_name[VND_PORT_NAME_MAXLEN];
+} vnd_userial_cb_t;
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+
+static vnd_userial_cb_t vnd_userial;
+extern int hw_config(char *port_name);
+
+/*****************************************************************************
+**   Helper Functions
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        userial_to_tcio_baud
+**
+** Description     helper function converts USERIAL baud rates into TCIO
+**                  conforming baud rates
+**
+** Returns         TRUE/FALSE
+**
+*******************************************************************************/
+uint8_t userial_to_tcio_baud(uint8_t cfg_baud, uint32_t *baud)
+{
+    if (cfg_baud == USERIAL_BAUD_115200)
+        *baud = B115200;
+    else if (cfg_baud == USERIAL_BAUD_4M)
+        *baud = B4000000;
+    else if (cfg_baud == USERIAL_BAUD_3M)
+        *baud = B3000000;
+    else if (cfg_baud == USERIAL_BAUD_2M)
+        *baud = B2000000;
+    else if (cfg_baud == USERIAL_BAUD_1M)
+        *baud = B1000000;
+    else if (cfg_baud == USERIAL_BAUD_921600)
+        *baud = B921600;
+    else if (cfg_baud == USERIAL_BAUD_460800)
+        *baud = B460800;
+    else if (cfg_baud == USERIAL_BAUD_230400)
+        *baud = B230400;
+    else if (cfg_baud == USERIAL_BAUD_57600)
+        *baud = B57600;
+    else if (cfg_baud == USERIAL_BAUD_19200)
+        *baud = B19200;
+    else if (cfg_baud == USERIAL_BAUD_9600)
+        *baud = B9600;
+    else if (cfg_baud == USERIAL_BAUD_1200)
+        *baud = B1200;
+    else if (cfg_baud == USERIAL_BAUD_600)
+        *baud = B600;
+    else
+    {
+        ALOGE( "userial vendor open: unsupported baud idx %i", cfg_baud);
+        *baud = B115200;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+/*******************************************************************************
+**
+** Function        userial_ioctl_init_bt_wake
+**
+** Description     helper function to set the open state of the bt_wake if ioctl
+**                  is used. it should not hurt in the rfkill case but it might
+**                  be better to compile it out.
+**
+** Returns         none
+**
+*******************************************************************************/
+void userial_ioctl_init_bt_wake(int fd)
+{
+    uint32_t bt_wake_state;
+
+    /* assert BT_WAKE through ioctl */
+    VNDUSERIALDBG("userial_ioctl_init_bt_wake read back BT_WAKE state=%i", \
+               bt_wake_state);
+}
+#endif // (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+
+
+/*****************************************************************************
+**   Userial Vendor API Functions
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        userial_vendor_init
+**
+** Description     Initialize userial vendor-specific control block
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_init(void)
+{
+    vnd_userial.fd = -1;
+    snprintf(vnd_userial.port_name, VND_PORT_NAME_MAXLEN, "%s", \
+            BLUETOOTH_UART_DEVICE_PORT);
+	ALOGI("vnd_userial.port_name is %s ",vnd_userial.port_name);
+	
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_open
+**
+** Description     Open the serial port with the given configuration
+**
+** Returns         device fd
+**
+*******************************************************************************/
+int userial_vendor_open(tUSERIAL_CFG *p_cfg)
+{
+    uint32_t baud;
+    uint8_t data_bits;
+    uint16_t parity;
+    uint8_t stop_bits;
+
+    vnd_userial.fd = -1;
+    vnd_userial.fd = hw_config(vnd_userial.port_name);
+    if (vnd_userial.fd < -1) {
+           ALOGI("Can't open serial port");
+           return -1;
+    }
+
+    ALOGI("device fd = %d open", vnd_userial.fd);
+
+    return vnd_userial.fd;
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_close
+**
+** Description     Conduct vendor-specific close work
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_close(void)
+{
+    int result;
+
+    if (vnd_userial.fd == -1)
+        return;
+
+    ALOGI("device fd = %d close", vnd_userial.fd);
+
+    if ((result = close(vnd_userial.fd)) < 0)
+        ALOGE( "close(fd:%d) FAILED result:%d", vnd_userial.fd, result);
+
+    vnd_userial.fd = -1;
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_set_baud
+**
+** Description     Set new baud rate
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_set_baud(uint8_t userial_baud)
+{
+    uint32_t tcio_baud;
+
+    userial_to_tcio_baud(userial_baud, &tcio_baud);
+
+    cfsetospeed(&vnd_userial.termios, tcio_baud);
+    cfsetispeed(&vnd_userial.termios, tcio_baud);
+    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_ioctl
+**
+** Description     ioctl inteface
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_ioctl(userial_vendor_ioctl_op_t op, void *p_data)
+{
+    switch(op)
+    {
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+        case USERIAL_OP_ASSERT_BT_WAKE:
+            VNDUSERIALDBG("## userial_vendor_ioctl: Asserting BT_Wake ##");
+            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_ASSERT, NULL);
+            break;
+
+        case USERIAL_OP_DEASSERT_BT_WAKE:
+            VNDUSERIALDBG("## userial_vendor_ioctl: De-asserting BT_Wake ##");
+            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_DEASSERT, NULL);
+            break;
+
+        case USERIAL_OP_GET_BT_WAKE_STATE:
+            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_GET_ST, p_data);
+            break;
+#endif  //  (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+
+        default:
+            break;
+    }
+}
+
+/*******************************************************************************
+**
+** Function        userial_set_port
+**
+** Description     Configure UART port name
+**
+** Returns         0 : Success
+**                 Otherwise : Fail
+**
+*******************************************************************************/
+int userial_set_port(char *p_conf_name, char *p_conf_value, int param)
+{
+    strcpy(vnd_userial.port_name, p_conf_value);
+
+    return 0;
+}
+
diff --git a/libbt-ath3k/vnd_buildcfg.mk b/libbt-ath3k/vnd_buildcfg.mk
old mode 100755
new mode 100644
index d18e121..efce64d
--- a/libbt-ath3k/vnd_buildcfg.mk
+++ b/libbt-ath3k/vnd_buildcfg.mk
@@ -1,4 +1,4 @@
-#
+
 # Copyright 2012 The Android Open Source Project
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
@@ -29,4 +29,4 @@ $(GEN): PRIVATE_CUSTOM_TOOL = $(TOOL) $< $@
 $(GEN): $(SRC)  $(TOOL)
 	$(transform-generated-source)
 
-LOCAL_GENERATED_SOURCES += $(GEN)
+LOCAL_GENERATED_SOURCES += $(GEN)
\ No newline at end of file
-- 
1.8.0

