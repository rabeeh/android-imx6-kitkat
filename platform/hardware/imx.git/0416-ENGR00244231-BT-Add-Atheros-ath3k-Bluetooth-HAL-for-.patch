From 6bca24aa0fce09f70fe6f759f48b2022a027b6ae Mon Sep 17 00:00:00 2001
From: Nitin Garg <nitin.garg@freescale.com>
Date: Fri, 8 Feb 2013 13:44:35 -0600
Subject: [PATCH 416/498] ENGR00244231: BT Add Atheros ath3k Bluetooth HAL for
 JB4.2

Add Atheros ath3k Bluetooth HAL for JB4.2 bluedroid stack.

Signed-off-by: Nitin Garg <nitin.garg@freescale.com>
---
 Android.mk                                      |    2 +-
 libbt-ath3k/Android.mk                          |   55 +
 libbt-ath3k/conf/fsl/imx53_smd/Android.mk       |   14 +
 libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf   |    5 +
 libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk     |   14 +
 libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf |    5 +
 libbt-ath3k/include/bt_vendor_ath3k.h           |   45 +
 libbt-ath3k/include/upio.h                      |   59 ++
 libbt-ath3k/include/userial_vendor.h            |  175 ++++
 libbt-ath3k/include/vnd_generic.txt             |    6 +
 libbt-ath3k/src/bt_vendor_ath3k.c               |  208 ++++
 libbt-ath3k/src/conf.c                          |  139 +++
 libbt-ath3k/src/hardware.c                      | 1253 +++++++++++++++++++++++
 libbt-ath3k/src/upio.c                          |  210 ++++
 libbt-ath3k/src/userial_vendor.c                |  360 +++++++
 libbt-ath3k/vnd_buildcfg.mk                     |   32 +
 16 files changed, 2581 insertions(+), 1 deletion(-)
 create mode 100755 libbt-ath3k/Android.mk
 create mode 100755 libbt-ath3k/conf/fsl/imx53_smd/Android.mk
 create mode 100755 libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf
 create mode 100755 libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk
 create mode 100755 libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf
 create mode 100644 libbt-ath3k/include/bt_vendor_ath3k.h
 create mode 100644 libbt-ath3k/include/upio.h
 create mode 100644 libbt-ath3k/include/userial_vendor.h
 create mode 100644 libbt-ath3k/include/vnd_generic.txt
 create mode 100644 libbt-ath3k/src/bt_vendor_ath3k.c
 create mode 100644 libbt-ath3k/src/conf.c
 create mode 100644 libbt-ath3k/src/hardware.c
 create mode 100644 libbt-ath3k/src/upio.c
 create mode 100644 libbt-ath3k/src/userial_vendor.c
 create mode 100755 libbt-ath3k/vnd_buildcfg.mk

diff --git a/Android.mk b/Android.mk
index 988e584..8b98bd7 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,4 +1,4 @@
-common_imx_dirs := libsensors libgps lights wlan
+common_imx_dirs := libsensors libgps lights wlan libbt-ath3k
 mx5x_dirs := $(common_imx_dirs) mx5x/audio mx5x/libcopybit mx5x/libgralloc  mx5x/hwcomposer mx5x/libcamera
 mx6_dirs := $(common_imx_dirs) alsa mx6/libgralloc_wrapper mx6/hwcomposer mx6/power
 
diff --git a/libbt-ath3k/Android.mk b/libbt-ath3k/Android.mk
new file mode 100755
index 0000000..8c7c0dd
--- /dev/null
+++ b/libbt-ath3k/Android.mk
@@ -0,0 +1,55 @@
+#
+# Copyright 2012 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+LOCAL_PATH := $(call my-dir)
+
+ifneq ($(BOARD_HAVE_BLUETOOTH_QCOM_ATH3K),)
+
+include $(CLEAR_VARS)
+
+BDROID_DIR := $(TOP_DIR)external/bluetooth/bluedroid
+
+LOCAL_SRC_FILES := \
+        src/bt_vendor_ath3k.c \
+        src/hardware.c \
+        src/userial_vendor.c \
+        src/upio.c \
+        src/conf.c
+
+LOCAL_C_INCLUDES += \
+        $(LOCAL_PATH)/include \
+        $(BDROID_DIR)/hci/include
+
+LOCAL_SHARED_LIBRARIES := \
+        libcutils
+
+LOCAL_MODULE := libbt-vendor
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_CLASS := SHARED_LIBRARIES
+LOCAL_MODULE_OWNER := qcom
+LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR_SHARED_LIBRARIES)
+
+include $(LOCAL_PATH)/vnd_buildcfg.mk
+
+include $(BUILD_SHARED_LIBRARY)
+
+ifeq ($(TARGET_DEVICE), imx53_smd)
+    include $(LOCAL_PATH)/conf/fsl/imx53_smd/Android.mk
+endif
+ifeq ($(TARGET_DEVICE), sabresd_6dq)
+    include $(LOCAL_PATH)/conf/fsl/sabresd_6dq/Android.mk
+endif
+endif # BOARD_HAVE_BLUETOOTH_QCOM_ATH3K
diff --git a/libbt-ath3k/conf/fsl/imx53_smd/Android.mk b/libbt-ath3k/conf/fsl/imx53_smd/Android.mk
new file mode 100755
index 0000000..974e213
--- /dev/null
+++ b/libbt-ath3k/conf/fsl/imx53_smd/Android.mk
@@ -0,0 +1,14 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/bluetooth
+
+LOCAL_MODULE_TAGS := eng
+
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
+
diff --git a/libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf b/libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf
new file mode 100755
index 0000000..b853e76
--- /dev/null
+++ b/libbt-ath3k/conf/fsl/imx53_smd/bt_vendor.conf
@@ -0,0 +1,5 @@
+# UART device port where Bluetooth controller is attached
+UartPort = /dev/ttymxc2
+
+# Firmware patch file location
+FwPatchFilePath = /lib/firmware/ar3k/
diff --git a/libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk b/libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk
new file mode 100755
index 0000000..974e213
--- /dev/null
+++ b/libbt-ath3k/conf/fsl/sabresd_6dq/Android.mk
@@ -0,0 +1,14 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := bt_vendor.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/bluetooth
+
+LOCAL_MODULE_TAGS := eng
+
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+
+include $(BUILD_PREBUILT)
+
diff --git a/libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf b/libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf
new file mode 100755
index 0000000..2b3b0ff
--- /dev/null
+++ b/libbt-ath3k/conf/fsl/sabresd_6dq/bt_vendor.conf
@@ -0,0 +1,5 @@
+# UART device port where Bluetooth controller is attached
+UartPort = /dev/ttymxc4
+
+# Firmware patch file location
+FwPatchFilePath = /system/lib/firmware/ar3k/
diff --git a/libbt-ath3k/include/bt_vendor_ath3k.h b/libbt-ath3k/include/bt_vendor_ath3k.h
new file mode 100644
index 0000000..f3f7be2
--- /dev/null
+++ b/libbt-ath3k/include/bt_vendor_ath3k.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+#ifndef BT_VENDOR_ATH3K_H
+#define BT_VENDOR_ATH3K_H
+
+#include "bt_vendor_lib.h"
+#include "vnd_buildcfg.h"
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+#ifndef TRUE
+#define TRUE   (!FALSE)
+#endif
+
+/* Run-time configuration file */
+#ifndef VENDOR_LIB_CONF_FILE
+#define VENDOR_LIB_CONF_FILE "/etc/bluetooth/bt_vendor.conf"
+#endif
+
+#ifndef UART_TARGET_BAUD_RATE
+#define UART_TARGET_BAUD_RATE           3000000
+#endif
+
+extern bt_vendor_callbacks_t *bt_vendor_cbacks;
+
+#endif /* BT_VENDOR_ATH3K_H */
+
diff --git a/libbt-ath3k/include/upio.h b/libbt-ath3k/include/upio.h
new file mode 100644
index 0000000..a22f2fe
--- /dev/null
+++ b/libbt-ath3k/include/upio.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      upio.h
+ *
+ *  Description:   Contains definitions used for I/O controls
+ *
+ ******************************************************************************/
+
+#ifndef UPIO_H
+#define UPIO_H
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#define UPIO_BT_POWER_OFF 0
+#define UPIO_BT_POWER_ON  1
+
+/******************************************************************************
+**  Extern variables and functions
+******************************************************************************/
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+
+/*******************************************************************************
+**
+** Function        upio_set_bluetooth_power
+**
+** Description     Interact with low layer driver to set Bluetooth power
+**                 on/off.
+**
+** Returns         0  : SUCCESS or Not-Applicable
+**                 <0 : ERROR
+**
+*******************************************************************************/
+int upio_set_bluetooth_power(int on);
+
+#endif /* UPIO_H */
+
diff --git a/libbt-ath3k/include/userial_vendor.h b/libbt-ath3k/include/userial_vendor.h
new file mode 100644
index 0000000..4b999cf
--- /dev/null
+++ b/libbt-ath3k/include/userial_vendor.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      userial_vendor.h
+ *
+ *  Description:   Contains vendor-specific definitions used in serial port
+ *                 controls
+ *
+ ******************************************************************************/
+
+#ifndef USERIAL_VENDOR_H
+#define USERIAL_VENDOR_H
+
+#include "bt_vendor_ath3k.h"
+#include "userial.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+/**** baud rates ****/
+#define USERIAL_BAUD_300        0
+#define USERIAL_BAUD_600        1
+#define USERIAL_BAUD_1200       2
+#define USERIAL_BAUD_2400       3
+#define USERIAL_BAUD_9600       4
+#define USERIAL_BAUD_19200      5
+#define USERIAL_BAUD_57600      6
+#define USERIAL_BAUD_115200     7
+#define USERIAL_BAUD_230400     8
+#define USERIAL_BAUD_460800     9
+#define USERIAL_BAUD_921600     10
+#define USERIAL_BAUD_1M         11
+#define USERIAL_BAUD_1_5M       12
+#define USERIAL_BAUD_2M         13
+#define USERIAL_BAUD_3M         14
+#define USERIAL_BAUD_4M         15
+#define USERIAL_BAUD_AUTO       16
+
+/**** Data Format ****/
+/* Stop Bits */
+#define USERIAL_STOPBITS_1      1
+#define USERIAL_STOPBITS_1_5    (1<<1)
+#define USERIAL_STOPBITS_2      (1<<2)
+
+/* Parity Bits */
+#define USERIAL_PARITY_NONE     (1<<3)
+#define USERIAL_PARITY_EVEN     (1<<4)
+#define USERIAL_PARITY_ODD      (1<<5)
+
+/* Data Bits */
+#define USERIAL_DATABITS_5      (1<<6)
+#define USERIAL_DATABITS_6      (1<<7)
+#define USERIAL_DATABITS_7      (1<<8)
+#define USERIAL_DATABITS_8      (1<<9)
+
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+/* These are the ioctl values used for bt_wake ioctl via UART driver. you may
+ * need to redefine them on you platform!
+ * Logically they need to be unique and not colide with existing uart ioctl's.
+ */
+#ifndef USERIAL_IOCTL_BT_WAKE_ASSERT
+#define USERIAL_IOCTL_BT_WAKE_ASSERT   0x8003
+#endif
+#ifndef USERIAL_IOCTL_BT_WAKE_DEASSERT
+#define USERIAL_IOCTL_BT_WAKE_DEASSERT 0x8004
+#endif
+#ifndef USERIAL_IOCTL_BT_WAKE_GET_ST
+#define USERIAL_IOCTL_BT_WAKE_GET_ST   0x8005
+#endif
+#endif // (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+
+/******************************************************************************
+**  Type definitions
+******************************************************************************/
+
+/* Structure used to configure serial port during open */
+typedef struct
+{
+    uint16_t fmt;       /* Data format */
+    uint8_t  baud;      /* Baud rate */
+} tUSERIAL_CFG;
+
+typedef enum {
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    USERIAL_OP_ASSERT_BT_WAKE,
+    USERIAL_OP_DEASSERT_BT_WAKE,
+    USERIAL_OP_GET_BT_WAKE_STATE,
+#endif
+    USERIAL_OP_NOP,
+} userial_vendor_ioctl_op_t;
+
+/******************************************************************************
+**  Extern variables and functions
+******************************************************************************/
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+
+/*******************************************************************************
+**
+** Function        userial_vendor_init
+**
+** Description     Initialize userial vendor-specific control block
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_init(void);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_open
+**
+** Description     Open the serial port with the given configuration
+**
+** Returns         device fd
+**
+*******************************************************************************/
+int userial_vendor_open(tUSERIAL_CFG *p_cfg);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_close
+**
+** Description     Conduct vendor-specific close work
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_close(void);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_set_baud
+**
+** Description     Set new baud rate
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_set_baud(uint8_t userial_baud);
+
+/*******************************************************************************
+**
+** Function        userial_vendor_ioctl
+**
+** Description     ioctl inteface
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_ioctl(userial_vendor_ioctl_op_t op, void *p_data);
+
+#endif /* USERIAL_VENDOR_H */
+
diff --git a/libbt-ath3k/include/vnd_generic.txt b/libbt-ath3k/include/vnd_generic.txt
new file mode 100644
index 0000000..9c43132
--- /dev/null
+++ b/libbt-ath3k/include/vnd_generic.txt
@@ -0,0 +1,6 @@
+BLUETOOTH_UART_DEVICE_PORT = "/dev/ttymxc4"
+FW_PATCHFILE_LOCATION = "/vendor/firmware/"
+BTVND_DBG = FALSE
+BTHW_DBG = FALSE
+VNDUSERIAL_DBG = FALSE
+UPIO_DBG = FALSE
diff --git a/libbt-ath3k/src/bt_vendor_ath3k.c b/libbt-ath3k/src/bt_vendor_ath3k.c
new file mode 100644
index 0000000..9289b3f
--- /dev/null
+++ b/libbt-ath3k/src/bt_vendor_ath3k.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      bt_vendor_ar3k.c
+ *
+ *  Description:   QCOM/Atheros vendor specific library implementation
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_vendor"
+
+#include <utils/Log.h>
+#include "bt_vendor_ath3k.h"
+#include "upio.h"
+#include "userial_vendor.h"
+
+#ifndef BTVND_DBG
+#define BTVND_DBG FALSE
+#endif
+
+#if (BTVND_DBG == TRUE)
+#define BTVNDDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
+#else
+#define BTVNDDBG(param, ...) {}
+#endif
+
+/******************************************************************************
+**  Static Variables
+******************************************************************************/
+
+static const tUSERIAL_CFG userial_init_cfg =
+{
+    (USERIAL_DATABITS_8 | USERIAL_PARITY_NONE | USERIAL_STOPBITS_1),
+    USERIAL_BAUD_115200
+};
+
+/******************************************************************************
+**  Externs
+******************************************************************************/
+extern void hw_config_start(void);
+extern void vnd_load_conf(const char *p_path);
+
+/******************************************************************************
+**  Variables
+******************************************************************************/
+bt_vendor_callbacks_t *bt_vendor_cbacks = NULL;
+uint8_t vnd_local_bd_addr[6]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+
+/*****************************************************************************
+**
+**   BLUETOOTH VENDOR INTERFACE LIBRARY FUNCTIONS
+**
+*****************************************************************************/
+
+static int init(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr)
+{
+    BTVNDDBG("init");
+
+    if (p_cb == NULL)
+    {
+        ALOGE("init failed with no user callbacks!");
+        return -1;
+    }
+
+    userial_vendor_init();
+
+    vnd_load_conf(VENDOR_LIB_CONF_FILE);
+
+    /* store reference to user callbacks */
+    bt_vendor_cbacks = (bt_vendor_callbacks_t *) p_cb;
+
+    /* This is handed over from the stack, when to use it? */
+    memcpy(vnd_local_bd_addr, local_bdaddr, 6);
+
+    return 0;
+}
+
+/** Requested operations */
+static int op(bt_vendor_opcode_t opcode, void *param)
+{
+    int retval = 0;
+
+    BTVNDDBG("op for %d", opcode);
+
+    switch(opcode)
+    {
+        case BT_VND_OP_POWER_CTRL:
+            {
+                int *state = (int *) param;
+
+                if (*state == BT_VND_PWR_OFF)
+                    upio_set_bluetooth_power(UPIO_BT_POWER_OFF);
+                else if (*state == BT_VND_PWR_ON)
+                    upio_set_bluetooth_power(UPIO_BT_POWER_ON);
+
+                retval = 0;
+
+            }
+            break;
+
+        case BT_VND_OP_FW_CFG:
+            {
+                if (bt_vendor_cbacks) {
+                   BTVNDDBG("Bluetooth hw config start");
+
+                   hw_config_start();
+
+                } else {
+                   ALOGE("Bluetooth bt_vendor_cbacks is NULL ");
+                }
+            }
+            break;
+
+        case BT_VND_OP_SCO_CFG:
+            {
+                bt_vendor_cbacks->scocfg_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
+                retval = -1;
+            }
+            break;
+
+        case BT_VND_OP_USERIAL_OPEN:
+            {
+                int (*fd_array)[] = (int (*)[]) param;
+                int fd, idx;
+                fd = userial_vendor_open((tUSERIAL_CFG *) &userial_init_cfg);
+                if (fd != -1)
+                {
+                    for (idx=0; idx < CH_MAX; idx++)
+                        (*fd_array)[idx] = fd;
+
+                    retval = 1;
+                }
+
+            }
+            break;
+
+        case BT_VND_OP_USERIAL_CLOSE:
+            {
+                 userial_vendor_close();
+            }
+            break;
+
+        case BT_VND_OP_GET_LPM_IDLE_TIMEOUT:
+            {
+                uint32_t *timeout_ms = (uint32_t *) param;
+                *timeout_ms = 50;
+            }
+            break;
+
+        case BT_VND_OP_LPM_SET_MODE:
+            {
+                bt_vendor_cbacks->lpm_cb(BT_VND_OP_RESULT_SUCCESS); //dummy
+            }
+            break;
+
+        case BT_VND_OP_LPM_WAKE_SET_STATE:
+            /*{
+                uint8_t *state = (uint8_t *) param;
+                uint8_t wake_assert = (*state == BT_VND_LPM_WAKE_ASSERT) ? \
+                                        TRUE : FALSE;
+            }*/
+            break;
+    }
+
+    return retval;
+}
+
+/** Closes the interface */
+static void cleanup( void )
+{
+    BTVNDDBG("cleanup");
+
+    bt_vendor_cbacks = NULL;
+}
+
+// Entry point of DLib
+const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE = {
+    sizeof(bt_vendor_interface_t),
+    init,
+    op,
+    cleanup
+};
diff --git a/libbt-ath3k/src/conf.c b/libbt-ath3k/src/conf.c
new file mode 100644
index 0000000..ba73964
--- /dev/null
+++ b/libbt-ath3k/src/conf.c
@@ -0,0 +1,139 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      conf.c
+ *
+ *  Description:   Contains functions to conduct run-time module configuration
+ *                 based on entries present in the .conf file
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_vnd_conf"
+
+#include <utils/Log.h>
+#include <string.h>
+#include "bt_vendor_ath3k.h"
+
+/******************************************************************************
+**  Externs
+******************************************************************************/
+int userial_set_port(char *p_conf_name, char *p_conf_value, int param);
+int hw_set_patch_file_path(char *p_conf_name, char *p_conf_value, int param);
+
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+#define CONF_COMMENT '#'
+#define CONF_DELIMITERS " =\n\r\t"
+#define CONF_VALUES_DELIMITERS "=\n\r\t"
+#define CONF_MAX_LINE_LEN 255
+
+typedef int (conf_action_t)(char *p_conf_name, char *p_conf_value, int param);
+
+typedef struct {
+    const char *conf_entry;
+    conf_action_t *p_action;
+    int param;
+} conf_entry_t;
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+
+/*
+ * Current supported entries and corresponding action functions
+ */
+static const conf_entry_t conf_table[] = {
+    {"UartPort", userial_set_port, 0},
+    {"FwPatchFilePath", hw_set_patch_file_path, 0},
+    {(const char *) NULL, NULL, 0}
+};
+
+/*****************************************************************************
+**   CONF INTERFACE FUNCTIONS
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        vnd_load_conf
+**
+** Description     Read conf entry from p_path file one by one and call
+**                 the corresponding config function
+**
+** Returns         None
+**
+*******************************************************************************/
+void vnd_load_conf(const char *p_path)
+{
+    FILE    *p_file;
+    char    *p_name;
+    char    *p_value;
+    conf_entry_t    *p_entry;
+    char    line[CONF_MAX_LINE_LEN+1]; /* add 1 for \0 char */
+
+    ALOGI("Attempt to load conf from %s", p_path);
+
+    if ((p_file = fopen(p_path, "r")) != NULL)
+    {
+        /* read line by line */
+        while (fgets(line, CONF_MAX_LINE_LEN+1, p_file) != NULL)
+        {
+            if (line[0] == CONF_COMMENT)
+                continue;
+
+            p_name = strtok(line, CONF_DELIMITERS);
+
+            if (NULL == p_name)
+            {
+                continue;
+            }
+
+            p_value = strtok(NULL, CONF_DELIMITERS);
+
+            if (NULL == p_value)
+            {
+                ALOGW("vnd_load_conf: missing value for name: %s", p_name);
+                continue;
+            }
+
+            p_entry = (conf_entry_t *)conf_table;
+
+            while (p_entry->conf_entry != NULL)
+            {
+                if (strcmp(p_entry->conf_entry, (const char *)p_name) == 0)
+                {
+                    p_entry->p_action(p_name, p_value, p_entry->param);
+                    break;
+                }
+
+                p_entry++;
+            }
+        }
+
+        fclose(p_file);
+    }
+    else
+    {
+        ALOGI( "vnd_load_conf file >%s< not found", p_path);
+    }
+}
+
diff --git a/libbt-ath3k/src/hardware.c b/libbt-ath3k/src/hardware.c
new file mode 100644
index 0000000..1f4ec0c
--- /dev/null
+++ b/libbt-ath3k/src/hardware.c
@@ -0,0 +1,1253 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      hardware.c
+ *
+ *  Description:   Contains ath3k controller-specific functions, like
+ *                      firmware patch download
+ *                      low power mode operations
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_hwcfg"
+
+#include <utils/Log.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include <time.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <ctype.h>
+#include <cutils/properties.h>
+#include <stdlib.h>
+
+#include "bt_hci_bdroid.h"
+#include "bt_vendor_ath3k.h"
+#include "userial_vendor.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#ifndef BTHW_DBG
+#define BTHW_DBG FALSE
+#endif
+
+#if (BTHW_DBG == TRUE)
+#define BTHWDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
+#else
+#define BTHWDBG(param, ...) {}
+#endif
+
+#define HCI_SLEEP_CMD_OCF       0x04
+#define GET_DEV_TYPE_OCF        0x05
+#define HCI_PS_CMD_OCF          0x0B
+#define HCI_CHG_BAUD_CMD_OCF    0x0C
+#define GET_VERSION_OCF         0x1E
+
+/* AR3k Vendor Specific commands */
+#define HCI_GRP_VENDOR_SPECIFIC (0x3F << 10)            /* 0xFC00 */
+#define HCI_VSC_SLEEP_CMD       (HCI_GRP_VENDOR_SPECIFIC | HCI_SLEEP_CMD_OCF)
+#define HCI_VSC_GET_DEV_TYPE    (HCI_GRP_VENDOR_SPECIFIC | GET_DEV_TYPE_OCF)
+#define HCI_VSC_PS_CMD          (HCI_GRP_VENDOR_SPECIFIC | HCI_PS_CMD_OCF)
+#define HCI_VSC_CHG_BAUD_CMD    (HCI_GRP_VENDOR_SPECIFIC | HCI_CHG_BAUD_CMD_OCF)
+#define HCI_VSC_GET_VERSION     (HCI_GRP_VENDOR_SPECIFIC | GET_VERSION_OCF)
+#define HCI_RESET               0x0C03
+
+#define HCI_CMD_MAX_LEN                         258
+#define HCI_EVT_CMD_CMPL_OPCODE                 3
+#define HCI_EVT_CMD_CMPL_STATUS_RET_BYTE        5
+#define HCI_EVT_CMD_CMPL_RESPONSE               6
+#define HCI_CMD_PREAMBLE_SIZE                   3
+#define GET_DEV_TYPE_CMD_PARAM_SIZE             5
+#define PS_CMD_GET_CRC_PARAM_SIZE               4
+#define PS_CMD_WRITE_BDADDR_PARAM_SIZE          10
+#define PS_CMD_WRITE_PATCH_PARAM_SIZE           4
+#define CHG_BAUD_CMD_PARAM_SIZE                 2
+#define PS_RESET_PARAM_LEN                      6
+
+#define DEV_REGISTER            0x4FFC
+#define PS_ASIC_FILE            "PS_ASIC.pst"
+#define PS_FPGA_FILE            "PS_FPGA.pst"
+#define MAXPATHLEN              4096
+#define PATCH_FILE              "RamPatch.txt"
+#define BDADDR_FILE             "ar3kbdaddr.pst"
+#define FPGA_ROM_VERSION        0x99999999
+#define ROM_DEV_TYPE            0xdeadc0de
+#define PS_HEX                  0
+#define PS_DEC                  1
+#define UNDEFINED               0xFFFF
+#define ARRAY                   'A'
+#define STRING                  'S'
+#define DECIMAL                 'D'
+#define BINARY                  'B'
+#define PS_UNDEF                0
+#define PS_ID                   1
+#define PS_LEN                  2
+#define PS_DATA                 3
+#define PS_MAX_LEN              500
+#define LINE_SIZE_MAX           (PS_MAX_LEN * 2)
+#define ENTRY_PER_LINE          16
+#define MAX_PREAMBLE_LEN        4
+#define PATCH_LOC_KEY           "DA:"
+#define MAX_BD_ADDR_LEN         20
+#define SET_PATCH_RAM_ID        0x0D
+#define SET_PATCH_RAM_CMD_SIZE  11
+#define ADDRESS_LEN             4
+#define MAX_TAGS                50
+#define PS_HDR_LEN              4
+#define VERIFY_CRC              9
+#define PS_REGION               1
+#define PATCH_REGION            2
+#define MAX_PATCH_CMD           244
+#define PS_WRITE                1
+#define PS_RESET                2
+#define WRITE_PATCH             8
+#define ENABLE_PATCH            11
+#define PS_ID_MASK              0xFF
+
+#define __check_comment(buf) (((buf)[0] == '/') && ((buf)[1] == '/'))
+#define __skip_space(str)      while (*(str) == ' ') ((str)++)
+#define __is_delim(ch) ((ch) == ':')
+
+#define STREAM_TO_UINT16(u16, p) {u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); (p) += 2;}
+#define UINT16_TO_STREAM(p, u16) {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8);}
+
+struct patch_entry {
+    int16_t len;
+    uint8_t data[MAX_PATCH_CMD];
+};
+
+#define HCI_PS_CMD_HDR_LEN HCI_CMD_PREAMBLE_SIZE + PS_HDR_LEN
+#define PS_RESET_CMD_LEN   (HCI_PS_CMD_HDR_LEN + PS_RESET_PARAM_LEN)
+
+#define LOCAL_NAME_BUFFER_LEN                   32
+
+void hw_config_cback(void *p_mem);
+#define PATCH_LOC_STRING_LEN   8
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+
+/* h/w config control block */
+typedef struct
+{
+    uint8_t state;                          /* Hardware configuration state */
+    int     fw_fd;                          /* FW patch file fd */
+    uint8_t f_set_baud_2;                   /* Baud rate switch state */
+    char    local_chip_name[LOCAL_NAME_BUFFER_LEN];
+} bt_hw_cfg_cb_t;
+
+static bt_hw_cfg_cb_t hw_cfg_cb;
+
+static char patch_file[PATH_MAX];
+static char ps_file[PATH_MAX];
+static FILE *rampatch_fd;
+static int tag_count=0;
+static int current_tag_idx=0;
+static uint32_t dev_type = 0xdeadc0de;
+static uint32_t rom_version = 0x30101;
+static uint32_t bld_version = 0x9d6a2;
+char ARbyte[3];
+char ARptr[MAX_PATCH_CMD + 1];
+int byte_cnt;
+int segment_idx = 0;
+char patch_loc[PATCH_LOC_STRING_LEN + 1];
+int ps_counter=0;
+static char fw_patchfile_path[MAXPATHLEN] = FW_PATCHFILE_LOCATION;
+
+struct tag_info {
+    unsigned section;
+    unsigned line_count;
+    unsigned char_cnt;
+    unsigned byte_count;
+};
+
+struct ps_cfg_entry {
+    uint32_t id;
+    uint32_t len;
+    uint8_t *data;
+};
+
+struct ps_entry_type {
+    unsigned char type;
+    unsigned char array;
+};
+
+struct ps_cfg_entry ps_list[MAX_TAGS];
+
+struct hci_command_hdr {
+    uint16_t    opcode;     /* OCF & OGF */
+    uint8_t     plen;
+};
+
+/* Hardware Configuration State */
+enum {
+    HW_CFG_START = 1,
+    HW_CFG_SET_CNTRLR_BAUD,
+    HW_CFG_GET_DEVICE_TYPE,
+    HW_CFG_GET_ATH3K_VERSION,
+    HW_CFG_GET_ATH3K_CRC,
+    HW_CFG_PSPATCH_START_DOWNLOAD,
+    HW_CFG_PSPATCH_DOWNLOAD,
+    HW_CFG_PSPATCH_DOWNLOADING,
+    HW_CFG_PSPATCH_DOWNLOADED,
+    HW_CFG_CONFIG_RESET,
+    HW_CFG_CONFIG_DOWNLOADING,
+    HW_CFG_WRITE_BDADDRESS,
+    HW_CFG_WRITE_BDADDRESS_DONE,
+    HW_CFG_HCI_RESET,
+    HW_CFG_CNTRLR_BAUD,
+    HW_CFG_CNTRLR_BAUD_UPDATE,
+};
+
+static int send_cmd(HC_BT_HDR *p_buf, uint8_t *buffer, int len)
+{
+    uint8_t     *p;
+
+    BTHWDBG("%s", __func__);
+
+    if (p_buf)
+    {
+        struct hci_command_hdr *ch = (void *)buffer;
+
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->len = len;
+        p_buf->layer_specific = 0;
+
+        p = (uint8_t *) (p_buf + 1);
+        memcpy(p, buffer, len);
+
+        bt_vendor_cbacks->xmit_cb(ch->opcode, p_buf, hw_config_cback);
+    }
+    return 0;
+}
+
+static void load_hci_ps_hdr(uint8_t *cmd, uint8_t ps_op, int len, int index)
+{
+    BTHWDBG("%s ps_op = 0x%x", __func__, ps_op);
+
+    UINT16_TO_STREAM(cmd, HCI_VSC_PS_CMD);
+    *cmd++ = len + PS_HDR_LEN;
+    *cmd++ = ps_op;
+    *cmd++ = index;
+    *cmd++ = index >> 8;
+    *cmd = len;
+}
+
+/* Sends PS commands using vendor specficic HCI commands */
+static int write_ps_cmd(HC_BT_HDR *p_buf, uint8_t opcode, uint32_t ps_param)
+{
+    uint8_t cmd[HCI_CMD_MAX_LEN];
+
+    BTHWDBG("%s opcode %d", __func__, opcode);
+
+    switch (opcode) {
+        case PS_WRITE:
+            {
+                load_hci_ps_hdr(cmd, opcode, ps_list[ps_param].len,
+                                ps_list[ps_param].id);
+
+                memcpy(&cmd[HCI_PS_CMD_HDR_LEN], ps_list[ps_param].data,
+                                        ps_list[ps_param].len);
+
+                if (send_cmd(p_buf, cmd, ps_list[ps_param].len +
+                                            HCI_PS_CMD_HDR_LEN) < 0)
+                    return -EILSEQ;
+            }
+            break;
+        case ENABLE_PATCH:
+            {
+                load_hci_ps_hdr(cmd, opcode, 0, 0x00);
+
+                if (send_cmd(p_buf, cmd, HCI_PS_CMD_HDR_LEN) < 0)
+                    return -EILSEQ;
+            }
+            break;
+
+        case PS_RESET:
+            {
+                load_hci_ps_hdr(cmd, opcode, PS_RESET_PARAM_LEN, 0x00);
+
+                cmd[7] = 0x00;
+                cmd[8] = 0x00;
+                cmd[9] = 0x00;
+                cmd[10] = 0x00;
+
+                cmd[PS_RESET_CMD_LEN - 2] = ps_param & PS_ID_MASK;
+                cmd[PS_RESET_CMD_LEN - 1] = (ps_param >> 8) & PS_ID_MASK;
+
+                if (send_cmd(p_buf, cmd, PS_RESET_CMD_LEN) < 0)
+                    return -EILSEQ;
+            }
+            break;
+    }
+    return 0;
+}
+
+/* Parse PS entry preamble of format [X:X] for main type and subtype */
+static int get_ps_type(char *ptr, int index, char *type, char *sub_type)
+{
+    int i;
+    int delim = FALSE;
+
+    BTHWDBG("%s ", __func__);
+
+    if (index > MAX_PREAMBLE_LEN)
+        return -EILSEQ;
+
+    for (i = 1; i < index; i++) {
+        if (__is_delim(ptr[i])) {
+            delim = TRUE;
+            continue;
+        }
+
+        if (isalpha(ptr[i])) {
+            if (delim == FALSE)
+                (*type) = toupper(ptr[i]);
+            else
+                (*sub_type) = toupper(ptr[i]);
+        }
+    }
+    return 0;
+}
+
+static int get_input_format(char *buf, struct ps_entry_type *format)
+{
+    char *ptr = NULL;
+    char type = '\0';
+    char sub_type = '\0';
+
+    format->type = PS_HEX;
+    format->array = TRUE;
+
+    if (strstr(buf, "[") != buf)
+        return 0;
+
+    ptr = strstr(buf, "]");
+    if (!ptr)
+        return -EILSEQ;
+
+    if (get_ps_type(buf, ptr - buf, &type, &sub_type) < 0)
+        return -EILSEQ;
+
+    /* Check is data type is of array */
+    if (type == ARRAY || sub_type == ARRAY)
+        format->array = TRUE;
+
+    if (type == STRING || sub_type == STRING)
+        format->array = FALSE;
+
+    if (type == DECIMAL || type == BINARY)
+        format->type = PS_DEC;
+    else
+        format->type = PS_HEX;
+
+    return 0;
+}
+
+static unsigned int read_data_in_section(char *buf, struct ps_entry_type type)
+{
+    char *ptr = buf;
+
+    if (!buf)
+        return UNDEFINED;
+
+    if (buf == strstr(buf, "[")) {
+        ptr = strstr(buf, "]");
+        if (!ptr)
+            return UNDEFINED;
+
+        ptr++;
+    }
+
+    if (type.type == PS_HEX && type.array != TRUE)
+        return strtol(ptr, NULL, 16);
+
+    return UNDEFINED;
+}
+
+/* Read PS entries as string, convert and add to Hex array */
+static void update_tag_data(struct ps_cfg_entry *tag,
+                    struct tag_info *info, const char *ptr)
+{
+    char buf[3];
+
+    buf[2] = '\0';
+
+    strncpy(buf, &ptr[info->char_cnt], 2);
+    tag->data[info->byte_count] = strtol(buf, NULL, 16);
+    info->char_cnt += 3;
+    info->byte_count++;
+
+    strncpy(buf, &ptr[info->char_cnt], 2);
+    tag->data[info->byte_count] = strtol(buf, NULL, 16);
+    info->char_cnt += 3;
+    info->byte_count++;
+}
+
+static inline int update_char_count(const char *buf)
+{
+    char *end_ptr;
+
+    if (strstr(buf, "[") == buf) {
+        end_ptr = strstr(buf, "]");
+        if (!end_ptr)
+            return 0;
+        else
+            return (end_ptr - buf) + 1;
+    }
+
+    return 0;
+}
+
+static int ath_parse_ps(FILE *ps_stream)
+{
+    char buf[LINE_SIZE_MAX + 1];
+    char *ptr;
+    uint8_t tag_cnt = 0;
+    int16_t byte_count = 0;
+    struct ps_entry_type format;
+    struct tag_info status = { 0, 0, 0, 0 };
+
+    do{
+        int read_count;
+        struct ps_cfg_entry *tag;
+
+        ptr = fgets(buf, LINE_SIZE_MAX, ps_stream);
+        if (!ptr)
+            break;
+
+        __skip_space(ptr);
+        if (__check_comment(ptr))
+            continue;
+
+        /* Lines with a '#' will be followed by new PS entry */
+        if (ptr == strstr(ptr, "#")) {
+            if (status.section != PS_UNDEF) {
+                return -EILSEQ;
+            } else {
+                status.section = PS_ID;
+                continue;
+            }
+        }
+
+        tag = &ps_list[tag_cnt];
+
+        switch (status.section) {
+        case PS_ID:
+            if (get_input_format(ptr, &format) < 0)
+                return -EILSEQ;
+
+            tag->id = read_data_in_section(ptr, format);
+            status.section = PS_LEN;
+            break;
+
+        case PS_LEN:
+            if (get_input_format(ptr, &format) < 0)
+                return -EILSEQ;
+
+            byte_count = read_data_in_section(ptr, format);
+            if (byte_count > PS_MAX_LEN)
+                return -EILSEQ;
+
+            tag->len = byte_count;
+            tag->data = (uint8_t *)malloc(byte_count);
+
+            status.section = PS_DATA;
+            status.line_count = 0;
+            break;
+
+        case PS_DATA:
+            if (status.line_count == 0)
+                if (get_input_format(ptr, &format) < 0)
+                    return -EILSEQ;
+
+            __skip_space(ptr);
+
+            status.char_cnt = update_char_count(ptr);
+
+            read_count = (byte_count > ENTRY_PER_LINE) ?
+                    ENTRY_PER_LINE : byte_count;
+
+            if (format.type == PS_HEX && format.array == TRUE) {
+                while (read_count > 0) {
+                    update_tag_data(tag, &status, ptr);
+                    read_count -= 2;
+                }
+
+                if (byte_count > ENTRY_PER_LINE)
+                    byte_count -= ENTRY_PER_LINE;
+                else
+                    byte_count = 0;
+            }
+
+            status.line_count++;
+
+            if (byte_count == 0)
+                memset(&status, 0x00, sizeof(struct tag_info));
+
+            if (status.section == PS_UNDEF)
+                tag_cnt++;
+
+            if (tag_cnt == MAX_TAGS)
+                return -EILSEQ;
+            break;
+        }
+    } while (ptr);
+
+    return tag_cnt;
+}
+
+
+static int ps_reset_config(HC_BT_HDR *p_buf)
+{
+#define PS_RAM_SIZE 2048
+
+    if (write_ps_cmd(p_buf, PS_RESET, PS_RAM_SIZE) < 0)
+        return -1;
+    else
+        return 0;
+}
+
+static int ps_config_download(HC_BT_HDR *p_buf, int tag_count)
+{
+    if (write_ps_cmd(p_buf, PS_WRITE, tag_count) < 0)
+        return -1;
+    else
+        return 0;
+}
+
+static int set_patch_ram(HC_BT_HDR *p_buf, char *patch_loc)
+{
+    int err;
+    int i;
+    char loc_byte[3];
+    uint8_t *p;
+
+    if (!patch_loc)
+        return -1;
+
+    loc_byte[2] = '\0';
+
+    if (p_buf)
+    {
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->len = HCI_CMD_PREAMBLE_SIZE + PS_HDR_LEN + ADDRESS_LEN;
+        p_buf->layer_specific = 0;
+
+        p = (uint8_t *) (p_buf + 1);
+
+        UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
+        *p++ = PS_HDR_LEN + ADDRESS_LEN;
+        *p++ = SET_PATCH_RAM_ID;
+        *p++ = 0;
+        *p++ = 0 >> 8;
+        *p++ = ADDRESS_LEN;
+
+        for (i = 3; i >= 0; i--) {
+            loc_byte[0] = patch_loc[0];
+            loc_byte[1] = patch_loc[1];
+            *p++ = strtol(loc_byte, NULL, 16);
+            patch_loc += 2;
+        }
+
+        hw_cfg_cb.state = HW_CFG_PSPATCH_START_DOWNLOAD;
+        bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
+    }
+    return err;
+}
+
+
+static int enable_patch(HC_BT_HDR *p_buf)
+{
+    BTHWDBG("%s ", __func__);
+
+    if (write_ps_cmd(p_buf, ENABLE_PATCH, 0) < 0)
+        return -1;
+
+    return 0;
+}
+
+static int write_patch(HC_BT_HDR *p_buf)
+{
+    uint8_t ret = -1;
+    uint8_t *p;
+    int i;
+    BTHWDBG("%s ", __func__);
+
+    if (ps_counter==1)
+    {
+        ps_counter=2;
+        byte_cnt = strtol(ARptr, NULL, 16);
+    }
+
+    if (byte_cnt > 0) {
+        struct patch_entry patch;
+
+        if (byte_cnt > MAX_PATCH_CMD)
+            patch.len = MAX_PATCH_CMD;
+        else
+            patch.len = byte_cnt;
+
+        /* Read 2 bytes from the stream */
+        for (i = 0; i < patch.len; i++) {
+            if (!fgets(ARbyte, 3, rampatch_fd)) {
+                return -1;
+            }
+            /* Convert to integer */
+            patch.data[i] = strtoul(ARbyte, NULL, 16);
+        }
+
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->len = patch.len + HCI_CMD_PREAMBLE_SIZE + PS_CMD_WRITE_PATCH_PARAM_SIZE;
+        p_buf->layer_specific = 0;
+
+        p = (uint8_t *) (p_buf + 1);
+
+        /* Set opcode */
+        UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
+
+        /* Set length */
+        *p++ = patch.len + PS_CMD_WRITE_PATCH_PARAM_SIZE;
+        *p++ = WRITE_PATCH;
+        /* LSB, MSB of segment index */
+        *p++ = segment_idx;
+        *p++ = segment_idx >> 8;
+        /* Segment length */
+        *p++ = patch.len;
+
+        memcpy(p, patch.data, patch.len);
+
+        hw_cfg_cb.state = HW_CFG_PSPATCH_DOWNLOADING;
+        ret = bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
+
+        segment_idx++;
+        byte_cnt = byte_cnt - patch.len;
+
+    }
+    else {
+        /* Rampatch download complete, enable patch */
+        hw_cfg_cb.state = HW_CFG_PSPATCH_DOWNLOADED;
+        ret = enable_patch(p_buf);
+    }
+
+    return ret;
+}
+
+
+static int set_patch_ram_id(HC_BT_HDR *p_buf)
+{
+    int ret = 0;
+    BTHWDBG("%s ", __func__);
+
+    if (ps_counter == 0)
+    {
+        ps_counter = 1;
+        ARbyte[2] = '\0';
+    }
+
+    /* Get first token before newline */
+    while (fgets(ARptr, MAX_PATCH_CMD, rampatch_fd) != NULL) {
+        if (strlen(ARptr) <= 1) {
+            continue;
+        }
+        else if (strstr(ARptr, PATCH_LOC_KEY) == ARptr) {
+            strncpy(patch_loc, &ARptr[sizeof(PATCH_LOC_KEY) - 1],PATCH_LOC_STRING_LEN);
+            set_patch_ram(p_buf, patch_loc);
+            break; //wait for next time be called from cal back function.
+        } else if (isxdigit(ARptr[0])) {
+            if (write_patch(p_buf) < 0)
+                ret = -1;
+            break;
+        }
+        else
+            break;
+    }
+    return ret;
+}
+
+static void convert_bdaddr(char *bdaddr, char *p)
+{
+    char bdbyte[3];
+    char *str_byte = bdaddr;
+    int i;
+    int colon_present = 0;
+
+    if (strstr(bdaddr, ":"))
+        colon_present = 1;
+
+    bdbyte[2] = '\0';
+
+    /* Reverse the BDADDR to LSB first */
+    for (i = 5; i >= 0; i--) {
+        bdbyte[0] = str_byte[0];
+        bdbyte[1] = str_byte[1];
+        p[i] = strtol(bdbyte, NULL, 16);
+
+        if (colon_present == 1)
+            str_byte += 3;
+        else
+            str_byte += 2;
+    }
+}
+
+
+static int write_bdaddr(HC_BT_HDR *p_buf, char *bdaddr)
+{
+    uint8_t  *p = NULL;
+
+    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+    p_buf->offset = 0;
+    p_buf->layer_specific = 0;
+    p_buf->len = HCI_CMD_PREAMBLE_SIZE + PS_CMD_WRITE_BDADDR_PARAM_SIZE;
+    p = (uint8_t *) (p_buf + 1);
+
+    /* Set PS cmd opcode */
+    UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
+
+    *p++ = PS_CMD_WRITE_BDADDR_PARAM_SIZE;
+    /* PS_WRITE */
+    *p++ = 0x01;
+    /* LSB, MSB of PS tag ID */
+    *p++ = 0x01;
+    *p++ = 0x00;
+    /* Length of BDAddress */
+    *p++ = 0x06;
+    /* Convert and copy the bdaddr */
+    convert_bdaddr(bdaddr, (char *)p);
+
+    //Next one is HW_CFG_WRITE_BDADDRESS_DONE
+    bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
+
+    return 0;
+}
+
+static void write_bdaddr_from_file(HC_BT_HDR *p_buf, int rom_version)
+{
+    FILE *fd;
+    char bdaddr[MAX_BD_ADDR_LEN];
+    char bdaddr_file[PATH_MAX];
+
+    snprintf(bdaddr_file, MAXPATHLEN, "%s%x/%s",
+            fw_patchfile_path, rom_version, BDADDR_FILE);
+
+    fd = fopen(bdaddr_file, "r");
+    if (!fd) {
+        ALOGE("Cannot open bdaddr file %s", bdaddr_file);
+        /* Set BDAddr to 0 */
+        memset(bdaddr, 0, sizeof(bdaddr));
+        write_bdaddr(p_buf, bdaddr);
+        return;
+    }
+
+    /* Get the first token before newline in BD Address file */
+    if (fgets(bdaddr, MAX_BD_ADDR_LEN, fd))
+        write_bdaddr(p_buf, bdaddr);
+
+    fclose(fd);
+}
+
+static void get_ps_file_name(uint32_t devtype, uint32_t rom_version,
+                                char *path)
+{
+    char *filename;
+
+    if (devtype == 0xdeadc0de)
+        filename = PS_ASIC_FILE;
+    else
+        filename = PS_FPGA_FILE;
+
+    snprintf(path, MAXPATHLEN, "%s%x/%s",
+                fw_patchfile_path, rom_version, filename);
+}
+
+static void get_patch_file_name(uint32_t dev_type, uint32_t rom_version,
+                                uint32_t bld_version, char *path)
+{
+    if ((rom_version == FPGA_ROM_VERSION) && (dev_type != ROM_DEV_TYPE) &&
+                (dev_type != 0) && (bld_version == 1))
+        path[0] = '\0';
+    else
+        snprintf(path, MAXPATHLEN, "%s%x/%s",
+                    fw_patchfile_path, rom_version, PATCH_FILE);
+}
+
+/*******************************************************************************
+**
+** Function        line_speed_to_userial_baud
+**
+** Description     helper function converts line speed number into USERIAL baud
+**                 rate symbol
+**
+** Returns         unit8_t (USERIAL baud symbol)
+**
+*******************************************************************************/
+uint8_t line_speed_to_userial_baud(uint32_t line_speed)
+{
+    uint8_t baud;
+
+    if (line_speed == 4000000)
+        baud = USERIAL_BAUD_4M;
+    else if (line_speed == 3000000)
+        baud = USERIAL_BAUD_3M;
+    else if (line_speed == 2000000)
+        baud = USERIAL_BAUD_2M;
+    else if (line_speed == 1000000)
+        baud = USERIAL_BAUD_1M;
+    else if (line_speed == 921600)
+        baud = USERIAL_BAUD_921600;
+    else if (line_speed == 460800)
+        baud = USERIAL_BAUD_460800;
+    else if (line_speed == 230400)
+        baud = USERIAL_BAUD_230400;
+    else if (line_speed == 115200)
+        baud = USERIAL_BAUD_115200;
+    else if (line_speed == 57600)
+        baud = USERIAL_BAUD_57600;
+    else if (line_speed == 19200)
+        baud = USERIAL_BAUD_19200;
+    else if (line_speed == 9600)
+        baud = USERIAL_BAUD_9600;
+    else if (line_speed == 1200)
+        baud = USERIAL_BAUD_1200;
+    else if (line_speed == 600)
+        baud = USERIAL_BAUD_600;
+    else
+    {
+        ALOGE( "userial vendor: unsupported baud speed %d", line_speed);
+        baud = USERIAL_BAUD_115200;
+    }
+
+    return baud;
+}
+
+static void set_cntrlr_baud(HC_BT_HDR *p_buf, int speed)
+{
+    BTHWDBG(" %s ", __FUNCTION__);
+
+    int baud;
+    uint8_t *p;
+
+    /* set controller baud rate to user specified value */
+
+    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+    p_buf->offset = 0;
+    p_buf->layer_specific = 0;
+    p_buf->len = HCI_CMD_PREAMBLE_SIZE + CHG_BAUD_CMD_PARAM_SIZE;
+
+    p = (uint8_t *)(p_buf + 1);
+
+    /* Set opcode */
+    UINT16_TO_STREAM(p, HCI_VSC_CHG_BAUD_CMD);
+    /* Set length */
+    *p++ = CHG_BAUD_CMD_PARAM_SIZE;
+
+    /* baud should be set as real baud/100 */
+    baud = speed/100;
+    /* Set baud LSB */
+    *p++ = baud & 0xff;
+    /* Set baud MSB */
+    *p = (baud >> 8) & 0xff;
+
+    bt_vendor_cbacks->xmit_cb(HCI_VSC_CHG_BAUD_CMD, p_buf, hw_config_cback);
+}
+
+void hw_config_start(void)
+{
+    HC_BT_HDR  *p_buf = NULL;
+    uint8_t     *p;
+
+    hw_cfg_cb.state = 0;
+    hw_cfg_cb.fw_fd = -1;
+    hw_cfg_cb.f_set_baud_2 = FALSE;
+    ps_counter=0;
+    current_tag_idx=0;
+    segment_idx=0;
+
+    BTHWDBG("%s ", __func__);
+
+    /* Start from sending HCI_RESET */
+
+    if (bt_vendor_cbacks)
+    {
+        p_buf = (HC_BT_HDR *) bt_vendor_cbacks->alloc(BT_HC_HDR_SIZE + \
+                                                       HCI_CMD_PREAMBLE_SIZE);
+    }
+
+    if (p_buf)
+    {
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->layer_specific = 0;
+        p_buf->len = HCI_CMD_PREAMBLE_SIZE;
+
+        p = (uint8_t *) (p_buf + 1);
+        UINT16_TO_STREAM(p, HCI_RESET);
+        *p = 0; /* parameter length */
+
+        hw_cfg_cb.state = HW_CFG_START;
+
+        bt_vendor_cbacks->xmit_cb(HCI_RESET, p_buf, hw_config_cback);
+    }
+    else
+    {
+        if (bt_vendor_cbacks)
+        {
+            ALOGE("vendor lib fw conf aborted [no buffer]");
+            bt_vendor_cbacks->fwcfg_cb(BT_VND_OP_RESULT_FAIL);
+        }
+    }
+}
+
+/*******************************************************************************
+**
+** Function         hw_config_cback
+**
+** Description      Callback function for controller configuration
+**
+** Returns          None
+**
+*******************************************************************************/
+void hw_config_cback(void *p_mem)
+{
+    HC_BT_HDR *p_evt_buf = (HC_BT_HDR *) p_mem;
+    char *p_tmp;
+    uint8_t *p, status;
+    uint16_t opcode;
+    HC_BT_HDR *p_buf=NULL;
+
+    status = *((uint8_t *)(p_evt_buf + 1) + HCI_EVT_CMD_CMPL_STATUS_RET_BYTE);
+    p = (uint8_t *)(p_evt_buf + 1) + HCI_EVT_CMD_CMPL_OPCODE;
+    STREAM_TO_UINT16(opcode,p);
+
+    BTHWDBG("Call back state %d status 0x%x, with opcode 0x%x", hw_cfg_cb.state, status, opcode);
+
+    /* Ask a new buffer big enough to hold any HCI commands sent in here */
+    /* HW_CFG_GET_ATH3K_CRC return non-zero if controller has no ram patch or PS config  */
+    if (((status == 0)&& bt_vendor_cbacks) ||
+        ((status != 0)&& bt_vendor_cbacks && (opcode == 0xfc0b) && (hw_cfg_cb.state == HW_CFG_GET_ATH3K_CRC)))
+        p_buf = (HC_BT_HDR *) bt_vendor_cbacks->alloc(BT_HC_HDR_SIZE + HCI_CMD_MAX_LEN);
+
+    if (p_buf != NULL)
+    {
+        p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+        p_buf->offset = 0;
+        p_buf->len = 0;
+        p_buf->layer_specific = 0;
+        p = (uint8_t *) (p_buf + 1);
+
+        switch (hw_cfg_cb.state)
+        {
+            case HW_CFG_START:
+                {
+                    hw_cfg_cb.state = HW_CFG_SET_CNTRLR_BAUD;
+                    set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                }
+                break;
+
+            case HW_CFG_SET_CNTRLR_BAUD:
+                {
+                    /* Set UART Baud after Ctrl Baud is set */
+                    userial_vendor_set_baud(line_speed_to_userial_baud(UART_TARGET_BAUD_RATE));
+
+
+                    //Next one is HW_CFG_GET_DEVICE_TYPE
+
+                    //*  --------------------------------------------
+                    //*  |  HC_BT_HDR  |  HCI command         |
+                    //*  --------------------------------------------
+                    //*
+                    //*     AR3002 HCI command
+                    //*  --------------------------------------------------------
+                    //*  |  packet type(1) | opcode (2)  | length(1) | command parameter |
+                    //*  --------------------------------------------------------
+                    //*
+                    //* So, the packet format will be:
+                    //*  ------------------------------------------------------------------------
+                    //*  |  HC_BT_HDR  | packet type(1) | opcode (2)  | length(1) | command parameter |
+                    //*  ------------------------------------------------------------------------
+
+                    p_buf->len = HCI_CMD_PREAMBLE_SIZE + GET_DEV_TYPE_CMD_PARAM_SIZE;
+
+                    /* Set opcode */
+                    UINT16_TO_STREAM(p, HCI_VSC_GET_DEV_TYPE);
+                    /* Set length */
+                    *p++ = GET_DEV_TYPE_CMD_PARAM_SIZE;
+
+                    /* Set Register Address */
+                    *p++ = (uint8_t)DEV_REGISTER;
+                    *p++ = (uint8_t)(DEV_REGISTER >> 8);
+                    *p++ = (uint8_t)(DEV_REGISTER >> 16);
+                    *p++ = (uint8_t)(DEV_REGISTER >> 24);
+                    /* Set length to read */
+                    *p = 0x04;
+
+                    hw_cfg_cb.state = HW_CFG_GET_DEVICE_TYPE;
+                    bt_vendor_cbacks->xmit_cb(HCI_VSC_GET_DEV_TYPE, p_buf, hw_config_cback);
+                }
+                break;
+            case HW_CFG_GET_DEVICE_TYPE:
+                {
+                    p_tmp = (char *) (p_evt_buf + 1 ) + HCI_EVT_CMD_CMPL_RESPONSE;
+
+                    /* MSB of device type */
+                    dev_type = *(p_tmp + 3);
+                    dev_type = (dev_type << 8) | *(p_tmp + 2);
+                    /* LSB of device type */
+                    dev_type = (dev_type << 8) | *(p_tmp + 1);
+                    dev_type = (dev_type << 8) | *(p_tmp );
+
+                    ALOGI("AR3002 dev_type %x", dev_type);
+
+                    //Next one is  HW_CFG_GET_ATH3K_VERSION
+
+                    p_buf->len = HCI_CMD_PREAMBLE_SIZE;
+
+                    /* Set opcode */
+                    UINT16_TO_STREAM(p, HCI_VSC_GET_VERSION);
+                    *p = 0;
+
+                    hw_cfg_cb.state = HW_CFG_GET_ATH3K_VERSION;
+                    bt_vendor_cbacks->xmit_cb(HCI_VSC_GET_VERSION, p_buf, hw_config_cback);
+
+                }
+                break;
+            case HW_CFG_GET_ATH3K_VERSION:
+                {
+                    p_tmp = (char *) (p_evt_buf +1 ) + HCI_EVT_CMD_CMPL_RESPONSE;
+
+                    /* Assemble ROM version from response */
+                    rom_version = *(p_tmp + 3);
+                    rom_version = (rom_version << 8) | *(p_tmp + 2);
+                    rom_version = (rom_version << 8) | *(p_tmp + 1);
+                    rom_version = (rom_version << 8) | *(p_tmp);
+
+                    /* Assemble Build version from response */
+                    bld_version = *(p_tmp + 7);
+                    bld_version = (bld_version << 8) | *(p_tmp + 6);
+                    bld_version = (bld_version << 8) | *(p_tmp + 5);
+                    bld_version = (bld_version << 8) | *(p_tmp + 4);
+
+                    ALOGI("AR3002 rom_version %x ,bld_version %x ", rom_version, bld_version);
+
+                    //Next one is HW_CFG_GET_ATH3K_CRC
+                    p_buf->len = HCI_CMD_PREAMBLE_SIZE + PS_CMD_GET_CRC_PARAM_SIZE;
+
+                    /* Set opcode */
+                    UINT16_TO_STREAM(p, HCI_VSC_PS_CMD);
+                    /* Set length */
+                    *p++ = PS_CMD_GET_CRC_PARAM_SIZE;
+                    *p++ = VERIFY_CRC;
+                    /* Memory region LSB, MSB */
+                    *p++ = PS_REGION|PATCH_REGION;
+                    *p++ = (PS_REGION|PATCH_REGION) >> 8;
+                    *p   = 0; /* Length */
+
+                    hw_cfg_cb.state = HW_CFG_GET_ATH3K_CRC;
+
+                    bt_vendor_cbacks->xmit_cb(HCI_VSC_PS_CMD, p_buf, hw_config_cback);
+                }
+                break;
+            case HW_CFG_GET_ATH3K_CRC:
+                {
+                    FILE *fd = 0;
+
+                    if  ( status == 0 )
+                    {
+                        ALOGI("bt vendor lib: AR3K already has ram patch and PS configuration;\
+                                                        there is no need to download them. ");
+                        /* Set bdaddr, Next one is HW_CFG_WRITE_BDADDRESS_DONE */
+                        hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS_DONE;
+                        write_bdaddr_from_file(p_buf, rom_version);
+                        break;
+                    }
+
+                    /* Get PS config file name */
+                    get_ps_file_name(dev_type, rom_version, ps_file);
+                    /* Get Ram Patch file name */
+                    get_patch_file_name(dev_type, rom_version, bld_version, patch_file);
+
+                    /* Open PS config file */
+                    fd = fopen(ps_file, "r");
+                    if (!fd) {
+                        ALOGE("PS config file open error");
+                        /* No PS config file, Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
+                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                        break;
+                    }
+
+                    /* Parse the PS config file and get number of tags */
+                    tag_count = ath_parse_ps(fd);
+
+                    /* Close PS config file */
+                    fclose(fd);
+
+                    if (tag_count < 0) {
+                        ALOGE("tag_count < 0\n");
+                        /* Set bdaddr, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
+                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                        break;
+                    }
+
+                    rampatch_fd = fopen(patch_file, "r");
+                    if (!rampatch_fd) {
+                        ALOGE("Rampatch file open error");
+                        /* No RamPatchfile, Set bdaddr, Next one is HW_CFG_WRITE_BDADDRESS_DONE */
+                        hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS_DONE;
+                        write_bdaddr_from_file(p_buf, rom_version);
+                        break;
+                    }
+                    else {
+                        if (set_patch_ram_id(p_buf) < 0) {
+                            ALOGE("PS patch write error");
+                            /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
+                            hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+                            set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                            break;
+                        }
+                    }
+                }
+                break;
+            case HW_CFG_PSPATCH_START_DOWNLOAD:
+            case HW_CFG_PSPATCH_DOWNLOADING:
+                {
+                    if (write_patch(p_buf) < 0) {
+                        ALOGE("PS patch write error");
+                        /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
+                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                        break;
+                    }
+                }
+                break;
+            case HW_CFG_PSPATCH_DOWNLOADED:
+                {
+                    /* RamPatch download finished, close the file */
+                    fclose(rampatch_fd);
+
+                    if (segment_idx < 0) {
+                        ALOGE("segment_idx < 0\n");
+                    }
+                    hw_cfg_cb.state = HW_CFG_CONFIG_RESET;
+                    if (ps_reset_config(p_buf) < 0) {
+                        ALOGE("PS patch write error");
+                        /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
+                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                        break;
+                    }
+                }
+                break;
+            case HW_CFG_CONFIG_RESET:
+            case HW_CFG_CONFIG_DOWNLOADING:
+                {
+                    if (ps_config_download(p_buf, current_tag_idx) < 0) {
+                        ALOGE("PS config write error");
+                        /* Set baud, Next one is HW_CFG_CNTRLR_BAUD_UPDATE */
+                        hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+                        set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                        break;
+                    }
+                    current_tag_idx++;
+                    if(tag_count == current_tag_idx) {
+                        hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS;
+                    }
+                    else
+                        hw_cfg_cb.state = HW_CFG_CONFIG_DOWNLOADING;
+                }
+                break;
+            case HW_CFG_WRITE_BDADDRESS:
+                {
+                    /* Write BDADDR */
+                    hw_cfg_cb.state = HW_CFG_WRITE_BDADDRESS_DONE;
+                    write_bdaddr_from_file(p_buf, rom_version);
+                }
+                break;
+            case HW_CFG_WRITE_BDADDRESS_DONE:
+                {
+                    /* Send HCI_RESET to enable patch */
+                    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+                    p_buf->offset = 0;
+                    p_buf->layer_specific = 0;
+                    p_buf->len = HCI_CMD_PREAMBLE_SIZE;
+
+                    p = (uint8_t *) (p_buf + 1);
+                    UINT16_TO_STREAM(p, HCI_RESET);
+                    *p = 0; /* parameter length */
+
+                    hw_cfg_cb.state = HW_CFG_HCI_RESET;
+
+                    bt_vendor_cbacks->xmit_cb(HCI_RESET, p_buf, hw_config_cback);
+                }
+                break;
+            case HW_CFG_HCI_RESET:
+                {
+                    /* Set BT controller baud */
+                    hw_cfg_cb.state = HW_CFG_CNTRLR_BAUD_UPDATE;
+
+                    set_cntrlr_baud(p_buf, UART_TARGET_BAUD_RATE);
+                }
+                break;
+            case HW_CFG_CNTRLR_BAUD_UPDATE:
+                {
+                    /* Set the UART port Baud */
+                    userial_vendor_set_baud(line_speed_to_userial_baud(UART_TARGET_BAUD_RATE));
+
+                    hw_cfg_cb.state = 0;
+                    bt_vendor_cbacks->dealloc(p_buf);
+                    bt_vendor_cbacks->fwcfg_cb(BT_VND_OP_RESULT_SUCCESS);
+                }
+                break;
+            default:
+                break;
+        } // switch(hw_cfg_cb.state)
+    } // if (p_buf != NULL)
+
+    /* Free the RX event buffer */
+    if (bt_vendor_cbacks)
+        bt_vendor_cbacks->dealloc(p_evt_buf);
+}
+
+/*******************************************************************************
+**
+** Function        hw_set_patch_file_path
+**
+** Description     Set the location of firmware patch file
+**
+** Returns         0 : Success
+**                 Otherwise : Fail
+**
+*******************************************************************************/
+int hw_set_patch_file_path(char *p_conf_name, char *p_conf_value, int param)
+{
+    strcpy(fw_patchfile_path, p_conf_value);
+
+    return 0;
+}
+
diff --git a/libbt-ath3k/src/upio.c b/libbt-ath3k/src/upio.c
new file mode 100644
index 0000000..12a2e75
--- /dev/null
+++ b/libbt-ath3k/src/upio.c
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      upio.c
+ *
+ *  Description:   Contains I/O functions, like
+ *                      rfkill control
+ *                      BT_WAKE/HOST_WAKE control
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_upio"
+
+#include <utils/Log.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <cutils/properties.h>
+#include "bt_vendor_ath3k.h"
+#include "upio.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#ifndef UPIO_DBG
+#define UPIO_DBG FALSE
+#endif
+
+#if (UPIO_DBG == TRUE)
+#define UPIODBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
+#else
+#define UPIODBG(param, ...) {}
+#endif
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+
+static int rfkill_id = -1;
+static int bt_emul_enable = 0;
+static char *rfkill_state_path = NULL;
+
+/******************************************************************************
+**  Static functions
+******************************************************************************/
+
+/*****************************************************************************
+**   Bluetooth On/Off Static Functions
+*****************************************************************************/
+static int is_emulator_context(void)
+{
+    char value[PROPERTY_VALUE_MAX];
+
+    property_get("ro.kernel.qemu", value, "0");
+    UPIODBG("is_emulator_context : %s", value);
+    if (strcmp(value, "1") == 0) {
+        return 1;
+    }
+    return 0;
+}
+
+static int is_rfkill_disabled(void)
+{
+    char value[PROPERTY_VALUE_MAX];
+
+    property_get("ro.rfkilldisabled", value, "0");
+    UPIODBG("is_rfkill_disabled ? [%s]", value);
+
+    if (strcmp(value, "1") == 0) {
+        return UPIO_BT_POWER_ON;
+    }
+
+    return UPIO_BT_POWER_OFF;
+}
+
+static int init_rfkill()
+{
+    char path[64];
+    char buf[16];
+    int fd, sz, id;
+
+    if (is_rfkill_disabled())
+        return -1;
+
+    for (id = 0; ; id++)
+    {
+        snprintf(path, sizeof(path), "/sys/class/rfkill/rfkill%d/type", id);
+        fd = open(path, O_RDONLY);
+        if (fd < 0)
+        {
+            ALOGE("init_rfkill : open(%s) failed: %s (%d)\n", \
+                 path, strerror(errno), errno);
+            return -1;
+        }
+
+        sz = read(fd, &buf, sizeof(buf));
+        close(fd);
+
+        if (sz >= 9 && memcmp(buf, "bluetooth", 9) == 0)
+        {
+            rfkill_id = id;
+            break;
+        }
+    }
+
+    asprintf(&rfkill_state_path, "/sys/class/rfkill/rfkill%d/state", rfkill_id);
+    return 0;
+}
+
+/*****************************************************************************
+**   UPIO Interface Functions
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        upio_set_bluetooth_power
+**
+** Description     Interact with low layer driver to set Bluetooth power
+**                 on/off.
+**
+** Returns         0  : SUCCESS or Not-Applicable
+**                 <0 : ERROR
+**
+*******************************************************************************/
+int upio_set_bluetooth_power(int on)
+{
+    int sz;
+    int fd = -1;
+    int ret = -1;
+    char buffer = '0';
+
+    switch(on)
+    {
+        case UPIO_BT_POWER_OFF:
+            buffer = '0';
+            break;
+
+        case UPIO_BT_POWER_ON:
+            buffer = '1';
+            break;
+    }
+
+    if (is_emulator_context())
+    {
+        /* if new value is same as current, return -1 */
+        if (bt_emul_enable == on)
+            return ret;
+
+        UPIODBG("set_bluetooth_power [emul] %d", on);
+
+        bt_emul_enable = on;
+        return 0;
+    }
+
+    /* check if we have rfkill interface */
+    if (is_rfkill_disabled())
+        return 0;
+
+    if (rfkill_id == -1)
+    {
+        if (init_rfkill())
+            return ret;
+    }
+
+    fd = open(rfkill_state_path, O_WRONLY);
+
+    if (fd < 0)
+    {
+        ALOGE("set_bluetooth_power : open(%s) for write failed: %s (%d)",
+            rfkill_state_path, strerror(errno), errno);
+        return ret;
+    }
+
+    sz = write(fd, &buffer, 1);
+
+    if (sz < 0) {
+        ALOGE("set_bluetooth_power : write(%s) failed: %s (%d)",
+            rfkill_state_path, strerror(errno),errno);
+    }
+    else
+        ret = 0;
+
+    if (fd >= 0)
+        close(fd);
+
+    return ret;
+}
+
+
diff --git a/libbt-ath3k/src/userial_vendor.c b/libbt-ath3k/src/userial_vendor.c
new file mode 100644
index 0000000..033a736
--- /dev/null
+++ b/libbt-ath3k/src/userial_vendor.c
@@ -0,0 +1,360 @@
+/*
+ * Copyright 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Copyright (C) 2013 Freescale Semiconductor, Inc. */
+
+/******************************************************************************
+ *
+ *  Filename:      userial_vendor.c
+ *
+ *  Description:   Contains vendor-specific userial functions
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_userial_vendor"
+
+#include <utils/Log.h>
+#include <termios.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>
+#include "bt_vendor_ath3k.h"
+#include "userial_vendor.h"
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+
+#ifndef VNDUSERIAL_DBG
+#define VNDUSERIAL_DBG FALSE
+#endif
+
+#if (VNDUSERIAL_DBG == TRUE)
+#define VNDUSERIALDBG(param, ...) {ALOGD(param, ## __VA_ARGS__);}
+#else
+#define VNDUSERIALDBG(param, ...) {}
+#endif
+
+#define VND_PORT_NAME_MAXLEN    256
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+/* vendor serial control block */
+typedef struct
+{
+    int fd;                     /* fd to Bluetooth device */
+    struct termios termios;     /* serial terminal of BT port */
+    char port_name[VND_PORT_NAME_MAXLEN];
+} vnd_userial_cb_t;
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+
+static vnd_userial_cb_t vnd_userial;
+
+/*****************************************************************************
+**   Helper Functions
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        userial_to_tcio_baud
+**
+** Description     helper function converts USERIAL baud rates into TCIO
+**                  conforming baud rates
+**
+** Returns         TRUE/FALSE
+**
+*******************************************************************************/
+uint8_t userial_to_tcio_baud(uint8_t cfg_baud, uint32_t *baud)
+{
+    if (cfg_baud == USERIAL_BAUD_115200)
+        *baud = B115200;
+    else if (cfg_baud == USERIAL_BAUD_4M)
+        *baud = B4000000;
+    else if (cfg_baud == USERIAL_BAUD_3M)
+        *baud = B3000000;
+    else if (cfg_baud == USERIAL_BAUD_2M)
+        *baud = B2000000;
+    else if (cfg_baud == USERIAL_BAUD_1M)
+        *baud = B1000000;
+    else if (cfg_baud == USERIAL_BAUD_921600)
+        *baud = B921600;
+    else if (cfg_baud == USERIAL_BAUD_460800)
+        *baud = B460800;
+    else if (cfg_baud == USERIAL_BAUD_230400)
+        *baud = B230400;
+    else if (cfg_baud == USERIAL_BAUD_57600)
+        *baud = B57600;
+    else if (cfg_baud == USERIAL_BAUD_19200)
+        *baud = B19200;
+    else if (cfg_baud == USERIAL_BAUD_9600)
+        *baud = B9600;
+    else if (cfg_baud == USERIAL_BAUD_1200)
+        *baud = B1200;
+    else if (cfg_baud == USERIAL_BAUD_600)
+        *baud = B600;
+    else
+    {
+        ALOGE( "userial vendor open: unsupported baud idx %i", cfg_baud);
+        *baud = B115200;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+/*******************************************************************************
+**
+** Function        userial_ioctl_init_bt_wake
+**
+** Description     helper function to set the open state of the bt_wake if ioctl
+**                  is used. it should not hurt in the rfkill case but it might
+**                  be better to compile it out.
+**
+** Returns         none
+**
+*******************************************************************************/
+void userial_ioctl_init_bt_wake(int fd)
+{
+    uint32_t bt_wake_state;
+
+    /* assert BT_WAKE through ioctl */
+    ioctl(fd, USERIAL_IOCTL_BT_WAKE_ASSERT, NULL);
+    ioctl(fd, USERIAL_IOCTL_BT_WAKE_GET_ST, &bt_wake_state);
+    VNDUSERIALDBG("userial_ioctl_init_bt_wake read back BT_WAKE state=%i", \
+               bt_wake_state);
+}
+#endif // (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+
+
+/*****************************************************************************
+**   Userial Vendor API Functions
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        userial_vendor_init
+**
+** Description     Initialize userial vendor-specific control block
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_init(void)
+{
+    vnd_userial.fd = -1;
+    snprintf(vnd_userial.port_name, VND_PORT_NAME_MAXLEN, "%s", \
+            BLUETOOTH_UART_DEVICE_PORT);
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_open
+**
+** Description     Open the serial port with the given configuration
+**
+** Returns         device fd
+**
+*******************************************************************************/
+int userial_vendor_open(tUSERIAL_CFG *p_cfg)
+{
+    uint32_t baud;
+    uint8_t data_bits;
+    uint16_t parity;
+    uint8_t stop_bits;
+
+    vnd_userial.fd = -1;
+
+    if (!userial_to_tcio_baud(p_cfg->baud, &baud))
+    {
+        return -1;
+    }
+
+    if(p_cfg->fmt & USERIAL_DATABITS_8)
+        data_bits = CS8;
+    else if(p_cfg->fmt & USERIAL_DATABITS_7)
+        data_bits = CS7;
+    else if(p_cfg->fmt & USERIAL_DATABITS_6)
+        data_bits = CS6;
+    else if(p_cfg->fmt & USERIAL_DATABITS_5)
+        data_bits = CS5;
+    else
+    {
+        ALOGE("userial vendor open: unsupported data bits");
+        return -1;
+    }
+
+    if(p_cfg->fmt & USERIAL_PARITY_NONE)
+        parity = 0;
+    else if(p_cfg->fmt & USERIAL_PARITY_EVEN)
+        parity = PARENB;
+    else if(p_cfg->fmt & USERIAL_PARITY_ODD)
+        parity = (PARENB | PARODD);
+    else
+    {
+        ALOGE("userial vendor open: unsupported parity bit mode");
+        return -1;
+    }
+
+    if(p_cfg->fmt & USERIAL_STOPBITS_1)
+        stop_bits = 0;
+    else if(p_cfg->fmt & USERIAL_STOPBITS_2)
+        stop_bits = CSTOPB;
+    else
+    {
+        ALOGE("userial vendor open: unsupported stop bits");
+        return -1;
+    }
+
+    ALOGI("userial vendor open: opening %s", vnd_userial.port_name);
+
+    if ((vnd_userial.fd = open(vnd_userial.port_name, O_RDWR)) == -1)
+    {
+        ALOGE("userial vendor open: unable to open %s", vnd_userial.port_name);
+        return -1;
+    }
+
+    tcflush(vnd_userial.fd, TCIOFLUSH);
+
+    tcgetattr(vnd_userial.fd, &vnd_userial.termios);
+    cfmakeraw(&vnd_userial.termios);
+    vnd_userial.termios.c_cflag |= (CRTSCTS | stop_bits);
+    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
+    tcflush(vnd_userial.fd, TCIOFLUSH);
+
+    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
+    tcflush(vnd_userial.fd, TCIOFLUSH);
+    tcflush(vnd_userial.fd, TCIOFLUSH);
+
+    /* set input/output baudrate */
+    cfsetospeed(&vnd_userial.termios, baud);
+    cfsetispeed(&vnd_userial.termios, baud);
+    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    userial_ioctl_init_bt_wake(vnd_userial.fd);
+#endif
+
+    ALOGI("device fd = %d open", vnd_userial.fd);
+
+    return vnd_userial.fd;
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_close
+**
+** Description     Conduct vendor-specific close work
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_close(void)
+{
+    int result;
+
+    if (vnd_userial.fd == -1)
+        return;
+
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    /* de-assert bt_wake BEFORE closing port */
+    ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_DEASSERT, NULL);
+#endif
+
+    ALOGI("device fd = %d close", vnd_userial.fd);
+
+    if ((result = close(vnd_userial.fd)) < 0)
+        ALOGE( "close(fd:%d) FAILED result:%d", vnd_userial.fd, result);
+
+    vnd_userial.fd = -1;
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_set_baud
+**
+** Description     Set new baud rate
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_set_baud(uint8_t userial_baud)
+{
+    uint32_t tcio_baud;
+
+    userial_to_tcio_baud(userial_baud, &tcio_baud);
+
+    cfsetospeed(&vnd_userial.termios, tcio_baud);
+    cfsetispeed(&vnd_userial.termios, tcio_baud);
+    tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
+}
+
+/*******************************************************************************
+**
+** Function        userial_vendor_ioctl
+**
+** Description     ioctl inteface
+**
+** Returns         None
+**
+*******************************************************************************/
+void userial_vendor_ioctl(userial_vendor_ioctl_op_t op, void *p_data)
+{
+    switch(op)
+    {
+#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+        case USERIAL_OP_ASSERT_BT_WAKE:
+            VNDUSERIALDBG("## userial_vendor_ioctl: Asserting BT_Wake ##");
+            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_ASSERT, NULL);
+            break;
+
+        case USERIAL_OP_DEASSERT_BT_WAKE:
+            VNDUSERIALDBG("## userial_vendor_ioctl: De-asserting BT_Wake ##");
+            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_DEASSERT, NULL);
+            break;
+
+        case USERIAL_OP_GET_BT_WAKE_STATE:
+            ioctl(vnd_userial.fd, USERIAL_IOCTL_BT_WAKE_GET_ST, p_data);
+            break;
+#endif  //  (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+
+        default:
+            break;
+    }
+}
+
+/*******************************************************************************
+**
+** Function        userial_set_port
+**
+** Description     Configure UART port name
+**
+** Returns         0 : Success
+**                 Otherwise : Fail
+**
+*******************************************************************************/
+int userial_set_port(char *p_conf_name, char *p_conf_value, int param)
+{
+    strcpy(vnd_userial.port_name, p_conf_value);
+
+    return 0;
+}
+
diff --git a/libbt-ath3k/vnd_buildcfg.mk b/libbt-ath3k/vnd_buildcfg.mk
new file mode 100755
index 0000000..d18e121
--- /dev/null
+++ b/libbt-ath3k/vnd_buildcfg.mk
@@ -0,0 +1,32 @@
+#
+# Copyright 2012 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+intermediates := $(local-intermediates-dir)
+
+SRC := $(call my-dir)/include/$(addprefix vnd_, $(addsuffix .txt,$(basename $(TARGET_DEVICE))))
+ifeq (,$(wildcard $(SRC)))
+# configuration file does not exist. Use default one
+SRC := $(call my-dir)/include/vnd_generic.txt
+endif
+GEN := $(intermediates)/vnd_buildcfg.h
+TOOL := $(TOP_DIR)external/bluetooth/bluedroid/tools/gen-buildcfg.sh
+
+$(GEN): PRIVATE_PATH := $(call my-dir)
+$(GEN): PRIVATE_CUSTOM_TOOL = $(TOOL) $< $@
+$(GEN): $(SRC)  $(TOOL)
+	$(transform-generated-source)
+
+LOCAL_GENERATED_SOURCES += $(GEN)
-- 
1.8.0

