From 18fe190506cff8cbab8712438bbe9a2ce81121bd Mon Sep 17 00:00:00 2001
From: Alan Tull <r80115@freescale.com>
Date: Thu, 3 Apr 2008 13:36:28 -0500
Subject: [PATCH 018/442] ENGR00030479 remove misc-testdatabase.txt

---
 misc-testdatabase.txt | 1235 -------------------------------------------------
 1 file changed, 1235 deletions(-)
 delete mode 100644 misc-testdatabase.txt

diff --git a/misc-testdatabase.txt b/misc-testdatabase.txt
deleted file mode 100644
index 079e4bf..0000000
--- a/misc-testdatabase.txt
+++ /dev/null
@@ -1,1235 +0,0 @@
-# Format is testid followed by a single space, followed by the actual test case
-
-FSL-UT-FB-0010 autorun-fb.sh
-FSL-UT-FB-0020 Execute a GUI application (Qtopia with Qt/Embedded)
-FSL-UT-FB-0030 cat image.bin > /dev/fb0
-
-FSL-UT-PF-0010 autorun-pf.sh
-
-FSL-UT-MMC-0010 autorun-mmc.sh
-FSL-UT-MMC-0020 dd if=/dev/zero of=/dev/mmcblk0 bs=1024 count=5
-FSL-UT-MMC-0030 dd if=file_name of=/dev/mmcblk0
-FSL-UT-MMC-0040 dd if=/dev/mmcblk0 of=output_file bs=1024 count=1
-FSL-UT-MMC-0050 fdisk /dev/mmcblk0; fdisk -l /dev/mmcblk0;     
-#Create the partitions on the card
-
-FSL-UT-MMC-0060 mkfs.ext2 /dev/mmcblk0p1; mkfs.minix /dev/mmcblk0p1 no_blocks
-#Format the card using mkfs.minix or mkfs.ext2,
-
-FSL-UT-MMC-0070 mkdir /mnt/mmc_part1; mount -t ext2 /dev/mmcblk0p1 /mnt/mmc_part1; umount /mnt/mmc_part1
-#Mount and Un-mount the file system
-
-FSL-UT-MU-0010 autorun-mu.sh
-
-FSL-UT-OPROFILE-0010 autorun-oprofile.sh
-FSL-UT-OPROFILE-0020 opcontrol --event=ETMEXTOUT[0]:12cache_event_count --event=DREQ:1000
-
-FSL-UT-PMIC-0010 autorun-pmic.sh
-FSL-UT-PMIC-Protocol-0010 pmic_testapp -T S_IT_U
-FSL-UT-PMIC-ADC-0010 pmic_testapp_adc -T CONV
-FSL-UT-PMIC-ADC-0020 pmic_testapp_adc -T MON
-FSL-UT-PMIC-Power-MOD-0010 mxc_pmic_power_testmod.ko
-FSL-UT-PMIC-Power-0010 pmic_testapp_power -T 1
-FSL-UT-PMIC-Power-0020 pmic_testapp_power -T 2
-FSL-UT-PMIC-Power-0030 pmic_testapp_power -T 3
-FSL-UT-PMIC-Power-0040 pmic_testapp_power -T 1
-#not running pmic_testapp_battery -T 6 as it hangs, TODO FIX
-FSL-UT-PMIC-Battery-0010 pmic_testapp_battery -T 6
-FSL-UT-PMIC-Light-0010 pmic_testapp_light
-				choose option:  5; 6; 7
-
-# (PMIC_SC55112) Zeus only		
-FSL-UT-PMIC-SC55112_Light-0010 pmic_sc55112_light_test/pmic_sc55112_light_test.out
-					   choose option: 1,1,6
-
-FSL-UT-PMIC-SC55112_Light-0020 pmic_sc55112_light_test/pmic_sc55112_light_test.out
-					   choose option: 1,2,3
-
-FSL-UT-PMIC-RTC-0010 pmic_testapp_rtc -T TEST
-
-FSL-UT-RNG-0010 autorun-rng.sh
-FSL-UT-RNG-0020 rng_test -S
-FSL-UT-RNG-0030 rng_test -Rn
-FSL-UT-RNG-0040 rng_test -Wn:v
-FSL-UT-RNG-0050 rng_test -E n
-FSL-UT-RNG-0060 rng_test -Ok -E n
-FSL-UT-RNG-0070 rng_test -Zv
-FSL-UT-RNG-0080 rng_test -Ok -Zv
-
-FSL-UT-RTC-0010 autorun-rtc.sh
-
-FSL-UT-SAHARA-0010 autorun-sahara.sh
-#User Space
-
-FSL-UT-SAHARA-0020 echo TacFghmrsw > /dev/shwtest
-#Kernel Space
-
-FSL-UT-SCC-0010 autorun-scc.sh
-
-FSL-UT-RTIC-0010 mxc_security_test.out
-root@freescale /unit_tests/modules$ insmod mxc_rtic_test.ko
-root@freescale /unit_tests/modules$ cd ..
-root@freescale /unit_tests$ cd mxc_security_test/
-root@freescale /unit_tests/mxc_security_test$ ls
-mxc_security_test.out
-root@freescale /unit_tests/mxc_security_test$ ./mxc_security_test.out
-========> Testing MXC security driver <========
-Select the following security module to be tested:
-1. HAC
-2. RTIC
-3. Exit
-Enter your option:
-
-For One time Hashing select option 1
-For Run time hashing go for Option 2 after hardware reset.
-For runtime Error check go for option 3 after hardware Reset.
-
-FSL-UT-RTIC-0020 autorun-rtic.sh
-
-FSL-UT-HACC-0010 autorun-hacc.sh
-
-FSL-UT-V4L2-0010 autorun-v4l2.sh
-FSL-UT-V4L2-overaly-sdc-0010 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 160 -oh 160 -ot 20 -ol 20 -r 0 -t 50 -d 0 -fg -fr 30
-FSL-UT-V4L2-overlay-sdc-0020 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 160 -oh 160 -ot 20 -ol 20 -r 4 -t 50 -d 0 -fr 30
-FSL-UT-V4L2-overlay-adc-0010 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 120 -oh 120 -ot 40 -ol 40 -r 0 -t 50 -d 1 -fg -fr 30
-FSL-UT-V4L2-overlay-adc-0020 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 120 -oh 120 -ot 40 -ol 40 -r 4 -t 50 -d 1 -fg -fr 30
-FSL-UT-V4L2-capture-0010 mxc_v4l2_capture.out -w 352 -h 288 -r 0 -c 50 -fr 30 test.yuv
-FSL-UT-V4L2-capture-0020 mxc_v4l2_still.out -w 640 -h 480 -f YUV422P
-FSL-UT-V4L2-output-0010 mxc_v4l2_output.out -iw 352 -ih 288 -ow 176 -oh 144 -r 0 -fr 20 test.yuv
-FSL-UT-IPU-PostFilter-SDC-0010 mxc_mpeg4dec_test.out -ow width -oh height -d 3 test.mp4
-FSL-UT-IPU-PostFilter-ADC-0020 mxc_mpeg4dec_test.out -ow width -oh height -d 0 test.mp4
-
-
-FSL-UT-WDOG-0010 autorun-wdog.sh
-FSL-UT-WDOG-0020 wdog_test.out 0
-FSL-UT-WDOG-0030 wdog_test.out 1
-FSL-UT-WDOG-0040 wdog_test.out 2
-FSL-UT-WDOG-0050 wdog_test.out 3
-FSL-UT-WDOG-0060 wdog_test.out 4
-FSL-UT-WDOG-0070 wdt_driver_test.out 1 2 0 &
-FSL-UT-WDOG-0080 wdt_driver_test.out 2 1 0 &
-
-
-FSL-UT-FIRI-0010 autorun-firi.sh
-FSL-UT-FIRI-0020
-Below are the steps to test Fast IrDA using IrLAN on the board.
-On one board:
-modprobe irda
-cp /lib/modules/2.6.18.1/kernel/net/irda/irlan/irlan.ko .
-cp /lib/modules/2.6.18.1/kernel/drivers/net/irda/mxc_ir.ko .
-insmod irlan.ko access=2
-ifconfig irlan0 10.0.0.1 netmask 255.255.255.0 broadcast 10.0.0.255
-insmod mxc_ir.ko
-ifconfig irda0 up
-echo 1 > /proc/sys/net/irda/discovery
-ping 10.0.0.2
-
-On the other board:
-modprobe irda
-cp /lib/modules/2.6.18.1/kernel/net/irda/irlan/irlan.ko .
-cp /lib/modules/2.6.18.1/kernel/drivers/net/irda/mxc_ir.ko .
-insmod irlan.ko access=2
-ifconfig irlan0 10.0.0.2 netmask 255.255.255.0 broadcast 10.0.0.255
-insmod mxc_ir.ko
-ifconfig irda0 up
-echo 1 > /proc/sys/net/irda/discovery
-telnet 10.0.0.1
-
-FSL-UT-UART-EXT-0010 ls >/dev/tts/0; ls >/dev/tts/1
-#Redirect the output of a shell command to another UART.
-
-FSL-UT-UART-EXT-0020 /bin/sh </dev/tts/1 >/dev/tts/1 2>/dev/tts/1 &
-FSL-UT-UART-EXT-0030 exec -b 0x800000 -l 0x200000 -c "rw root=/dev/nfs nfsroot=10.193.100.211:/
-			        home/r65130/rootdisk/mx21 console=ttyS0,115200"
-#Boot up with external uart as console
-
-FSL-UT-UART-EXT-0040 stty -F /dev/ttymxc/0 115200; cat >/dev/ttymxc/0
-#Transmission/Reception of text/binary file
-
-FSL-UT-UART-EXT-0050
-Test for different baud rates/stop/parity bitsUse uart1 as console, use "stty" with different
-baud rates/stop/parity bits to /dev/tts/0, use "cat >/dev/tts/0" or "cat
-/dev/tts/0" to test if can receive and transmit data.
-
-FSL-UT-UART-EXT-0060
-Redirect the output of a shell command to another UARTUse command "stty -F
-/dev/ttymxc/0 115200" to uart1, and then use ls >/dev/ttymxc/0 -- the output
-should be printed on UART1s window.
-
-FSL-UT-UART-MXC-0010 
-Redirect the output of a shell command to another UART. Ensure both ends are using the same
-baud rate and other port settings.
-stty -F /dev/ttymxc/1 115200 -- set the baud rate of UART 2 to 115200
-ls >/dev/ttymxc/1 -- the output should be printed on UART2s window
-
-FSL-UT-UART-MXC-0020 
-Start a shell in the background and redirect its standard input, standard output and standard error
-to a different UART port
-sh </dev/ttymxc/2 >/dev/ttymxc/2 2>/dev/ttymxc/2
-
-FSL-UT-UART-MXC-0030 
-Type the following command on the linux console
-cat /dev/ttymxc/0
-On the board, connect UART 1 to a serial port on your PC. Open a Hyperterminal window that is
-connected to this serial port. Type characters in the Hyperterminal window. These characters
-should be printed by the cat application in the console window. Text files should also be transferred
-(Transfer->Send Text File). The contents of this file should be received by the cat received through
-UART 1. Note that this test will not pass for serial ports which have the UART DMA
-Enable/Disable (UARTx_DMA_ENABLE) configuration option set to 1 as the port will be operating
-in a raw mode where the character input is not being parsed. This is expected behavior.
-
-#test all internal MXC UART Ports (ttymxc/0..ttymxc/XX)
-FSL-UT-UART-MXC-0040 mxc_uart_test.out /dev/ttymxc1  
-
-
-FSL-UT-USB-ARC-HOST-PTP-0010
-How to build?
-enter ptp directory. Make the PTP driver module.
-make CROSS_COMPILE=${CROSS_COMPILE}
-Output: usbstillimage.ko
-ct ptp/test
-make CROSS_COMPILE=${CROSS_COMPILE}
-Ouput: ptp_test
-Material: One Digital Camera (DC). Set the DCs USB mode to PTP mode.
-Step:
-1. modprobe ehci-hcd
-2. insmod usbstillimage.ko
-3. Power on DC, and connect it to the board with USB cable.
-4. Download the ptp_test to the board.
-chmod 777 ptp_test
-./ptp_test
-If this function is not used, unload the following drivers
-rmmod usbstillimage
-rmmod ehci-hcd
-	Display: Please input command:
-	0: Exit
-	1: Display device information
-	2: Display storage information
-	3: Display file information
-	4: Get file
-	5: Get file thumbnail
-	6: Send a file
-	7: Set file protection
-	8: Delete file
-	9: Format storage
-
-input '1' and press Enter. It will display the device list and display the detailed device information such as
-the manufacturer/model/serial number/operations supported.
-
-press '2' and press Enter. It will display the detailed information of all the storage media in the device.
-
-press '3' and press Enter. It will display the detailed information of all the files (objects) in the device. The
-file ID for each file may be seen. This file ID can be used in the followed file test.
-
-press '4' and press Enter. It will ask you to input the ID of the file to get. Just input the hex value (no '0x'
-prefix needed), press Enter. It will start to get the file/object from the device, and save it to test.jpg in the
-current directory on the platform. For robust test, unplug the device during the file reading process. It will
-show some error message, but will not crash. Notice that you cannot get a directory, such as 'MISC'.
-
-press '5' and press Enter. It will ask you to input the ID of the file to get the thumbnail. Just input the hex
-value (no '0x' prefix needed), press Enter. It will start to get the file/object thumbnail from the device, and
-save it to thumb.jpg in the current directory on the platform. For robust test, unplug the device during the
-file reading process. It will show some error message but will not crash.
-
-press '6' and press Enter. It will ask you to input the name of the source file to be sent from the platform to
-the device. Just enter the files full path and name and press Enter.
-
-Then it will ask you to input the directory handle where the file is to be put. The folder is the object with
-the object Association Type 1. Choose a folder, for example "DCIM", input its object handle, and press
-Enter. It will start to send the file.
-
-To keep the best compatibility, the file will be forced into the picture format. This means that the device
-will treat it as a picture file and arrange another sequence file name for it, not the source file name. After
-it finishes sending the file, press "3" to show all the files, and see that a new file has been added.
-
-If the device is unplugged during the write process, the driver will not crash, but sometimes the storage
-information on the target device will be damaged. This is because of a design limitation of the target
-device. Under Windows XP/2000 a USB device may not be unplugged when it is writing. Therefore, it is
-recommended that the device not be unplugged during the write process.
-
-press '7' and press Enter. It will ask you to input the ID of the file to set/clear file protection. Just input the
-hex value (no '0x' prefix needed), press Enter. It will ask you to input the clear or set command. Press '1'
-and press Enter to set file protection (or press '0' and press Enter to clear file protection).
-
-press '8' and press Enter. It will ask you to input the ID of the file to delete. Just input the hex value (no '0x'
-prefix needed), press Enter. It will try to delete the file. If the file is protected, it will show the delete fail
-information.
-
-press '9' and press Enter. It will ask you to input the ID of the storage to format. Just input the hex value
-(no '0x' prefix needed) and press Enter. It will try to format the target storage media.
-To quit the test, input 0 and press Enter.
-
-Notes: Some DCs only support read operation and dont support write operation. On this type of DC steps
-6 - 9 cant be executed, and the DC wont be able to send a file, set file protection, delete a file or format
-storage.
-
-
-FSL-UT-USB-ARC-HOST-MSC-0020
-Step:
-1. modprobe ehci-hcd
-2. mkdir /mnt/udisk
-3. Plug in a U-disk
-4. cat /proc/partitions, e.g.
-major minor #blocks name
-31 0 256 mtdblock0
-8 16 127744 sdb
-find partitions with a major that is 8, this example , the sdb is U-disk partition.
-5. mount -t vfat /dev/sdb /mnt/udisk
-If this function is not used, unload the following drivers
-umount /mnt/udisk
-rmmod ehci-hcd
-
-FSL-UT-USB-ARC-HOST-HID-0030
-Material: USB mouse or USB keyboard.
-Step:
-1.modprobe ehci-hcd
-2.modprobe usbhid
-Insert USB mouse or USB keyboard.
-3. ./evtest /dev/input/event2
-If this function is not used, unload the following drivers.
-rmmod usbhid
-rmmod ehci-hcd
-Notes:
-1. For i.MX31, set:
-USB support --> USB Human Interface Device (full HID) support. Select it as a module.
-CONFIG_USB_HID=m
-USB support --> HID input layer support. Select as built in. CONFIG_USB_HIDINPUT = y.
-then
-modprobe ehci-hcd
-insmod usbhid.ko
-2. About evtest tools, find evtest.c and compile under the current platform.
-The evtest tool is a popular Linux open source tool, and can be found on the internet.
-
-
-FSL-UT-USB-ARC-Peripheral-MSC-0010
-If the NAND Flash is to be used as a USB peripheral:
-1. Plug a NAND Flash card into the board.
-2.Boot the board.
-3.Select a NAND Flash "data/user" partition as USB peripheral, e.g.
-/dev/mtdblock/8.
-Assume this partition is 100MB size. Perform the following action only once.
-4.dd bs=1M count=100 if=/dev/zero of=/dev/mtdblock/8
-If using it as a U-disk, skip this step.
-5.modprobe arcotg_udc
-6.modprobe g_file_storage file="/dev/mtdblock/8"
-Connect the board to the PC with a USB cable.
-7. The PC should recognize the U-disk.
-If this is the first time it has been used, it will have to be formatted.
-On a PC, enter Computer Management tools, storage-> Disk Management. Following the PC tutor, get a
-raw disk, create a partition on it, and format it with FAT or FAT32.
-8. Files can now be transferred between the PC and the board.
-To use a partition of the hard disk as a U disk:
-Step:
-Get a raw hard disk, and connect it to the ATA interface of board.
-1. dd if=/dev/zero of=/dev/hda bs=1M count=100
-2. reboot this board.
-3. modprobe arcotg_udc
-4. modprobe g_file_storage file="/dev/hda"
-5. Use the PC to create a partition table, and format every partition.
-On a PC using Windows, open "Computer Management", enter storage -> Disk Management
-Enter Initialize and Convert Disk Wizard. Everything should be set to the default.
-Create a partition table using the PC with Windows.
-After creating a partition table, input the "sync" command in the Linux console.
-6. Reboot this board, and look at the partition table (fdisk -l )
-root@10 ~$ fdisk -l
-Disk /dev/hda: 20.0 GB, 20003880960 bytes
-255 heads, 63 sectors/track, 2432 cylinders
-Units = cylinders of 16065 * 512 = 8225280 bytes
-Device Boot Start End Blocks Id System
-/dev/hda1 1 127 1020096 b W95 FAT32
-/dev/hda2 128 2431 18506880 f W95 Ext'd (LBA)
-/dev/hda5 128 254 1020096 6 FAT16
-/dev/hda6 255 636 3068383+ b W95 FAT32
-The above steps need to be done only once.
-Each time it is used perform the following steps:
-1. modprobe arcotg_udc
-2. Set the hard disk partition as a USB disk.
-modprobe g_file_storage file="/dev/hda"
-3. Files may now be transferred between the PC and the board.
-4. After finishing the file transfer, it can mounted
-5. mount -t vfat /dev/hda6 /mnt/test
-6. ls /mnt/test, everything here.
-Notes:
-1. Don't use the Linux format command (e.g. fdisk) to create a hard disk partition table. PC Windows must
-be used to create it if one partition is to be used as a U disk.
-2. Dont use this partition on the PC and the board at the same time.
-3. If this function is not used, unload the following drivers
-umount /mnt/test
-rmmod g_file_storage
-rmmod arcotg_udc
-
-
-FSL-UT-USB-ARC-Peripheral-Ethernet-0020
-Step:
-1. modprobe arcotg_udc
-2. modprobe g_ether
-3. ifconfig usb0
-4. ifconfig usb0 192.168.0.2 up
-When first using the USB Ethernet, and the PC OS is Windows XP, a driver must be installed.
-Use the BSP file: linux\Documentation\usb\linux.inf to install the driver.
-5. On the PC (if running Windows), find a device named Linux USB Ethernet/RNDIS Gadget
-Configure it with a fixed IP.
-Press the right button on the mouse, and click on TCP/IP ' Properties '
-Use the following IP address and settings:
-192.168.0.1
-255.255.255.0
-192.168.0.1
-Save these settings.
-From the PC, ping 192.168.0.2.
-If this function is not used, unload the following drivers
-rmmod g_ether
-rmmod arcotg_udc
-
-To enable OTG HS: CONFIG_USB_EHCI_ARC_OTGHS = y
-To enable OTG FS: CONFIG_USB_EHCI_ARC_OTGFS = y
-1. For the i.MX27 board:
-i.MX27 Hardware changes:
-(1) If using High-Speed USB OTG (J9), remove RP11, RP12; then install RP3, RP4, RP5;
-(2) If using Full-Speed USB OTG (J10), install RP11, RP12; then remove RP3, RP4, RP5;
-Enable High-Speed USB HOST2 (J7), remove RP6, RP8; then install RP7, RP9. Remove R238, R239,
-R240, R241, R246, R247, R248, R249.
-Disable High-Speed USB HOST2 (J7), install RP6, RP8; then remove RP7, RP9. Install R238, R239,
-R240, R241, R246, R247, R248, R249.
-All these resistor packs are 0 Ohm.
-i.MX27 Software changes:
-
-Default, Host2 conflicts with CSPI2 and CSPI1,
-To enable Host2, disable them by:
-Device Drivers ---> SPI support, deselect this option.
-2. For the i.MX31 ADS board
-i.MX31 Hardware changes:
-(1) If using High-Speed USB OTG (J1), remove U47,U48 IC;
-(2) If using Full-Speed USB OTG (J2), install U47,U48 IC;
-IC type is IDT74CBTLV3257Q.
-All these resistor packs are 0 Ohm.
-The USB Host2 port: pin conflicts with NAND Flash. If Host2 is to be used, remove the NAND Flash card
-from board.
-
-
-FSL-UT-USB-OTG-Peripherals-0010
-The current USB-OTG release has support for the following peripherals:
-1. Random Mouse function
-2. Network Function
-3. ACM Function
-4. Mass Storage function
-To test the Random Mouse function, use the default configurations.
-1. After Linux boots up, connect the USB OTG cable to OTG transceiver of EVB and PC.
-Notice that the PC mouse automatically moves randomly.
-To run the Network function test, modify the .config as shown below:
-1. Make menuconfig
-2. Enter net-blan string to Composite Configuration (string), found in
-Device Drivers->On-The-Go and USB Peripheral Support->Targeted Peripherals List ->
-OTG Generic function->
-OTG Generic Composite function options.
- Disable Random Mouse function.
- Select Network Function Driver.
- Enable MDLM-BLAN networking (Select Enable Older Network Protocols, Enable
-MDLM-BLAN network, Append 32bit CRC and Support Vendor Requests to Configure
-Network Interface).
- Save the config and build zImage.
-3. Configure IP address, net mask, gateway to usbl0 using ifconfig.
-The host PC should be installed with Belcarra USB LAN LINK Windows driver. Configure this
-LAN link with IP address, net mask, gateway etc. Example ifconfig usbl0 10.0.0.2. Connect the
-USB OTG cable to OTG transceiver of EVB and PC.
-4. After configuring, test the network function using ping or telnet application.
-To run an ACM function test, modify the .config as shown below:
-1. make menuconfig
-2. Enter acm-tty string to Composite Configuration (string), found in
-Device Drivers->On-The-Go and USB Peripheral Support->Targeted Peripherals List->OTG
-Generic function->OTG Generic Composite function options.
-3. Disable the Random Mouse function.
-4. Select an OTG ACM Function
-5. Save the config and build zImage.
-6. After Linux boots up, connect the USB OTG cable to OTG transceiver of EVB and PC.
-The host PC should be installed with Microsoft WDM modem drivers configured to use with the
-Belcarra ACM function driver.
-7. Spawn a terminal on the ACM tty file by using the command getty -L ACM0 115200
-vt100
-8. Open hyperterminal at PC side with COM port created by the USB to serial class driver, you will
-see the virtual console on it. Stop the hyperterminal before you un-plug the USB cable.
-To run the Mass Storage function test, modify the .config as shown below:
-1. make menuconfig
-2. Enter msc string to Composite Configuration (string), found in
-Device Drivers->On-The-Go and USB Peripheral Support->Targeted Peripherals List ->OTG
-Generic function->OTG Generic Composite function options.
-3. Disable the Random Mouse function.
-4. Select a Mass Storage function
-5. Save the config and build zImage.
-After Linux boots up Now you will see an extra mass storage drive at PC side.
-6. Run this command after downloading msc_admin to root directory ./msc_admin
-msc_mount 1 0.
-7. Connect the USB OTG cable to OTG transceiver of EVB and PC.
-8. Now you can format and read/write to that drive.
-To use the simulated block device method instead of ramdisk, replace step 6 with following steps:
-1. Or use dd if=/dev/zero of=/root/sdloop bs=1024k count=16
-2. losetup /dev/loop/0 /root/sdloop
-3. msc_admin msc_mount 7 0
-
-
-FSL-UT-USB-OTG-HOST-0020
-The current USB-OTG release claims host support only for the ISP1301 USB transceiver, and it only
-works as a kernel module. The only class driver supported now is the Belcarra LAN device. Here are the
-steps:
-1. Build the support for on-The-Go and USB Peripheral into the kernel.
-2. Select Platform selection, either 1301 or MC13783 transceiver.
-3. On-The-Go Options->
-4. On the go or USB Device Configuration --->USB Peripheral or Host
-5. Enable AutoStart.
-6. OTG Fast Tracing
-7. Targeted Peripherals List->
-8. Integrate USBLAN into the kernel, OTG generic composite function option -> string to
-net-blan.
-9. Select OTG Network Function->select Network Function Driver, on OTG Network
-Function
-10. options->Select Enable MDLM-BLAN network, with the BLAN Network function
-options->Select
-11. Automatically configure the network interface.
-12. Select support for host side USB build in kernel. Select support for Belcarra USBLAN networking
-for USB in kernel. Set VID to 0x15ec and PID to 0xF001.
-13. Connect the cable between the two MXC boards; mini-A on the host side and mini-B on the second
-MXC board.
-14. Do ifconfig, you will see usbl0 172.16.0.5
-15. Go to the USB peripheral site, ifconfig usbl0 172.16.0.6
-16. Do ping from both host and peripheral sites.
-
-FSL-UT-USB-OTG-DualRole-0020
-a kernel module. The only class driver supported now is the Belcarra LAN device.
-To set up dual role support, follow these steps.
-1. Build the support for on-The-Go and USB Peripheral into the kernel.
-On-The-Go Options->
- On the go or USB Device Configuration --->OTG Device - can act as A or B Device
- Disable AutoStart.
-Targeted Peripherals List - Repeat the peripheral network function test setup for usblan.
-2. Select support for host side USB build in kernel, select support for Belcarra USBLAN networking
-for USB in kernel, put the VID 0x15ec, PID 0xF001.
-3. Connect in the cable between the two MXC boards, mini-A on the first board, mini-B on the second
-MXC board.
-4. Run the otg_admin application at both sides, type l for loading and followed by e for enabling.
-The first board status should be a-idle, and the second board should be b-idle.
-5. Type r on first board, the first board status will change to A-Device[host], the second board
-will be B-Device[peripheral].
-6. Run ifconfig. You will see usb0 10.0.0.1 on the first board and the second board ifconfig usbl0
-10.0.0.2
-7. Ping from both host and peripheral sites.
-8. Now at the first board type r again, so both board status will become idle again. Then type r on the
-second board, the first board status will become A-Device[peripheral] and second board
-will be B-Device[host].
-9. Run ifconfig, you will see usb0 10.0.0.1 on the second board and the first board ifconfig usbl0
-10.0.0.2
-10. Ping from both host and peripheral sites.
-
-
-FSL-UT-LCDC-FB-0010
-Framebuffer Tests:
- Redirecting an image directly to the background framebuffer device:
-# cat image.bin > /dev/fb0
-The panel to be enabled during Linux booting up can be specified by appending video options into the
-kernel command line.
- Enable Sharp QVGA panel during Linux booting up. The kernel command line could be like:
-noinitrd console=ttymxc0,115200 root=/dev/nfs
-nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp
-video=mxcfb:Sharp-QVGA
- Enable NEC VGA panel during Linux booting up. The kernel command line could be like:
-noinitrd console=ttymxc0,115200 root=/dev/nfs
-nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:NEC-VGA
- Enable PAL during Linux booting up. The kernel command line could be like:
-noinitrd console=ttymxc0,115200 root=/dev/nfs
-nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-PAL
- Enable NTSC during Linux booting up. The kernel command line could be like:
-noinitrd console=ttymxc0,115200 root=/dev/nfs
-nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-NTSC
-If no video options are specified in kernel command line, the Sharp QVGA panel will be enabled by
-default.
-
-FSL-UT-TV-OUT-0010
-Enable PAL during Linux booting up. The kernel command line could be like:
-noinitrd console=ttymxc0,115200 root=/dev/nfs
-nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-PAL
-
-FSL-UT-TV-OUT-0020
-Enable NTSC during Linux booting up. The kernel command line could be like:
-noinitrd console=ttymxc0,115200 root=/dev/nfs
-nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-NTSC
-
-FSL-UT-TV-OUT-0030
-Enable PAL mode:
-#/unit_tests/mxc_fb_test/mxc_tvout_test.out -m p
-
-FSL-UT-TV-OUT-0040
-Enable NTSC mode:
-#/unit_tests/mxc_fb_test/mxc_tvout_test.out -m n
-
-FSL-UT-TV-OUT-0050
-Enable TVout:
-#/unit_tests/mxc_fb_test/mxc_tvout_test.out -e y
-
-FSL-UT-TV-OUT-0060
-Disable TVout:
-#/unit_tests/mxc_fb_test/mxc_tvout_test.out -e n
-
-FSL-UT-EMMA-overaly-0010 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 160 -oh 160 -ot 20 -ol 20 -t 50 -d 0 -fg -fr 30
-FSL-UT-EMMA-overlay-0020 mxc_v4l2_overlay.out -iw 640 -ih 480 -ow 120 -oh 160 -t 50 -d 0 -r 4 -fr 30
-FSL-UT-EMMA-capture-0010 mxc_v4l2_capture.out -w 352 -h 288 -c 50 -fr 30 test.yuv
-FSL-UT-EMMA-capture-0020 mxc_v4l2_still.out -w 640 -h 480
-FSL-UT-EMMA-output-0010 mxc_v4l2_output.out -iw 352 -ih 288 -ow 176 -oh 144 -d 0 -fg -fr 20 test.yuv
-
-FSL-UT-HANTRO-PerfTest-0010
-Hantro provides a unit test for the functions of Encoder kernel module and tested
-Hantro API. The test application Perftest and the kernel module memalloc.ko are
-distributed in the root filesystem as built binaries. These show up in the /root
-directory of the root filesystem for the architecture supported hantro cif encoder
-only. Once the kernel modules are properly loaded, the PerfTest application can be
-invoked to encode a CIF yuv video stream file to MPEG4. The input file (not provided)
-must be in the same directory as PerfTest (/root) and must be named stream.yuv. The
-output file is named stream.mpeg4 and may be verified by playing it back on a host
-PC using a suitable player such as mplayer (available by free download from
-http://www.mplayerhq.hu). The test procedure is as follows:
-
-root@10 ~$ insmod memalloc.ko
-root@10 ~$ ./PerfTest
-
-The stream.mpeg4 file, which is output, is stored in the /root directory.
-
-FSL-UT-HANTRO-Stream-Enc-0010
-The Test application named enctest along with above mentioned mxc_hmp4e.ko and memalloc.ko is
-distributed in the root filesystem as built binary. It requires ten qcif and cif input YUV test streams for
-p2sh3 test. Also seven input YUV test streams for p2sh7 test. Test procedure is as follows
-
-Follow first two steps as mentioned above for PerfTest if you still not inserted mxc_hmp4e.ko and
-memalloc.ko kernel modules.
-Once the kernel modules are properly loaded, you must copy input YUV streams to same directory as
-enctest test application with input YUV streams named as below
-Ten QCIF YUV streams for P2SH3:
-qcif_case1.yuv qcif_case61.yuv
-qcif_case2.yuv qcif_case62.yuv
-qcif_case3.yuv qcif_case63.yuv
-qcif_case4.yuv qcif_case64.yuv
-qcif_case5.yuv qcif_case65.yuv
-Ten CIF YUV streams for P2SH3:
-cif_case1.yuv cif_case61.yuv
-cif_case2.yuv cif_case62.yuv
-cif_case3.yuv cif_case63.yuv
-cif_case4.yuv cif_case64.yuv
-cif_case5.yuv cif_case65.yuv
-Seven YUV streams for P2SH7:
-p2sh7_case1.yuv
-p2sh7_case2.yuv
-p2sh7_case3.yuv
-p2sh7_case4.yuv
-p2sh7_case5.yuv
-p2sh7_case6.yuv
-p2sh7_case7.yuv
-After getting all streams execute below command to get respective mpeg4 streams in the same directory
-which can be verified in mpeg4 player(mplayer).
-A home made test is called cam2mpeg4, which captures the camera stream and stores into
-a mpeg4 file, the application source is under the
-misc/source/test/mxc_mpeg4_enc_test/cam2mpeg4 directory.
-cam2mpeg4 [width] [height] [number of frames] [frame rate] [filename]
-The application will capture [number of frames] frames from the camera sensor and
-pass it to the hantro encoder to generate a mpeg4 file called [filename] with size
-defined by [width] and [height]. For example cam2mpeg4 352 288 50 30 test.mp4.
-
-FSL-UT-VPU-LoopBack-0010 mxc_vpu_test.out -c codec.cfg.fifo.loopback.vga_to_qvga.h264
-
-FSL-UT-VPU-LoopBack-0020 mxc_vpu_test.out -c codec.cfg.net.loopback.vga.h264
-#Loopback demo through NET
-The difference between <a> and <b> is the communication way. <a> is FIFO, while <b> is NET.
-
-FSL-UT-VPU-LoopBack-0030 mxc_loopback_opt_test.out -c codec.cfg.opt.loopback.vga_to_qvga.h264
-#Loopback demo (optimized version)
-
-FSL-UT-VPU-StandAlone-Encode-0010 mxc_vpu_test.out -c codec.cfg.standalone.enc.vga.h264
-
-FSL-UT-VPU-StandAlone-Decode-0020 mxc_vpu_test.out -c codec.cfg.standalone.dec.vga.h264
-
-FSL-UT-VPU-RTP-ENCDEC-0010
-RTP demo between two boards.
-User could run by following commands on two different boards (or use do_test script)
-./mxc_vpu_test.out -c codec.cfg.net.dec.vga.h264
-./mxc_vpu_test.out -c codec.cfg.net.enc.vga.h264
-
-FSL-UT-VPU-VGA-Panel-0010
-VGA panel support
-NEC VGA panel is supported both in kernel image and test program. By default, the kernel will use QVGA
-panel. If user wants to use VGA panel, assign video=mxcfb:NEC-VGA in the kernel command line when
-Linux boots up. At test program side, make sure the output size is suitable for LCD panel. Take QVGA
-panel for example, if the bitstream resolution is 640x480, user can change out_ratio to be 4 or change
-out_ratio to be 2 and rot_angle to be 90; otherwise, the program will give out error message Could
-not start stream.
-
-FSL-UT-MBX-Services-0010 /usr/local/bin/services_test
-The MBX can be initialized using the rc.pvr script in the /etc/init.d directory. To load the drivers type
-/etc/init.d/rc.pvr start on the HyperTerminal console.To unload the driver, type /etc/init.d/rc.pvr stop.
-
-FSL-UT-MBX-EGL-0010 /usr/local/bin/egl_test 1000
-No console messages are generated for egl_test. However, you should see two rotating triangles.
-
-
-FSL-UT-ALSA-0010 aplay N M file.wav
-Playback on stereo DAC:
-
-FSL-UT-ALSA-0020 aplay N M D hw:0,1 file.wav
-Playback on voice codec
-
-FSL-UT-ALSA-0030 arecord r 8000 c 1 f S16_LE N M d 20 file.wav
-ALSA recording
-
-FSL-UT-ALSA-0040 alsamixer V all
-
-FSL-UT-ALSA-0050 arecord -c 1 -f S16_LE -r 8000/16000 | aplay -D hw:0,1
-Audio Loop Back
-
-FSL-UT-OSS-Emulation-0010 check_audio.out 1 file.wav
-Playback on stereo DAC:
-
-FSL-UT-OSS-Emulation-0020 check_audio.out 0 file.wav
-Playback on voice codec
-
-FSL-UT-OSS-Emulation-0030 check_recording.out file.wav 2 100000 16000/8000 1
-Use check_recording.out(in /unit_tests/mxc_sound_test)
-./check_recording.out file.wav 2 num_bytes 8000/16000 c
-2 -> Headset Mic
-num_bytes is the number of bytes to be recorded at 8000/16000 sample rate with c channels. (c has to be 1
-as only mono recording is supported)
-
-FSL-UT-KEYPAD-0010 autorun-keypad.sh
-FSL-UT-KEYPAD-0020 mxc_keyb_test.out
-The test program does the following actions:
-1. Opens event interface. The event interface in turn open MXC keypad driver
-2. Does a read to test the key press and key release.
-3. If the testing keypad is over key, press the END key to terminate the keypad testing.
-4. Closes the device.
-5. After running the below keypad application will print 2 messages for key press and key release.
-For example if 1 is pressed on the keypad, the message appears as below,
-6. KPP TEST APP: Pressed key is 1
-
-FSL-UT-NOR-MTD-0010 
-mkfs.jffs2 d jffs2 o fs.jffs2 e 0x20000 pad=0x400000
-
-load -r -b 0x100000 fs.jffs2
-fis write -f 0xa1b00000 -b 0x100000 -l 0x400000
-fis create -l 0x400000 -f 0xa1b00000 -n myjffs2
-
-for MX27:  fis write -f 0xc0000000 -b 0x100000 -l 0x400000
-		fis create -l 0x400000 -f 0xc0000000 -n myjffs2
-
-cd /tmp
-mkdir jffs2
-mount t jffs2 /dev/mtdblock/3 /tmp/jffs2
-
-FSL-UT-NAND-MTD-0010 
-1. Create a raw file containing a Jffs2 filesystem
-$ mkfs.jffs2 -d /etc -o etc.jffs2 -e 0x4000 --pad=0x400000
-2. Erase one of the NAND Flash partitions using flash_eraseall
-$ flash_eraseall /dev/mtd/6
-3. Write the Jffs2 image on to the NAND raw device
-$ nandwrite /dev/mtd/6 etc.jffs2
-4. Mount the NAND partition and read the files
-$ mkdir -p /tmp/mtd/6
-$ mount -t jffs2 /dev/mtdblock/6 /tmp/mtd/6
-$ cd /tmp/mtd/6
-$ find . # list all the files
-$ find . -type f -exec cat {} \; >/dev/null # read all the files into /dev/null
-
-FSL-UT-ETHERNET-0010 
-ping OK
-ftp OK (busybox 1.00)
-dhcp OK
-telnet OK
-telnetd FAILED
-nfs OK
-
-FSL-UT-FEC-0010 
-ping OK
-ftp OK (busybox 1.00)
-dhcp OK
-telnet OK
-telnetd FAILED
-nfs OK
-
-FSL-UT-SDMA-0010 /mxc_sdma_test/mxc_sdma_test.out
-$cd unit_tests/modules/
-$insmod mxc_sdma_mem_test.ko
-
-FSL-UT-SDMA-TTY-0020 /mxc_sdma_tty_interactive_test/mxc_sdma_tty_interactive_test.out word1 word2 word3
-Usage: sdma_tty_interactive_test <word1> <word2> <word3> ...
-        The test will write all the words to sdma tty driver,
-        read them back and print the read buffer on the terminal
-        All the process will be done 10 times
-
-FSL-UT-SDMA-0030 /mxc_sdma_tty_test/mxc_sdma_tty_test.out 0 or 1
-
-FSL-UT-SDMA-0040 /mxc_sdma_tty_test/mxc_sdma_tty_test2.out 0 or 1
-# Need a DSP image 
-
-FSL-UT-UDMA-0010 /mxc_udma_test/mxc_udma_test.out 0 /*1D memory to memory dma is tested*/
-$cd unit_tests/modules/
-$insmod mxc_udma_testdriver.ko
-
-FSL-UT-UDMA-0020 /mxc_udma_test/mxc_udma_test.out 1   /*1D memory to 2D memory dma is tested*/
-FSL-UT-UDMA-0030 /mxc_udma_test/mxc_udma_test.out 5 3     /*chain buffer memory to memory dma is tested*/
-
-FSL-UT-I2C-0010 
-No testapp for I2C, run IPU or V4L tests
-
-FSL-UT-1WIRE-0010 
-If MXC 1-wire driver is successfully loaded, you will see the following entry,
-/sys/devices/w1_bus_master1/23-00000051c3cb/eeprom
-Open eeprom file and edit it. Save the file and power cycle or reset the board. Now, read back and same
-file. If you see the contents then this verifies that MXC 1-wire driver has functioned correctly.
-
-FSL-UT-1WIRE-0020 autorun-owire.sh
-
-FSL-UT-IPC-0010 mxc_ipc_test.out -t 1
-insmod /unit_tests/modules/ipctestmod.ko
-
-FSL-UT-IPC-0020 mxc_ipc_test.out -t 2
-FSL-UT-IPC-0030 mxc_ipc_test.out -t 3
-FSL-UT-IPC-0040 mxc_ipc_test.out -t 4
-FSL-UT-IPC-0050 mxc_ipc_test.out -t 5
-FSL-UT-IPC-0060 mxc_ipc_test.out -t 6
-FSL-UT-IPC-0070 mxc_ipc_test.out -t 8
-FSL-UT-IPC-0080 mxc_ipc_test.out -t 20
-FSL-UT-IPC-0090 mxc_ipc_test.out -t 21
-FSL-UT-IPC-0100 mxc_ipc_test.out -t 22
-FSL-UT-IPC-0110 mxc_ipc_test.out -t 23
-FSL-UT-IPC-0120 mxc_ipc_test.out -t 24
-FSL-UT-IPC-0130 mxc_ipc_test.out -t 25
-FSL-UT-IPC-0140 mxc_ipc_test.out -t 26
-FSL-UT-IPC-0150 mxc_ipc_test.out -t 27
-FSL-UT-IPC-0160 mxc_ipc_test.out -t 28
-
-
-FSL-UT-SSI-0010 
-Please run ALSA tests
-
-
-FSL-UT-PM-MX27-0010 
-insmod mxc_pm_test.ko
-./mxc_pm_test.out
-root@freescale /unit_tests/mxc_pm_test$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-4. Test Low Power Modes
-5. Select CKOH output
-9. Infinite loop cycling through operating points.
-4
-1. WAIT mode
-2. DOZE mode
-3. STOP mode
-4. DSM mode
-Enter a valid choice:
-3
-A key press will wake up the core for choice 3 (STOP mode).
-
-
-FSL-UT-PM-MX31-0010 
-insmod mxc_pm_test.ko
-./mxc_pm_test.out
-The actual frequency change or a voltage change request can only be measured and detected using an
-oscilloscope.
-The State Retention Mode can be tested only using DPM command, echo -n mem > /sys/power/state.
-Unit-test cannot be used to test this mode.
-
-FSL-UT-PM-MXC91131-0010 
-insmod mxc_pm_test.ko
-./mxc_pm_test.out
-
-E.g.
-Example 1:
-root@(none) ~$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-
-Please note that option 3 is not available for MXC91331
-4. Test Low Power Modes
-5. Select CKOH output
-6. Configure PMIC for High Voltage (Regs at 1.6V)
-7. Configure PMIC for Low Voltage (Regs at 1.2V)
-8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
-
-Please note that options 6,7,8 are not available for MXC91331
-9. Infinite loop cycling through operating points.
-Please note that option 9 is not available for MXC91331
-8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
-3
-Enter a valid ARM frequency:
-532
-You ============== INT/PLL Scale IOCTL ==============
-have requested 532000000 Hz ARM Core frequency
-root@(none) ~$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-Please note that option 3 is not available for MXC91331
-4. Test Low Power Modes
-5. Select CKOH output
-6. Configure PMIC for High Voltage (Regs at 1.6V)
-7. Configure PMIC for Low Voltage (Regs at 1.2V)
-8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.
-
-Please note that options 6,7,8 are not available for MXC91331
-9. Infinite loop cycling through operating points.
-Please note that option 9 is not available for MXC91331
-4
-Enter low-power mode choice:
-1. WAIT mode
-2. STOP mode
-3. DSM mode
-Enter a valid choice:
-2
-============= Low-Power mode IOCTL ============
-Testing low-power modes
-To Test STOP mode
-root@(none) ~$
-
- 
-FSL-UT-PM-MXC91221-0010 
-insmod mxc_test.ko
-./mxc_pm_test.out
-
-E.g.
-Example 1:root@freescale /unit_tests/mxc_pm_test$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-4. Test Low Power Modes
-5. Select CKOH output
-4
-Enter low-power mode choice:
-1. WAIT mode
-2. STOP mode
-3. DSM mode
-Enter a valid choice:
-2
-Testing low-power modes
-============= Low-Power mode IOCTL ============
-To Test STOP mode
-Example 2:
-root@freescale /unit_tests/mxc_pm_test$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-4. Test Low Power Modes
-5. Select CKOH output
-4
-Enter low-power mode choice:
-1. WAIT mode
-2. STOP mode
-3. DSM mode
-Enter a valid choice:
-3
-Testing low-power modes
-============= Low-Power mode IOCTL ============
-To Test DSM mode
-
-
-FSL-UT-PM-MXC91231-0010 
-insmod mxc_test.ko
-./mxc_pm_test.out
-
-E.g.
-Example 1:
-root@(none) ~$ ./mxc_pm_test.out [J
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-Please note that option 3 is not available for MXC91331
-4. Test Low Power Modes
-5. Select CKOH output
-6. Configure PMIC for High Voltage (Regs at 1.6V)
-7. Configure PMIC for Low Voltage (Regs at 1.2V)
-8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
-Please note that options 6,7,8 are not available for MXC91331
-9. Infinite loop cycling through operating points.
-Please note that option 9 is not available for MXC91331
-3
-Enter a valid ARM frequency:
-532
-You have requested 532000000 Hz ARM Core frequency
-============== INT/PLL Scale IOCTL ==============
-Calling INT/PLL Scaling
-The result is 0
-Note: in MXC91231 P1, the PLL will be set to 532MHz and the ARM frequency will be set to 266. This
-is due to the SDRAMC issues discussed earlier. Also, keypad driver is now a TTY driver and therefore
-there will not be any /dev entry for keypad which will give as error as Bad file descriptor but this will
-not affect LLPM testing.
-Example 2:
-root@(none) ~$ ./mxc_pm_test.out [J
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-Please note that option 3 is not available for MXC91331
-4. Test Low Power Modes
-5. Select CKOH output
-6. Configure PMIC for High Voltage (Regs at 1.6V)
-7. Configure PMIC for Low Voltage (Regs at 1.2V)
-8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
-Please note that options 6,7,8 are not available for MXC91331
-9. Infinite loop cycling through operating points.
-Please note that option 9 is not available for MXC91331
-4
-Enter low-power mode choice (1,2,3):
-1. WAIT mode
-2. STOP mode
-3. DSM mode
-Enter a valid choice:
-2
-Testing low-power modes
-============= Low-Power mode IOCTL ============
-To Test STOP mode
-
-
-FSL-UT-PM-MXC91321-0010 
-insmod mxc_pm_test.ko
-./mxc_pm_test.out
-
-E.g.
-Example 1:
-root@(none) /unit_tests/module_test$ /unit_tests/mxc_pm_test/mxc_pm_test.out [J
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-Please note that option 3 is not available for MXC91331
-4. Test Low Power Modes
-5. Select CKOH output
-6. Configure PMIC for High Voltage (Regs at 1.6V)
-7. Configure PMIC for Low Voltage (Regs at 1.2V)
-8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
-Please note that options 6,7,8 are not available for MXC91331
-9. Infinite loop cycling through operating points.
-Please note that option 9 is not available for MXC91331
-3
-Enter a valid ARM frequency:
-532
-You have requested 532000000 Hz ARM Core frequency
-============== INT/PLL Scale IOCTL ==============
-The result is 0
-
-
-FSL-UT-PM-MXC91331-0010 
-insmod mxc_test.ko
-./mxc_pm_test.out
-
-E.g.
-Example 1:
-root@(none) ~$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-4. Test Low Power Modes
-5. Select CKOH output
-1
-Enter a valid ARM frequency:
-400000000
-Enter a valid AHB frequency:
-100000000
-Enter a valid IPG frequency:
-50000000
-You have requested 266000000 Hz ARM Core frequency
-============== INT Scale IOCTL ==============
-Calling Integer Scaling
-The result is 0
-root@(none) ~$
-Example 2:
-
-root@(none) ~$ ./mxc_pm_test.out
-========== TESTING Low-level PM DRIVER ==========
-Note that some option #'s may be skipped depending on platform.
-So, enter the option number corresponding to each option correctly
-Enter any of the following options:
-1. Test Integer Scaling
-2. Test PLL Scaling
-3. Test Int/PLL Scaling (choice decided by PM driver)
-4. Test Low Power Modes
-5. Select CKOH output
-1
-Enter a valid ARM frequency:
-100000000
-Enter a valid AHB frequency:
-100000000
-Enter a valid IPG frequency:
-50000000
-You have requested 266000000 Hz ARM Core frequency
-============== INT Scale IOCTL ==============
-Calling Integer Scaling
-The result is 0
-root@(none) ~$
-
-
-
-FSL-UT-DVFS-0010 
-The driver can be tested using dptc_hi demo located at
-LINUX2.6/misc/source/demo/dvfs_dptc_hi_demo/dvfs_dptc_hi.c. (Select Demo
-Programs -> Available Demo Programs -> DVFS & DPTC Human Interface Demo option in
-menuconfig).
-The demo provides several options:
-DPTC module status:
-Enabled - 0
-DVFS module status:
-Enabled - 0
-DPTC driver commands
-1. Enable DPTCEnables DPTC. When DPTC is enabled, DPTC module status: Enabled - 1
-appears above the menu.
-2. Disable DPTCDisables DPTC. When DPTC is disabled, DPTC module status: Enabled - 0
-appears above the menu.
-3. Update DPTC driver translation tableUpdates the driver translation table. When it is chosen,
-provide a file name for the new table.
-
-4. Read DPTC driver translation tableDumps the table into a file. When it is chosen, provide an
-output file name.
-5. Set DPTC reference circuitsSets the reference circuit status. When it is chosen a number in
-hexadecimal format should be provided. Only 4 LSBs are used, each bit corresponds to 1 of the 4
-reference circuits. The number says which reference circuits should be enabled and which
-reference circuits should be disabled.
-6. Show DPTC log bufferShows the log buffer. The log buffer is a table with 2 columns: time point
-and DPTC working point. It can be used to verify that DPTC changes the voltages when it is
-enabled. The table updates automatically, until the key is pressed to exit from the menu.
-7. Set DPTC working pointSets a DPTC working point. It can be used for debugging only, and is
-activated only when DPTC is disabled. It updates the voltage according to new working point
-number.
-------------------------
-DVFS driver commands
-8. Enable DVFSEnables DVFS. When DVFS is enabled, DVFS module status: Enabled - 1
-should appear above the menu.
-9. Disable DVFSDisables DVFS. When DVFS is disabled, DVFS module status: Enabled - 0
-should appear above the menu.
-a) Set SW general purpose bitsWrites to SW general purpose bits. A number in hexadecimal format
-should be provided. Only 4 LSBs will be used. These 4 bits will be written to register
-b)Set WFI monitorEnables/disables WFI monitoring. If WFI monitoring is disabled, then DVFS will
-take into account only general purpose bits.
-c)Show frequencyDisplays current frequency.
-------------------------
-------------------------
-q) QuitQuits the program.
-For testing DPTC, use options 1 and 2 to enable/disable DPTC. Use option 6 to see that the voltage is
-changing. Use option 5 to select reference circuits. Use option 3 and 4 to update and dump the driver
-translation table.
-For testing DVFS, use options 8 and 9 to enable/disable DVFS. Use option c to see that the frequency is
-changing.
-
-
-FSL-UT-DPTC-0010 
-The driver can be tested using dptc_hi demo located at
-LINUX2.6/misc/source/demo/dptc_hi_demo/dptc_hi.c. (Select Demo Programs ->
-Available Demo Programs -> DPTC Human Interface Demo option in menuconfig).
-The demo provides eight options, each based on a DPTC driver command:
-1. 1) Enable DPTCEnables DPTC. When DPTC is enabled, DPTC module status: Enabled - 1
-should appear above the menu.
-2. 2) Disable DPTCDisables DPTC. When DPTC is disabled, DPTC module status: Enabled - 0
-should appear above the menu
-3. 3) Update DPTC driver translation tableUpdates the driver translation table. When it is chosen,
-the file name with new table should be provided
-4. 4) Read DPTC driver translation tableDumps the table to a file. When it is chosen, the output file
-name should be provided.
-5. 5) Set DPTC reference circuitsSets the reference circuit status. When it is chosen, a number in
-hexadecimal format should be provided. Only 4 LSBs are used, each bit corresponds to one of the
-four reference circuits. The number says which reference circuits should be enabled and which
-reference circuits should be disabled.
-6. 6) Show DPTC log bufferShows the log buffer. The log buffer shows a table with two columns:
-time point and DPTC working point. It can be used to see that DPTC changes the voltages when it
-is enabled. The table updates automatically, until some key is pressed to exit from the menu.
-7. 7) Set DPTC working pointSets the DPTC working point. It can be used for debugging only. It
-is working only when DPTC is disabled. It updates the voltage according to new working point
-number.
-8. 8) QuitQuits the program.
-To test the driver, use Options 1 and 2 to enable/disable the DPTC. Use Option 6 to verify that the voltage
-is changing. Use Option 5 to select reference circuits. Use Options 3 and 4 to update and dump the driver
-translation table.
-
-
-FSL-UT-DPTC-0020 
-The driver can be tested using dptc_hi demo located at LINUX2.6/misc/source/demo/dptc_hi_demo/
-dptc_hi.c. (Select Demo Programs -> Available Demo Programs -> DPTC Human Interface Demo option
-in menuconfig).
-This demo provides several options:
-DPTC driver commands tested in the demo
- Enable DPTCEnables DPTC. When DPTC is enabled, DPTC module status: Enabled - 1
-appears above the menu
- Disable DPTCDisables DPTC. When DPTC is disabled, DPTC module status: Enabled - 0
-appears above the menu.
- Update DPTC driver translation tableUpdates the driver translation table. When this command
-is chosen, a file name for the new table must be provided.
- Read DPTC driver translation tableDumps the table into a file. When this command is chosen,
-the output file name must be provided.
- Set DPTC reference circuitsSets the reference circuit status. When this command is chosen, a
-number in hexadecimal format must be provided. Only 4 LSBs are used, and each bit corresponds
-to one of the four reference circuits. The number determines which reference circuits should be
-enabled and which reference circuits should be disabled.
- Show DPTC log bufferShows the log buffer. The log buffer shows a table with two columns:
-time point and DPTC working point. It can be used to determine how DPTC changes the voltages
-when it is enabled. The table updates automatically, until some key is pressed to exit from the
-menu.
- Set DPTC working pointSets the DPTC working point. It can be used for debugging only. It
-works only when DPTC is disabled. It updates the voltage according to the new working point
-number.
- Quitquits the program.
-For testing whether the driver is working at all, use the enable and disable DPTC commands. Use the Show
-DPTC Log Buffer command to see how the voltage is changing. Use the Set DPTC Reference Circuit
-command to select reference circuits. Use the Update DPTC driver translation table command and the
-Read DPTC driver translation table command to update and dump the driver translation table.
-
-
-FSL-UT-MINIBOOT-0010 
-Once the UART is enabled, successful test conditions can be verified by displaying messages on the
-console.
- Test transmitter and receiver functions of the UART by entering data at the terminal and reprinting
-it.
- Test the menu options selected by displaying the option on the terminal through the UART.
- Test the command line options by displaying the option on the terminal through the UART.
- Test the bad kernel by checking its CRC and displaying the message on the terminal through the
-UART whether the CRC is a success or failure.
- Display the hexadecimal source address of the Linux kernel where it is located, and the destination
-address from where it should execute.
-
-FSL-UT-NANDBOOT-0010 
-
-As this is boot code, once the UART is up, successful test conditions can be verified by displaying
-messages on the console. Enable UNIT_TEST flag in source files to enable unit testing support.
- Testing transmitter and receiver functions of UART by entering data at the terminal and reprinting
-it.
- Testing the menu options selected by displaying the option on the terminal through UART.
- Testing the command line options by displaying the option on the terminal through UART.
- Testing the bad kernel by checking its CRC and displaying the message on UART if successful or
-failure. Displaying the hexadecimal source address of Linux kernel where it is located and
-destination address from where it should execute.
-- 
1.8.0

