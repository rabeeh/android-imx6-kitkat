From 8d24774921f200f67e9cdc90ca0eebb9aaa18ff5 Mon Sep 17 00:00:00 2001
From: Jiejing Zhang <b33651@freescale.com>
Date: Thu, 3 Mar 2011 10:29:35 +0800
Subject: [PATCH 213/449] ENGR00140273 BT: add bt hciattach for ar3k bluetooth
 chip for demo

Binary build & Tested under ubuntu lucid(10.04).

This source code is from Atheros & Upstream community.

Howto test:

after you got a clean ubuntu release,
1. make sure you have install firmware-imx package,
   if not, please install it by:
    $ sudo apt-get install firmware-imx
2. then you can run the start shell in this package,
    $ ./ar3k-bt-start.sh

If success:
   you should see these messages:
   """
   <init_uart>: u->post is loaded
   Device setup complete
   """
Then you can see a bluetooth icon on your status bar.

Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
Acked-by: Lily Zhang <r58066@freescale.com>
---
 test/ar3k_bt/Makefile           |   37 +
 test/ar3k_bt/ar3k-bt-start.sh   |    6 +
 test/ar3k_bt/hciattach-ar3k.bin |  Bin 0 -> 37594 bytes
 test/ar3k_bt/hciattach.8        |  155 ++++
 test/ar3k_bt/hciattach.c        | 1552 +++++++++++++++++++++++++++++++++++++++
 test/ar3k_bt/hciattach.h        |   52 ++
 test/ar3k_bt/hciattach_ar3k.c   | 1209 ++++++++++++++++++++++++++++++
 test/ar3k_bt/hciattach_st.c     |  278 +++++++
 test/ar3k_bt/hciattach_ti.c     |  522 +++++++++++++
 test/ar3k_bt/hciattach_tialt.c  |  244 ++++++
 test/make.rules                 |    6 +
 11 files changed, 4061 insertions(+)
 create mode 100755 test/ar3k_bt/Makefile
 create mode 100644 test/ar3k_bt/ar3k-bt-start.sh
 create mode 100755 test/ar3k_bt/hciattach-ar3k.bin
 create mode 100644 test/ar3k_bt/hciattach.8
 create mode 100755 test/ar3k_bt/hciattach.c
 create mode 100755 test/ar3k_bt/hciattach.h
 create mode 100755 test/ar3k_bt/hciattach_ar3k.c
 create mode 100755 test/ar3k_bt/hciattach_st.c
 create mode 100755 test/ar3k_bt/hciattach_ti.c
 create mode 100755 test/ar3k_bt/hciattach_tialt.c

diff --git a/test/ar3k_bt/Makefile b/test/ar3k_bt/Makefile
new file mode 100755
index 0000000..131e3da
--- /dev/null
+++ b/test/ar3k_bt/Makefile
@@ -0,0 +1,37 @@
+# Makefile for atheros BT hciattach app
+#
+# This package is for atheros ar3k bt chip, you can use the binary,
+# also provide the modified source code, if you need rebuild the tool
+# please rebuild, it need the rootfs and bluez source & lib path
+EXCLUDE_LIST:= IMX21ADS IMX27ADS IMX31ADS IMX32ADS IMX37_3STACK IMX25_3STACK
+
+INC += -I$(LINUXPATH)/include
+
+ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
+OBJS = $(OBJDIR)/hciattach-ar3k.bin $(OBJDIR)/ar3k-bt-start.sh
+else
+OBJS =
+endif
+
+all : $(OBJS)
+
+.PHONY: clean
+clean:
+	rm -f $(OBJS)
+
+include ../make.rules
+
+
+# If you want to compile the source code, please reference follow make file.
+# this is default off by here.
+# it will be compile on your target envroioment.(eg, ubuntu).
+
+#CC := gcc
+
+#all: hciattach-ar3k
+
+#hciattach-ar3k:
+#	$(CC) -Wall -lbluetooth -g hciattach_ar3k.c hciattach.c -o hciattach-ar3k
+
+#clean:
+#	rm -f hciattach-ar3k *.o
diff --git a/test/ar3k_bt/ar3k-bt-start.sh b/test/ar3k_bt/ar3k-bt-start.sh
new file mode 100644
index 0000000..bdfa3ae
--- /dev/null
+++ b/test/ar3k_bt/ar3k-bt-start.sh
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+sudo pkill -9 hciattach-ar3k.bin
+sudo su -c "echo 1 > /sys/class/rfkill/rfkill0/state"
+sudo chmod 777 /dev/ttymxc2
+sudo ./hciattach-ar3k.bin -n ttymxc2 ar3k 576000 &
diff --git a/test/ar3k_bt/hciattach-ar3k.bin b/test/ar3k_bt/hciattach-ar3k.bin
new file mode 100755
index 0000000000000000000000000000000000000000..55a11ce0f15e0b26aeeb90671f211f1d1bc2a407
GIT binary patch
literal 37594
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
Vt|%IvsBn?No?6^jtqEtX{cn`I$2tH2

literal 0
HcmV?d00001

diff --git a/test/ar3k_bt/hciattach.8 b/test/ar3k_bt/hciattach.8
new file mode 100644
index 0000000..e0e2730
--- /dev/null
+++ b/test/ar3k_bt/hciattach.8
@@ -0,0 +1,155 @@
+.TH HCIATTACH 8 "Jan 22 2002" BlueZ "Linux System Administration"
+.SH NAME
+hciattach \- attach serial devices via UART HCI to BlueZ stack
+.SH SYNOPSIS
+.B hciattach
+.RB [\| \-b \|]
+.RB [\| \-n \|]
+.RB [\| \-p \|]
+.RB [\| \-t
+.IR timeout \|]
+.RB [\| \-s
+.IR speed \|]
+.RB [\| \-l \|]
+.RB [\| \-r \|]
+.I tty
+.IR type \||\| id
+.I speed
+.I flow
+.I bdaddr
+.SH DESCRIPTION
+.LP
+Hciattach is used to attach a serial UART to the Bluetooth stack as HCI
+transport interface.
+.SH OPTIONS
+.TP
+.B \-b
+Send break.
+.TP
+.B \-n
+Don't detach from controlling terminal.
+.TP
+.B \-p
+Print the PID when detaching.
+.TP
+.BI \-t " timeout"
+Specify an initialization timeout.  (Default is 5 seconds.)
+.TP
+.BI \-s " speed"
+Specify an initial speed instead of the hardware default.
+.TP
+.B \-l
+List all available configurations.
+.TP
+.B \-r
+Set the HCI device into raw mode (the kernel and bluetoothd will ignore it).
+.TP
+.I tty
+This specifies the serial device to attach. A leading
+.B /dev
+can be omitted. Examples:
+.B /dev/ttyS1
+.B ttyS2
+.TP
+.IR type \||\| id
+The
+.I type
+or
+.I id
+of the Bluetooth device that is to be attached, i.e. vendor or other device
+specific identifier. Currently supported types are
+.RS
+.TP
+.B type
+.B description
+.TP
+.B any
+Unspecified HCI_UART interface, no vendor specific options
+.TP
+.B ericsson
+Ericsson based modules
+.TP
+.B digi
+Digianswer based cards
+.TP
+.B xircom
+Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter
+.TP
+.B csr
+CSR Casira serial adapter or BrainBoxes serial dongle (BL642)
+.TP
+.B bboxes
+BrainBoxes PCMCIA card (BL620)
+.TP
+.B swave
+Silicon Wave kits
+.TP
+.B bcsp
+Serial adapters using CSR chips with BCSP serial protocol
+.TP
+.B ath3k
+Atheros AR300x based serial Bluetooth device
+.RE
+
+Supported IDs are (manufacturer id, product id)
+.RS
+.TP
+.B 0x0105, 0x080a
+Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter
+.TP
+.B 0x0160, 0x0002
+BrainBoxes PCMCIA card (BL620)
+.RE
+
+.TP
+.I speed
+The
+.I speed
+specifies the UART speed to use. Baudrates higher than 115.200bps require
+vendor specific initializations that are not implemented for all types of
+devices. In general the following speeds are supported:
+
+.B 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600
+
+Supported vendor devices are automatically initialised to their respective
+best settings.
+.TP
+.I flow
+If the keyword
+.I flow
+is appended to the list of options then hardware flow control is forced on
+the serial link (
+.B CRTSCTS
+). All above mentioned device types have
+.B flow
+set by default. To force no flow control use
+.B noflow
+instead.
+.TP
+.I sleep
+Enables hardware specific power management feature. If
+.I sleep
+is appended to the list of options then this feature is enabled. To disable
+this feature use
+.B nosleep
+instead.
+All above mentioned device types have
+.B nosleep
+set by default.
+
+Note: This option will only be valid for hardware which support
+hardware specific power management enable option from host.
+.TP
+.I bdaddr
+The
+.I bdaddr
+specifies the Bluetooth Address to use.  Some devices (like the STLC2500)
+do not store the Bluetooth address in hardware memory.  Instead it must
+be uploaded during the initialization process.  If this argument
+is specified, then the address will be used to initialize the device.
+Otherwise, a default address will be used.
+
+.SH AUTHORS
+Written by Maxim Krasnyansky <maxk@qualcomm.com>
+.PP
+Manual page by Nils Faerber <nils@kernelconcepts.de>
diff --git a/test/ar3k_bt/hciattach.c b/test/ar3k_bt/hciattach.c
new file mode 100755
index 0000000..4405079
--- /dev/null
+++ b/test/ar3k_bt/hciattach.c
@@ -0,0 +1,1552 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2000-2001  Qualcomm Incorporated
+ *  Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
+ *  Copyright (C) 2002-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <syslog.h>
+#include <termios.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/poll.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/hci.h>
+#include <bluetooth/hci_lib.h>
+
+#include "hciattach.h"
+
+#ifdef NEED_PPOLL
+#include "ppoll.h"
+#endif
+
+struct uart_t {
+	char *type;
+	int  m_id;
+	int  p_id;
+	int  proto;
+	int  init_speed;
+	int  speed;
+	int  flags;
+	char *bdaddr;
+	int  (*init) (int fd, struct uart_t *u, struct termios *ti);
+	int  (*post) (int fd, struct uart_t *u, struct termios *ti);
+};
+
+#define FLOW_CTL	0x0001
+
+static volatile sig_atomic_t __io_canceled = 0;
+
+static void sig_hup(int sig)
+{
+}
+
+static void sig_term(int sig)
+{
+	__io_canceled = 1;
+}
+
+static void sig_alarm(int sig)
+{
+	fprintf(stderr, "Initialization timed out.\n");
+	exit(1);
+}
+
+static int uart_speed(int s)
+{
+	switch (s) {
+	case 9600:
+		return B9600;
+	case 19200:
+		return B19200;
+	case 38400:
+		return B38400;
+	case 57600:
+		return B57600;
+	case 115200:
+		return B115200;
+	case 230400:
+		return B230400;
+	case 460800:
+		return B460800;
+	case 500000:
+		return B500000;
+	case 576000:
+		return B576000;
+	case 921600:
+		return B921600;
+	case 1000000:
+		return B1000000;
+	case 1152000:
+		return B1152000;
+	case 1500000:
+		return B1500000;
+	case 2000000:
+		return B2000000;
+#ifdef B2500000
+	case 2500000:
+		return B2500000;
+#endif
+#ifdef B3000000
+	case 3000000:
+		return B3000000;
+#endif
+#ifdef B3500000
+	case 3500000:
+		return B3500000;
+#endif
+#ifdef B4000000
+	case 4000000:
+		return B4000000;
+#endif
+	default:
+		return B57600;
+	}
+}
+
+int set_speed(int fd, struct termios *ti, int speed)
+{
+	cfsetospeed(ti, uart_speed(speed));
+	cfsetispeed(ti, uart_speed(speed));
+	return tcsetattr(fd, TCSANOW, ti);
+}
+
+/*
+ * Read an HCI event from the given file descriptor.
+ */
+int read_hci_event(int fd, unsigned char* buf, int size)
+{
+	int remain, r;
+	int count = 0;
+
+	if (size <= 0)
+		return -1;
+
+	/* The first byte identifies the packet type. For HCI event packets, it
+	 * should be 0x04, so we read until we get to the 0x04. */
+	while (1) {
+		r = read(fd, buf, 1);
+		if (r <= 0)
+			return -1;
+		if (buf[0] == 0x04)
+			break;
+	}
+	count++;
+
+	/* The next two bytes are the event code and parameter total length. */
+	while (count < 3) {
+		r = read(fd, buf + count, 3 - count);
+		if (r <= 0)
+			return -1;
+		count += r;
+	}
+
+	/* Now we read the parameters. */
+	if (buf[2] < (size - 3))
+		remain = buf[2];
+	else
+		remain = size - 3;
+
+	while ((count - 3) < remain) {
+		r = read(fd, buf + count, remain - (count - 3));
+		if (r <= 0)
+			return -1;
+		count += r;
+	}
+
+	return count;
+}
+
+/*
+ * Ericsson specific initialization
+ */
+static int ericsson(int fd, struct uart_t *u, struct termios *ti)
+{
+	struct timespec tm = {0, 50000};
+	char cmd[5];
+
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x09;
+	cmd[2] = 0xfc;
+	cmd[3] = 0x01;
+
+	switch (u->speed) {
+	case 57600:
+		cmd[4] = 0x03;
+		break;
+	case 115200:
+		cmd[4] = 0x02;
+		break;
+	case 230400:
+		cmd[4] = 0x01;
+		break;
+	case 460800:
+		cmd[4] = 0x00;
+		break;
+	case 921600:
+		cmd[4] = 0x20;
+		break;
+	case 2000000:
+		cmd[4] = 0x25;
+		break;
+	case 3000000:
+		cmd[4] = 0x27;
+		break;
+	case 4000000:
+		cmd[4] = 0x2B;
+		break;
+	default:
+		cmd[4] = 0x03;
+		u->speed = 57600;
+		fprintf(stderr, "Invalid speed requested, using %d bps instead\n", u->speed);
+		break;
+	}
+
+	/* Send initialization command */
+	if (write(fd, cmd, 5) != 5) {
+		perror("Failed to write init command");
+		return -1;
+	}
+
+	nanosleep(&tm, NULL);
+	return 0;
+}
+
+/*
+ * Digianswer specific initialization
+ */
+static int digi(int fd, struct uart_t *u, struct termios *ti)
+{
+	struct timespec tm = {0, 50000};
+	char cmd[5];
+
+	/* DigiAnswer set baud rate command */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x07;
+	cmd[2] = 0xfc;
+	cmd[3] = 0x01;
+
+	switch (u->speed) {
+	case 57600:
+		cmd[4] = 0x08;
+		break;
+	case 115200:
+		cmd[4] = 0x09;
+		break;
+	default:
+		cmd[4] = 0x09;
+		u->speed = 115200;
+		break;
+	}
+
+	/* Send initialization command */
+	if (write(fd, cmd, 5) != 5) {
+		perror("Failed to write init command");
+		return -1;
+	}
+
+	nanosleep(&tm, NULL);
+	return 0;
+}
+
+#if 0
+static int texas(int fd, struct uart_t *u, struct termios *ti)
+{
+	return texas_init(fd, ti);
+}
+
+static int texas2(int fd, struct uart_t *u, struct termios *ti)
+{
+	return texas_post(fd, ti);
+}
+
+static int texasalt(int fd, struct uart_t *u, struct termios *ti)
+{
+	return texasalt_init(fd, u->speed, ti);
+}
+#endif
+
+static int read_check(int fd, void *buf, int count)
+{
+	int res;
+
+	do {
+		res = read(fd, buf, count);
+		if (res != -1) {
+			buf += res;
+			count -= res;
+		}
+	} while (count && (errno == 0 || errno == EINTR));
+
+	if (count)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * BCSP specific initialization
+ */
+static int serial_fd;
+static int bcsp_max_retries = 10;
+
+static void bcsp_tshy_sig_alarm(int sig)
+{
+	unsigned char bcsp_sync_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xda,0xdc,0xed,0xed,0xc0};
+	int len, retries = 0;
+
+	if (retries < bcsp_max_retries) {
+		retries++;
+		len = write(serial_fd, &bcsp_sync_pkt, 10);
+		alarm(1);
+		return;
+	}
+
+	tcflush(serial_fd, TCIOFLUSH);
+	fprintf(stderr, "BCSP initialization timed out\n");
+	exit(1);
+}
+
+static void bcsp_tconf_sig_alarm(int sig)
+{
+	unsigned char bcsp_conf_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xad,0xef,0xac,0xed,0xc0};
+	int len, retries = 0;
+
+	if (retries < bcsp_max_retries){
+		retries++;
+		len = write(serial_fd, &bcsp_conf_pkt, 10);
+		alarm(1);
+		return;
+	}
+
+	tcflush(serial_fd, TCIOFLUSH);
+	fprintf(stderr, "BCSP initialization timed out\n");
+	exit(1);
+}
+
+static int bcsp(int fd, struct uart_t *u, struct termios *ti)
+{
+	unsigned char byte, bcsph[4], bcspp[4],
+		bcsp_sync_resp_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xac,0xaf,0xef,0xee,0xc0},
+		bcsp_conf_resp_pkt[10] = {0xc0,0x00,0x41,0x00,0xbe,0xde,0xad,0xd0,0xd0,0xc0},
+		bcspsync[4]     = {0xda, 0xdc, 0xed, 0xed},
+		bcspsyncresp[4] = {0xac,0xaf,0xef,0xee},
+		bcspconf[4]     = {0xad,0xef,0xac,0xed},
+		bcspconfresp[4] = {0xde,0xad,0xd0,0xd0};
+	struct sigaction sa;
+	int len;
+
+	if (set_speed(fd, ti, u->speed) < 0) {
+		perror("Can't set default baud rate");
+		return -1;
+	}
+
+	ti->c_cflag |= PARENB;
+	ti->c_cflag &= ~(PARODD);
+
+	if (tcsetattr(fd, TCSANOW, ti) < 0) {
+		perror("Can't set port settings");
+		return -1;
+	}
+
+	alarm(0);
+
+	serial_fd = fd;
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_flags = SA_NOCLDSTOP;
+	sa.sa_handler = bcsp_tshy_sig_alarm;
+	sigaction(SIGALRM, &sa, NULL);
+
+	/* State = shy */
+
+	bcsp_tshy_sig_alarm(0);
+	while (1) {
+		do {
+			if (read_check(fd, &byte, 1) == -1){
+				perror("Failed to read");
+				return -1;
+			}
+		} while (byte != 0xC0);
+
+		do {
+			if ( read_check(fd, &bcsph[0], 1) == -1){
+				perror("Failed to read");
+				return -1;
+			}
+		} while (bcsph[0] == 0xC0);
+
+		if ( read_check(fd, &bcsph[1], 3) == -1){
+			perror("Failed to read");
+			return -1;
+		}
+
+		if (((bcsph[0] + bcsph[1] + bcsph[2]) & 0xFF) != (unsigned char)~bcsph[3])
+			continue;
+		if (bcsph[1] != 0x41 || bcsph[2] != 0x00)
+			continue;
+
+		if (read_check(fd, &bcspp, 4) == -1){
+			perror("Failed to read");
+			return -1;
+		}
+
+		if (!memcmp(bcspp, bcspsync, 4)) {
+			len = write(fd, &bcsp_sync_resp_pkt,10);
+		} else if (!memcmp(bcspp, bcspsyncresp, 4))
+			break;
+	}
+
+	/* State = curious */
+
+	alarm(0);
+	sa.sa_handler = bcsp_tconf_sig_alarm;
+	sigaction(SIGALRM, &sa, NULL);
+	alarm(1);
+
+	while (1) {
+		do {
+			if (read_check(fd, &byte, 1) == -1){
+				perror("Failed to read");
+				return -1;
+			}
+		} while (byte != 0xC0);
+
+		do {
+			if (read_check(fd, &bcsph[0], 1) == -1){
+				perror("Failed to read");
+				return -1;
+			}
+		} while (bcsph[0] == 0xC0);
+
+		if (read_check(fd, &bcsph[1], 3) == -1){
+			perror("Failed to read");
+			return -1;
+		}
+
+		if (((bcsph[0] + bcsph[1] + bcsph[2]) & 0xFF) != (unsigned char)~bcsph[3])
+			continue;
+
+		if (bcsph[1] != 0x41 || bcsph[2] != 0x00)
+			continue;
+
+		if (read_check(fd, &bcspp, 4) == -1){
+			perror("Failed to read");
+			return -1;
+		}
+
+		if (!memcmp(bcspp, bcspsync, 4))
+			len = write(fd, &bcsp_sync_resp_pkt, 10);
+		else if (!memcmp(bcspp, bcspconf, 4))
+			len = write(fd, &bcsp_conf_resp_pkt, 10);
+		else if (!memcmp(bcspp, bcspconfresp,  4))
+			break;
+	}
+
+	/* State = garrulous */
+
+	return 0;
+}
+
+/*
+ * CSR specific initialization
+ * Inspired strongly by code in OpenBT and experimentations with Brainboxes
+ * Pcmcia card.
+ * Jean Tourrilhes <jt@hpl.hp.com> - 14.11.01
+ */
+static int csr(int fd, struct uart_t *u, struct termios *ti)
+{
+	struct timespec tm = {0, 10000000};	/* 10ms - be generous */
+	unsigned char cmd[30];		/* Command */
+	unsigned char resp[30];		/* Response */
+	int  clen = 0;		/* Command len */
+	static int csr_seq = 0;	/* Sequence number of command */
+	int  divisor;
+
+	/* It seems that if we set the CSR UART speed straight away, it
+	 * won't work, the CSR UART gets into a state where we can't talk
+	 * to it anymore.
+	 * On the other hand, doing a read before setting the CSR speed
+	 * seems to be ok.
+	 * Therefore, the strategy is to read the build ID (useful for
+	 * debugging) and only then set the CSR UART speed. Doing like
+	 * this is more complex but at least it works ;-)
+	 * The CSR UART control may be slow to wake up or something because
+	 * every time I read its speed, its bogus...
+	 * Jean II */
+
+	/* Try to read the build ID of the CSR chip */
+	clen = 5 + (5 + 6) * 2;
+	/* HCI header */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x00;		/* CSR command */
+	cmd[2] = 0xfc;		/* MANUFACTURER_SPEC */
+	cmd[3] = 1 + (5 + 6) * 2;	/* len */
+	/* CSR MSG header */
+	cmd[4] = 0xC2;		/* first+last+channel=BCC */
+	/* CSR BCC header */
+	cmd[5] = 0x00;		/* type = GET-REQ */
+	cmd[6] = 0x00;		/* - msB */
+	cmd[7] = 5 + 4;		/* len */
+	cmd[8] = 0x00;		/* - msB */
+	cmd[9] = csr_seq & 0xFF;/* seq num */
+	cmd[10] = (csr_seq >> 8) & 0xFF;	/* - msB */
+	csr_seq++;
+	cmd[11] = 0x19;		/* var_id = CSR_CMD_BUILD_ID */
+	cmd[12] = 0x28;		/* - msB */
+	cmd[13] = 0x00;		/* status = STATUS_OK */
+	cmd[14] = 0x00;		/* - msB */
+	/* CSR BCC payload */
+	memset(cmd + 15, 0, 6 * 2);
+
+	/* Send command */
+	do {
+		if (write(fd, cmd, clen) != clen) {
+			perror("Failed to write init command (GET_BUILD_ID)");
+			return -1;
+		}
+
+		/* Read reply. */
+		if (read_hci_event(fd, resp, 100) < 0) {
+			perror("Failed to read init response (GET_BUILD_ID)");
+			return -1;
+		}
+
+	/* Event code 0xFF is for vendor-specific events, which is
+	 * what we're looking for. */
+	} while (resp[1] != 0xFF);
+
+#ifdef CSR_DEBUG
+	{
+	char temp[512];
+	int i;
+	for (i=0; i < rlen; i++)
+		sprintf(temp + (i*3), "-%02X", resp[i]);
+	fprintf(stderr, "Reading CSR build ID %d [%s]\n", rlen, temp + 1);
+	// In theory, it should look like :
+	// 04-FF-13-FF-01-00-09-00-00-00-19-28-00-00-73-00-00-00-00-00-00-00
+	}
+#endif
+	/* Display that to user */
+	fprintf(stderr, "CSR build ID 0x%02X-0x%02X\n",
+		resp[15] & 0xFF, resp[14] & 0xFF);
+
+	/* Try to read the current speed of the CSR chip */
+	clen = 5 + (5 + 4)*2;
+	/* -- HCI header */
+	cmd[3] = 1 + (5 + 4)*2;	/* len */
+	/* -- CSR BCC header -- */
+	cmd[9] = csr_seq & 0xFF;	/* seq num */
+	cmd[10] = (csr_seq >> 8) & 0xFF;	/* - msB */
+	csr_seq++;
+	cmd[11] = 0x02;		/* var_id = CONFIG_UART */
+	cmd[12] = 0x68;		/* - msB */
+
+#ifdef CSR_DEBUG
+	/* Send command */
+	do {
+		if (write(fd, cmd, clen) != clen) {
+			perror("Failed to write init command (GET_BUILD_ID)");
+			return -1;
+		}
+
+		/* Read reply. */
+		if (read_hci_event(fd, resp, 100) < 0) {
+			perror("Failed to read init response (GET_BUILD_ID)");
+			return -1;
+		}
+
+	/* Event code 0xFF is for vendor-specific events, which is
+	 * what we're looking for. */
+	} while (resp[1] != 0xFF);
+
+	{
+	char temp[512];
+	int i;
+	for (i=0; i < rlen; i++)
+		sprintf(temp + (i*3), "-%02X", resp[i]);
+	fprintf(stderr, "Reading CSR UART speed %d [%s]\n", rlen, temp+1);
+	}
+#endif
+
+	if (u->speed > 1500000) {
+		fprintf(stderr, "Speed %d too high. Remaining at %d baud\n",
+			u->speed, u->init_speed);
+		u->speed = u->init_speed;
+	} else if (u->speed != 57600 && uart_speed(u->speed) == B57600) {
+		/* Unknown speed. Why oh why can't we just pass an int to the kernel? */
+		fprintf(stderr, "Speed %d unrecognised. Remaining at %d baud\n",
+			u->speed, u->init_speed);
+		u->speed = u->init_speed;
+	}
+	if (u->speed == u->init_speed)
+		return 0;
+
+	/* Now, create the command that will set the UART speed */
+	/* CSR BCC header */
+	cmd[5] = 0x02;			/* type = SET-REQ */
+	cmd[6] = 0x00;			/* - msB */
+	cmd[9] = csr_seq & 0xFF;	/* seq num */
+	cmd[10] = (csr_seq >> 8) & 0xFF;/* - msB */
+	csr_seq++;
+
+	divisor = (u->speed*64+7812)/15625;
+
+	/* No parity, one stop bit -> divisor |= 0x0000; */
+	cmd[15] = (divisor) & 0xFF;		/* divider */
+	cmd[16] = (divisor >> 8) & 0xFF;	/* - msB */
+	/* The rest of the payload will be 0x00 */
+
+#ifdef CSR_DEBUG
+	{
+	char temp[512];
+	int i;
+	for(i = 0; i < clen; i++)
+		sprintf(temp + (i*3), "-%02X", cmd[i]);
+	fprintf(stderr, "Writing CSR UART speed %d [%s]\n", clen, temp + 1);
+	// In theory, it should look like :
+	// 01-00-FC-13-C2-02-00-09-00-03-00-02-68-00-00-BF-0E-00-00-00-00-00-00
+	// 01-00-FC-13-C2-02-00-09-00-01-00-02-68-00-00-D8-01-00-00-00-00-00-00
+	}
+#endif
+
+	/* Send the command to set the CSR UART speed */
+	if (write(fd, cmd, clen) != clen) {
+		perror("Failed to write init command (SET_UART_SPEED)");
+		return -1;
+	}
+
+	nanosleep(&tm, NULL);
+	return 0;
+}
+
+/*
+ * Atheros AR3xxx specific initialization code with power management disabled.
+ * Suraj Sumangala <Suraj@Atheros.com>
+ */
+static int ar3kpost(int fd, struct uart_t *u, struct termios *ti)
+{
+	int dev_id, dd;
+	struct timespec tm = {0, 50000};
+	int status = 0;
+
+	ATH_INFO("");
+
+	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
+	if (dev_id < 0) {
+		perror("cannot get device id");
+		return -1;
+	}
+	ATH_INFO("ioctl(fd, HCIUARTGETDEVICE, 0)");
+
+	dd = hci_open_dev(dev_id);
+	if (dd < 0) {
+		perror("HCI device open failed");
+		return -1;
+	}
+	ATH_INFO("hci_open_dev");
+
+	sleep(2);
+
+	/* send vendor specific command with Sleep feature disabled */
+	hci_send_cmd(dd, OGF_VENDOR_CMD, 0x04, 1, &status);
+	ATH_INFO("Send vendor specific command with Sleep feature disabled");
+
+	nanosleep(&tm, NULL);
+	hci_close_dev(dd);
+
+	return 0;
+
+}
+/*
+ * Atheros AR3xxx specific initialization post callback
+ *  with power management enabled
+ * Suraj Sumangala <Suraj@Atheros.com>
+ */
+static int ar3kpmpost(int fd, struct uart_t *u, struct termios *ti)
+{
+	int dev_id, dd;
+	struct timespec tm = {0, 50000};
+	int status = 1;
+
+	ATH_INFO("");
+
+	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
+	if (dev_id < 0) {
+		perror("cannot get device id");
+		return -1;
+	}
+	ATH_INFO("ioctl(fd, HCIUARTGETDEVICE, 0)");
+
+	dd = hci_open_dev(dev_id);
+	if (dd < 0) {
+		perror("HCI device open failed");
+		return -1;
+	}
+	ATH_INFO("hci_open_dev");
+
+	sleep(2);
+
+	/* send vendor specific command with Sleep feature Enabled */
+	if (hci_send_cmd(dd, OGF_VENDOR_CMD, 0x04, 1, &status) < 0)
+		perror("sleep enable command not sent");
+
+	ATH_INFO("Send vendor specific command with Sleep feature Enabled");
+
+	nanosleep(&tm, NULL);
+	hci_close_dev(dd);
+
+	return 0;
+}
+/*
+ * Atheros AR3xxx specific initialization
+ * Suraj Sumangala <Suraj@Atheros.com>
+ */
+static int ar3kinit(int fd, struct uart_t *u, struct termios *ti)
+{
+	struct timespec tm = { 0, 500000 };
+	unsigned char cmd[14], rsp[100];
+	int r;
+	int baud;
+
+	ATH_INFO("");
+
+	/* Download PS and patch */
+	r = ath_ps_download(fd);
+	if (r < 0) {
+		perror("Failed to Download configuration");
+		return -1;
+	}
+	ATH_INFO("Download PS and patch");
+
+	/* Write BDADDR if user has provided any */
+	if (u->bdaddr != NULL) {
+		/* Set BD_ADDR */
+		memset(cmd, 0, sizeof(cmd));
+		memset(rsp, 0, sizeof(rsp));
+		cmd[0] = HCI_COMMAND_PKT;
+		cmd[1] = 0x0B;
+		cmd[2] = 0xfc;
+		cmd[3] = 0x0A;
+		cmd[4] = 0x01;
+		cmd[5] = 0x01;
+		cmd[6] = 0x00;
+		cmd[7] = 0x06;
+		str2ba(u->bdaddr, (bdaddr_t *) (cmd + 8));
+
+		/* Send command */
+		if (write(fd, cmd, 14) != 14) {
+			fprintf(stderr, "Failed to write BD_ADDR command\n");
+			return -1;
+		}
+
+		/* Read reply */
+		if (read_hci_event(fd, rsp, 10) < 0) {
+			fprintf(stderr, "Failed to set BD_ADDR\n");
+			return -1;
+		}
+		ATH_INFO("Write BDADDR");
+	}
+
+	/* Send HCI Reset to write the configuration */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x03;
+	cmd[2] = 0x0c;
+	cmd[3] = 0x00;
+	/* Send reset command */
+	r = write(fd, cmd, 4);
+
+	if (r != 4)
+		return -1;
+
+	nanosleep(&tm, NULL);
+	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0)
+		return -1;
+	ATH_INFO("Send HCI Reset");
+
+	/* Set baud rate command,
+	 * set controller baud rate to user specified value */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x0C;
+	cmd[2] = 0xfc;
+	cmd[3] = 0x02;
+	baud = u->speed/100;
+	cmd[4] = (char)baud;
+	cmd[5] = (char)(baud >> 8);
+
+	if (write(fd, cmd, 6) != 6) {
+		perror("Failed to write init command");
+		return -1;
+	}
+
+	/* Wait for the command complete event for Baud rate change Command */
+	nanosleep(&tm, NULL);
+	if (read_hci_event(fd, rsp, sizeof(rsp)) < 0)
+		return -1;
+	ATH_INFO("Set baud rate command");
+
+	return 0;
+}
+/*
+ * Silicon Wave specific initialization
+ * Thomas Moser <thomas.moser@tmoser.ch>
+ */
+static int swave(int fd, struct uart_t *u, struct termios *ti)
+{
+	struct timespec tm = { 0, 500000 };
+	char cmd[10], rsp[100];
+	int r;
+
+	// Silicon Wave set baud rate command
+	// see HCI Vendor Specific Interface from Silicon Wave
+	// first send a "param access set" command to set the
+	// appropriate data fields in RAM. Then send a "HCI Reset
+	// Subcommand", e.g. "soft reset" to make the changes effective.
+
+	cmd[0] = HCI_COMMAND_PKT;	// it's a command packet
+	cmd[1] = 0x0B;			// OCF 0x0B	= param access set
+	cmd[2] = 0xfc;			// OGF bx111111 = vendor specific
+	cmd[3] = 0x06;			// 6 bytes of data following
+	cmd[4] = 0x01;			// param sub command
+	cmd[5] = 0x11;			// tag 17 = 0x11 = HCI Transport Params
+	cmd[6] = 0x03;			// length of the parameter following
+	cmd[7] = 0x01;			// HCI Transport flow control enable
+	cmd[8] = 0x01;			// HCI Transport Type = UART
+
+	switch (u->speed) {
+	case 19200:
+		cmd[9] = 0x03;
+		break;
+	case 38400:
+		cmd[9] = 0x02;
+		break;
+	case 57600:
+		cmd[9] = 0x01;
+		break;
+	case 115200:
+		cmd[9] = 0x00;
+		break;
+	default:
+		u->speed = 115200;
+		cmd[9] = 0x00;
+		break;
+	}
+
+	/* Send initialization command */
+	if (write(fd, cmd, 10) != 10) {
+		perror("Failed to write init command");
+		return -1;
+	}
+
+	// We should wait for a "GET Event" to confirm the success of
+	// the baud rate setting. Wait some time before reading. Better:
+	// read with timeout, parse data
+	// until correct answer, else error handling ... todo ...
+
+	nanosleep(&tm, NULL);
+
+	r = read(fd, rsp, sizeof(rsp));
+	if (r > 0) {
+		// guess it's okay, but we should parse the reply. But since
+		// I don't react on an error anyway ... todo
+		// Response packet format:
+		//  04	Event
+		//  FF	Vendor specific
+		//  07	Parameter length
+		//  0B	Subcommand
+		//  01	Setevent
+		//  11	Tag specifying HCI Transport Layer Parameter
+		//  03	length
+		//  01	flow on
+		//  01 	Hci Transport type = Uart
+		//  xx	Baud rate set (see above)
+	} else {
+		// ups, got error.
+		return -1;
+	}
+
+	// we probably got the reply. Now we must send the "soft reset"
+	// which is standard HCI RESET.
+
+	cmd[0] = HCI_COMMAND_PKT;	// it's a command packet
+	cmd[1] = 0x03;
+	cmd[2] = 0x0c;
+	cmd[3] = 0x00;
+
+	/* Send reset command */
+	if (write(fd, cmd, 4) != 4) {
+		perror("Can't write Silicon Wave reset cmd.");
+		return -1;
+	}
+
+	nanosleep(&tm, NULL);
+
+	// now the uart baud rate on the silicon wave module is set and effective.
+	// change our own baud rate as well. Then there is a reset event comming in
+ 	// on the *new* baud rate. This is *undocumented*! The packet looks like this:
+	// 04 FF 01 0B (which would make that a confirmation of 0x0B = "Param
+	// subcommand class". So: change to new baud rate, read with timeout, parse
+	// data, error handling. BTW: all param access in Silicon Wave is done this way.
+	// Maybe this code would belong in a seperate file, or at least code reuse...
+
+	return 0;
+}
+
+/*
+ * ST Microelectronics specific initialization
+ * Marcel Holtmann <marcel@holtmann.org>
+ */
+static int st(int fd, struct uart_t *u, struct termios *ti)
+{
+	struct timespec tm = {0, 50000};
+	char cmd[5];
+
+	/* ST Microelectronics set baud rate command */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x46;			// OCF = Hci_Cmd_ST_Set_Uart_Baud_Rate
+	cmd[2] = 0xfc;			// OGF = Vendor specific
+	cmd[3] = 0x01;
+
+	switch (u->speed) {
+	case 9600:
+		cmd[4] = 0x09;
+		break;
+	case 19200:
+		cmd[4] = 0x0b;
+		break;
+	case 38400:
+		cmd[4] = 0x0d;
+		break;
+	case 57600:
+		cmd[4] = 0x0e;
+		break;
+	case 115200:
+		cmd[4] = 0x10;
+		break;
+	case 230400:
+		cmd[4] = 0x12;
+		break;
+	case 460800:
+		cmd[4] = 0x13;
+		break;
+	case 921600:
+		cmd[4] = 0x14;
+		break;
+	default:
+		cmd[4] = 0x10;
+		u->speed = 115200;
+		break;
+	}
+
+	/* Send initialization command */
+	if (write(fd, cmd, 5) != 5) {
+		perror("Failed to write init command");
+		return -1;
+	}
+
+	nanosleep(&tm, NULL);
+	return 0;
+}
+
+#if 0
+static int stlc2500(int fd, struct uart_t *u, struct termios *ti)
+{
+	bdaddr_t bdaddr;
+	unsigned char resp[10];
+	int n;
+	int rvalue;
+
+	/* STLC2500 has an ericsson core */
+	rvalue = ericsson(fd, u, ti);
+	if (rvalue != 0)
+		return rvalue;
+
+#ifdef STLC2500_DEBUG
+	fprintf(stderr, "Setting speed\n");
+#endif
+	if (set_speed(fd, ti, u->speed) < 0) {
+		perror("Can't set baud rate");
+		return -1;
+	}
+
+#ifdef STLC2500_DEBUG
+	fprintf(stderr, "Speed set...\n");
+#endif
+
+	/* Read reply */
+	if ((n = read_hci_event(fd, resp, 10)) < 0) {
+		fprintf(stderr, "Failed to set baud rate on chip\n");
+		return -1;
+	}
+
+#ifdef STLC2500_DEBUG
+	for (i = 0; i < n; i++) {
+		fprintf(stderr, "resp[%d] = %02x\n", i, resp[i]);
+	}
+#endif
+
+	str2ba(u->bdaddr, &bdaddr);
+	return stlc2500_init(fd, &bdaddr);
+}
+
+static int bgb2xx(int fd, struct uart_t *u, struct termios *ti)
+{
+	bdaddr_t bdaddr;
+
+	str2ba(u->bdaddr, &bdaddr);
+
+	return bgb2xx_init(fd, &bdaddr);
+}
+
+/*
+ * Broadcom specific initialization
+ * Extracted from Jungo openrg
+ */
+static int bcm2035(int fd, struct uart_t *u, struct termios *ti)
+{
+	int n;
+	unsigned char cmd[30], resp[30];
+
+	/* Reset the BT Chip */
+	memset(cmd, 0, sizeof(cmd));
+	memset(resp, 0, sizeof(resp));
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x03;
+	cmd[2] = 0x0c;
+	cmd[3] = 0x00;
+
+	/* Send command */
+	if (write(fd, cmd, 4) != 4) {
+		fprintf(stderr, "Failed to write reset command\n");
+		return -1;
+	}
+
+	/* Read reply */
+	if ((n = read_hci_event(fd, resp, 4)) < 0) {
+		fprintf(stderr, "Failed to reset chip\n");
+		return -1;
+	}
+
+	if (u->bdaddr != NULL) {
+		/* Set BD_ADDR */
+		memset(cmd, 0, sizeof(cmd));
+		memset(resp, 0, sizeof(resp));
+		cmd[0] = HCI_COMMAND_PKT;
+		cmd[1] = 0x01;
+		cmd[2] = 0xfc;
+		cmd[3] = 0x06;
+		str2ba(u->bdaddr, (bdaddr_t *) (cmd + 4));
+
+		/* Send command */
+		if (write(fd, cmd, 10) != 10) {
+			fprintf(stderr, "Failed to write BD_ADDR command\n");
+			return -1;
+		}
+
+		/* Read reply */
+		if ((n = read_hci_event(fd, resp, 10)) < 0) {
+			fprintf(stderr, "Failed to set BD_ADDR\n");
+			return -1;
+		}
+	}
+
+	/* Read the local version info */
+	memset(cmd, 0, sizeof(cmd));
+	memset(resp, 0, sizeof(resp));
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x01;
+	cmd[2] = 0x10;
+	cmd[3] = 0x00;
+
+	/* Send command */
+	if (write(fd, cmd, 4) != 4) {
+		fprintf(stderr, "Failed to write \"read local version\" "
+			"command\n");
+		return -1;
+	}
+
+	/* Read reply */
+	if ((n = read_hci_event(fd, resp, 4)) < 0) {
+		fprintf(stderr, "Failed to read local version\n");
+		return -1;
+	}
+
+	/* Read the local supported commands info */
+	memset(cmd, 0, sizeof(cmd));
+	memset(resp, 0, sizeof(resp));
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x02;
+	cmd[2] = 0x10;
+	cmd[3] = 0x00;
+
+	/* Send command */
+	if (write(fd, cmd, 4) != 4) {
+		fprintf(stderr, "Failed to write \"read local supported "
+						"commands\" command\n");
+		return -1;
+	}
+
+	/* Read reply */
+	if ((n = read_hci_event(fd, resp, 4)) < 0) {
+		fprintf(stderr, "Failed to read local supported commands\n");
+		return -1;
+	}
+
+	/* Set the baud rate */
+	memset(cmd, 0, sizeof(cmd));
+	memset(resp, 0, sizeof(resp));
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x18;
+	cmd[2] = 0xfc;
+	cmd[3] = 0x02;
+	switch (u->speed) {
+	case 57600:
+		cmd[4] = 0x00;
+		cmd[5] = 0xe6;
+		break;
+	case 230400:
+		cmd[4] = 0x22;
+		cmd[5] = 0xfa;
+		break;
+	case 460800:
+		cmd[4] = 0x22;
+		cmd[5] = 0xfd;
+		break;
+	case 921600:
+		cmd[4] = 0x55;
+		cmd[5] = 0xff;
+		break;
+	default:
+		/* Default is 115200 */
+		cmd[4] = 0x00;
+		cmd[5] = 0xf3;
+		break;
+	}
+	fprintf(stderr, "Baud rate parameters: DHBR=0x%2x,DLBR=0x%2x\n",
+		cmd[4], cmd[5]);
+
+	/* Send command */
+	if (write(fd, cmd, 6) != 6) {
+		fprintf(stderr, "Failed to write \"set baud rate\" command\n");
+		return -1;
+	}
+
+	if ((n = read_hci_event(fd, resp, 6)) < 0) {
+		fprintf(stderr, "Failed to set baud rate\n");
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+struct uart_t uart[] = {
+	{ "any",        0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+	{ "ericsson",   0x0000, 0x0000, HCI_UART_H4,   57600,  115200, FLOW_CTL, NULL, ericsson },
+	{ "digi",       0x0000, 0x0000, HCI_UART_H4,   9600,   115200, FLOW_CTL, NULL, digi     },
+
+	{ "bcsp",       0x0000, 0x0000, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+
+	/* Xircom PCMCIA cards: Credit Card Adapter and Real Port Adapter */
+	{ "xircom",     0x0105, 0x080a, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+
+	/* CSR Casira serial adapter or BrainBoxes serial dongle (BL642) */
+	{ "csr",        0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, csr      },
+
+	/* BrainBoxes PCMCIA card (BL620) */
+	{ "bboxes",     0x0160, 0x0002, HCI_UART_H4,   115200, 460800, FLOW_CTL, NULL, csr      },
+
+	/* Silicon Wave kits */
+	{ "swave",      0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, swave    },
+
+	/* Texas Instruments Bluelink (BRF) modules */
+	//{ "texas",      0x0000, 0x0000, HCI_UART_LL,   115200, 115200, FLOW_CTL, NULL, texas,    texas2 },
+	//{ "texasalt",   0x0000, 0x0000, HCI_UART_LL,   115200, 115200, FLOW_CTL, NULL, texasalt, NULL   },
+
+	/* ST Microelectronics minikits based on STLC2410/STLC2415 */
+	{ "st",         0x0000, 0x0000, HCI_UART_H4,    57600, 115200, FLOW_CTL, NULL, st       },
+
+	/* ST Microelectronics minikits based on STLC2500 */
+	//{ "stlc2500",   0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, "00:80:E1:00:AB:BA", stlc2500 },
+
+	/* Philips generic Ericsson IP core based */
+	{ "philips",    0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+
+	/* Philips BGB2xx Module */
+	//{ "bgb2xx",    0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, "BD:B2:10:00:AB:BA", bgb2xx },
+
+	/* Sphinx Electronics PICO Card */
+	{ "picocard",   0x025e, 0x1000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+
+	/* Inventel BlueBird Module */
+	{ "inventel",   0x0000, 0x0000, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, NULL     },
+
+	/* COM One Platinium Bluetooth PC Card */
+	{ "comone",     0xffff, 0x0101, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+
+	/* TDK Bluetooth PC Card and IBM Bluetooth PC Card II */
+	{ "tdk",        0x0105, 0x4254, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+
+	/* Socket Bluetooth CF Card (Rev G) */
+	{ "socket",     0x0104, 0x0096, HCI_UART_BCSP, 230400, 230400, 0,        NULL, bcsp     },
+
+	/* 3Com Bluetooth Card (Version 3.0) */
+	{ "3com",       0x0101, 0x0041, HCI_UART_H4,   115200, 115200, FLOW_CTL, NULL, csr      },
+
+	/* AmbiCom BT2000C Bluetooth PC/CF Card */
+	{ "bt2000c",    0x022d, 0x2000, HCI_UART_H4,    57600, 460800, FLOW_CTL, NULL, csr      },
+
+	/* Zoom Bluetooth PCMCIA Card */
+	{ "zoom",       0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+
+	/* Sitecom CN-504 PCMCIA Card */
+	{ "sitecom",    0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+
+	/* Billionton PCBTC1 PCMCIA Card */
+	{ "billionton", 0x0279, 0x950b, HCI_UART_BCSP, 115200, 115200, 0,        NULL, bcsp     },
+
+	/* Broadcom BCM2035 */
+	//{ "bcm2035",    0x0A5C, 0x2035, HCI_UART_H4,   115200, 460800, FLOW_CTL, NULL, bcm2035  },
+
+	/* ATHEROS AR300x */
+	{ "ar3kalt",	 0x0000, 0x0000, HCI_UART_ATH,
+	   115200, 115200, FLOW_CTL, NULL, ar3kinit, ar3kpost  },
+
+	{ "ar3k",    0x0000, 0x0000, HCI_UART_ATH,
+	   115200, 115200, FLOW_CTL, NULL, ar3kinit, ar3kpmpost  },
+
+
+	{ NULL, 0 }
+};
+
+static struct uart_t * get_by_id(int m_id, int p_id)
+{
+	int i;
+	for (i = 0; uart[i].type; i++) {
+		if (uart[i].m_id == m_id && uart[i].p_id == p_id)
+			return &uart[i];
+	}
+	return NULL;
+}
+
+static struct uart_t * get_by_type(char *type)
+{
+	int i;
+	for (i = 0; uart[i].type; i++) {
+		if (!strcmp(uart[i].type, type))
+			return &uart[i];
+	}
+	return NULL;
+}
+
+/* Initialize UART driver */
+static int init_uart(char *dev, struct uart_t *u, int send_break)
+{
+	struct termios ti;
+	int fd, i;
+
+	fd = open(dev, O_RDWR | O_NOCTTY);
+	if (fd < 0) {
+		perror("Can't open serial port");
+		return -1;
+	}
+	ATH_INFO("Serial port is opened");
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (tcgetattr(fd, &ti) < 0) {
+		perror("Can't get port settings");
+		return -1;
+	}
+	ATH_INFO("Port settings is gotten");
+
+	cfmakeraw(&ti);
+
+	ti.c_cflag |= CLOCAL;
+	if (u->flags & FLOW_CTL)
+		ti.c_cflag |= CRTSCTS;
+	else
+		ti.c_cflag &= ~CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, &ti) < 0) {
+		perror("Can't set port settings");
+		return -1;
+	}
+	ATH_INFO("Port settings is set");
+
+	/* Set initial baudrate */
+	if (set_speed(fd, &ti, u->init_speed) < 0) {
+		perror("Can't set initial baud rate");
+		return -1;
+	}
+	ATH_INFO("Initial baud rate is set");
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (send_break) {
+		tcsendbreak(fd, 0);
+		usleep(500000);
+	}
+	ATH_INFO("Break is sent");
+
+	if (u->init && u->init(fd, u, &ti) < 0)
+		return -1;
+	ATH_INFO("u->init is loaded");
+
+	tcflush(fd, TCIOFLUSH);
+
+	/* Set actual baudrate */
+	if (set_speed(fd, &ti, u->speed) < 0) {
+		perror("Can't set baud rate");
+		return -1;
+	}
+	ATH_INFO("Actual baud rate is set");
+
+	/* Set TTY to N_HCI line discipline */
+	i = N_HCI;
+	if (ioctl(fd, TIOCSETD, &i) < 0) {
+		perror("Can't set line discipline");
+		return -1;
+	}
+	ATH_INFO("Line discipline is set");
+
+	if (ioctl(fd, HCIUARTSETPROTO, u->proto) < 0) {
+		perror("Can't set device");
+		return -1;
+	}
+	ATH_INFO("Ioctl device is set");
+
+	if (u->post && u->post(fd, u, &ti) < 0)
+		return -1;
+	ATH_INFO("u->post is loaded");
+
+	return fd;
+}
+
+static void usage(void)
+{
+	printf("hciattach - HCI UART driver initialization utility\n");
+	printf("Usage:\n");
+	printf("\thciattach [-n] [-p] [-b] [-t timeout] [-s initial_speed] <tty> <type | id> [speed] [flow|noflow] [bdaddr]\n");
+	printf("\thciattach -l\n");
+}
+
+int main(int argc, char *argv[])
+{
+	struct uart_t *u = NULL;
+	int detach, printpid, opt, i, n, ld, err;
+	int to = 10;
+	int init_speed = 0;
+	int send_break = 0;
+	pid_t pid;
+	struct sigaction sa;
+	struct pollfd p;
+	sigset_t sigs;
+	char dev[PATH_MAX];
+
+	detach = 1;
+	printpid = 0;
+
+	while ((opt=getopt(argc, argv, "bnpt:s:l")) != EOF) {
+		switch(opt) {
+		case 'b':
+			send_break = 1;
+			break;
+
+		case 'n':
+			detach = 0;
+			break;
+
+		case 'p':
+			printpid = 1;
+			break;
+
+		case 't':
+			to = atoi(optarg);
+			break;
+
+		case 's':
+			init_speed = atoi(optarg);
+			break;
+
+		case 'l':
+			for (i = 0; uart[i].type; i++) {
+				printf("%-10s0x%04x,0x%04x\n", uart[i].type,
+							uart[i].m_id, uart[i].p_id);
+			}
+			exit(0);
+
+		default:
+			usage();
+			exit(1);
+		}
+	}
+
+	n = argc - optind;
+	if (n < 2) {
+		usage();
+		exit(1);
+	}
+
+	for (n = 0; optind < argc; n++, optind++) {
+		char *opt;
+
+		opt = argv[optind];
+
+		switch(n) {
+		case 0:
+			dev[0] = 0;
+			if (!strchr(opt, '/'))
+				strcpy(dev, "/dev/");
+			strcat(dev, opt);
+			break;
+
+		case 1:
+			if (strchr(argv[optind], ',')) {
+				int m_id, p_id;
+				sscanf(argv[optind], "%x,%x", &m_id, &p_id);
+				u = get_by_id(m_id, p_id);
+			} else {
+				u = get_by_type(opt);
+			}
+
+			if (!u) {
+				fprintf(stderr, "Unknown device type or id\n");
+				exit(1);
+			}
+
+			break;
+
+		case 2:
+			u->speed = atoi(argv[optind]);
+			break;
+
+		case 3:
+			if (!strcmp("flow", argv[optind]))
+				u->flags |=  FLOW_CTL;
+			else
+				u->flags &= ~FLOW_CTL;
+			break;
+
+		case 4:
+			u->bdaddr = argv[optind];
+			break;
+		}
+	}
+
+	if (!u) {
+		fprintf(stderr, "Unknown device type or id\n");
+		exit(1);
+	}
+
+	/* If user specified a initial speed, use that instead of
+	   the hardware's default */
+	if (init_speed)
+		u->init_speed = init_speed;
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_flags   = SA_NOCLDSTOP;
+	sa.sa_handler = sig_alarm;
+	sigaction(SIGALRM, &sa, NULL);
+
+	/* 10 seconds should be enough for initialization */
+	alarm(to);
+	bcsp_max_retries = to;
+
+	n = init_uart(dev, u, send_break);
+	if (n < 0) {
+		perror("Can't initialize device");
+		exit(1);
+	}
+
+	printf("Device setup complete\n");
+
+	alarm(0);
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_flags   = SA_NOCLDSTOP;
+	sa.sa_handler = SIG_IGN;
+	sigaction(SIGCHLD, &sa, NULL);
+	sigaction(SIGPIPE, &sa, NULL);
+
+	sa.sa_handler = sig_term;
+	sigaction(SIGTERM, &sa, NULL);
+	sigaction(SIGINT,  &sa, NULL);
+
+	sa.sa_handler = sig_hup;
+	sigaction(SIGHUP, &sa, NULL);
+
+	if (detach) {
+		if ((pid = fork())) {
+			if (printpid)
+				printf("%d\n", pid);
+			return 0;
+		}
+
+		for (i = 0; i < 20; i++)
+			if (i != n)
+				close(i);
+	}
+
+	p.fd = n;
+	p.events = POLLERR | POLLHUP;
+
+	sigfillset(&sigs);
+	sigdelset(&sigs, SIGCHLD);
+	sigdelset(&sigs, SIGPIPE);
+	sigdelset(&sigs, SIGTERM);
+	sigdelset(&sigs, SIGINT);
+	sigdelset(&sigs, SIGHUP);
+
+	while (!__io_canceled) {
+		p.revents = 0;
+		err = ppoll(&p, 1, NULL, &sigs);
+		if (err < 0 && errno == EINTR)
+			continue;
+		if (err)
+			break;
+	}
+
+	/* Restore TTY line discipline */
+	ld = N_TTY;
+	if (ioctl(n, TIOCSETD, &ld) < 0) {
+		perror("Can't restore line discipline");
+		exit(1);
+	}
+
+	return 0;
+}
diff --git a/test/ar3k_bt/hciattach.h b/test/ar3k_bt/hciattach.h
new file mode 100755
index 0000000..8cfa541
--- /dev/null
+++ b/test/ar3k_bt/hciattach.h
@@ -0,0 +1,52 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2003-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <termios.h>
+
+#define ATH_DBG(fmt, arg...)  fprintf(stderr, "[ATH_DBG] (%s) <%s>: " fmt "\n" , __FILE__ , __func__ , ## arg)
+#define ATH_INFO(fmt, arg...)  fprintf(stderr, "[ATH_INFO] (%s) <%s>: " fmt "\n" , __FILE__ , __func__ , ## arg)
+
+#ifndef N_HCI
+#define N_HCI	15
+#endif
+
+#define HCIUARTSETPROTO		_IOW('U', 200, int)
+#define HCIUARTGETPROTO		_IOR('U', 201, int)
+#define HCIUARTGETDEVICE	_IOR('U', 202, int)
+
+#define HCI_UART_H4	0
+#define HCI_UART_BCSP	1
+#define HCI_UART_3WIRE	2
+#define HCI_UART_H4DS	3
+#define HCI_UART_LL	4
+#define HCI_UART_ATH    5
+
+int read_hci_event(int fd, unsigned char* buf, int size);
+int set_speed(int fd, struct termios *ti, int speed);
+
+//int texas_init(int fd, struct termios *ti);
+//int texas_post(int fd, struct termios *ti);
+//int texasalt_init(int fd, int speed, struct termios *ti);
+//int stlc2500_init(int fd, bdaddr_t *bdaddr);
+//int bgb2xx_init(int dd, bdaddr_t *bdaddr);
+int ath_ps_download(int fd);
diff --git a/test/ar3k_bt/hciattach_ar3k.c b/test/ar3k_bt/hciattach_ar3k.c
new file mode 100755
index 0000000..ba5bc97
--- /dev/null
+++ b/test/ar3k_bt/hciattach_ar3k.c
@@ -0,0 +1,1209 @@
+/*
+ * Copyright (c) 2009-2010 Atheros Communications Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+
+#include <bluetooth/bluetooth.h>
+
+#include "hciattach.h"
+
+#define FALSE				0
+#define TRUE				1
+
+/* The maximum number of bytes possible in a patch entry */
+#define MAX_PATCH_SIZE			20000
+
+/* Maximum HCI packets that will be formed from the Patch file */
+#define MAX_NUM_PATCH_ENTRY		((MAX_PATCH_SIZE/MAX_BYTE_LENGTH) + 1)
+
+#define DEV_REGISTER			0x4FFC
+
+#ifdef ANDROID_OS
+#define FW_PATH                         "/system/lib/firmware/ar3k"
+#else
+#define FW_PATH				"/lib/firmware/ar3k/"
+#endif
+
+#define PS_ASIC_FILE			"PS_ASIC.pst"
+#define PS_FPGA_FILE			"PS_FPGA.pst"
+#define PATCH_FILE			"RamPatch.txt"
+#define BDADDR_FILE			"ar3kbdaddr.pst"
+
+#define HCI_CMD_HEADER_LEN		7
+
+/* PS command types */
+#define PS_RESET			2
+#define PS_WRITE			1
+#define WRITE_PATCH			8
+#define PS_VERIFY_CRC			9
+#define ENABLE_PATCH			11
+
+/* PS configuration entry time */
+#define PS_TYPE_HEX			0
+#define PS_TYPE_DEC			1
+
+#define PS_RESET_PARAM_LEN		6
+#define PS_RESET_CMD_LEN		(PS_RESET_PARAM_LEN +\
+					 HCI_CMD_HEADER_LEN)
+
+#define NUM_WAKEUP_RETRY		10
+
+
+#define RAM_PS_REGION			(1<<0)
+#define RAM_PATCH_REGION		(1<<1)
+
+#define RAMPS_MAX_PS_TAGS_PER_FILE	50
+#define PS_MAX_LEN			500
+#define LINE_SIZE_MAX			(PS_MAX_LEN * 2)
+
+#define BYTES_OF_PS_DATA_PER_LINE	16
+#define MAX_BYTE_LENGTH                 244
+
+#define skip_space(str)	while (*(str) == (' ')) ((str)++)
+
+#define IS_BETWEEN(x, lower, upper)	(((lower) <= (x)) && ((x) <= (upper)))
+
+#define tohexval(c)	(isdigit(c) ? ((c) - '0') :	\
+			(IS_BETWEEN((c), 'A', 'Z') ?	\
+			((c) - 'A' + 10) : ((c) - 'a' + 10)))
+
+#define stringtohex(str)	(((uint8_t)(tohexval((str)[0]) << 4)) |\
+				((uint8_t)tohexval((str)[1])))
+
+#define set_pst_format(pst, type, array_val)	((pst)->data_type = (type),\
+						(pst)->is_array = (array_val))
+
+struct ps_tag_entry {
+	uint32_t		tag_id;
+	uint32_t		tag_len;
+	uint8_t			*tag_data;
+};
+
+struct ps_ram_patch {
+	int16_t			Len;
+	uint8_t			*Data;
+};
+struct ps_data_format {
+	unsigned char		data_type;
+	unsigned char		is_array;
+};
+
+struct ps_cmd_packet {
+	uint8_t			*Hcipacket;
+	int			packetLen;
+};
+
+struct st_read_status {
+	unsigned		section;
+	unsigned		line_count;
+	unsigned		char_cnt;
+	unsigned		byte_count;
+};
+
+struct ps_tag_entry		ps_tag_entry[RAMPS_MAX_PS_TAGS_PER_FILE];
+struct ps_ram_patch		ram_patch[MAX_NUM_PATCH_ENTRY];
+
+static void load_hci_header(uint8_t *hci_ps_cmd,
+			    uint8_t opcode,
+			    int length,
+			    int index)
+{
+	hci_ps_cmd[0] = 0x0B;
+	hci_ps_cmd[1] = 0xFC;
+	hci_ps_cmd[2] = length + 4;
+	hci_ps_cmd[3] = opcode;
+	hci_ps_cmd[4] = (index & 0xFF);
+	hci_ps_cmd[5] = ((index >> 8) & 0xFF);
+	hci_ps_cmd[6] = length;
+}
+
+static int ath_create_ps_command(uint8_t opcode,
+				 uint32_t param_1,
+				 struct ps_cmd_packet *ps_patch_packet,
+				 uint32_t *index)
+{
+	uint8_t *hci_ps_cmd;
+	int i;
+
+	switch (opcode) {
+	case WRITE_PATCH:
+
+		ATH_INFO("WRITE_PATCH");
+
+		for (i = 0; i < param_1; i++) {
+
+			/* Allocate command buffer */
+			hci_ps_cmd = (uint8_t *) malloc(ram_patch[i].Len +
+							HCI_CMD_HEADER_LEN);
+
+			if (!hci_ps_cmd)
+				return -ENOMEM;
+
+			/* Update commands to buffer */
+			load_hci_header(hci_ps_cmd,
+					opcode,
+					ram_patch[i].Len,
+					i);
+			memcpy(&hci_ps_cmd[HCI_CMD_HEADER_LEN],
+			       ram_patch[i].Data,
+			       ram_patch[i].Len);
+
+			ps_patch_packet[*index].Hcipacket = hci_ps_cmd;
+			ps_patch_packet[*index].packetLen = ram_patch[i].Len +
+							    HCI_CMD_HEADER_LEN;
+
+			(*index)++;
+		}
+		break;
+
+	case ENABLE_PATCH:
+
+		ATH_INFO("ENABLE_PATCH");
+
+		hci_ps_cmd = (uint8_t *) malloc(HCI_CMD_HEADER_LEN);
+
+		if (!hci_ps_cmd)
+			return -ENOMEM;
+
+		load_hci_header(hci_ps_cmd, opcode, 0, 0x00);
+		ps_patch_packet[*index].Hcipacket = hci_ps_cmd;
+		ps_patch_packet[*index].packetLen = HCI_CMD_HEADER_LEN;
+
+		(*index)++;
+
+		break;
+
+	case PS_RESET:
+
+		ATH_INFO("PS_RESET");
+
+		hci_ps_cmd = (uint8_t *) malloc(PS_RESET_CMD_LEN);
+
+		if (!hci_ps_cmd)
+			return -ENOMEM;
+
+		load_hci_header(hci_ps_cmd, opcode, PS_RESET_PARAM_LEN, 0x00);
+		hci_ps_cmd[7] = 0x00;
+		hci_ps_cmd[PS_RESET_CMD_LEN - 2] = (param_1 & 0xFF);
+		hci_ps_cmd[PS_RESET_CMD_LEN - 1] = ((param_1 >> 8) & 0xFF);
+
+		ps_patch_packet[*index].Hcipacket = hci_ps_cmd;
+		ps_patch_packet[*index].packetLen = PS_RESET_CMD_LEN;
+
+		(*index)++;
+
+		break;
+
+	case PS_WRITE:
+
+		ATH_INFO("PS_WRITE");
+
+		for (i = 0; i < param_1; i++) {
+			hci_ps_cmd =
+			    (uint8_t *) malloc(ps_tag_entry[i].tag_len +
+					       HCI_CMD_HEADER_LEN);
+			if (!hci_ps_cmd)
+				return -ENOMEM;
+
+			load_hci_header(hci_ps_cmd,
+					opcode,
+					ps_tag_entry[i].tag_len,
+					ps_tag_entry[i].tag_id);
+
+			memcpy(&hci_ps_cmd[HCI_CMD_HEADER_LEN],
+			       ps_tag_entry[i].tag_data,
+			       ps_tag_entry[i].tag_len);
+
+			ps_patch_packet[*index].Hcipacket = hci_ps_cmd;
+
+			ps_patch_packet[*index].packetLen =
+			ps_tag_entry[i].tag_len + HCI_CMD_HEADER_LEN;
+
+			(*index)++;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int get_ps_type(char *line,
+		       int eol_index,
+		       unsigned char *type,
+		       unsigned char *sub_type)
+{
+
+	switch (eol_index) {
+	case 1:
+		return 0;
+	break;
+
+	case 2:
+		(*type) = toupper(line[1]);
+	break;
+
+	case 3:
+		if (line[2] == ':')
+			(*type) = toupper(line[1]);
+		else if (line[1] == ':')
+			(*sub_type) = toupper(line[2]);
+		else
+			return -1;
+
+	break;
+
+	case 4:
+		if (line[2] != ':')
+			return -1;
+		(*type) = toupper(line[1]);
+		(*sub_type) = toupper(line[3]);
+	break;
+
+	case -1:
+		return -1;
+	break;
+	}
+	return 0;
+}
+
+static int get_input_data_format(char *line, struct ps_data_format *pst_format)
+{
+	unsigned char type, sub_type;
+	int eol_index, sep_index;
+	int i;
+
+	type = '\0';
+	sub_type = '\0';
+	eol_index = -1;
+	sep_index = -1;
+
+	/* The default values */
+	set_pst_format(pst_format, PS_TYPE_HEX, TRUE);
+
+	if (line[0] != '[') {
+
+		set_pst_format(pst_format, PS_TYPE_HEX, TRUE);
+		return 0;
+	}
+
+	for (i = 1; i < 5; i++) {
+		if (line[i] == ']') {
+			eol_index = i;
+			break;
+		}
+	}
+
+	if (get_ps_type(line, eol_index, &type, &sub_type) < 0)
+		return -1;
+
+	/* By default Hex array type is assumed */
+	if (type == '\0' && sub_type == '\0')
+		set_pst_format(pst_format, PS_TYPE_HEX, TRUE);
+
+	/* Check is data type is of array */
+	if (type == 'A' || sub_type == 'A')
+		pst_format->is_array = TRUE;
+
+	if (type == 'S' || sub_type == 'S')
+		pst_format->is_array = FALSE;
+
+	switch (type) {
+	case 'D':
+	case 'B':
+		pst_format->data_type = PS_TYPE_DEC;
+	break;
+
+	default:
+		pst_format->data_type = PS_TYPE_HEX;
+	break;
+	}
+
+	line += (eol_index + 1);
+
+	return 0;
+
+}
+
+static unsigned int read_data_in_section(char *line,
+					 struct ps_data_format format_info)
+{
+	char *token_ptr = line;
+
+	if (token_ptr[0] == '[') {
+
+		while (token_ptr[0] != ']' && token_ptr[0] != '\0')
+			token_ptr++;
+
+		if (token_ptr[0] == '\0')
+			return 0x0FFF;
+
+		token_ptr++;
+	}
+
+	if (format_info.data_type == PS_TYPE_HEX) {
+
+		if (format_info.is_array == TRUE)
+			return 0x0FFF;
+		else
+			return strtol(token_ptr, NULL, 16);
+	} else
+		return 0x0FFF;
+
+	return 0x0FFF;
+}
+static int ath_parse_file(FILE *stream)
+{
+	char *buffer;
+	char *line;
+	uint8_t tag_cnt;
+	int16_t byte_count;
+	uint32_t pos;
+	int read_count;
+	int num_ps_entry;
+	struct ps_data_format stps_data_format;
+	struct st_read_status read_status = {
+		0, 0, 0, 0
+	};
+
+	pos = 0;
+	buffer = NULL;
+	tag_cnt = 0;
+	byte_count = 0;
+
+	if (!stream) {
+		perror("Could not open config file  .\n");
+		return -1;
+	}
+
+	buffer = malloc(LINE_SIZE_MAX + 1);
+
+	if (!buffer)
+		return -ENOMEM;
+
+	do {
+		line = fgets(buffer, LINE_SIZE_MAX, stream);
+
+		if (!line)
+			break;
+
+		skip_space(line);
+
+		if ((line[0] == '/') && (line[1] == '/'))
+			continue;
+
+		if ((line[0] == '#')) {
+
+			if (read_status.section != 0) {
+				perror("error\n");
+
+				if (buffer != NULL)
+					free(buffer);
+
+				return -1;
+
+			} else {
+				read_status.section = 1;
+				continue;
+			}
+		}
+
+		if ((line[0] == '/') && (line[1] == '*')) {
+
+			read_status.section = 0;
+
+			continue;
+		}
+
+		if (read_status.section == 1) {
+			skip_space(line);
+
+			if (get_input_data_format(
+			    line, &stps_data_format) < 0) {
+
+				if (buffer != NULL)
+					free(buffer);
+				return -1;
+			}
+			ps_tag_entry[tag_cnt].tag_id =
+			    read_data_in_section(line, stps_data_format);
+			read_status.section = 2;
+
+		} else if (read_status.section == 2) {
+
+			if (get_input_data_format(
+			    line, &stps_data_format) < 0) {
+
+				if (buffer != NULL)
+					free(buffer);
+				return -1;
+			}
+
+			byte_count =
+			    read_data_in_section(line, stps_data_format);
+
+			read_status.section = 2;
+			if (byte_count > LINE_SIZE_MAX / 2) {
+				if (buffer != NULL)
+					free(buffer);
+
+				return -1;
+			}
+
+			ps_tag_entry[tag_cnt].tag_len = byte_count;
+			ps_tag_entry[tag_cnt].tag_data = (uint8_t *)
+							 malloc(byte_count);
+
+			read_status.section = 3;
+			read_status.line_count = 0;
+
+		} else if (read_status.section == 3) {
+
+			if (read_status.line_count == 0) {
+				if (get_input_data_format(
+				    line, &stps_data_format) < 0) {
+					if (buffer != NULL)
+						free(buffer);
+					return -1;
+				}
+			}
+
+			skip_space(line);
+			read_status.char_cnt = 0;
+
+			if (line[read_status.char_cnt] == '[') {
+
+				while (line[read_status.char_cnt] != ']' &&
+				       line[read_status.char_cnt] != '\0')
+					read_status.char_cnt++;
+
+				if (line[read_status.char_cnt] == ']')
+					read_status.char_cnt++;
+				else
+					read_status.char_cnt = 0;
+
+			}
+
+			read_count = (byte_count > BYTES_OF_PS_DATA_PER_LINE)
+			    ? BYTES_OF_PS_DATA_PER_LINE : byte_count;
+
+			if (stps_data_format.data_type == PS_TYPE_HEX &&
+			    stps_data_format.is_array == TRUE) {
+
+				while (read_count > 0) {
+
+					ps_tag_entry[tag_cnt].tag_data
+					[read_status.byte_count] =
+					stringtohex(
+					&line[read_status.char_cnt]);
+
+					ps_tag_entry[tag_cnt].tag_data
+					[read_status.byte_count + 1] =
+					stringtohex(
+					&line[read_status.char_cnt + 3]);
+
+					read_status.char_cnt += 6;
+					read_status.byte_count += 2;
+					read_count -= 2;
+
+				}
+
+				if (byte_count > BYTES_OF_PS_DATA_PER_LINE)
+					byte_count -=
+						BYTES_OF_PS_DATA_PER_LINE;
+				else
+					byte_count = 0;
+			}
+
+			read_status.line_count++;
+
+			if (byte_count == 0) {
+				read_status.section = 0;
+				read_status.char_cnt = 0;
+				read_status.line_count = 0;
+				read_status.byte_count = 0;
+			} else
+				read_status.char_cnt = 0;
+
+			if ((read_status.section == 0) &&
+			    (++tag_cnt == RAMPS_MAX_PS_TAGS_PER_FILE)) {
+				if (buffer != NULL)
+					free(buffer);
+				return -1;
+			}
+
+		}
+
+	} while (line);
+
+	num_ps_entry = tag_cnt;
+
+	if (tag_cnt > RAMPS_MAX_PS_TAGS_PER_FILE) {
+		if (buffer != NULL)
+			free(buffer);
+		return -1;
+	}
+
+	if (buffer != NULL)
+		free(buffer);
+
+	return num_ps_entry;
+}
+
+static int parse_patch_file(FILE *stream)
+{
+	char byte[3];
+	char line[MAX_BYTE_LENGTH + 1];
+	int byte_cnt, byte_cnt_org;
+	int patch_index = 0;
+	int i, k;
+	int data;
+	int patch_count = 0;
+
+	byte[2] = '\0';
+
+	while (fgets(line, MAX_BYTE_LENGTH, stream)) {
+		if (strlen(line) <= 1 || !isxdigit(line[0]))
+			continue;
+		else
+			break;
+	}
+
+
+	byte_cnt = strtol(line, NULL, 16);
+	byte_cnt_org = byte_cnt;
+
+	while (byte_cnt > MAX_BYTE_LENGTH) {
+
+		/* Handle case when the number of patch buffer is
+		 * more than the 20K */
+		if (MAX_NUM_PATCH_ENTRY == patch_count) {
+			for (i = 0; i < patch_count; i++)
+				free(ram_patch[i].Data);
+			return -ENOMEM;
+		}
+		ram_patch[patch_count].Len = MAX_BYTE_LENGTH;
+		ram_patch[patch_count].Data =
+		    (uint8_t *) malloc(MAX_BYTE_LENGTH);
+
+		if (!ram_patch[patch_count].Data)
+			return -ENOMEM;
+
+		patch_count++;
+		byte_cnt = byte_cnt - MAX_BYTE_LENGTH;
+	}
+
+	ram_patch[patch_count].Len = (byte_cnt & 0xFF);
+
+	if (byte_cnt != 0) {
+		ram_patch[patch_count].Data = (uint8_t *) malloc(byte_cnt);
+
+		if (!ram_patch[patch_count].Data)
+			return -ENOMEM;
+		patch_count++;
+	}
+
+	while (byte_cnt_org > MAX_BYTE_LENGTH) {
+
+		k = 0;
+		for (i = 0; i < MAX_BYTE_LENGTH * 2; i += 2) {
+			if (!fgets(byte, 3, stream))
+				return -1;
+			data = strtoul(&byte[0], NULL, 16);
+			ram_patch[patch_index].Data[k] = (data & 0xFF);
+
+			k++;
+		}
+
+		patch_index++;
+
+		byte_cnt_org = byte_cnt_org - MAX_BYTE_LENGTH;
+	}
+
+	if (patch_index == 0)
+		patch_index++;
+
+	for (k = 0; k < byte_cnt_org; k++) {
+
+		if (!fgets(byte, 3, stream))
+			return -1;
+
+		data = strtoul(byte, NULL, 16);
+		ram_patch[patch_index].Data[k] = (data & 0xFF);
+	}
+
+	return patch_count;
+}
+
+static int ath_parse_ps(FILE *stream, int *total_tag_len)
+{
+	int num_ps_tags;
+	int i;
+	unsigned char bdaddr_present = 0;
+
+
+	if (NULL != stream)
+		num_ps_tags = ath_parse_file(stream);
+
+	if (num_ps_tags < 0)
+		return -1;
+
+	if (num_ps_tags == 0)
+		*total_tag_len = 10;
+	else {
+
+		for (i = 0; i < num_ps_tags; i++) {
+
+			if (ps_tag_entry[i].tag_id == 1)
+				bdaddr_present = 1;
+			if (ps_tag_entry[i].tag_len % 2 == 1)
+				*total_tag_len = *total_tag_len
+					+ ps_tag_entry[i].tag_len + 1;
+			else
+				*total_tag_len =
+				*total_tag_len + ps_tag_entry[i].tag_len;
+
+		}
+	}
+	if (num_ps_tags > 0 && !bdaddr_present)
+		*total_tag_len = *total_tag_len + 10;
+
+	*total_tag_len = *total_tag_len + 10 + (num_ps_tags * 4);
+
+	return num_ps_tags;
+}
+
+static int ath_create_cmd_list(struct ps_cmd_packet **hci_packet_list,
+			       uint32_t *num_packets,
+			       int tag_count,
+			       int patch_count,
+			       int total_tag_len)
+{
+	uint8_t count;
+	uint32_t num_cmd_entry = 0;
+
+	*num_packets = 0;
+
+
+	if (patch_count || tag_count) {
+
+		/* PS Reset Packet  + Patch List + PS List */
+		num_cmd_entry += (1 + patch_count + tag_count);
+		if (patch_count > 0)
+			num_cmd_entry++;	/* Patch Enable Command */
+
+		(*hci_packet_list) =
+		    malloc(sizeof(struct ps_cmd_packet) * num_cmd_entry);
+
+		if (!(*hci_packet_list))
+			return	-ENOMEM;
+
+		if (patch_count > 0) {
+
+			if (ath_create_ps_command(WRITE_PATCH, patch_count,
+			    *hci_packet_list, num_packets) < 0)
+				return -1;
+			if (ath_create_ps_command(ENABLE_PATCH, 0,
+			    *hci_packet_list, num_packets) < 0)
+				return -1;
+
+		}
+
+		if (ath_create_ps_command(PS_RESET, total_tag_len,
+		    *hci_packet_list, num_packets) < 0)
+			return -1;
+
+		if (tag_count > 0)
+			ath_create_ps_command(PS_WRITE, tag_count,
+					      *hci_packet_list, num_packets);
+	}
+
+	for (count = 0; count < patch_count; count++)
+		free(ram_patch[patch_count].Data);
+
+	for (count = 0; count < tag_count; count++)
+		free(ps_tag_entry[count].tag_data);
+
+	return *num_packets;
+}
+
+static int ath_free_command_list(struct ps_cmd_packet **hci_packet_list,
+			  uint32_t num_packets)
+{
+	int i;
+
+	if (*hci_packet_list == NULL)
+		return -1;
+
+	for (i = 0; i < num_packets; i++)
+		free((*hci_packet_list)[i].Hcipacket);
+
+	free(*hci_packet_list);
+
+	return 0;
+}
+
+/*
+ *  This API is used to send the HCI command to controller and return
+ *  with a HCI Command Complete event.
+ */
+static int send_hci_cmd_wait_event(int dev,
+			    uint8_t *hci_command,
+			    int cmd_length,
+			    uint8_t **event, uint8_t **buffer_to_free)
+{
+	int r;
+	uint8_t *hci_event;
+	uint8_t pkt_type = 0x01;
+
+	if (cmd_length == 0)
+		return -1;
+
+	if (write(dev, &pkt_type, 1) != 1)
+		return -1;
+
+	if (write(dev, (unsigned char *)hci_command, cmd_length) != cmd_length)
+		return -1;
+
+	hci_event = (uint8_t *) malloc(100);
+
+	if (!hci_event)
+		return -ENOMEM;
+
+	r = read_hci_event(dev, (unsigned char *)hci_event, 100);
+
+	if (r > 0) {
+		*event = hci_event;
+		*buffer_to_free = hci_event;
+	} else {
+
+		/* Did not get an event from controller. return error */
+		free(hci_event);
+		*buffer_to_free = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int read_ps_event(uint8_t *data)
+{
+
+	if (data[5] == 0xFC && data[6] == 0x00) {
+		switch (data[4]) {
+		case 0x0B:/* CRC Check */
+		case 0x0C:/* Change Baudrate */
+		case 0x04:/* Enable sleep */
+			return 0;
+		break;
+		default:
+			return -1;
+		break;
+		}
+	}
+
+	return -1;
+}
+
+static int get_ps_file_name(int devtype, int rom_version, char *path)
+{
+	char *filename;
+	int status = 0;
+
+	if (devtype == 0xdeadc0de) {
+		filename = PS_ASIC_FILE;
+		status = 1;
+	} else {
+		filename = PS_FPGA_FILE;
+		status = 0;
+	}
+
+	sprintf(path, "%s%x/%s", FW_PATH, rom_version, filename);
+
+	return status;
+}
+
+static int get_patch_file_name(int dev_type, int rom_version,
+			       int build_version, char *path)
+{
+
+	if ((dev_type != 0) &&
+	    (dev_type != 0xdeadc0de) &&
+	    (rom_version == 0x99999999) &&
+	    (build_version == 1))
+		path[0] = '\0';
+	 else
+		sprintf(path, "%s%x/%s", FW_PATH, rom_version, PATCH_FILE);
+
+	return 0;
+}
+static int get_ar3k_crc(int dev, int tag_count, int patch_count)
+{
+	uint8_t hci_cmd[7];
+	uint8_t *event;
+	uint8_t *buffer_to_free = NULL;
+	int retval = 1;
+	int crc = 0;
+
+
+	if (patch_count > 0)
+		crc |= RAM_PATCH_REGION;
+	if (tag_count > 0)
+		crc |= RAM_PS_REGION;
+
+	load_hci_header(hci_cmd, PS_VERIFY_CRC, 0, crc);
+
+	if (send_hci_cmd_wait_event(dev, hci_cmd,
+				    sizeof(hci_cmd), &event,
+				    &buffer_to_free) == 0) {
+		if (read_ps_event(event) == 0)
+			retval = -1;
+
+		if (buffer_to_free != NULL)
+			free(buffer_to_free);
+	}
+
+	return retval;
+}
+static int get_device_type(int dev, uint32_t *code)
+{
+	uint8_t hci_cmd[] = {
+		0x05, 0xfc, 0x05, 0x00, 0x00, 0x00, 0x00, 0x04
+	};
+	uint8_t *event;
+	uint8_t *buffer_to_free = NULL;
+	uint32_t reg;
+
+	int result = -1;
+	*code = 0;
+
+	hci_cmd[3] = (uint8_t) (DEV_REGISTER & 0xFF);
+	hci_cmd[4] = (uint8_t) ((DEV_REGISTER >> 8) & 0xFF);
+	hci_cmd[5] = (uint8_t) ((DEV_REGISTER >> 16) & 0xFF);
+	hci_cmd[6] = (uint8_t) ((DEV_REGISTER >> 24) & 0xFF);
+
+	if (send_hci_cmd_wait_event(dev, hci_cmd,
+				    sizeof(hci_cmd), &event,
+				    &buffer_to_free) == 0) {
+		if (event[5] == 0xFC && event[6] == 0x00) {
+
+			switch (event[4]) {
+			case 0x05:
+				reg = event[10];
+				reg = ((reg << 8) | event[9]);
+				reg = ((reg << 8) | event[8]);
+				reg = ((reg << 8) | event[7]);
+				*code = reg;
+				result = 0;
+
+				break;
+
+			case 0x06:
+				break;
+			}
+		}
+	}
+
+	if (buffer_to_free != NULL)
+		free(buffer_to_free);
+
+	return result;
+}
+
+static int read_ar3k_version(int pConfig, int *rom_version, int *build_version)
+{
+	uint8_t hci_cmd[] = {0x1E, 0xfc, 0x00};
+	uint8_t *event;
+	uint8_t *buffer_to_free = NULL;
+	int result = -1;
+
+	if (send_hci_cmd_wait_event(pConfig,
+				    hci_cmd,
+				    sizeof(hci_cmd),
+				    &event,
+				    &buffer_to_free) == 0) {
+		if (event[5] == 0xFC && event[6] == 0x00 && event[4] == 0x1E) {
+			(*rom_version) = event[10];
+			(*rom_version) = (((*rom_version) << 8) | event[9]);
+			(*rom_version) = (((*rom_version) << 8) | event[8]);
+			(*rom_version) = (((*rom_version) << 8) | event[7]);
+
+			(*build_version) = event[14];
+			(*build_version) = (((*build_version) << 8) |
+					   event[13]);
+			(*build_version) = (((*build_version) << 8) |
+					   event[12]);
+			(*build_version) = (((*build_version) << 8) |
+					   event[11]);
+
+			result = 1;
+
+		}
+		if (buffer_to_free != NULL)
+			free(buffer_to_free);
+	}
+
+
+
+	return result;
+}
+
+static int str2bdaddr(char *str_bdaddr, char *bdaddr)
+{
+	char bdbyte[3];
+	char *str_byte = str_bdaddr;
+	int i, j;
+	unsigned char colon_present = 0;
+
+	if (strstr(str_bdaddr, ":") != NULL)
+		colon_present = 1;
+
+	bdbyte[2] = '\0';
+
+	for (i = 0, j = 5; i < 6; i++, j--) {
+
+		bdbyte[0] = str_byte[0];
+		bdbyte[1] = str_byte[1];
+		bdaddr[j] = strtol(bdbyte, NULL, 16);
+
+		if (colon_present == 1)
+			str_byte += 3;
+		else
+			str_byte += 2;
+	}
+	return 0;
+}
+
+static int write_bdaddr(int pConfig, char *bdaddr)
+{
+	uint8_t bdaddr_cmd[] = { 0x0B, 0xFC, 0x0A, 0x01, 0x01,
+		0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	uint8_t *event;
+	uint8_t *buffer_to_free = NULL;
+	int result = -1;
+
+	str2bdaddr(bdaddr, (char *)&bdaddr_cmd[7]);
+
+	if (send_hci_cmd_wait_event(pConfig,
+				    bdaddr_cmd,
+				    sizeof(bdaddr_cmd),
+				    &event,
+				    &buffer_to_free) == 0) {
+
+		if (event[5] == 0xFC && event[6] == 0x00) {
+			if (event[4] == 0x0B)
+				result = 0;
+		}
+
+	} else
+		perror("Write failed\n");
+
+	if (buffer_to_free != NULL)
+		free(buffer_to_free);
+
+	return result;
+}
+
+int ath_ps_download(int hdev)
+{
+	int i;
+	int status = 0;
+	int tag_count = 0;
+	int patch_count = 0;
+	int total_tag_len = 0;
+	int rom_version = 0, build_version = 0;
+
+	struct ps_cmd_packet *hci_cmd_list;	/* List storing the commands */
+	uint32_t num_cmds;
+	uint8_t *event;
+	uint8_t *buffer_to_free;
+	uint32_t dev_type;
+
+	char patch_file_name[PATH_MAX];
+	char ps_file_name[PATH_MAX];
+	char bdaddr_file_name[PATH_MAX];
+
+	FILE *stream;
+	char bdaddr[21];
+
+	hci_cmd_list = NULL;
+
+	ATH_INFO("");
+
+	do {
+		/*
+		 * Verfiy firmware version. depending on it select the PS
+		 * config file to download.
+		 */
+
+		if (get_device_type(hdev, &dev_type) == -1) {
+			status = -1;
+			break;
+		}
+		ATH_INFO("get_device_type");
+
+		if (read_ar3k_version(hdev,
+				      &rom_version,
+				      &build_version) == -1) {
+			status = -1;
+			break;
+		}
+		ATH_INFO("read_ar3k_version");
+
+		ATH_INFO("get_ps_file_name");
+		get_ps_file_name(dev_type, rom_version, ps_file_name);
+
+		ATH_INFO("get_patch_file_name");
+		get_patch_file_name(dev_type, rom_version, build_version,
+				    patch_file_name);
+
+		/* Read the PS file to a dynamically allocated buffer */
+		stream = fopen(ps_file_name, "r");
+		if (stream == NULL) {
+			perror("firmware file open error\n");
+			status = -1;
+			break;
+		}
+		ATH_INFO("fopen(ps_file_name)");
+
+		tag_count = ath_parse_ps(stream, &total_tag_len);
+
+		fclose(stream);
+
+		if (tag_count == -1) {
+			status = -1;
+			break;
+		}
+		ATH_INFO("ath_parse_ps");
+
+		/*
+		 * It is not necessary that Patch file be available,
+		 * continue with PS Operations if.
+		 * failed.
+		 */
+		if (patch_file_name[0] == '\0')
+			status = 0;
+
+		stream = fopen(patch_file_name, "r");
+		if (stream  == NULL)
+			status = 0;
+		else {
+			/* parse and store the Patch file contents to
+			 * a global variables
+			 */
+			ATH_INFO("fopen(patch_file_name)");
+
+			patch_count = parse_patch_file(stream);
+
+			fclose(stream);
+
+			if (patch_count < 0) {
+				status = -1;
+				break;
+			}
+			ATH_INFO("parse_patch_file");
+		}
+
+		/*
+		 * Send the CRC packet,
+		 * Continue with the PS operations
+		 * only if the CRC check failed
+		 */
+		if (get_ar3k_crc(hdev, tag_count, patch_count) < 0) {
+			status = 0;
+			break;
+		}
+		ATH_INFO("get_ar3k_crc");
+
+		/* Create an HCI command list
+		 * from the parsed PS and patch information
+		 */
+		ATH_INFO("ath_create_cmd_list");
+		ath_create_cmd_list(&hci_cmd_list,
+				    &num_cmds,
+				    tag_count,
+				    patch_count,
+				    total_tag_len);
+
+		for (i = 0; i < num_cmds; i++) {
+
+			if (send_hci_cmd_wait_event
+			    (hdev, hci_cmd_list[i].Hcipacket,
+			     hci_cmd_list[i].packetLen, &event,
+			     &buffer_to_free) == 0) {
+
+				if (read_ps_event(event) < 0) {
+
+					/* Exit if the status is not success */
+					if (buffer_to_free != NULL)
+						free(buffer_to_free);
+
+					status = -1;
+					break;
+				}
+				if (buffer_to_free != NULL)
+					free(buffer_to_free);
+			} else {
+				status = 0;
+				break;
+			}
+		}
+
+		/* Read the PS file to a dynamically allocated buffer */
+		sprintf(bdaddr_file_name, "%s%x/%s",
+			FW_PATH,
+			rom_version,
+			BDADDR_FILE);
+
+		stream = fopen(bdaddr_file_name, "r");
+
+		if (stream == NULL) {
+			status = 0;
+			break;
+		}
+		ATH_INFO("fopen(bdaddr_file_name)");
+
+		if (fgets(bdaddr, 20, stream) != NULL)
+			status = write_bdaddr(hdev, bdaddr);
+
+		ATH_INFO("write_bdaddr");
+
+		fclose(stream);
+
+	} while (FALSE);
+
+	if (hci_cmd_list != NULL)
+		ath_free_command_list(&hci_cmd_list, num_cmds);
+
+	return status;
+}
diff --git a/test/ar3k_bt/hciattach_st.c b/test/ar3k_bt/hciattach_st.c
new file mode 100755
index 0000000..dbb7c47
--- /dev/null
+++ b/test/ar3k_bt/hciattach_st.c
@@ -0,0 +1,278 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <dirent.h>
+#include <sys/param.h>
+
+#include <bluetooth/bluetooth.h>
+
+#include "hciattach.h"
+
+static int debug = 0;
+
+static int do_command(int fd, uint8_t ogf, uint16_t ocf,
+			uint8_t *cparam, int clen, uint8_t *rparam, int rlen)
+{
+	//uint16_t opcode = (uint16_t) ((ocf & 0x03ff) | (ogf << 10));
+	unsigned char cp[260], rp[260];
+	int len, size, offset = 3;
+
+	cp[0] = 0x01;
+	cp[1] = ocf & 0xff;
+	cp[2] = ogf << 2 | ocf >> 8;
+	cp[3] = clen;
+
+	if (clen > 0)
+		memcpy(cp + 4, cparam, clen);
+
+	if (debug) {
+		int i;
+		printf("[<");
+		for (i = 0; i < clen + 4; i++)
+			printf(" %02x", cp[i]);
+		printf("]\n");
+	}
+
+	if (write(fd, cp, clen + 4) < 0)
+		return -1;
+
+	do {
+		if (read(fd, rp, 1) < 1)
+			return -1;
+	} while (rp[0] != 0x04);
+
+	if (read(fd, rp + 1, 2) < 2)
+		return -1;
+
+	do {
+		len = read(fd, rp + offset, sizeof(rp) - offset);
+		offset += len;
+	} while (offset < rp[2] + 3);
+
+	if (debug) {
+		int i;
+		printf("[>");
+		for (i = 0; i < offset; i++)
+			printf(" %02x", rp[i]);
+		printf("]\n");
+	}
+
+	if (rp[0] != 0x04) {
+		errno = EIO;
+		return -1;
+	}
+
+	switch (rp[1]) {
+	case 0x0e:	/* command complete */
+		if (rp[6] != 0x00)
+			return -ENXIO;
+		offset = 3 + 4;
+		size = rp[2] - 4;
+		break;
+	case 0x0f:	/* command status */
+		/* fall through */
+	default:
+		offset = 3;
+		size = rp[2];
+		break;
+	}
+
+	if (!rparam || rlen < size)
+		return -ENXIO;
+
+	memcpy(rparam, rp + offset, size);
+
+	return size;
+}
+
+static int load_file(int dd, uint16_t version, const char *suffix)
+{
+	DIR *dir;
+	struct dirent *d;
+	char pathname[PATH_MAX], filename[NAME_MAX], prefix[20];
+	unsigned char cmd[256];
+	unsigned char buf[256];
+	uint8_t seqnum = 0;
+	int fd, size, len, found_fw_file;
+
+	memset(filename, 0, sizeof(filename));
+
+	snprintf(prefix, sizeof(prefix), "STLC2500_R%d_%02d_",
+						version >> 8, version & 0xff);
+
+	strcpy(pathname, "/lib/firmware");
+	dir = opendir(pathname);
+	if (!dir) {
+		strcpy(pathname, ".");
+		dir = opendir(pathname);
+		if (!dir)
+			return -errno;
+	}
+
+	found_fw_file = 0;
+	while (1) {
+		d = readdir(dir);
+		if (!d)
+			break;
+
+		if (strncmp(d->d_name + strlen(d->d_name) - strlen(suffix),
+						suffix, strlen(suffix)))
+			continue;
+
+		if (strncmp(d->d_name, prefix, strlen(prefix)))
+			continue;
+
+		snprintf(filename, sizeof(filename), "%s/%s",
+							pathname, d->d_name);
+		found_fw_file = 1;
+	}
+
+	closedir(dir);
+
+	if (!found_fw_file)
+		return -ENOENT;
+
+	printf("Loading file %s\n", filename);
+
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		perror("Can't open firmware file");
+		return -errno;
+	}
+
+	while (1) {
+		size = read(fd, cmd + 1, 254);
+		if (size <= 0)
+			break;
+
+		cmd[0] = seqnum;
+
+		len = do_command(dd, 0xff, 0x002e, cmd, size + 1, buf, sizeof(buf));
+		if (len < 1)
+			break;
+
+		if (buf[0] != seqnum) {
+			fprintf(stderr, "Sequence number mismatch\n");
+			break;
+		}
+
+		seqnum++;
+	}
+
+	close(fd);
+
+	return 0;
+}
+
+int stlc2500_init(int dd, bdaddr_t *bdaddr)
+{
+	unsigned char cmd[16];
+	unsigned char buf[254];
+	uint16_t version;
+	int len;
+	int err;
+
+	/* Hci_Cmd_Ericsson_Read_Revision_Information */
+	len = do_command(dd, 0xff, 0x000f, NULL, 0, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	printf("%s\n", buf);
+
+	/* HCI_Read_Local_Version_Information */
+	len = do_command(dd, 0x04, 0x0001, NULL, 0, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	version = buf[2] << 8 | buf[1];
+
+	err = load_file(dd, version, ".ptc");
+	if (err < 0) {
+		if (err == -ENOENT)
+			fprintf(stderr, "No ROM patch file loaded.\n");
+		else
+			return -1;
+	}
+
+	err = load_file(dd, buf[2] << 8 | buf[1], ".ssf");
+	if (err < 0) {
+		if (err == -ENOENT)
+			fprintf(stderr, "No static settings file loaded.\n");
+		else
+			return -1;
+	}
+
+	cmd[0] = 0xfe;
+	cmd[1] = 0x06;
+	bacpy((bdaddr_t *) (cmd + 2), bdaddr);
+
+	/* Hci_Cmd_ST_Store_In_NVDS */
+	len = do_command(dd, 0xff, 0x0022, cmd, 8, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	/* HCI_Reset : applies parameters*/
+	len = do_command(dd, 0x03, 0x0003, NULL, 0, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	return 0;
+}
+
+int bgb2xx_init(int dd, bdaddr_t *bdaddr)
+{
+	unsigned char cmd[16];
+	unsigned char buf[254];
+	int len;
+
+	len = do_command(dd, 0xff, 0x000f, NULL, 0, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	printf("%s\n", buf);
+
+	cmd[0] = 0xfe;
+	cmd[1] = 0x06;
+	bacpy((bdaddr_t *) (cmd + 2), bdaddr);
+
+	len = do_command(dd, 0xff, 0x0022, cmd, 8, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	len = do_command(dd, 0x03, 0x0003, NULL, 0, buf, sizeof(buf));
+	if (len < 0)
+		return -1;
+
+	return 0;
+}
diff --git a/test/ar3k_bt/hciattach_ti.c b/test/ar3k_bt/hciattach_ti.c
new file mode 100755
index 0000000..7627bc1
--- /dev/null
+++ b/test/ar3k_bt/hciattach_ti.c
@@ -0,0 +1,522 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2007-2008  Texas Instruments, Inc.
+ *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <termios.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/hci.h>
+#include <bluetooth/hci_lib.h>
+
+#include "hciattach.h"
+
+#ifdef HCIATTACH_DEBUG
+#define DPRINTF(x...)	printf(x)
+#else
+#define DPRINTF(x...)
+#endif
+
+#define HCIUARTGETDEVICE	_IOR('U', 202, int)
+
+#define MAKEWORD(a, b)  ((uint16_t)(((uint8_t)(a)) | ((uint16_t)((uint8_t)(b))) << 8))
+
+#define TI_MANUFACTURER_ID	13
+
+#define FIRMWARE_DIRECTORY	"/lib/firmware/"
+
+#define ACTION_SEND_COMMAND	1
+#define ACTION_WAIT_EVENT	2
+#define ACTION_SERIAL		3
+#define ACTION_DELAY		4
+#define ACTION_RUN_SCRIPT	5
+#define ACTION_REMARKS		6
+
+#define BRF_DEEP_SLEEP_OPCODE_BYTE_1	0x0c
+#define BRF_DEEP_SLEEP_OPCODE_BYTE_2	0xfd
+#define BRF_DEEP_SLEEP_OPCODE		\
+	(BRF_DEEP_SLEEP_OPCODE_BYTE_1 | (BRF_DEEP_SLEEP_OPCODE_BYTE_2 << 8))
+
+#define FILE_HEADER_MAGIC	0x42535442
+
+/*
+ * BRF Firmware header
+ */
+struct bts_header {
+	uint32_t	magic;
+	uint32_t	version;
+	uint8_t	future[24];
+	uint8_t	actions[0];
+}__attribute__ ((packed));
+
+/*
+ * BRF Actions structure
+ */
+struct bts_action {
+	uint16_t	type;
+	uint16_t	size;
+	uint8_t	data[0];
+} __attribute__ ((packed));
+
+struct bts_action_send {
+	uint8_t data[0];
+} __attribute__ ((packed));
+
+struct bts_action_wait {
+	uint32_t msec;
+	uint32_t size;
+	uint8_t data[0];
+}__attribute__ ((packed));
+
+struct bts_action_delay {
+	uint32_t msec;
+}__attribute__ ((packed));
+
+struct bts_action_serial {
+	uint32_t baud;
+	uint32_t flow_control;
+}__attribute__ ((packed));
+
+static FILE *bts_load_script(const char* file_name, uint32_t* version)
+{
+	struct bts_header header;
+	FILE* fp;
+
+	fp = fopen(file_name, "rb");
+	if (!fp) {
+		perror("can't open firmware file");
+		goto out;
+	}
+
+	if (1 != fread(&header, sizeof(struct bts_header), 1, fp)) {
+		perror("can't read firmware file");
+		goto errclose;
+	}
+
+	if (header.magic != FILE_HEADER_MAGIC) {
+		fprintf(stderr, "%s not a legal TI firmware file\n", file_name);
+		goto errclose;
+	}
+
+	if (NULL != version)
+		*version = header.version;
+
+	goto out;
+
+errclose:
+	fclose(fp);
+	fp = NULL;
+out:
+	return fp;
+}
+
+static unsigned long bts_fetch_action(FILE* fp, unsigned char* action_buf,
+				unsigned long buf_size, uint16_t* action_type)
+{
+	struct bts_action action_hdr;
+	unsigned long nread;
+
+	if (!fp)
+		return 0;
+
+	if (1 != fread(&action_hdr, sizeof(struct bts_action), 1, fp))
+		return 0;
+
+	if (action_hdr.size > buf_size) {
+		fprintf(stderr, "bts_next_action: not enough space to read next action\n");
+		return 0;
+	}
+
+	nread = fread(action_buf, sizeof(uint8_t), action_hdr.size, fp);
+	if (nread != (action_hdr.size)) {
+		fprintf(stderr, "bts_next_action: fread failed to read next action\n");
+		return 0;
+	}
+
+	*action_type = action_hdr.type;
+
+	return nread * sizeof(uint8_t);
+}
+
+static void bts_unload_script(FILE* fp)
+{
+	if (fp)
+		fclose(fp);
+}
+
+static int is_it_texas(const uint8_t *respond)
+{
+	uint16_t manufacturer_id;
+
+	manufacturer_id = MAKEWORD(respond[11], respond[12]);
+
+	return TI_MANUFACTURER_ID == manufacturer_id ? 1 : 0;
+}
+
+static const char *get_firmware_name(const uint8_t *respond)
+{
+	static char firmware_file_name[PATH_MAX] = {0};
+	uint16_t version = 0, chip = 0, min_ver = 0, maj_ver = 0;
+
+	version = MAKEWORD(respond[13], respond[14]);
+	chip =  (version & 0x7C00) >> 10;
+	min_ver = (version & 0x007F);
+	maj_ver = (version & 0x0380) >> 7;
+
+	if (version & 0x8000)
+		maj_ver |= 0x0008;
+
+	sprintf(firmware_file_name, FIRMWARE_DIRECTORY "TIInit_%d.%d.%d.bts", chip, maj_ver, min_ver);
+
+	return firmware_file_name;
+}
+
+static void brf_delay(struct bts_action_delay *delay)
+{
+	usleep(1000 * delay->msec);
+}
+
+static int brf_set_serial_params(struct bts_action_serial *serial_action,
+						int fd, struct termios *ti)
+{
+	fprintf(stderr, "texas: changing baud rate to %u, flow control to %u\n",
+				serial_action->baud, serial_action->flow_control );
+	tcflush(fd, TCIOFLUSH);
+
+	if (serial_action->flow_control)
+		ti->c_cflag |= CRTSCTS;
+	else
+		ti->c_cflag &= ~CRTSCTS;
+
+	if (tcsetattr(fd, TCSANOW, ti) < 0) {
+		perror("Can't set port settings");
+		return -1;
+	}
+
+	tcflush(fd, TCIOFLUSH);
+
+	if (set_speed(fd, ti, serial_action->baud) < 0) {
+		perror("Can't set baud rate");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int brf_send_command_socket(int fd, struct bts_action_send* send_action)
+{
+	char response[1024] = {0};
+	hci_command_hdr *cmd = (hci_command_hdr *) send_action->data;
+	uint16_t opcode = cmd->opcode;
+
+	struct hci_request rq;
+	memset(&rq, 0, sizeof(rq));
+	rq.ogf    = cmd_opcode_ogf(opcode);
+	rq.ocf    = cmd_opcode_ocf(opcode);
+	rq.event  = EVT_CMD_COMPLETE;
+	rq.cparam = &send_action->data[3];
+	rq.clen   = send_action->data[2];
+	rq.rparam = response;
+	rq.rlen   = sizeof(response);
+
+	if (hci_send_req(fd, &rq, 15) < 0) {
+		perror("Cannot send hci command to socket");
+		return -1;
+	}
+
+	/* verify success */
+	if (response[0]) {
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int brf_send_command_file(int fd, struct bts_action_send* send_action, long size)
+{
+	unsigned char response[1024] = {0};
+	long ret = 0;
+
+	/* send command */
+	if (size != write(fd, send_action, size)) {
+		perror("Texas: Failed to write action command");
+		return -1;
+	}
+
+	/* read response */
+	ret = read_hci_event(fd, response, sizeof(response));
+	if (ret < 0) {
+		perror("texas: failed to read command response");
+		return -1;
+	}
+
+	/* verify success */
+	if (ret < 7 || 0 != response[6]) {
+		fprintf( stderr, "TI init command failed.\n" );
+		errno = EIO;
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static int brf_send_command(int fd, struct bts_action_send* send_action, long size, int hcill_installed)
+{
+	int ret = 0;
+	char *fixed_action;
+
+	/* remove packet type when giving to socket API */
+	if (hcill_installed) {
+		fixed_action = ((char *) send_action) + 1;
+		ret = brf_send_command_socket(fd, (struct bts_action_send *) fixed_action);
+	} else {
+		ret = brf_send_command_file(fd, send_action, size);
+	}
+
+	return ret;
+}
+
+static int brf_do_action(uint16_t brf_type, uint8_t *brf_action, long brf_size,
+				int fd, struct termios *ti, int hcill_installed)
+{
+	int ret = 0;
+
+	switch (brf_type) {
+	case ACTION_SEND_COMMAND:
+		DPRINTF("W");
+		ret = brf_send_command(fd, (struct bts_action_send*) brf_action, brf_size, hcill_installed);
+		break;
+	case ACTION_WAIT_EVENT:
+		DPRINTF("R");
+		break;
+	case ACTION_SERIAL:
+		DPRINTF("S");
+		ret = brf_set_serial_params((struct bts_action_serial *) brf_action, fd, ti);
+		break;
+	case ACTION_DELAY:
+		DPRINTF("D");
+		brf_delay((struct bts_action_delay *) brf_action);
+		break;
+	case ACTION_REMARKS:
+		DPRINTF("C");
+		break;
+	default:
+		fprintf(stderr, "brf_init: unknown firmware action type (%d)\n", brf_type);
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * tests whether a given brf action is a HCI_VS_Sleep_Mode_Configurations cmd
+ */
+static int brf_action_is_deep_sleep(uint8_t *brf_action, long brf_size,
+							uint16_t brf_type)
+{
+	uint16_t opcode;
+
+	if (brf_type != ACTION_SEND_COMMAND)
+		return 0;
+
+	if (brf_size < 3)
+		return 0;
+
+	if (brf_action[0] != HCI_COMMAND_PKT)
+		return 0;
+
+	/* HCI data is little endian */
+	opcode = brf_action[1] | (brf_action[2] << 8);
+
+	if (opcode != BRF_DEEP_SLEEP_OPCODE)
+		return 0;
+
+	/* action is deep sleep configuration command ! */
+	return 1;
+}
+
+/*
+ * This function is called twice.
+ * The first time it is called, it loads the brf script, and executes its
+ * commands until it reaches a deep sleep command (or its end).
+ * The second time it is called, it assumes HCILL protocol is set up,
+ * and sends rest of brf script via the supplied socket.
+ */
+static int brf_do_script(int fd, struct termios *ti, const char *bts_file)
+{
+	int ret = 0,  hcill_installed = bts_file ? 0 : 1;
+	uint32_t vers;
+	static FILE *brf_script_file = NULL;
+	static uint8_t brf_action[512];
+	static long brf_size;
+	static uint16_t brf_type;
+
+	/* is it the first time we are called ? */
+	if (0 == hcill_installed) {
+		DPRINTF("Sending script to serial device\n");
+		brf_script_file = bts_load_script(bts_file, &vers );
+		if (!brf_script_file) {
+			fprintf(stderr, "Warning: cannot find BTS file: %s\n",
+					bts_file);
+			return 0;
+		}
+
+		fprintf( stderr, "Loaded BTS script version %u\n", vers );
+
+		brf_size = bts_fetch_action(brf_script_file, brf_action,
+						sizeof(brf_action), &brf_type);
+		if (brf_size == 0) {
+			fprintf(stderr, "Warning: BTS file is empty !");
+			return 0;
+		}
+	}
+	else {
+		DPRINTF("Sending script to bluetooth socket\n");
+	}
+
+	/* execute current action and continue to parse brf script file */
+	while (brf_size != 0) {
+		ret = brf_do_action(brf_type, brf_action, brf_size,
+						fd, ti, hcill_installed);
+		if (ret == -1)
+			break;
+
+		brf_size = bts_fetch_action(brf_script_file, brf_action,
+						sizeof(brf_action), &brf_type);
+
+		/* if this is the first time we run (no HCILL yet) */
+		/* and a deep sleep command is encountered */
+		/* we exit */
+		if (!hcill_installed &&
+				brf_action_is_deep_sleep(brf_action,
+							brf_size, brf_type))
+			return 0;
+	}
+
+	bts_unload_script(brf_script_file);
+	brf_script_file = NULL;
+	DPRINTF("\n");
+
+	return ret;
+}
+
+int texas_init(int fd, struct termios *ti)
+{
+	struct timespec tm = {0, 50000};
+	char cmd[4];
+	unsigned char resp[100];		/* Response */
+	const char *bts_file;
+	int n;
+
+	memset(resp,'\0', 100);
+
+	/* It is possible to get software version with manufacturer specific
+	   HCI command HCI_VS_TI_Version_Number. But the only thing you get more
+	   is if this is point-to-point or point-to-multipoint module */
+
+	/* Get Manufacturer and LMP version */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x01;
+	cmd[2] = 0x10;
+	cmd[3] = 0x00;
+
+	do {
+		n = write(fd, cmd, 4);
+		if (n < 0) {
+			perror("Failed to write init command (READ_LOCAL_VERSION_INFORMATION)");
+			return -1;
+		}
+		if (n < 4) {
+			fprintf(stderr, "Wanted to write 4 bytes, could only write %d. Stop\n", n);
+			return -1;
+		}
+
+		/* Read reply. */
+		if (read_hci_event(fd, resp, 100) < 0) {
+			perror("Failed to read init response (READ_LOCAL_VERSION_INFORMATION)");
+			return -1;
+		}
+
+		/* Wait for command complete event for our Opcode */
+	} while (resp[4] != cmd[1] && resp[5] != cmd[2]);
+
+	/* Verify manufacturer */
+	if (! is_it_texas(resp)) {
+		fprintf(stderr,"ERROR: module's manufacturer is not Texas Instruments\n");
+		return -1;
+	}
+
+	fprintf(stderr, "Found a Texas Instruments' chip!\n");
+
+	bts_file = get_firmware_name(resp);
+	fprintf(stderr, "Firmware file : %s\n", bts_file);
+
+	n = brf_do_script(fd, ti, bts_file);
+
+	nanosleep(&tm, NULL);
+
+	return n;
+}
+
+int texas_post(int fd, struct termios *ti)
+{
+	int dev_id, dd, ret = 0;
+
+	sleep(1);
+
+	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);
+	if (dev_id < 0) {
+		perror("cannot get device id");
+		return -1;
+	}
+
+	DPRINTF("\nAdded device hci%d\n", dev_id);
+
+	dd = hci_open_dev(dev_id);
+	if (dd < 0) {
+		perror("HCI device open failed");
+		return -1;
+	}
+
+	ret = brf_do_script(dd, ti, NULL);
+
+	hci_close_dev(dd);
+
+	return ret;
+}
diff --git a/test/ar3k_bt/hciattach_tialt.c b/test/ar3k_bt/hciattach_tialt.c
new file mode 100755
index 0000000..1ba009c
--- /dev/null
+++ b/test/ar3k_bt/hciattach_tialt.c
@@ -0,0 +1,244 @@
+/*
+ *
+ *  BlueZ - Bluetooth protocol stack for Linux
+ *
+ *  Copyright (C) 2005-2010  Marcel Holtmann <marcel@holtmann.org>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <syslog.h>
+#include <termios.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/poll.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+
+#include <bluetooth/bluetooth.h>
+#include <bluetooth/hci.h>
+#include <bluetooth/hci_lib.h>
+
+#include "hciattach.h"
+
+#define FAILIF(x, args...) do {   \
+	if (x) {					  \
+		fprintf(stderr, ##args);  \
+		return -1;				  \
+	}							  \
+} while(0)
+
+typedef struct {
+	uint8_t uart_prefix;
+	hci_event_hdr hci_hdr;
+	evt_cmd_complete cmd_complete;
+	uint8_t status;
+	uint8_t data[16];
+} __attribute__((packed)) command_complete_t;
+
+static int read_command_complete(int fd, unsigned short opcode, unsigned char len) {
+	command_complete_t resp;
+	/* Read reply. */
+	FAILIF(read_hci_event(fd, (unsigned char *)&resp, sizeof(resp)) < 0,
+		   "Failed to read response");
+
+	/* Parse speed-change reply */
+	FAILIF(resp.uart_prefix != HCI_EVENT_PKT,
+		   "Error in response: not an event packet, but 0x%02x!\n",
+		   resp.uart_prefix);
+
+	FAILIF(resp.hci_hdr.evt != EVT_CMD_COMPLETE, /* event must be event-complete */
+		   "Error in response: not a cmd-complete event, "
+		   "but 0x%02x!\n", resp.hci_hdr.evt);
+
+	FAILIF(resp.hci_hdr.plen < 4, /* plen >= 4 for EVT_CMD_COMPLETE */
+		   "Error in response: plen is not >= 4, but 0x%02x!\n",
+		   resp.hci_hdr.plen);
+
+	/* cmd-complete event: opcode */
+	FAILIF(resp.cmd_complete.opcode != (uint16_t)opcode,
+		   "Error in response: opcode is 0x%04x, not 0x%04x!",
+		   resp.cmd_complete.opcode, opcode);
+
+	return resp.status == 0 ? 0 : -1;
+}
+
+typedef struct {
+	uint8_t uart_prefix;
+	hci_command_hdr hci_hdr;
+	uint32_t speed;
+} __attribute__((packed)) texas_speed_change_cmd_t;
+
+static int texas_change_speed(int fd, uint32_t speed)
+{
+	return 0;
+}
+
+static int texas_load_firmware(int fd, const char *firmware) {
+
+	int fw = open(firmware, O_RDONLY);
+
+	fprintf(stdout, "Opening firmware file: %s\n", firmware);
+
+	FAILIF(fw < 0,
+		   "Could not open firmware file %s: %s (%d).\n",
+		   firmware, strerror(errno), errno);
+
+	fprintf(stdout, "Uploading firmware...\n");
+	do {
+		/* Read each command and wait for a response. */
+		unsigned char data[1024];
+		unsigned char cmdp[1 + sizeof(hci_command_hdr)];
+		hci_command_hdr *cmd = (hci_command_hdr *)(cmdp + 1);
+		int nr;
+		nr = read(fw, cmdp, sizeof(cmdp));
+		if (!nr)
+			break;
+		FAILIF(nr != sizeof(cmdp), "Could not read H4 + HCI header!\n");
+		FAILIF(*cmdp != HCI_COMMAND_PKT, "Command is not an H4 command packet!\n");
+
+		FAILIF(read(fw, data, cmd->plen) != cmd->plen,
+			   "Could not read %d bytes of data for command with opcode %04x!\n",
+			   cmd->plen,
+			   cmd->opcode);
+
+		{
+			int nw;
+#if 0
+			fprintf(stdout, "\topcode 0x%04x (%d bytes of data).\n",
+					cmd->opcode,
+					cmd->plen);
+#endif
+			struct iovec iov_cmd[2];
+			iov_cmd[0].iov_base = cmdp;
+			iov_cmd[0].iov_len	= sizeof(cmdp);
+			iov_cmd[1].iov_base = data;
+			iov_cmd[1].iov_len	= cmd->plen;
+			nw = writev(fd, iov_cmd, 2);
+			FAILIF(nw != (int) sizeof(cmd) +	cmd->plen,
+				   "Could not send entire command (sent only %d bytes)!\n",
+				   nw);
+		}
+
+		/* Wait for response */
+		if (read_command_complete(fd,
+								  cmd->opcode,
+								  cmd->plen) < 0) {
+			return -1;
+		}
+
+	} while(1);
+	fprintf(stdout, "Firmware upload successful.\n");
+
+	close(fw);
+	return 0;
+}
+
+int texasalt_init(int fd, int speed, struct termios *ti)
+{
+	struct timespec tm = {0, 50000};
+	char cmd[4];
+	unsigned char resp[100];		/* Response */
+	int n;
+
+	memset(resp,'\0', 100);
+
+	/* It is possible to get software version with manufacturer specific
+	   HCI command HCI_VS_TI_Version_Number. But the only thing you get more
+	   is if this is point-to-point or point-to-multipoint module */
+
+	/* Get Manufacturer and LMP version */
+	cmd[0] = HCI_COMMAND_PKT;
+	cmd[1] = 0x01;
+	cmd[2] = 0x10;
+	cmd[3] = 0x00;
+
+	do {
+		n = write(fd, cmd, 4);
+		if (n < 0) {
+			perror("Failed to write init command (READ_LOCAL_VERSION_INFORMATION)");
+			return -1;
+		}
+		if (n < 4) {
+			fprintf(stderr, "Wanted to write 4 bytes, could only write %d. Stop\n", n);
+			return -1;
+		}
+
+		/* Read reply. */
+		if (read_hci_event(fd, resp, 100) < 0) {
+			perror("Failed to read init response (READ_LOCAL_VERSION_INFORMATION)");
+			return -1;
+		}
+
+		/* Wait for command complete event for our Opcode */
+	} while (resp[4] != cmd[1] && resp[5] != cmd[2]);
+
+	/* Verify manufacturer */
+	if ((resp[11] & 0xFF) != 0x0d)
+		fprintf(stderr,"WARNING : module's manufacturer is not Texas Instrument\n");
+
+	/* Print LMP version */
+	fprintf(stderr, "Texas module LMP version : 0x%02x\n", resp[10] & 0xFF);
+
+	/* Print LMP subversion */
+	{
+		unsigned short lmp_subv = resp[13] | (resp[14] << 8);
+		unsigned short brf_chip = (lmp_subv & 0x7c00) >> 10;
+		static const char *c_brf_chip[8] = {
+			"unknown",
+			"unknown",
+			"brf6100",
+			"brf6150",
+			"brf6300",
+			"brf6350",
+			"unknown",
+			"wl1271"
+		};
+		char fw[100];
+
+		fprintf(stderr, "Texas module LMP sub-version : 0x%04x\n", lmp_subv);
+
+		fprintf(stderr,
+				"\tinternal version freeze: %d\n"
+				"\tsoftware version: %d\n"
+				"\tchip: %s (%d)\n",
+				lmp_subv & 0x7f,
+				((lmp_subv & 0x8000) >> (15-3)) | ((lmp_subv & 0x380) >> 7),
+				((brf_chip > 7) ? "unknown" : c_brf_chip[brf_chip]),
+				brf_chip);
+
+		sprintf(fw, "/etc/firmware/%s.bin", c_brf_chip[brf_chip]);
+		texas_load_firmware(fd, fw);
+
+		texas_change_speed(fd, speed);
+	}
+	nanosleep(&tm, NULL);
+	return 0;
+}
diff --git a/test/make.rules b/test/make.rules
index 8a5dbaa..cf17d5a 100755
--- a/test/make.rules
+++ b/test/make.rules
@@ -75,6 +75,12 @@ $(OBJDIR)/%.sh : %.sh
 	$(VERBOSE)cp -af $< $@
 	$(VERBOSE)chmod u+x $@
 
+$(OBJDIR)/%.bin : %.bin
+	$(VERBOSE)mkdir -p `dirname $@`
+	$(VERBOSE)echo "     Copying $< to $@"
+	$(VERBOSE)cp -af $< $@
+	$(VERBOSE)chmod u+x $@
+
 $(OBJDIR)/%.rgb : %.rgb
 	$(VERBOSE)mkdir -p `dirname $@`
 	$(VERBOSE)echo "     Copying $< to $@"
-- 
1.8.0

