From 03c4f61bfa11e310e33f0120e5181166cde6bebe Mon Sep 17 00:00:00 2001
From: Raj Rajasekaran <b10872@freescale.com>
Date: Mon, 30 Jun 2008 15:06:24 -0500
Subject: [PATCH 033/442] ENGR00081856: Add SCC2 & RNGC driver support for
 i.MX37.

Added unit test related files for SCC2 and RNGC drivers to test repository.

Signed-off-by: Raj Rajasekaran <b10872@freescale.com>
---
 include/rng_test_driver.h        |   84 +-
 include/scc2_test_driver.h       |  209 ++++
 module_test/Makefile             |    2 +-
 module_test/rng_test_driver.c    |  747 ++++++------
 module_test/scc2_test_driver.c   |  669 +++++++++++
 test/mxc_rng_test/Makefile       |    3 +
 test/mxc_rng_test/rng_test.c     |   89 +-
 test/mxc_scc/scc_test.c          |   88 +-
 test/mxc_scc2/Makefile           |   21 +
 test/mxc_scc2/autorun-scc2.sh    |   18 +
 test/mxc_scc2/fail_mode_tests.sh |   64 ++
 test/mxc_scc2/fsl_platform.h     |  128 +++
 test/mxc_scc2/fsl_shw.h          | 1966 ++++++++++++++++++++++++++++++++
 test/mxc_scc2/partition_tests.sh |   31 +
 test/mxc_scc2/sahara.h           | 2323 ++++++++++++++++++++++++++++++++++++++
 test/mxc_scc2/scc2_setup.sh      |  109 ++
 test/mxc_scc2/scc2_test.c        | 1474 ++++++++++++++++++++++++
 test/mxc_scc2/scc2_test_driver.h |  207 ++++
 test/mxc_scc2/test_subs.sh       |  158 +++
 19 files changed, 7892 insertions(+), 498 deletions(-)
 create mode 100644 include/scc2_test_driver.h
 create mode 100644 module_test/scc2_test_driver.c
 create mode 100644 test/mxc_scc2/Makefile
 create mode 100644 test/mxc_scc2/autorun-scc2.sh
 create mode 100644 test/mxc_scc2/fail_mode_tests.sh
 create mode 100644 test/mxc_scc2/fsl_platform.h
 create mode 100644 test/mxc_scc2/fsl_shw.h
 create mode 100644 test/mxc_scc2/partition_tests.sh
 create mode 100644 test/mxc_scc2/sahara.h
 create mode 100644 test/mxc_scc2/scc2_setup.sh
 create mode 100644 test/mxc_scc2/scc2_test.c
 create mode 100644 test/mxc_scc2/scc2_test_driver.h
 create mode 100644 test/mxc_scc2/test_subs.sh

diff --git a/include/rng_test_driver.h b/include/rng_test_driver.h
index deb8db5..2f0a5b8 100644
--- a/include/rng_test_driver.h
+++ b/include/rng_test_driver.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -11,20 +11,6 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-/* +FHDR-----------------------------------------------------------------------
- * FILE NAME      : rng_test_driver.h
- * ----------------------------------------------------------------------------
- * LATEST : $Revision: 1.5 $ $Date: Tue Jun 20 14:11:51 2006 $
- * ----------------------------------------------------------------------------
- * KEYWORDS : RNG, Security, Linux driver
- * ----------------------------------------------------------------------------
- * PURPOSE: Provide a test driver for access to the RNG driver
- * ----------------------------------------------------------------------------
- * REUSE ISSUES
- * RNGB/RNGC have different interface, but there might be some reuse
- * -FHDR-----------------------------------------------------------------------
- */
-
 /*! @file rng_test_driver.h
  *
  *  This header file provides definitions needed by the RNG test driver.
@@ -49,10 +35,10 @@
 
 #ifdef __KERNEL__
 
-static os_error_code rng_test_get_random(fsl_shw_uco_t * user_ctx,
-					 unsigned long rng_data);
-static os_error_code rng_test_add_entropy(fsl_shw_uco_t * user_ctx,
-					  unsigned long rng_data);
+static os_error_code rng_test_get_random(fsl_shw_uco_t* user_ctx,
+                                          unsigned long rng_data);
+static os_error_code rng_test_add_entropy(fsl_shw_uco_t* user_ctx,
+                                          unsigned long rng_data);
 static os_error_code rng_test_read_register(unsigned long rng_data);
 static os_error_code rng_test_write_register(unsigned long rng_data);
 static os_error_code rng_test_setup_user_driver_interaction(void);
@@ -60,15 +46,17 @@ static void rng_test_cleanup(void);
 
 extern int rng_major_node;
 
+
 #ifndef RNG_TEST_MAJOR_NODE
-/*! Linux major node value for the device special file (/dev/rng_test) */
+/** Linux major node value for the device special file (/dev/rng_test) */
 #define RNG_TEST_MAJOR_NODE  0
 #endif
 
-#endif				/* kernel */
+#endif /* kernel */
+
 
 #ifndef RNG_TEST_DRIVER_NAME
-/*! /dev/xxx name for this device */
+/** /dev/xxx name for this device */
 #define RNG_TEST_DRIVER_NAME "rng_test"
 #endif
 
@@ -87,61 +75,65 @@ extern int rng_major_node;
 
 /* Define RNG Driver Commands (Argument 2 of ioctl) */
 
-/*! @defgroup ioctlcmds ioctl command (argument 2) values */
-/*! @addtogroup ioctlcmds */
-/*! @{ */
-/*! ioctl cmd to test the rng_read_register() function of the RNG driver */
+/** @defgroup ioctlcmds ioctl command (argument 2) values */
+/** @addtogroup ioctlcmds */
+/** @{ */
+/** ioctl cmd to test the rng_read_register() function of the RNG driver */
 #define RNG_TEST_READ_REG        _IOWR(RNG_TEST_DRIVER_IOCTL_IDENTIFIER, 1, \
          rng_test_reg_access_t)
-/*! ioctl cmd to test the rng_write_register() function of the RNG driver */
+/** ioctl cmd to test the rng_write_register() function of the RNG driver */
 #define RNG_TEST_WRITE_REG       _IOWR(RNG_TEST_DRIVER_IOCTL_IDENTIFIER, 2, \
          rng_test_reg_access_t)
-/*! ioctl cmd to test the rng_add_entropy() function of the RNG driver */
+/** ioctl cmd to test the rng_add_entropy() function of the RNG driver */
 #define RNG_TEST_ADD_ENTROPY     _IOWR(RNG_TEST_DRIVER_IOCTL_IDENTIFIER, 3, \
          rng_test_add_entropy_t)
-/*! ioctl cmd to test the rng_get_random() function of the RNG driver */
+/** ioctl cmd to test the rng_get_random() function of the RNG driver */
 #define RNG_TEST_GET_RANDOM     _IOWR(RNG_TEST_DRIVER_IOCTL_IDENTIFIER, 4, \
          rng_test_get_random_t)
-/*! @} */
+/** @} */
 
-/*! @defgroup ioctlStructs Special structs for argument 3 of ioctl
+
+/** @defgroup ioctlStructs Special structs for argument 3 of ioctl
  *
  *
  */
-/*! @addtogroup ioctlStructs */
-/*! @{ */
+/** @addtogroup ioctlStructs */
+/** @{ */
 
-/*!
+/**
  * ioctl structure for add entropy to the RNG, through the driver, used
  * with #RNG_ADD_ENTROPY
  */
 typedef struct {
-	rng_return_t function_return_code;	/*!< Straight from RNG driver. */
-	uint32_t count_bytes;	/*!< Number of bytes at entropy.  */
-	uint8_t *entropy;	/*!< Location of entropy add to RNG.  */
+    rng_return_t function_return_code; /**< Straight from RNG driver. */
+    uint32_t  count_bytes;      /**< Number of bytes at entropy.  */
+    uint8_t*  entropy;          /**< Location of entropy add to RNG.  */
 } rng_test_add_entropy_t;
 
-/*!
+
+/**
  * ioctl structure for retrieving entropy from the RNG driver, used
  * with #RNG_GET_RANDOM
  */
 typedef struct {
-	int count_bytes;	/*!< Amount of entropy to retrieve */
-	uint8_t *random;	/*!< Place to copy the random data  */
-	int isr_flag;		/*!< Request entropy using isr mode */
-	rng_return_t function_return_code;	/*!< Straight from RNG driver */
+    int count_bytes;            /**< Amount of entropy to retrieve */
+    uint8_t* random;           /**< Place to copy the random data  */
+    int isr_flag;               /**< Request entropy using isr mode */
+    rng_return_t function_return_code; /**< Straight from RNG driver */
 } rng_test_get_random_t;
 
-/*!
+
+/**
  * ioctl structure for accessing RNG registers, used with
  * #RNG_TEST_READ_REG and #RNG_TEST_WRITE_REG.
  */
 typedef struct {
-	uint32_t reg_offset;	/*!< The register address from Memory Map */
-	uint32_t reg_data;	/*!< Data to/from the register */
-	rng_return_t function_return_code;	/*!< Straight from RNG driver */
+    uint32_t reg_offset;        /**< The register address from Memory Map */
+    uint32_t reg_data;          /**< Data to/from the register */
+    rng_return_t      function_return_code; /**< Straight from RNG driver */
 } rng_test_reg_access_t;
 
+
 /*! @} */
 
 #endif				/* rng_test_driver.h */
diff --git a/include/scc2_test_driver.h b/include/scc2_test_driver.h
new file mode 100644
index 0000000..77bfe2b
--- /dev/null
+++ b/include/scc2_test_driver.h
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*! @file scc2_test_driver.h
+ *
+ *  This header file provides definitions needed by the SCC2 test driver.
+ *
+ */
+
+
+#ifndef SCC2_TEST_DRIVER_H
+#define SCC2_TEST_DRIVER_H
+
+#ifdef __KERNEL__
+
+#include <portable_os.h>
+#include <asm/arch/hardware.h>
+
+#endif /* kernel */
+
+
+#include <asm/arch/mxc_scc2_driver.h>
+
+
+#ifndef SCC2_TEST_DRIVER_NAME
+
+/** /dev/xxx name for this device */
+#define SCC2_TEST_DRIVER_NAME "scc2_test"
+
+
+#endif /* kernel */
+
+
+/* User/Driver interface definitions */
+
+/**
+ * @defgroup ioctlreturns Ioctl Error Codes.
+ *
+ * These are the values returned by #scc_ioctl and placed into @c
+ * errno by @c ioctl. Porting opportunity.  These values were chosen to
+ * match standard Linux values.
+ */
+/** @addtogroup ioctlreturns */
+/** @{ */
+#define IOCTL_SCC2_OK             0      /**< @c ioctl completed successfully */
+#define IOCTL_SCC2_INVALID_CMD    ENOTTY /**< Invalid command passed. */
+#define IOCTL_SCC2_INVALID_MODE   EINVAL /**< Invalid cipher mode. */
+#define IOCTL_SCC2_SCM_BUSY       EBUSY  /**< SCM is busy */
+#define IOCTL_SCC2_IMPROPER_STATE EBADFD /**< Improper state for operation */
+#define IOCTL_SCC2_IMPROPER_ADDR  EFAULT /**< Improper address/offset passed */
+#define IOCTL_SCC2_NO_MEMORY      ENOMEM /**< Insufficient memory to process */
+#define IOCTL_SCC2_FAILURE        ESPIPE /**< Generic 'SCC2 error' error */
+/** @} */
+
+/*
+ * Interface definitions between user and driver
+ */
+
+/* This is a porting opportunity.  It identifies the 'unique' byte
+   value inserted into the IOCTL number.  It really only has to be
+   unique within the software used on a given device. */
+#ifndef SCC2_TEST_DRIVER_IOCTL_IDENTIFIER
+#define SCC2_TEST_DRIVER_IOCTL_IDENTIFIER 's'
+#endif
+
+/* Define SCC2 Driver Commands (Argument 2 of ioctl) */
+
+/** @defgroup ioctlcmds ioctl command (argument 2) values */
+/** @addtogroup ioctlcmds */
+/** @{ */
+/** ioctl cmd to return version and configuration information on driver and
+ *  SCC2 */
+#ifdef _IOW
+#undef _IOW
+#endif
+#ifdef _IOWR
+#undef _IOWR
+#endif
+#ifdef _IO
+#undef _IO
+#endif
+
+#define _IOW(x, y, z) y
+#define _IOWR(x, y, z) y
+#define _IO(x, y) y
+
+#define SCC2_TEST_GET_CONFIGURATION _IOW (SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 0, \
+         scc_configuration_access)
+/** ioctl cmd to test the scc_read_register() function of the SCC2 driver */
+#define SCC2_TEST_READ_REG         _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 1, \
+         scc_reg_access)
+/** ioctl cmd to test the scc_write_register() function of the SCC2 driver */
+#define SCC2_TEST_WRITE_REG        _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 2, \
+         scc_reg_access)
+/** ioctl cmd to test the scc_crypt() function of the SCC2 driver */
+#define SCC2_TEST_ENCRYPT          _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 3, \
+         scc_encrypt_decrypt)
+/** ioctl cmd to test the scc_crypt() function of the SCC2 driver */
+#define SCC2_TEST_DECRYPT          _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 4, \
+         scc_encrypt_decrypt)
+/** ioctl cmd to test the scc_set_sw_alarm() function of the SCC2 driver */
+#define SCC2_TEST_SET_ALARM        _IO  (SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 5)
+/** ioctl cmd to test the scc_zeroize_memories() function of the SCC2 driver */
+#define SCC2_TEST_ZEROIZE          _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 6, \
+         scc_return_t)
+/** ioctl cmd to test partition allocation function of the SCC2 driver */
+#define SCC2_TEST_ALLOC_PART       _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 12, \
+        scc_partition_access)
+/** ioctl cmd to test partition engagement function of the SCC2 driver */
+#define SCC2_TEST_ENGAGE_PART      _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 13, \
+        scc_partition_access)
+/** ioctl cmd to test partition cipher function of the SCC2 driver */
+#define SCC2_TEST_ENCRYPT_PART     _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 14, \
+        scc_part_cipher_access)
+#define SCC2_TEST_DECRYPT_PART     _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 15, \
+        scc_part_cipher_access)
+/** ioctl cmd to test partition allocation function of the SCC2 driver */
+#define SCC2_TEST_RELEASE_PART     _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 16, \
+        scc_partition_access)
+/** ioctl cmd to load data into an SCC2 partition */
+#define SCC2_TEST_LOAD_PART        _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 17, \
+        scc_part_cipher_access)
+/** ioctl cmd to lread data from an SCC2 partition */
+#define SCC2_TEST_READ_PART        _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 18, \
+        scc_part_cipher_access)
+
+/** @} */
+
+
+/** @defgroup ioctlStructs Special structs for argument 3 of ioctl
+ *
+ *
+ */
+/** @addtogroup ioctlStructs */
+/** @{ */
+
+/**
+ * ioctl structure for retrieving driver & SCC2 version ids, used
+ * with #SCC2_TEST_GET_CONFIGURATION.
+ */
+typedef struct {
+    int driver_major_version;   /**< Major version of the SCC2 driver code  */
+    int driver_minor_version;   /**< Minor version of the SCC2 driver code  */
+    int scm_version;            /**< from Configuration register */
+    int smn_version;            /**< from SMN Status register */
+    int block_size;             /**< bytes in a block */
+    int black_ram_size;         /**< number of blocks of Black RAM */
+    int red_ram_size;           /**< number of blocks of Red RAM */
+} scc_configuration_access;
+
+
+/**
+ * ioctl structure for accessing SCC2 registers, used with
+ * #SCC2_TEST_READ_REG and #SCC2_TEST_WRITE_REG.
+ */
+typedef struct {
+    uint32_t reg_offset;        /**< The register address from Memory Map */
+    uint32_t reg_data;          /**< Data to/from the register */
+    scc_return_t      function_return_code; /**< Straight from SCC2 driver */
+} scc_reg_access;
+
+
+/**
+ * ioctl structure for partition setup/teardown functions
+ */
+typedef struct {
+    uint32_t virt_address;      /**< Its virtual address */
+    union {
+        /* for allocate */
+        struct {
+            uint32_t smid;      /**< From user  */
+            uint32_t part_no;   /**< Which partition was allocated */
+            uint32_t phys_address; /**<Its physical address */
+        };
+        /* for engage */
+        struct {
+            const uint8_t* umid; /**< 16-byte UMID for partition, or NULL */
+            uint32_t permissions; /**< Mode register setting for initial access  */
+        };
+    };
+    scc_return_t scc_status;    /**< Returned status of call to scc2 driver */
+} scc_partition_access;
+
+/** @} */
+
+/**
+ * ioctl structure for partition encrypt/decrypt functions
+ */
+typedef struct {
+    uint32_t virt_address;      /**< Its virtual address */
+    uint32_t red_offset;        /**< Byte offset into partition */
+    uint8_t* black_address;     /**< Virtual address of Black data */
+    uint32_t size_bytes;        /**< Number of bytes of red/black data */
+    uint64_t iv;                /**< first half of IV for CBC mode; second half
+                                   is zero */
+    scc_return_t scc_status;    /**< Returned status of call to scc2 driver */
+} scc_part_cipher_access;
+
+#endif /* scc2_test_driver.h */
diff --git a/module_test/Makefile b/module_test/Makefile
index c63a4e7..85b176d 100644
--- a/module_test/Makefile
+++ b/module_test/Makefile
@@ -5,10 +5,10 @@ ifneq ($(KERNELRELEASE),)
 # When adding modules, either add to the 'module_list' for all platfoms or add
 # below to the 'module_list +=...' list for each platform that needs it.
 module_list-y := mxc_rtic_test.o
-
 module_list-$(CONFIG_MXC_PMIC_MC13783) += mxc_pm_test.o mxc_pmic_power_testmod.o
 module_list-$(CONFIG_MXC_IPC) += ipctestmod.o
 module_list-$(CONFIG_MXC_SECURITY_SCC) += scc_test_driver.o
+module_list-$(CONFIG_MXC_SECURITY_SCC2) += scc2_test_driver.o
 module_list-$(CONFIG_MXC_SECURITY_RNG) += rng_test_driver.o
 module_list-$(CONFIG_MXC_SECURITY_HAC) += mxc_HAC_test.o
 module_list-$(CONFIG_MXC_SAHARA) += sahara_test_driver.o
diff --git a/module_test/rng_test_driver.c b/module_test/rng_test_driver.c
index d345ae5..759cbf8 100644
--- a/module_test/rng_test_driver.c
+++ b/module_test/rng_test_driver.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -11,20 +11,6 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-/* +FHDR-----------------------------------------------------------------------
- * FILE NAME      : rng_test_driver.c
- * ----------------------------------------------------------------------------
- * LATEST : $Revision: 1.7 $ $Date: Thu Jun 22 17:56:14 2006 $
- * ----------------------------------------------------------------------------
- * KEYWORDS : RNG, Security, Test driver
- * ----------------------------------------------------------------------------
- * PURPOSE: Provide a test driver for access to the RNG driver
- * ----------------------------------------------------------------------------
- * REUSE ISSUES
- * RNGB/RNGC have different interface, but there might be some reuse
- * -FHDR-----------------------------------------------------------------------
- */
-
 /*! @file rng_test_driver.c
  *
  * @brief This is a test driver for the RNG driver.
@@ -82,396 +68,407 @@ static os_driver_reg_t reg_handle;
  *
  * This is called during module load (insmod) or kernel init.
  */
-OS_DEV_INIT(rng_test_init)
-{
-	os_error_code code;
-
+	OS_DEV_INIT(rng_test_init)
+	{
+		os_error_code code;
+	
 #ifdef RNG_DEBUG
-	os_printk("%s: Driver Initialization begins\n", RNG_TEST_DRIVER_NAME);
+		os_printk("%s: Driver Initialization begins\n", RNG_TEST_DRIVER_NAME);
 #endif
-	code = rng_test_setup_user_driver_interaction();
-
+		code = rng_test_setup_user_driver_interaction();
+	
 #ifdef RNG_DEBUG
-	os_printk("%s: Driver Completed: %d\n", RNG_TEST_DRIVER_NAME, code);
+		os_printk("%s: Driver Completed: %d\n", RNG_TEST_DRIVER_NAME, code);
 #endif
-
-	os_dev_init_return(code);
-}				/* rng_test_init */
-
-/*!*********************************************************************
- * rng_test_open()                                                     *
- **********************************************************************/
-/*!
- * Driver interface function for open() system call.
- *
- * Register the test user with the FSL SHW API.
- */
-OS_DEV_OPEN(rng_test_open)
-{
-	fsl_shw_uco_t *user_ctx = os_alloc_memory(sizeof(*user_ctx), 0);
-	os_error_code code = OS_ERROR_NO_MEMORY_S;
-
-	if (user_ctx != NULL) {
-		fsl_shw_return_t ret;
-
-		fsl_shw_uco_init(user_ctx, 20);
-		ret = fsl_shw_register_user(user_ctx);
-
-		if (ret != FSL_RETURN_OK_S) {
-			code = OS_ERROR_FAIL_S;
-		} else {
-			os_dev_set_user_private(user_ctx);
-			code = OS_ERROR_OK_S;
+	
+		os_dev_init_return(code);
+	} /* rng_test_init */
+	
+	
+	
+	/***********************************************************************
+	 * rng_test_open()													   *
+	 **********************************************************************/
+	/**
+	 * Driver interface function for open() system call.
+	 *
+	 * Register the test user with the FSL SHW API.
+	 */
+	OS_DEV_OPEN(rng_test_open)
+	{
+		fsl_shw_uco_t* user_ctx = os_alloc_memory(sizeof(*user_ctx), 0);
+		os_error_code code = OS_ERROR_NO_MEMORY_S;
+	
+		if (user_ctx != NULL) {
+			fsl_shw_return_t ret;
+	
+			fsl_shw_uco_init(user_ctx, 20);
+			ret = fsl_shw_register_user(user_ctx);
+	
+			if (ret != FSL_RETURN_OK_S) {
+				code = OS_ERROR_FAIL_S;
+			} else {
+				os_dev_set_user_private(user_ctx);
+				code = OS_ERROR_OK_S;
+			}
 		}
+	
+		os_dev_open_return(code);
 	}
-
-	os_dev_open_return(code);
-}
-
-/*!*********************************************************************
- * rng_test_ioctl()                                                    *
- **********************************************************************/
-/*!
- * Driver interface function for ioctl() system call.
- *
- * This function serves as a control for the commands being
- * passed by the application code.  Depending on what command has been
- * sent, a specific function will occur.
- *
- * This routine handles the following valid commands:
- *
- * - #RNG_GET_CONFIGURATION - Return driver, SMN, and SCM versions, memory
- sizes, block size.
- * - #RNG_READ_REG - Read register from RNG.
- * - #RNG_WRITE_REG - Write register to RNG.
- *
- * @pre Application code supplies a command with the related data (via the
- * rng_data struct)
- *
- * @post A specific action is performed based on the requested command.
- *
- * @return os_error_code
- */
-OS_DEV_IOCTL(rng_test_ioctl)
-{
-	os_error_code code = OS_ERROR_FAIL_S;
-	fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
-
-	switch (os_dev_get_ioctl_op()) {
-	case RNG_TEST_GET_RANDOM:
-		if (user_ctx != NULL) {
-			code = rng_test_get_random(user_ctx,
-						   os_dev_get_ioctl_arg());
+	
+	
+	/***********************************************************************
+	 * rng_test_ioctl() 												   *
+	 **********************************************************************/
+	/**
+	 * Driver interface function for ioctl() system call.
+	 *
+	 * This function serves as a control for the commands being
+	 * passed by the application code.	Depending on what command has been
+	 * sent, a specific function will occur.
+	 *
+	 * This routine handles the following valid commands:
+	 *
+	 * - #RNG_GET_CONFIGURATION - Return driver, SMN, and SCM versions, memory
+	 sizes, block size.
+	 * - #RNG_READ_REG - Read register from RNG.
+	 * - #RNG_WRITE_REG - Write register to RNG.
+	 *
+	 * @pre Application code supplies a command with the related data (via the
+	 * rng_data struct)
+	 *
+	 * @post A specific action is performed based on the requested command.
+	 *
+	 * @return os_error_code
+	 */
+	OS_DEV_IOCTL(rng_test_ioctl)
+	{
+		os_error_code  code = OS_ERROR_FAIL_S;
+		fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
+	
+		switch (os_dev_get_ioctl_op()) {
+		case RNG_TEST_GET_RANDOM:
+			if (user_ctx != NULL) {
+				code = rng_test_get_random(user_ctx,
+										   os_dev_get_ioctl_arg());
+			}
+			break;
+	
+		case RNG_TEST_ADD_ENTROPY:
+			if (user_ctx != NULL) {
+				code = rng_test_add_entropy(user_ctx,
+											os_dev_get_ioctl_arg());
+			}
+			break;
+	
+		case RNG_TEST_READ_REG:
+			code = rng_test_read_register(os_dev_get_ioctl_arg());
+			break;
+	
+		case RNG_TEST_WRITE_REG:
+			code = rng_test_write_register(os_dev_get_ioctl_arg());
+			break;
+	
+		default:
+			code = OS_ERROR_FAIL_S;
 		}
-		break;
-
-	case RNG_TEST_ADD_ENTROPY:
+	
+		os_dev_ioctl_return(code);
+	}
+	
+	
+	/***********************************************************************
+	 * rng_test_release()												   *
+	 **********************************************************************/
+	/**
+	 * Driver interface function for close() system call.
+	 *
+	 * De-register from the FSL SHW API.  Free associated memory.
+	 */
+	OS_DEV_CLOSE(rng_test_release)
+	{
+		fsl_shw_uco_t* user_ctx = os_dev_get_user_private();
+	
 		if (user_ctx != NULL) {
-			code = rng_test_add_entropy(user_ctx,
-						    os_dev_get_ioctl_arg());
+			fsl_shw_deregister_user(user_ctx);
+			os_free_memory(user_ctx);
+			os_dev_set_user_private(NULL);
 		}
-		break;
-
-	case RNG_TEST_READ_REG:
-		code = rng_test_read_register(os_dev_get_ioctl_arg());
-		break;
-
-	case RNG_TEST_WRITE_REG:
-		code = rng_test_write_register(os_dev_get_ioctl_arg());
-		break;
-
-	default:
-		code = OS_ERROR_FAIL_S;
-	}
-
-	os_dev_ioctl_return(code);
-}
-
-/*!*********************************************************************
- * rng_test_release()                                                  *
- **********************************************************************/
-/*!
- * Driver interface function for close() system call.
- *
- * De-register from the FSL SHW API.  Free associated memory.
- */
-OS_DEV_CLOSE(rng_test_release)
-{
-	fsl_shw_uco_t *user_ctx = os_dev_get_user_private();
-
-	if (user_ctx != NULL) {
-		fsl_shw_deregister_user(user_ctx);
-		os_free_memory(user_ctx);
-		os_dev_set_user_private(NULL);
+	
+		os_dev_close_return(OS_ERROR_OK_S);
 	}
-
-	os_dev_close_return(OS_ERROR_OK_S);
-}
-
-/*!****************************************************************************
- *
- *  Function Implementations - IOCTL support
- *
- *****************************************************************************/
-
-/*!***************************************************************************/
-/* fn rng_test_get_random()                                                  */
-/*!***************************************************************************/
-/*!
- * This function will retrieve entropy from the internal buffer of the RNG
- * driver.  If not enough entropy is available, it will SLEEP until more is
- * available.
- *
- *
- * @return                   See #rng_return_t.
- */
-static os_error_code
-rng_test_get_random(fsl_shw_uco_t * user_ctx, unsigned long rng_data)
-{
-	rng_test_get_random_t get_struct;
-	rng_return_t rng_return = -1;
-	os_error_code code = OS_ERROR_BAD_ADDRESS;
-	uint32_t *data_buffer = NULL;
-	int count_words;
-
-	if (os_copy_from_user
-	    (&get_struct, (void *)rng_data, sizeof(get_struct))) {
+	
+	
+	/******************************************************************************
+	 *
+	 *	Function Implementations - IOCTL support
+	 *
+	 *****************************************************************************/
+	
+	/*****************************************************************************/
+	/* fn rng_test_get_random() 												 */
+	/*****************************************************************************/
+	/**
+	 * This function will retrieve entropy from the internal buffer of the RNG
+	 * driver.	If not enough entropy is available, it will SLEEP until more is
+	 * available.
+	 *
+	 *
+	 * @return					 See #rng_return_t.
+	 */
+	static os_error_code
+	rng_test_get_random(fsl_shw_uco_t* user_ctx, unsigned long rng_data)
+	{
+		rng_test_get_random_t get_struct;
+		rng_return_t	 rng_return = -1;
+		os_error_code	 code = OS_ERROR_BAD_ADDRESS_S;
+		uint32_t*		 data_buffer = NULL;
+		int 			 count_words;
+	
+		if (os_copy_from_user(&get_struct, (void *)rng_data, sizeof(get_struct))) {
 #ifdef RNG_DEBUG
-		os_printk("RNG TEST: Error reading get struct from user\n");
+			os_printk("RNG TEST: Error reading get struct from user\n");
 #endif
-	} else {
-		data_buffer = os_alloc_memory(get_struct.count_bytes, 0);
-		count_words =
-		    (get_struct.count_bytes + sizeof(uint32_t) - 1) / 4;
-		rng_return =
-		    fsl_shw_get_random(user_ctx, sizeof(uint32_t) * count_words,
-				       (uint8_t *) data_buffer);
-
-		get_struct.function_return_code = rng_return;
-
-		/* Copy return code back (by copying whole request structure. */
-		code = os_copy_to_user((void *)rng_data, &get_struct,
-				       sizeof(get_struct));
-
-		/* If appropriate, copy back data. */
-		if (rng_return == RNG_RET_OK) {
-			code = os_copy_to_user(get_struct.random, data_buffer,
-					       get_struct.count_bytes);
-		}
-
-		if (data_buffer != NULL) {
-			os_free_memory(data_buffer);
+		} else {
+			data_buffer = os_alloc_memory(get_struct.count_bytes, 0);
+			count_words = (get_struct.count_bytes+sizeof(uint32_t)-1)/4;
+			rng_return = fsl_shw_get_random(user_ctx, sizeof(uint32_t)*count_words,
+											(uint8_t*) data_buffer);
+	
+			get_struct.function_return_code = rng_return;
+	
+			/* Copy return code back (by copying whole request structure. */
+			code = os_copy_to_user((void*)rng_data, &get_struct,
+								   sizeof(get_struct));
+	
+			/* If appropriate, copy back data. */
+			if (rng_return == RNG_RET_OK) {
+				code = os_copy_to_user(get_struct.random, data_buffer,
+									   get_struct.count_bytes);
+			}
+	
+			if (data_buffer != NULL) {
+				os_free_memory(data_buffer);
+			}
 		}
-	}
-
-	return code;
-}				/* rng_test_get_random */
-
-/*!***************************************************************************/
-/* fn rng_test_add_entropy()                                                */
-/*!***************************************************************************/
-/*!
- * This function will add @c randomness to the RNG.
- *
- * @param[in]  randomness       Some 'good' entropy to add to the RNG.
- *
- * @return                   See #rng_test_return_t.
- */
-static os_error_code
-rng_test_add_entropy(fsl_shw_uco_t * user_ctx, unsigned long rng_data)
-{
-	rng_test_add_entropy_t add_struct;
-	uint8_t *entropy = NULL;
-	os_error_code code;
-
-	code = os_copy_from_user(&add_struct, (void *)rng_data,
-				 sizeof(add_struct));
-	if (code != 0) {
+	
+	
+		return code;
+	} /* rng_test_get_random */
+	
+	
+	/*****************************************************************************/
+	/* fn rng_test_add_entropy()												*/
+	/*****************************************************************************/
+	/**
+	 * This function will add @c randomness to the RNG.
+	 *
+	 * @param[in]  randomness		Some 'good' entropy to add to the RNG.
+	 *
+	 * @return					 See #rng_test_return_t.
+	 */
+	static os_error_code
+	rng_test_add_entropy(fsl_shw_uco_t* user_ctx, unsigned long rng_data)
+	{
+		rng_test_add_entropy_t add_struct;
+		uint8_t*			   entropy = NULL;
+		os_error_code		   code;
+	
+		code = os_copy_from_user(&add_struct, (void *)rng_data,
+								 sizeof(add_struct));
+		if (code != 0) {
 #ifdef RNG_DEBUG
-		os_printk("RNG TEST: Error reading add struct from user\n");
+			os_printk("RNG TEST: Error reading add struct from user\n");
 #endif
-	} else {
-		entropy = os_alloc_memory(add_struct.count_bytes, 0);
-		if (entropy != NULL) {
-			add_struct.function_return_code =
-			    fsl_shw_add_entropy(user_ctx,
-						add_struct.count_bytes,
-						entropy);
-			code =
-			    os_copy_to_user((void *)rng_data, &add_struct,
-					    sizeof(add_struct));
-			os_free_memory(entropy);
 		} else {
+			entropy = os_alloc_memory(add_struct.count_bytes, 0);
+			if (entropy != NULL) {
+				add_struct.function_return_code =
+					fsl_shw_add_entropy(user_ctx, add_struct.count_bytes,
+										entropy);
+				code = os_copy_to_user((void*)rng_data, &add_struct,
+									   sizeof(add_struct));
+				os_free_memory(entropy);
+			} else {
 #ifdef RNG_DEBUG
-			os_printk
-			    ("RNG TEST: Error allocating %d bytes for entropy\n",
-			     add_struct.count_bytes);
+				os_printk("RNG TEST: Error allocating %d bytes for entropy\n",
+						  add_struct.count_bytes);
 #endif
-			code = OS_ERROR_NO_MEMORY_S;
+				code = OS_ERROR_NO_MEMORY_S;
+			}
 		}
-	}
-
-	return code;
-}				/* rng_test_add_entropy */
-
-/*!***************************************************************************/
-/* fn rng_test_read_register()                                              */
-/*!***************************************************************************/
-/*!
- * Read value from an RNG register.
- * The offset will be checked for validity (range) as well as whether it is
- * accessible at the time of the call.
- *
- * @param[in]   register_offset  The (byte) offset within the RNG block
- *                               of the register to be queried.  See
- *                               @ref rngregs for meanings.
- * @param[out]  value            Pointer to where value from the register
- *                               should be placed.
- *
- * @return                   See #rng_return_t.
- *
- */
-static os_error_code rng_test_read_register(unsigned long rng_data)
-{
-	rng_test_reg_access_t reg_struct;
-	rng_return_t rng_return = -1;
-	os_error_code code;
-
-	code = os_copy_from_user(&reg_struct, (void *)rng_data,
-				 sizeof(reg_struct));
-	if (code != OS_ERROR_OK_S) {
+	
+		return code;
+	} /* rng_test_add_entropy */
+	
+	
+	/*****************************************************************************/
+	/* fn rng_test_read_register()												*/
+	/*****************************************************************************/
+	/**
+	 * Read value from an RNG register.
+	 * The offset will be checked for validity (range) as well as whether it is
+	 * accessible at the time of the call.
+	 *
+	 * @param[in]	register_offset  The (byte) offset within the RNG block
+	 *								 of the register to be queried.  See
+	 *								 @ref rngregs for meanings.
+	 * @param[out]	value			 Pointer to where value from the register
+	 *								 should be placed.
+	 *
+	 * @return					 See #rng_return_t.
+	 *
+	 */
+	static os_error_code
+	rng_test_read_register(unsigned long rng_data)
+	{
+		rng_test_reg_access_t reg_struct;
+		rng_return_t	 rng_return = -1;
+		os_error_code	 code;
+	
+		code = os_copy_from_user(&reg_struct, (void *)rng_data,
+								 sizeof(reg_struct));
+		if (code != OS_ERROR_OK_S) {
 #ifdef RNG_DEBUG
-		os_printk("RNG TEST: Error reading reg struct from user\n");
+			os_printk("RNG TEST: Error reading reg struct from user\n");
 #endif
-	} else {
-		/* call the real driver here */
-		rng_return = rng_read_register(reg_struct.reg_offset,
-					       &reg_struct.reg_data);
-		reg_struct.function_return_code = rng_return;
-
-		code = os_copy_to_user((void *)rng_data, &reg_struct,
-				       sizeof(reg_struct));
-	}
-
-	return code;
-}				/* rng_test_read_register */
-
-/*!***************************************************************************/
-/* fn rng_test_write_register()                                             */
-/*!***************************************************************************/
-/*!
- * Write a new value into an RNG register.
- *
- * The offset will be checked for validity (range) as well as whether it is
- * accessible at the time of the call.
- *
- * @param[in]  register_offset  The (byte) offset within the RNG block
- *                              of the register to be modified.  See
- *                              @ref rngregs for meanings.
- * @param[in]  value            The value to store into the register.
- *
- * @return                   See #rng_test_return_t.
- *
- */
-static os_error_code rng_test_write_register(unsigned long rng_data)
-{
-	rng_test_reg_access_t reg_struct;
-	rng_return_t rng_return = -1;
-	os_error_code code;
-
-	/* Try to copy user's reg_struct */
-	code = os_copy_from_user(&reg_struct, (void *)rng_data,
-				 sizeof(reg_struct));
-	if (code != OS_ERROR_OK_S) {
+		} else {
+			/* call the real driver here */
+			rng_return = rng_read_register(reg_struct.reg_offset,
+										   &reg_struct.reg_data);
+			reg_struct.function_return_code = rng_return;
+	
+			code = os_copy_to_user((void *)rng_data, &reg_struct,
+								   sizeof(reg_struct));
+		}
+	
+		return code;
+	} /* rng_test_read_register */
+	
+	
+	/*****************************************************************************/
+	/* fn rng_test_write_register() 											*/
+	/*****************************************************************************/
+	/**
+	 * Write a new value into an RNG register.
+	 *
+	 * The offset will be checked for validity (range) as well as whether it is
+	 * accessible at the time of the call.
+	 *
+	 * @param[in]  register_offset	The (byte) offset within the RNG block
+	 *								of the register to be modified.  See
+	 *								@ref rngregs for meanings.
+	 * @param[in]  value			The value to store into the register.
+	 *
+	 * @return					 See #rng_test_return_t.
+	 *
+	 */
+	static os_error_code
+	rng_test_write_register(unsigned long rng_data)
+	{
+		rng_test_reg_access_t reg_struct;
+		rng_return_t	 rng_return = -1;
+		os_error_code	 code;
+	
+		/* Try to copy user's reg_struct */
+		code = os_copy_from_user(&reg_struct, (void *)rng_data,
+								 sizeof(reg_struct));
+		if (code != OS_ERROR_OK_S) {
 #ifdef RNG_DEBUG
-		os_printk("RNG TEST: Error reading reg struct from user\n");
+			os_printk("RNG TEST: Error reading reg struct from user\n");
 #endif
-	} else {
-		/* call the real driver here */
-		rng_return = rng_write_register(reg_struct.reg_offset,
-						reg_struct.reg_data);
-		reg_struct.function_return_code = rng_return;
-		code = os_copy_to_user((void *)rng_data, &reg_struct,
-				       sizeof(reg_struct));
-	}
-
-	return code;
-}				/* rng_test_write_register */
-
-/*!****************************************************************************
- *
- *  Function Implementations - Strictly Internal
- *
- *****************************************************************************/
-
-/*!***************************************************************************/
-/* fn setup_user_driver_interaction()                                        */
-/*!***************************************************************************/
-/*!
- * Register the driver as the driver for #RNG_TEST_MAJOR_NODE
- *
- * If RNG_TEST_MAJOR_NODE is zero, then make sure that #rng_test_major_node
- * has the registered node value.
- */
-static os_error_code rng_test_setup_user_driver_interaction(void)
-{
-	os_error_code code = OS_ERROR_FAIL_S;
-
-	os_driver_init_registration(reg_handle);
-	os_driver_add_registration(reg_handle, OS_FN_OPEN,
-				   OS_DEV_IOCTL_REF(rng_test_open));
-	os_driver_add_registration(reg_handle, OS_FN_IOCTL,
-				   OS_DEV_IOCTL_REF(rng_test_ioctl));
-	os_driver_add_registration(reg_handle, OS_FN_CLOSE,
-				   OS_DEV_IOCTL_REF(rng_test_release));
-	code = os_driver_complete_registration(reg_handle,
-					       rng_test_major_node,
-					       RNG_TEST_DRIVER_NAME);
-
-	if (code != OS_ERROR_OK_S) {
-		/* failure ! */
+		} else {
+			/* call the real driver here */
+			rng_return = rng_write_register(reg_struct.reg_offset,
+											reg_struct.reg_data);
+			reg_struct.function_return_code = rng_return;
+			code = os_copy_to_user((void *)rng_data, &reg_struct,
+								   sizeof(reg_struct));
+		}
+	
+		return code;
+	} /* rng_test_write_register */
+	
+	
+	
+	/******************************************************************************
+	 *
+	 *	Function Implementations - Strictly Internal
+	 *
+	 *****************************************************************************/
+	
+	
+	/*****************************************************************************/
+	/* fn setup_user_driver_interaction()										 */
+	/*****************************************************************************/
+	/**
+	 * Register the driver as the driver for #RNG_TEST_MAJOR_NODE
+	 *
+	 * If RNG_TEST_MAJOR_NODE is zero, then make sure that #rng_test_major_node
+	 * has the registered node value.
+	 */
+	static os_error_code
+	rng_test_setup_user_driver_interaction(void)
+	{
+		os_error_code code = OS_ERROR_FAIL_S;
+	
+		os_driver_init_registration(reg_handle);
+		os_driver_add_registration(reg_handle, OS_FN_OPEN,
+								   OS_DEV_IOCTL_REF(rng_test_open));
+		os_driver_add_registration(reg_handle, OS_FN_IOCTL,
+								   OS_DEV_IOCTL_REF(rng_test_ioctl));
+		os_driver_add_registration(reg_handle, OS_FN_CLOSE,
+								   OS_DEV_IOCTL_REF(rng_test_release));
+		code = os_driver_complete_registration(reg_handle,
+											   rng_test_major_node,
+											   RNG_TEST_DRIVER_NAME);
+	
+		if (code != OS_ERROR_OK_S) {
+			/* failure ! */
 #ifdef RNG_DEBUG
-		os_printk("RNG Test: register device driver failed: %d\n",
-			  code);
+			os_printk ("RNG Test: register device driver failed: %d\n", code);
 #endif
-	} else {		/* success */
-		rng_device_registered = 1;
+		} else {					  /* success */
+			rng_device_registered = 1;
 #ifdef RNG_DEBUG
-		os_printk("RNG Test:  Major node is %d\n",
-			  os_dev_driver_major_node(reg_handle));
+			os_printk("RNG Test:  Major node is %d\n",
+					  os_dev_driver_major_node(reg_handle));
 #endif
-	}			/* else success */
-
-	return code;
-}				/* rng_test_setup_user_driver_interaction */
-
-/*!***************************************************************************/
-/* fn rng_test_cleanup()                                                    */
-/*!***************************************************************************/
-/*!
- * Prepare driver for exit.
- *
- * This is called during @c rmmod when the driver is unloading.  Try to undo
- * whatever was done during #rng_test_init(), to make the machine be in the
- * same state, if possible.
- *
- * Mask off RNG interrupts.  Put the RNG to sleep?
- */
-OS_DEV_SHUTDOWN(rng_test_cleanup)
-{
-	os_error_code code = OS_ERROR_OK_S;
-
-	if (rng_device_registered) {
-		/* turn off the mapping to the device special file */
-		code = os_driver_remove_registration(reg_handle);
-		rng_device_registered = 0;
-	}
+		} /* else success */
+	
+		return code;
+	} /* rng_test_setup_user_driver_interaction */
+	
+	
+	/*****************************************************************************/
+	/* fn rng_test_cleanup()													*/
+	/*****************************************************************************/
+	/**
+	 * Prepare driver for exit.
+	 *
+	 * This is called during @c rmmod when the driver is unloading.  Try to undo
+	 * whatever was done during #rng_test_init(), to make the machine be in the
+	 * same state, if possible.
+	 *
+	 * Mask off RNG interrupts.  Put the RNG to sleep?
+	 */
+	OS_DEV_SHUTDOWN(rng_test_cleanup)
+	{
+		os_error_code code = OS_ERROR_OK_S;
+	
+		if (rng_device_registered) {
+			/* turn off the mapping to the device special file */
+			code = os_driver_remove_registration(reg_handle);
+			rng_device_registered = 0;
+		}
+	
 #ifdef RNG_DEBUG
-	os_printk("RNG Test: Cleaned up\n");
+		os_printk ("RNG Test: Cleaned up\n");
 #endif
+	
+		os_dev_shutdown_return(code);
+	} /* rng_test_cleanup */
 
-	os_dev_shutdown_return(code);
-}				/* rng_test_cleanup */
 
 MODULE_DESCRIPTION("Test Module for MXC drivers");
 MODULE_LICENSE("GPL");
diff --git a/module_test/scc2_test_driver.c b/module_test/scc2_test_driver.c
new file mode 100644
index 0000000..251bb39
--- /dev/null
+++ b/module_test/scc2_test_driver.c
@@ -0,0 +1,669 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All rights reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+ * @file scc2_test_driver.c
+ * @brief This is a test driver for the SCC2.
+ *
+ * This driver and its associated reference test program are intended
+ * to demonstrate the use of the SCC2 block in various ways.
+ *
+ * The driver runs in a Linux environment.  Portation notes are
+ * included at various points which should be helpful in moving the
+ * code to a different environment.
+ *
+ */
+
+#include "../include/scc2_test_driver.h"
+
+
+MODULE_AUTHOR("Freescale Semiconductor");
+MODULE_DESCRIPTION("Test Device Driver for SCC2 (SMN/SCM) Driver");
+
+MODULE_LICENSE("GPL");
+
+/** Create a place to track/notify sleeping processes */
+DECLARE_WAIT_QUEUE_HEAD(waitQueue);
+
+OS_DEV_INIT_DCL(scc2_test_init);
+OS_DEV_SHUTDOWN_DCL(scc2_test_cleanup);
+OS_DEV_OPEN_DCL(scc2_test_open);
+OS_DEV_IOCTL_DCL(scc2_test_ioctl);
+OS_DEV_CLOSE_DCL(scc2_test_release);
+
+static os_driver_reg_t reg_handle;
+
+/** The /dev/node value for user-kernel interaction */
+int scc2_test_major_node = 0;
+
+
+/** saved-off pointer of configuration information */
+scc_config_t* scc_cfg;
+
+static int scc2_test_get_configuration(unsigned long scc_data);
+static int scc2_test_read_register(unsigned long scc_data);
+static int scc2_test_write_register(unsigned long scc_data);
+static os_error_code setup_user_driver_interaction(void);
+static void scc2_test_report_failure(void);
+
+static int scc2_test_alloc_part(unsigned long scc_data);
+static int scc2_test_engage_part(unsigned long scc_data);
+static int scc2_test_encrypt_part(unsigned long cmd, unsigned long scc_data);
+static int scc2_test_release_part(unsigned long scc_data);
+static int scc2_test_load_data(unsigned long scc_data);
+static int scc2_test_read_data(unsigned long scc_data);
+
+extern int scc2_test_major_node;
+
+
+/***********************************************************************
+ * scc2_test_init()                                                    *
+ **********************************************************************/
+/**
+ * Driver interface function which initializes the Linux device driver.
+ *
+ * It registers the SCC character device, sets up the base address for
+ * the SCC, and registers interrupt handlers.  It is called during
+ * insmod(8).  The interface is defined by the Linux DDI/DKI.
+ *
+ * @return This function returns 0 upon success or a (negative) errno
+ * code on failure.
+ *
+ * @todo An appropriate "major" number must be selected, or generated
+ * automatically (along with mknod() call!?)
+ */
+OS_DEV_INIT(scc2_test_init)
+{
+    os_error_code      error_code = 0;
+    uint32_t smn_status;
+
+    /* call the real driver here */
+    scc_cfg = scc_get_configuration();
+
+    /* call the real driver here */
+    if (! (error_code = scc_read_register(SMN_STATUS_REG, &smn_status))) {
+
+        /* set up driver as character driver */
+        if (! (error_code = setup_user_driver_interaction())) {
+
+            /* Determine status of SCC */
+            if ((smn_status & SMN_STATUS_STATE_MASK) == SMN_STATE_FAIL) {
+                printk("SCC2 TEST Driver: SCC is in Fail mode\n");
+            }
+            else {
+                printk("SCC2 TEST Driver: Ready\n");
+            }
+        }
+        else {
+        }
+    }
+    else {
+        printk("SCC2 TEST: Could not read SMN_STATUS register: %d\n",
+               error_code);
+    }
+
+    scc_monitor_security_failure(scc2_test_report_failure);
+
+    /* any errors, we must undo what we've done */
+    if (error_code) {
+        scc2_test_cleanup();
+    }
+
+    os_dev_init_return(error_code);
+}
+
+
+/***********************************************************************
+ * scc2_test_open()                                                   *
+ **********************************************************************/
+/**
+ * Driver interface function for open() system call.
+ *
+ * This function increments the "IN USE" count.  It is called during
+ * an open().  The interface is defined by the Linux DDI/DKI.
+ *
+ * @return 0 if successful, error code if not
+ */
+OS_DEV_OPEN(scc2_test_open)
+{
+    os_dev_open_return(OS_ERROR_OK_S);
+}
+
+
+/***********************************************************************
+ * scc2_test_release()                                                 *
+ **********************************************************************/
+/**
+ * Driver interface function for close() system call.
+ *
+ * This function decrements the "IN USE" count.  It is called during a
+ * close().  The interface is defined by the Linux DDI/DKI.
+ *
+ *
+ * @return 0 (always - errors are ignored)
+ */
+OS_DEV_CLOSE(scc2_test_release)
+{
+    os_dev_close_return(OS_ERROR_OK_S);
+}
+
+
+/***********************************************************************
+ * scc2_test_cleanup()                                                 *
+ **********************************************************************/
+/**
+ * Driver interface function for unloading the device driver.
+ *
+ * This function is called during rmmod(8).  The interface is defined
+ * by the Linux DDI/DKI.
+ *
+ * It deregisters the SCC character device, unmaps memory, and
+ * deregisters the interrupt handler(s).
+ *
+ * Called by the kernel during an @c rmmod(8) operation, but also
+ * during error handling from #scc2_test_init().
+ *
+ */
+OS_DEV_SHUTDOWN(scc2_test_cleanup)
+{
+    os_driver_remove_registration(reg_handle);
+
+    pr_debug("SCC2 TEST: Cleaned up\n");
+
+    os_dev_shutdown_return(TRUE);
+}
+
+
+/***********************************************************************
+ * scc2_test_ioctl()                                                   *
+ **********************************************************************/
+/**
+ * Driver interface function for ioctl() system call.
+ *
+ * This function serves as a control for the commands being
+ * passed by the application code.  Depending on what command has been
+ * sent, a specific function will occur.  The interface is defined by
+ * the Linux DDI/DKI.
+ *
+ * This routine handles the following valid commands:
+ *
+ * - #SCC2_GET_CONFIGURATION - Return driver, SMN, and SCM versions, memory
+      sizes, block size.
+ * - #SCC_READ_REG - Read register from SCC.
+ * - #SCC2_WRITE_REG - Write register to SCC.
+ * - #SCC2_ENCRYPT - Encrypt Red memory into Black memory.
+ * - #SCC2_DECRYPT - Decrypt Black memory into Red memory.
+ *
+ * @pre Application code supplies a command with the related data (via the
+ * scc_data struct)
+ *
+ * @post A specific action is performed based on the requested command.
+ *
+ * @return 0 or an error code (IOCTL_SCC2_xxx)
+ */
+OS_DEV_IOCTL(scc2_test_ioctl)
+{
+    os_error_code error_code = OS_ERROR_OK_S;
+    unsigned cmd = os_dev_get_ioctl_op();
+    unsigned long scc_data = os_dev_get_ioctl_arg();
+
+    switch (cmd) {
+    case SCC2_TEST_GET_CONFIGURATION:
+        error_code = scc2_test_get_configuration(scc_data);
+        break;
+
+    case SCC2_TEST_READ_REG:
+        error_code = scc2_test_read_register(scc_data);
+        break;
+
+    case SCC2_TEST_WRITE_REG:
+        error_code = scc2_test_write_register(scc_data);
+        break;
+
+    case SCC2_TEST_SET_ALARM:
+        scc_set_sw_alarm();     /* call the real driver here */
+        break;
+
+    case SCC2_TEST_ALLOC_PART:
+        error_code = scc2_test_alloc_part(scc_data);
+        break;
+
+    case SCC2_TEST_ENGAGE_PART:
+        error_code = scc2_test_engage_part(scc_data);
+        break;
+
+    case SCC2_TEST_ENCRYPT_PART:
+    case SCC2_TEST_DECRYPT_PART:
+        error_code = scc2_test_encrypt_part(cmd, scc_data);
+        break;
+
+    case SCC2_TEST_LOAD_PART:
+        error_code = scc2_test_load_data(scc_data);
+        break;
+
+    case SCC2_TEST_READ_PART:
+        error_code = scc2_test_read_data(scc_data);
+        break;
+
+    case SCC2_TEST_RELEASE_PART:
+        error_code = scc2_test_release_part(scc_data);
+        break;
+
+    default:
+#ifdef SCC2_DEBUG
+        printk("SCC2 TEST: Error in ioctl(): (0x%x) is an invalid "
+               "command (0x%x,0x%x)\n", cmd, SCC2_TEST_GET_CONFIGURATION,
+               SCC2_TEST_ALLOC_SLOT);
+        printk("uint64 is %d, alloc is %d\n", sizeof(uint64_t),
+               sizeof(scc_alloc_slot_access));
+#endif
+        error_code = -IOCTL_SCC2_INVALID_CMD;
+        break;
+
+    } /* End switch */
+
+    os_dev_ioctl_return(error_code);
+}
+
+
+/***********************************************************************
+ * scc2_test_get_configuration()                                       *
+ **********************************************************************/
+/**
+ * Internal routine to handle ioctl command #SCC2_GET_CONFIGURATION.
+ *
+ * @param scc_data Address is user space of scc_configuration_access
+ * which is passed with the ioctl() system call.
+ *
+ * @return 0 on success, IOCTL_xxx on failure.
+ *
+ * This function does not access the SCC, it just passes up static,
+ * previously retrieved information.
+ *
+ */
+static int
+scc2_test_get_configuration(unsigned long scc_data)
+{
+    int error_code = IOCTL_SCC2_OK;
+
+#ifdef SCC2_DEBUG
+    printk("SCC2 TEST: Configuration\n");
+#endif
+
+    /* now copy out (write) the data into user space */
+    /** @todo make sure scc_get_configuration never returns null! */
+    if (copy_to_user((void *)scc_data, scc_get_configuration(),
+                     sizeof(scc_config_t))) {
+#ifdef SCC2_DEBUG
+        printk("SCC2 TEST: Error writing data to user\n");
+#endif
+        error_code = -IOCTL_SCC2_IMPROPER_ADDR;
+    }
+
+    return error_code;
+
+} /* scc2_get_configuration */
+
+
+/***********************************************************************
+ * scc2_test_read_register()                                           *
+ **********************************************************************/
+/**
+ * Read a register value from the SCC.
+ *
+ * @param scc_data The address in user memory of the scc_reg_access struct
+ * passed in the ioctl().
+ *
+ * @return 0 for success, an error code on failure.
+ */
+static int
+scc2_test_read_register(unsigned long scc_data)
+{
+    scc_reg_access reg_struct;
+    scc_return_t   scc_return = -1;
+    int            error_code = IOCTL_SCC2_OK;
+    unsigned long  retval;
+
+    if (copy_from_user(&reg_struct, (void *)scc_data, sizeof(reg_struct))) {
+#ifdef SCC2_DEBUG
+        printk("SCC2 TEST: Error reading reg struct from user\n");
+#endif
+        error_code = -IOCTL_SCC2_IMPROPER_ADDR;
+    }
+
+    else {
+        /* call the real driver here */
+        scc_return = scc_read_register(reg_struct.reg_offset,
+                                       &reg_struct.reg_data);
+        if (scc_return != SCC_RET_OK) {
+            error_code = -IOCTL_SCC2_IMPROPER_ADDR;
+        }
+    }
+
+    reg_struct.function_return_code = scc_return;
+    retval = copy_to_user((void *)scc_data, &reg_struct, sizeof(reg_struct));
+    return error_code;
+}
+
+
+/***********************************************************************
+ * scc2_test_write_register()                                          *
+ **********************************************************************/
+/**
+ * Write a register value to the SCC.
+ *
+ * @param scc_data The address in user memory of the scc_reg_access struct
+ * passed in the ioctl().
+ *
+ * @return 0 for success, an error code on failure.
+ */
+static int
+scc2_test_write_register(unsigned long scc_data) {
+    scc_reg_access reg_struct;
+    scc_return_t   scc_return = -1;
+    int            error_code = IOCTL_SCC2_OK;
+    unsigned long  retval;
+
+    /* Try to copy user's reg_struct */
+    if (copy_from_user(&reg_struct, (void *)scc_data, sizeof(reg_struct))) {
+#ifdef SCC2_DEBUG
+        printk("SCC2 TEST: Error reading reg struct from user\n");
+#endif
+        error_code = -IOCTL_SCC2_IMPROPER_ADDR;
+    }
+    else {
+
+        /* call the real driver here */
+        scc_return = scc_write_register(reg_struct.reg_offset,
+                                        reg_struct.reg_data);
+        if (scc_return != SCC_RET_OK) {
+            error_code = -IOCTL_SCC2_IMPROPER_ADDR;
+        }
+    }
+
+    reg_struct.function_return_code = scc_return;
+    retval = copy_to_user((void *)scc_data, &reg_struct, sizeof(reg_struct));
+    return error_code;
+}
+
+
+/*****************************************************************************/
+/* fn scc2_test_alloc_part()                                                 */
+/*****************************************************************************/
+static int
+scc2_test_alloc_part(unsigned long scc_data)
+{
+    scc_partition_access acc;
+    int status;
+
+    status = copy_from_user(&acc, (void*)scc_data, sizeof(acc));
+
+    if (status == 0) {
+        acc.scc_status = scc_allocate_partition(acc.smid,
+                                                 &acc.part_no,
+                                                 (void*)&acc.virt_address,
+                                                 &acc.phys_address);
+        status = copy_to_user((void*)scc_data, &acc, sizeof(acc));
+    }
+
+    return status;
+}
+
+
+/*****************************************************************************/
+/* fn scc2_test_engage_part()                                                */
+/*****************************************************************************/
+static int
+scc2_test_engage_part(unsigned long scc_data)
+{
+    uint8_t umid[16];
+    scc_partition_access acc;
+    int status;
+    uint8_t* umid_ptr = NULL;
+
+    printk(KERN_ALERT "calling copy_from_user\n");
+    status = copy_from_user(&acc, (void*)scc_data, sizeof(acc));
+
+    if (status == 0) {
+        if (acc.umid != NULL) {
+            printk(KERN_ALERT "calling copy_from_user\n");
+            status = copy_from_user(umid, acc.umid, 16);
+            umid_ptr = umid;
+        }
+        if (status == 0) {
+            printk(KERN_ALERT "calling engage_partition\n");
+            acc.scc_status = scc_engage_partition((void*)acc.virt_address,
+                                                   umid_ptr,
+                                                   acc.permissions);
+            status = copy_to_user((void*)scc_data, &acc, sizeof(acc));
+        }
+    }
+
+    return status;
+}
+
+
+/*****************************************************************************/
+/* fn do_encrypt_part()                                                      */
+/*****************************************************************************/
+static int
+do_encrypt_part(scc_part_cipher_access* acc, uint8_t* local_black,
+                dma_addr_t black_phys)
+{
+    int status;
+    uint32_t IV[4];
+    uint32_t* iv_ptr = (uint32_t*)&(acc->iv);
+    
+    /* Build the IV */
+    IV[0] = iv_ptr[0];
+    IV[1] = iv_ptr[1];
+    IV[2] = 0;
+    IV[3] = 0;
+
+    /* Perform the red -> black encryption */
+    acc->scc_status = scc_encrypt_region(acc->virt_address, acc->red_offset,
+                                         acc->size_bytes, (void*)black_phys,
+                                         IV, SCC_CYPHER_MODE_CBC);
+
+    /* Copy the result to user's memory */
+    status = copy_to_user(acc->black_address, local_black, acc->size_bytes);
+
+    return status;
+}
+
+/*****************************************************************************/
+/* fn do_decrypt_part()                                                      */
+/*****************************************************************************/
+static int
+do_decrypt_part(scc_part_cipher_access* acc, uint8_t* local_black,
+                dma_addr_t black_phys)
+{
+    int status;
+    uint32_t IV[4];
+    uint32_t* iv_ptr = (uint32_t*)&(acc->iv);
+    
+    /* Build the IV */
+    IV[0] = iv_ptr[0];
+    IV[1] = iv_ptr[1];
+    IV[2] = 0;
+    IV[3] = 0;
+
+    /* Copy the black data from user's memory */
+    status = copy_from_user(local_black, acc->black_address, acc->size_bytes);
+
+    if (status == 0) {
+        /* Perform the black -> red decryption */
+        acc->scc_status = scc_decrypt_region(acc->virt_address, acc->red_offset,
+                                             acc->size_bytes, (void*)black_phys,
+                                             IV, SCC_CYPHER_MODE_CBC);
+    }
+
+    return status;
+}
+
+
+/*****************************************************************************/
+/* fn scc2_test_encrypt_part()                                               */
+/*****************************************************************************/
+static int
+scc2_test_encrypt_part(unsigned long cmd, unsigned long scc_data)
+{
+    scc_part_cipher_access acc;
+    int status;
+
+    status = copy_from_user(&acc, (void*)scc_data, sizeof(acc));
+
+    if (status == 0) {
+        dma_addr_t black_phys;
+        void* black = (void*)dma_alloc_coherent(NULL, acc.size_bytes, &black_phys, GFP_USER);
+
+        if (black == NULL) {
+            status = IOCTL_SCC2_NO_MEMORY;
+        }
+
+        if (status == 0) {
+            if (cmd == SCC2_TEST_ENCRYPT_PART) {
+                status = do_encrypt_part(&acc, black, black_phys);
+            }
+            else {
+                status = do_decrypt_part(&acc, black, black_phys);
+            }
+        }
+
+        if (black != NULL) {
+            dma_free_coherent(NULL, acc.size_bytes, black, black_phys);
+        }
+        if (status == 0) {
+            status = copy_to_user((void*)scc_data, &acc, sizeof(acc));
+        }
+    }
+
+    return status;
+
+
+}
+
+static int
+scc2_test_load_data(unsigned long scc_data)
+{
+    scc_part_cipher_access acc;
+    int status;
+
+    status = copy_from_user(&acc, (void*)scc_data, sizeof(acc));
+    if (status == 0) {
+        status = copy_from_user((void*)acc.virt_address + acc.red_offset,
+                                acc.black_address,
+                                acc.size_bytes);
+        acc.scc_status = SCC_RET_OK;
+    }
+
+    return status;
+}
+
+
+static int
+scc2_test_read_data(unsigned long scc_data)
+{
+    scc_part_cipher_access acc;
+    int status;
+
+    status = copy_from_user(&acc, (void*)scc_data, sizeof(acc));
+    if (status == 0) {
+        status = copy_to_user(acc.black_address,
+                              (void*)acc.virt_address + acc.red_offset,
+                              acc.size_bytes);
+        acc.scc_status = SCC_RET_OK;
+    }
+
+    return status;
+}
+
+
+/*****************************************************************************/
+/* fn scc2_test_release_part()                                               */
+/*****************************************************************************/
+static int
+scc2_test_release_part(unsigned long scc_data)
+{
+    scc_partition_access acc;
+    int status;
+
+    status = copy_from_user(&acc, (void*)scc_data, sizeof(acc));
+
+    if (status == 0) {
+        acc.scc_status = scc_release_partition((void*)acc.virt_address);
+        status = copy_to_user((void*)scc_data, &acc, sizeof(acc));
+    }
+
+    return status;
+}
+
+
+/*****************************************************************************/
+/* fn setup_user_driver_interaction()                                        */
+/*****************************************************************************/
+/**
+ * Register the driver with the kernel.
+ *
+ * Call @c register_chrdev() to set this driver up as being
+ * responsible for the SCC.  Save the major number for the driver
+ * in scc2_test_major_node.
+ *
+ * Called from #scc2_test_init()
+ *
+ * @return 0 on success, -errno on failure.
+ */
+static os_error_code
+setup_user_driver_interaction(void)
+{
+    os_error_code code = OS_ERROR_OK_S;
+
+    os_driver_init_registration(reg_handle);
+    os_driver_add_registration(reg_handle, OS_FN_OPEN,
+                               OS_DEV_OPEN_REF(scc2_test_open));
+    os_driver_add_registration(reg_handle, OS_FN_IOCTL,
+                               OS_DEV_IOCTL_REF(scc2_test_ioctl));
+    os_driver_add_registration(reg_handle, OS_FN_CLOSE,
+                               OS_DEV_CLOSE_REF(scc2_test_release));
+    code = os_driver_complete_registration(reg_handle, scc2_test_major_node,
+                                               SCC2_TEST_DRIVER_NAME);
+
+    if (code != OS_ERROR_OK_S) {
+        /* failure ! */
+        os_printk("SCC2 TEST Driver: register device driver failed: %d\n",
+                  code);
+
+        return code;
+    }
+
+    /* Save the major node value */
+    if (scc2_test_major_node == 0) {
+        /* We passed in a zero value, then one was assigned to us.  */
+        scc2_test_major_node = code;
+    }
+
+    pr_debug("SCC2 TEST Driver:  Major node is %d\n", scc2_test_major_node);
+
+    return code;
+}
+
+
+/*****************************************************************************/
+/* fn scc2_test_report_failure()                                             */
+/*****************************************************************************/
+/** Let the console know that the SCC has reported a security failure */
+static void
+scc2_test_report_failure(void)
+{
+    printk("SCC2 TEST Driver: SMN reported alarm\n");
+}
diff --git a/test/mxc_rng_test/Makefile b/test/mxc_rng_test/Makefile
index c21bab4..2038be8 100644
--- a/test/mxc_rng_test/Makefile
+++ b/test/mxc_rng_test/Makefile
@@ -28,6 +28,9 @@ endif
 ifeq ("$(PLATFORM)", "MXC91131EVB")
 TARGET_ARCH=-DCONFIG_ARCH_MXC91131
 endif
+ifeq ("$(PLATFORM)", "IMX37_3STACK")
+TARGET_ARCH=-DCONFIG_ARCH_MX37
+endif
 
 # Location of local headers and API "common" sources
 INCLUDEDIR= -I. -I../../include -I../mxc_sahara_test $(INC)
diff --git a/test/mxc_rng_test/rng_test.c b/test/mxc_rng_test/rng_test.c
index 339e438..b6c5b31 100644
--- a/test/mxc_rng_test/rng_test.c
+++ b/test/mxc_rng_test/rng_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -11,20 +11,6 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-/* +FHDR-----------------------------------------------------------------------
- * FILE NAME      : scc_test.c
- * ----------------------------------------------------------------------------
- * LATEST : $Revision: 1.7 $ $Date: Tue Jun 27 16:07:18 2006 $
- * ----------------------------------------------------------------------------
- * KEYWORDS : RNG Security, Linux driver
- * ----------------------------------------------------------------------------
- * PURPOSE: Provide a test program for access to RNG driver
- * ----------------------------------------------------------------------------
- * REUSE ISSUES
- * RNGB/RNGC may require some changes
- * -FHDR-----------------------------------------------------------------------
- */
-
 /*!
  * @file rng_test.c
  * This is a reference test program for the RNG block.
@@ -87,7 +73,7 @@ void rngAddEntropy(int device, uint32_t entropy);
 void rngAddUserEntropy(fsl_shw_uco_t * user_context, uint32_t entropy);
 
 /* utility print functions */
-void printEntropy(const char *data, size_t count);
+void printEntropy(const unsigned char *data, size_t count);
 void printRngStatusRegister(const uint32_t status);
 void printRngControlRegister(const uint32_t status);
 
@@ -316,7 +302,7 @@ int writeRngRegister(int device, uint32_t address, uint32_t value)
 
 void rngGetEntropy(int device, int byte_count)
 {
-	char *entropy;
+	unsigned char *entropy;
 	ssize_t error_code = -EIO;
 
 	if (byte_count < 0) {
@@ -354,7 +340,7 @@ void rngGetEntropy(int device, int byte_count)
 
 void rngGetUserEntropy(fsl_shw_uco_t * ctx, int byte_count)
 {
-	char *entropy;
+	unsigned char *entropy;
 	fsl_shw_return_t code;
 
 	if (byte_count < 0) {
@@ -402,11 +388,11 @@ void rngAddUserEntropy(fsl_shw_uco_t * ctx, uint32_t entropy)
 	}
 }
 
-void printEntropy(const char *data, size_t count)
+void printEntropy(const unsigned char *data, size_t count)
 {
-	const int valuesPerLine = 20;
+	const unsigned int valuesPerLine = 20;
 
-	int i;
+	unsigned int i;
 	for (i = 0; i < count; i++) {
 		printf("%02x ", *data++);
 		if (i % valuesPerLine == valuesPerLine - 1) {
@@ -480,11 +466,72 @@ void printRngControlRegister(const uint32_t control)
 }
 
 #else				/* RNGC ... */
+
+typedef struct registerNames_t
+{
+    uint32_t code;
+    char* name;
+} registerNames_t;
+
+registerNames_t RNGCStatusNames[] =
+    {{RNGC_STATUS_SEC_STATE,        "SecureState"},
+     {RNGC_STATUS_BUSY,             "Busy"},
+     {RNGC_STATUS_SLEEP,            "Sleeping"},
+     {RNGC_STATUS_RESEED,           "ReseedRequired"},
+     {RNGC_STATUS_ST_DONE,          "SelfTestDone"},
+     {RNGC_STATUS_SEED_DONE,        "SeedDone"},
+     {RNGC_STATUS_NEXT_SEED_DONE,   "NextSeedDone"},
+     {RNGC_STATUS_ERROR,            "Error"},
+     {RNGC_STATUS_ST_PF_PRNG,       "PRNGSelfTestFail"},
+     {RNGC_STATUS_ST_PF_TRNG,       "TRNGSelfTestFail"}};
+
+#define RNGCSTATUSNAMESLENGTH                                               \
+    sizeof(RNGCStatusNames)/sizeof(registerNames_t)
+
 void printRngStatusRegister(const uint32_t status)
 {
+    uint32_t i;
+	printf("RNGC Status: 0x%08x: ", status);
+
+    for (i = 0; i < RNGCSTATUSNAMESLENGTH; i++) {
+        if (status & RNGCStatusNames[i].code) {
+            printf("%s, ", RNGCStatusNames[i].name);
+        }
+    }
+    printf("\n");
+
+	printf("SelfTest: 0x%02x\n",
+	       (status & RNGC_STATUS_STAT_TEST_PF_MASK) >>
+	       RNGC_STATUS_STAT_TEST_PF_SHIFT);
+	printf("fifo level: %d, fifo size: %d\n",
+	       (status & RNGC_STATUS_FIFO_LEVEL_MASK) >>
+	       RNGC_STATUS_FIFO_LEVEL_SHIFT,
+	       (status & RNGC_STATUS_FIFO_SIZE_MASK) >>
+	       RNGC_STATUS_FIFO_SIZE_SHIFT);
+
 }
 
+registerNames_t RNGCControlNames[] =
+    {{RNGC_CONTROL_AUTO_SEED,       "AutoSeed"},
+     {RNGC_CONTROL_MASK_DONE,       "MaskDone"},
+     {RNGC_CONTROL_MASK_ERROR,      "MaskError"},
+     {RNGC_CONTROL_VERIF_MODE,      "VerificationMode"},
+     {RNGC_CONTROL_CTL_ACC,         "ControlAccessMode"}};
+
+#define RNGCCONTROLNAMESLENGTH                                              \
+    sizeof(RNGCStatusNames)/sizeof(registerNames_t)
+
 void printRngControlRegister(const uint32_t control)
 {
+    uint32_t i;
+	printf("RNGC Control: 0x%08x: ", control);
+
+    for (i = 0; i < RNGCCONTROLNAMESLENGTH; i++) {
+        if (control & RNGCControlNames[i].code) {
+            printf("%s, ", RNGCControlNames[i].name);
+        }
+    }
+    printf("\n");
 }
+
 #endif				/* RNGA or RNGC */
diff --git a/test/mxc_scc/scc_test.c b/test/mxc_scc/scc_test.c
index 42da637..a70b997 100644
--- a/test/mxc_scc/scc_test.c
+++ b/test/mxc_scc/scc_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
  */
 
 /*
@@ -11,27 +11,6 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-/* +FHDR-----------------------------------------------------------------------
- * FILE NAME      : scc_test.c
- * DEPARTMENT     : Security Technology Center (STC), NCSG
- * AUTHOR         : Ron Harvey (r66892)
- * ----------------------------------------------------------------------------
- * REVIEW(S) :
- * ----------------------------------------------------------------------------
- * RELEASE HISTORY
- * VERSION DATE       AUTHOR       DESCRIPTION
- * 0.0.1   2004-12-02 R. Harvey    Initial version
- * 0.0.8   2005-03-08 R. Harvey    Implementation complete
- * ----------------------------------------------------------------------------
- * KEYWORDS : SCC, SMN, SCM, Security, Linux driver
- * ----------------------------------------------------------------------------
- * PURPOSE: Provide a program to test the SCC (Security Controller) driver
- * ----------------------------------------------------------------------------
- * REUSE ISSUES
- * Version 2 of the SCC block will look a lot different
- * -FHDR-----------------------------------------------------------------------
- */
-
 /**
  * @file scc_test.c
  * @brief This is a test program for the SCC driver.
@@ -52,7 +31,7 @@
 #include <stdarg.h>
 
 #include <inttypes.h>
-#include "scc_test.h"
+#include "../include/scc_test_driver.h"
 
 
 /* test routines */
@@ -80,7 +59,7 @@ void print_smn_command_register(const uint32_t);
 void print_scc_debug_detector_register(uint32_t);
 void print_scc_return_code(const scc_return_t);
 void dump_cipher_control_block(scc_encrypt_decrypt*);
-int do_slot_function(int device, char* arg);
+int do_slot_function(int device, char *arg);
 
 /* utility register access functions */
 int write_scc_register(int device, uint32_t address, uint32_t value);
@@ -112,11 +91,11 @@ uint8_t plaintext[4096] = {0xca, 0xbb, 0xad, 0xba,
 void
 init_plaintext()
 {
-    int i;
+    uint32_t i;
 
     /* Starting after precompiled values, fill up the rest */
     for (i = 24; i < sizeof(plaintext); i++) {
-        plaintext[i] = i%256;
+        plaintext[i] = i % 256;
     }
 }
 
@@ -165,8 +144,8 @@ scc_configuration_access *get_scc_configuration(int);
  ****************************************************************************/
 int
 main(int arg_count,             /* # command-line arguments */
-     char*arg_list[])            /* pointers to command-line arguments */
-{ 
+     char *arg_list[])            /* pointers to command-line arguments */
+{
     /* Declare and initialize variables */
     int scc_fd;                 /* The SCC device */
     char *scc_device_path = "/dev/scc_test";
@@ -179,7 +158,7 @@ main(int arg_count,             /* # command-line arguments */
 #if 0
     int one = 1;                /* little-endian test vector */
 #endif
-    
+
     init_plaintext();
 
 #if 0
@@ -200,8 +179,8 @@ main(int arg_count,             /* # command-line arguments */
     }
 
     /* Process command line arguments - until we come up empty */
-    while ( (argument_switch = getopt(arg_count, arg_list, "K:L:MP:R:S:T:W:"))
-            != EOF ) {
+    while ((argument_switch = getopt(arg_count, arg_list, "K:L:MP:R:S:T:W:"))
+            != EOF) {
         switch (argument_switch) {
         case 'K':               /* Key slot functions */
             test_status |= do_slot_function(scc_fd, optarg);
@@ -437,7 +416,7 @@ main(int arg_count,             /* # command-line arguments */
         default:
             fprintf(stderr, "Test switch %c unknown\n", test_switch);
         }
-        
+
     }
 
     close(scc_fd);
@@ -450,7 +429,7 @@ main(int arg_count,             /* # command-line arguments */
 void
 display_configuration(int scc_fd) {
     scc_configuration_access *config;
-    
+
     config = get_scc_configuration(scc_fd);
     if (config == NULL) {
         perror("\nCannot display SCC Configuration");
@@ -863,7 +842,7 @@ run_cipher_tests(int scc_fd)
             read_scc_register(scc_fd, SMN_STATUS, &value);
             printf("SMN Status                  (0x%08x): ", value);
             print_smn_status_register(value);
-  
+
             read_scc_register(scc_fd, SCM_ERROR_STATUS, &value);
             printf("SCM Error Register          (0x%08x):", value);
             print_scc_error_status_register(value);
@@ -882,7 +861,7 @@ run_cipher_tests(int scc_fd)
             cipher_control.data_out = new_plaintext;
             cipher_control.data_out_length = plaintext_length +
                 decrypt_padding_allowance;
-        
+
             if (inject_crc_error) {
                 ciphertext[rand()%cipher_control.data_in_length] ^= 1;
             }
@@ -934,7 +913,7 @@ run_cipher_tests(int scc_fd)
                     printf("SCM Error Register          (0x%08x):", value);
                     print_scc_error_status_register(value);
                 }
- 
+
                 if (cipher_control.data_out_length != plaintext_length) {
                     printf("Error:  input plaintext length (%d) and output "
                            "plaintext length (%ld) do not match.\n",
@@ -1022,7 +1001,7 @@ run_aic_tests(int scc_fd) {
     printf("SMN Status: ");
     print_smn_status_register(value);
 
-    
+
     return 0;
 }
 
@@ -1130,8 +1109,8 @@ read_scc_register(int device, /* OS device connect */
 /***********************************************************************
  get_scc_configuration()
  **********************************************************************/
-scc_configuration_access*
-get_scc_configuration(int scc_fd) {
+scc_configuration_access
+*get_scc_configuration(int scc_fd) {
     static scc_configuration_access *config = NULL;
     int status;
 
@@ -1196,8 +1175,8 @@ run_wrap_tests (int scc_fd)
     scc_get_slot_info_access info_acc;
     scc_encrypt_slot_access unload_acc;
     int slot_allocated = 0;
-    
-    strcpy((char*)key,"abcdefgh");
+
+    strcpy((char *)key,"abcdefgh");
 
     alloc_acc.owner_id = owner1;
     alloc_acc.value_size_bytes = 8;
@@ -1219,7 +1198,7 @@ run_wrap_tests (int scc_fd)
         load_acc.slot = alloc_acc.slot;
         load_acc.owner_id = owner1;
         load_acc.key_is_red = 1;
-        load_acc.key_data = (uint8_t*)key;
+        load_acc.key_data = (uint8_t *)key;
         load_acc.key_data_length = alloc_acc.value_size_bytes;
         status = ioctl(scc_fd, SCC_TEST_LOAD_SLOT, &load_acc);
         if (status != 0) {
@@ -1228,7 +1207,7 @@ run_wrap_tests (int scc_fd)
             if (load_acc.scc_status != SCC_RET_OK) {
                 printf("Red value load returned %d\n", load_acc.scc_status);
                 status = 1;
-            }                
+            }
         }
     }
 
@@ -1270,7 +1249,7 @@ run_wrap_tests (int scc_fd)
             }
         }
     }
-                            
+
     /* Now unload the key */
     if (status == 0) {
         unload_acc.slot = alloc_acc.slot;
@@ -1290,7 +1269,7 @@ run_wrap_tests (int scc_fd)
             }
         }
     }
-    
+
     /* Reacquire a slot */
     if ((status == 0) && !slot_allocated) {
         status = ioctl(scc_fd, SCC_TEST_ALLOC_SLOT, &alloc_acc);
@@ -1379,7 +1358,7 @@ run_wrap_tests (int scc_fd)
  * @param arg      Argument associated with slot request
  */
 int
-do_slot_function(int scc_fd, char* arg)
+do_slot_function(int scc_fd, char *arg)
 {
     int status = 1;
     char request = *arg++;
@@ -1612,10 +1591,10 @@ print_smn_status_register(uint32_t status)
 {
     int version_id;
     uint8_t state;
-          
+
     version_id = (status&SMN_STATUS_VERSION_ID_MASK)
         >> SMN_STATUS_VERSION_ID_SHIFT;
-    state = (status&SMN_STATUS_STATE_MASK) >> SMN_STATUS_STATE_SHIFT; 
+    state = (status&SMN_STATUS_STATE_MASK) >> SMN_STATUS_STATE_SHIFT;
 
     printf("Version %d %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s, State: %s\n",
            version_id,
@@ -1645,10 +1624,9 @@ print_smn_status_register(uint32_t status)
 
 
 /** Interpret the state (a field of the SMN State register) and return its
- *  name 
+ *  name
 **/
-char *
-get_smn_state_name(const uint8_t state)
+char *get_smn_state_name(const uint8_t state)
 {
     switch (state) {
     case SMN_STATE_START:
@@ -1688,7 +1666,7 @@ print_scm_status_register(uint32_t status)
            (status&SCM_STATUS_CIPHERING) ? ", CIPHERING" : "",
            (status&SCM_STATUS_ZEROIZING) ? ", ZEROIZING" : "",
            (status&SCM_STATUS_BUSY) ? ", BUSY" : "");
-           
+
 
 }
 
@@ -1698,9 +1676,9 @@ void
 print_scm_control_register(uint32_t control)
 {
     printf("%s%s%s\n",
-           ((control&SCM_CONTROL_CIPHER_MODE_MASK)==SCM_DECRYPT_MODE) ? 
+           ((control&SCM_CONTROL_CIPHER_MODE_MASK)==SCM_DECRYPT_MODE) ?
            "DECRYPT " : "ENCRYPT ",
-           ((control&SCM_CONTROL_CHAINING_MODE_MASK)==SCM_CBC_MODE) ? 
+           ((control&SCM_CONTROL_CHAINING_MODE_MASK)==SCM_CBC_MODE) ?
            "CBC " : "ECB ",
            (control&SCM_CONTROL_START_CIPHER) ? "CipherStart":"");
 }
@@ -1725,7 +1703,7 @@ print_scc_error_status_register(uint32_t error)
            (error&SCM_ERR_CIPHERING) ? ", CIPHERING" : "",
            (error&SCM_ERR_ZEROIZING) ? ", ZEROIZING" : "",
            (error&SCM_ERR_BUSY) ? ", BUSY" : "");
-           
+
 }
 
 
diff --git a/test/mxc_scc2/Makefile b/test/mxc_scc2/Makefile
new file mode 100644
index 0000000..88a76cb
--- /dev/null
+++ b/test/mxc_scc2/Makefile
@@ -0,0 +1,21 @@
+# list of platforms which did not want this test case
+EXCLUDE_LIST:="IMX21ADS IMX27_ADS IMX31_ADS IMX31_3STACK IMX35_3STACK"
+
+ifeq (,$(findstring $(PLATFORM), $(EXCLUDE_LIST)))
+OBJS = $(OBJDIR)/scc2_test.out $(OBJDIR)/autorun-scc2.sh
+else
+OBJS =
+endif
+
+all : $(OBJS)
+	cp -r *.sh $(OBJDIR)
+
+.PHONY: clean
+clean :
+	rm -f $(OBJ)
+
+#
+# include the Rules
+#
+include ../make.rules
+
diff --git a/test/mxc_scc2/autorun-scc2.sh b/test/mxc_scc2/autorun-scc2.sh
new file mode 100644
index 0000000..20dff3e
--- /dev/null
+++ b/test/mxc_scc2/autorun-scc2.sh
@@ -0,0 +1,18 @@
+#!/bin/sh
+PATH=$PATH:/unit_tests/modules:$PWD
+source /unit_tests/test-utils.sh
+
+#
+# Exit status is 0 for PASS, nonzero for FAIL
+#
+STATUS=0
+
+# Inserting the SCC Module.
+insmod_test /lib/modules/$(kernel_version)/test/scc2_test_driver.ko
+
+run_testcase ./partition_tests.sh
+run_testcase ./fail_mode_tests.sh
+
+print_status
+exit $STATUS
+
diff --git a/test/mxc_scc2/fail_mode_tests.sh b/test/mxc_scc2/fail_mode_tests.sh
new file mode 100644
index 0000000..793595d
--- /dev/null
+++ b/test/mxc_scc2/fail_mode_tests.sh
@@ -0,0 +1,64 @@
+#!/bin/sh
+# Initialize the test accounting environment
+. test_subs.sh
+
+. scc2_setup.sh
+
+setup_offsets
+
+# Dump all registers
+pos_test scc2_test.out -Lr
+
+
+# Verify that a register can be written and does change
+start_test Changing SCM_CIPHER_BLACK_START register to 4
+scc2_test.out -W${SCM_CIPHER_BLACK_START}:4
+length_value=`scc2_test.out -S+Q -R${SCM_CIPHER_BLACK_START}`
+if [  -z $length_value ]; then
+    record_failure Reading result of changed SCM_CIPHER_BLACK_START failed.
+else
+    if [ $length_value -eq 4 ]; then
+	record_success Verified result of changed SCM_CIPHER_BLACK_START.
+    else
+	record_failure Read of SCM_CIPHER_BLACK_START return $length_value.
+    fi
+fi
+
+# Verify it can changed to something else
+start_test Changing SCM_CIPHER_BLACK_START register to 8
+scc2_test.out -W${SCM_CIPHER_BLACK_START}:8
+length_value=`scc2_test.out -S+Q -R${SCM_CIPHER_BLACK_START}`
+if [  -z $length_value ]; then
+    record_failure Reading result of changed SCM_CIPHER_BLACK_START failed.
+else
+    if [ $length_value -eq 8 ]; then
+	record_success Verified result of changed SCM_CIPHER_BLACK_START.
+    else
+	record_failure Read of SCM_CIPHER_BLACK_START return $length_value.
+    fi
+fi
+
+
+# This will invoke the Software Alarm and put the SMN into FAIL mode
+pos_test scc2_test.out -La
+
+
+# Read all 'safe' registers when SCC has gone to alarm/FAILED state
+pos_test scc2_test.out -Ls
+
+
+# Check that the state has transitioned to FAIL as expected
+start_test Testing that the SCC state has transitioned to FAIL
+status_value=`scc2_test.out -S+Q -R${SMN_STATUS}`
+if [  -z $status_value ]; then
+    record_failure Reading SMN_STATUS register failed
+else
+    if [ $((0x$status_value & 9)) -eq 9 ]; then
+	record_success Part transitioned to FAIL state properly
+    else
+	record_failure Read of SMN_STATUS return $status_value.
+    fi
+fi
+
+# Let the world know how things went
+print_test_results
diff --git a/test/mxc_scc2/fsl_platform.h b/test/mxc_scc2/fsl_platform.h
new file mode 100644
index 0000000..c60eb04
--- /dev/null
+++ b/test/mxc_scc2/fsl_platform.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fsl_platform.h
+ *
+ * Header file to isolate code which might be platform-dependent
+ */
+
+#ifndef FSL_PLATFORM_H
+#define FSL_PLATFORM_H
+
+#ifdef __KERNEL__
+#include "portable_os.h"
+#endif
+
+#if defined(FSL_PLATFORM_OTHER)
+
+/* Have Makefile or other method of setting FSL_HAVE_* flags */
+
+#elif defined(CONFIG_ARCH_MX3)	/* i.MX31 */
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_RNGA
+
+#elif defined(CONFIG_ARCH_MX21)
+
+#define FSL_HAVE_HAC
+#define FSL_HAVE_RNGA
+#define FSL_HAVE_SCC
+
+#elif defined(CONFIG_ARCH_MX27)
+
+#define FSL_HAVE_SAHARA2
+#define SUBMIT_MULTIPLE_DARS
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_SCC
+#define USE_OLD_PTRS
+
+#elif defined(CONFIG_ARCH_MXC91131)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGA
+#define FSL_HAVE_HAC
+
+#elif defined(CONFIG_ARCH_MXC91221)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_RTIC2
+
+#elif defined(CONFIG_ARCH_MXC91231)
+
+#define FSL_HAVE_SAHARA2
+#define USE_OLD_PTRS
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_SCC
+#define NO_OUTPUT_1K_CROSSING
+
+#elif defined(CONFIG_ARCH_MXC91311)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGC
+
+#elif defined(CONFIG_ARCH_MXC91321)
+
+#define FSL_HAVE_SAHARA2
+#define FSL_HAVE_RTIC
+#define FSL_HAVE_SCC
+#define NO_OUTPUT_1K_CROSSING
+#define USE_OLD_PTRS
+
+#elif defined(CONFIG_ARCH_MXC92323)
+
+#define FSL_HAVE_SCC2
+#define FSL_HAVE_SAHARA4
+#define FSL_HAVE_RTIC2
+#define NO_1K_CROSSING
+#define NO_RESEED_WORKAROUND
+#define NEED_CTR_WORKAROUND
+#define USE_3WORD_BURST
+
+#elif  defined(CONFIG_ARCH_MXC91331)
+
+#define FSL_HAVE_SCC
+#define FSL_HAVE_RNGA
+#define FSL_HAVE_HAC
+#define FSL_HAVE_RTIC
+
+#elif defined(CONFIG_8548)
+
+#define FSL_HAVE_SEC2x
+
+#elif defined(CONFIG_MPC8374)
+
+#define FSL_HAVE_SEC3x
+
+#elif defined(CONFIG_ARCH_MX37)
+
+#define FSL_HAVE_SCC2
+#define FSL_HAVE_RNGC
+#define FSL_HAVE_RTIC2
+#define NO_1K_CROSSING
+#define NO_RESEED_WORKAROUND
+#define NEED_CTR_WORKAROUND
+#define USE_S2_CCM_ENCRYPT_CHAIN
+#define USE_S2_CCM_DECRYPT_CHAIN
+
+#else
+
+/*#error UNKNOWN_PLATFORM*/
+#define UNKNOWN_PLATFORM
+
+
+#endif				/* platform checks */
+
+#endif				/* FSL_PLATFORM_H */
diff --git a/test/mxc_scc2/fsl_shw.h b/test/mxc_scc2/fsl_shw.h
new file mode 100644
index 0000000..dbb6d13
--- /dev/null
+++ b/test/mxc_scc2/fsl_shw.h
@@ -0,0 +1,1966 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * NOTE TO MAINTAINERS: Although this header file is *the* header file to be
+ * #include'd by FSL SHW programs, it does not itself make any definitions for
+ * the API.  Instead, it use te fsl_platform.h file and / or compiler
+ * environment variables to determine which actual driver header file to
+ * include.  This allows different implementations to contain different
+ * implementations of the various objects, macros, etc., or even to change
+ * which functions are macros and which are not.
+ */
+
+/*!
+ * @file fsl_shw.h
+ *
+ * @brief Definition of the Freescale Security Hardware API.
+ *
+ * See @ref index for an overview of the API.
+ */
+
+/*!
+ * @if USE_MAINPAGE
+ * @mainpage Common API for Freescale Security Hardware (FSL SHW API)
+ * @endif
+ *
+ * @section intro_sec Introduction
+ *
+ * This is the interface definition for the Freescale Security Hardware API
+ * (FSL SHW API) for User Mode and Kernel Mode to access Freescale Security
+ * Hardware components for cryptographic acceleration. The API is intended to
+ * provide cross-platform access to security hardware components of Freescale.
+ *
+ * This documentation has not been approved, and should not be taken to
+ * mean anything definite about future direction.
+ *
+ * Some example code is provided to give some idea of usage of this API.
+ *
+ * Note: This first version has been defined around the capabilities of the
+ * Sahara2 cryptographic accelerator, and may be expanded in the future to
+ * provide support for other platforms.  The Platform Capabilities Object is
+ * intended as a way to allow programs to adapt to different platforms.
+ *
+ *
+ * @section usr_ctx The User Context
+ *
+ * The User Context Object (#fsl_shw_uco_t) controls the interaction between
+ * the user program and the API.  It is initialized as part of user
+ * registration (#fsl_shw_register_user()), and is part of every interaction
+ * thereafter.
+ *
+ * @section pf_sec Platform Capababilities
+ *
+ * Since this API is not tied to one specific type of hardware or even one
+ * given version of a given type of hardware, the platform capabilities object
+ * could be used by a portable program to make choices about using software
+ * instead of hardware for certain operations.
+ *
+ * See the #fsl_shw_pco_t, returned by #fsl_shw_get_capabilities().
+ *
+ * @ref pcoops are provided to query its contents.
+ *
+ *
+ * @section sym_sec Symmetric-Key Encryption and Decryption
+ *
+ * Symmetric-Key encryption support is provided for the block cipher algorithms
+ * AES, DES, and Triple DES.  Modes supported are #FSL_SYM_MODE_ECB,
+ * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR, though not necessarily all modes
+ * for all algorithms.  There is also support for the stream cipher algorithm
+ * commonly known as ARC4.
+ *
+ * Encryption and decryption are performed by using the functions
+ * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt(), respectively.
+ * There are two objects which provide information about the operation of these
+ * functions.  They are the #fsl_shw_sko_t, to provide key and algorithm
+ * information; and the #fsl_shw_scco_t, to provide (and store) initial context
+ * or counter value information.
+ *
+ * CCM is not supported by these functions.  For information CCM support, see
+ * @ref cmb_sec.
+ *
+ *
+ * @section hash_sec Cryptographic Hashing
+ *
+ * Hashing is performed by fsl_shw_hash(). Control of the function is through
+ * flags in the #fsl_shw_hco_t.  The algorithms which are
+ * supported are listed in #fsl_shw_hash_alg_t.
+ *
+ * The hashing function works on octet streams.  If a user application needs to
+ * hash a bitstream, it will need to do its own padding of the last block.
+ *
+ *
+ * @section hmac_sec Hashed Message Authentication Codes
+ *
+ * An HMAC is a method of combining a hash and a key so that a message cannot
+ * be faked by a third party.
+ *
+ * The #fsl_shw_hmac() can be used by itself for one-shot or multi-step
+ * operations, or in combination with #fsl_shw_hmac_precompute() to provide the
+ * ability to compute and save the beginning hashes from a key one time, and
+ * then use #fsl_shw_hmac() to calculate an HMAC on each message as it is
+ * processed.
+ *
+ * The maximum key length which is directly supported by this API is 64 octets.
+ * If a longer key size is needed for HMAC, the user will have to hash the key
+ * and present the digest value as the key to be used by the HMAC functions.
+ *
+ *
+ * @section rnd_sec Random Numbers
+ *
+ * Support is available for acquiring random values from a
+ * cryptographically-strong random number generator.  See
+ * #fsl_shw_get_random().  The function #fsl_shw_add_entropy() may be used to
+ * add entropy to the random number generaator.
+ *
+ *
+ * @section cmb_sec Combined Cipher and Authentication
+ *
+ * Some schemes require that messages be encrypted and that they also have an
+ * authentication code associated with the message. The function
+ * #fsl_shw_gen_encrypt() will generate the authentication code and encrypt the
+ * message.
+ *
+ * Upon receipt of such a message, the message must be decrypted and the
+ * authentication code validated.  The function
+ * #fsl_shw_auth_decrypt() will perform these steps.
+ *
+ * Only AES-CCM is supported.
+ *
+ *
+ * @section Wrapped Keys
+ *
+ * On platforms with a Secure Memory, the function #fsl_shw_establish_key() can
+ * be used to place a key into the Secure Memory.  This key then be used
+ * directly by the cryptographic hardware.  It later then be wrapped
+ * (cryptographically obscured) by #fsl_shw_extract_key() and stored for later
+ * use.
+ *
+ * The wrapping and unwrapping functions provide security against unauthorized
+ * use and detection of tampering.
+ */
+
+/*! @defgroup glossary Glossary
+ *
+ * @li @b AES - Advanced Encryption Standard - An NIST-created block cipher
+ *          originally knowns as Rijndael.
+ * @li @b ARC4 - ARCFOUR - An S-Box-based OFB mode stream cipher.
+ * @li @b CBC - Cipher-Block Chaining - Each encrypted block is XORed with the
+ *          result of the previous block's encryption.
+ * @li @b CCM - A way of combining CBC and CTR to perform cipher and
+ *        authentication.
+ * @li @b ciphertext - @a plaintext which has been encrypted in some fashion.
+ * @li @b context - Information on the state of a cryptographic operation,
+ *        excluding any key.  This could include IV, Counter Value, or SBox.
+ * @li @b CTR - A mode where a counter value is encrypted and then XORed with
+ *        the data.  After each block, the counter value is incremented.
+ * @li @b DES - Data Encryption Standard - An 8-octet-block cipher.
+ * @li @b ECB - Electronic Codebook - A straight encryption/decryption of the
+ *        data.
+ * @li @b hash - A cryptographically strong one-way function peformed on data.
+ * @li @b HMAC - Hashed Message Authentication Code - A key-dependent one-way
+ *        hash result, used to verify authenticity of a message.  The equation
+ *        for an HMAC is hash((K + A) || hash((K + B) || msg)), where K is the
+ *        key, A is the constant for the outer hash, B is the constant for the
+ *        inner hash, and hash is the hashing function (MD5, SHA256, etc).
+ * @li @b IPAD - In an HMAC operation, the context generated by XORing the key
+ *        with a constant and then hashing that value as the first block of the
+ *        inner hash.
+ * @li @b IV - An "Initial Vector" or @a context for modes like CBC.
+ * @li @b MAC - A Message Authentication Code.  HMAC, hashing, and CCM all
+ *        produce a MAC.
+ * @li @b mode  - A way of using a cryptographic algorithm.  See ECB, CBC, etc.
+ * @li @b MD5 - Message Digest 5 - A one-way hash function.
+ * @li @b plaintext - Data which has not been encrypted, or has been decrypted
+ *        from @a ciphertext.
+ * @li @b OPAD - In an HMAC operation, the context generated by XORing the key
+ *        with a constant and then hashing that value as the first block of the
+ *        outer hash.
+ * @li @b SHA - Secure Hash Algorithm - A one-way hash function.
+ * @li @b TDES - AKA @b 3DES - Triple Data Encryption Standard - A method of
+ *        using two or three keys and DES to perform three operations (encrypt
+ *        decrypt encrypt) to create a new algorithm.
+ * @li @b XOR - Exclusive-OR.  A Boolean arithmetic function.
+ * @li @b Wrapped value - A (key) which has been encrypted into an opaque datum
+ *        which cannot be unwrapped (decrypted) for use except by an authorized
+ *        user.  Once created, the key is never visible, but may be used for
+ *        other cryptographic operations.
+ */
+
+#ifndef FSL_SHW_H
+#define FSL_SHW_H
+
+/* Set FSL_HAVE_* flags */
+
+#include "fsl_platform.h"
+#include "sahara.h"
+
+
+#ifndef API_DOC
+
+#if defined(FSL_HAVE_SAHARA2) || defined(FSL_HAVE_SAHARA4)
+
+#include "sahara.h"
+
+#else
+
+#if defined(FSL_HAVE_RNGA) || defined(FSL_HAVE_RNGC)
+
+#include "rng_driver.h"
+
+#else
+
+#define FSL_SHW_API_platform_not_recognized
+
+#endif
+
+#endif				/* HAVE_SAHARA2 */
+
+#else				/* API_DOC */
+
+#include <inttypes.h>		/* for uint32_t, etc. */
+#include <stdio.h>		/* Mainly for definition of NULL !! */
+
+/* These groups will appear in the order in which they are defined. */
+
+/*!
+ * @defgroup strgrp Objects
+ *
+ * These objects are used to pass information into and out of the API.  Through
+ * flags and other settings, they control the behavior of the @ref opfuns.
+ *
+ * They are maninpulated and queried by use of the various access functions.
+ * There are different sets defined for each object.  See @ref objman.
+ */
+
+/*!
+ * @defgroup consgrp Enumerations and other Constants
+ *
+ * This collection of symbols comprise the values which can be passed into
+ * various functions to control how the API will work.
+ */
+
+/*! @defgroup opfuns Operational Functions
+ *
+ * These functions request that the underlying hardware perform cryptographic
+ * operations.  They are the heart of the API.
+ */
+
+/******  Organization the Object Operations under one group ! **********/
+/*! @defgroup objman Object-Manipulation Operations
+ *
+ */
+/*! @addtogroup objman
+    @{ */
+/*!
+ * @defgroup pcoops Platform Context Object Operations
+ *
+ * The Platform Context object is "read-only", so only query operations are
+ * provided for it.  It is returned by the #fsl_shw_get_capabilities()
+ * function.
+ */
+
+/*! @defgroup ucoops User Context Operations
+ *
+ * These operations should be the only access to the #fsl_shw_uco_t
+ * type/struct, as the internal members of the object are subject to change.
+ * The #fsl_shw_uco_init() function must be called before any other use of the
+ * object.
+ */
+
+/*!
+ * @defgroup rops Result Object Operations
+ *
+ * As the Result Object contains the result of one of the @ref opfuns.  The
+ * manipulations provided are query-only.  No initialization is needed for this
+ * object.
+ */
+
+/*!
+ * @defgroup skoops Secret Key Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_sko_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup hcops Hash Context Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_hco_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup hmcops HMAC Context Object Operations
+ *
+ * These operations should be the only access to the #fsl_shw_hmco_t
+ * type/struct, as the internal members of that object are subject to change.
+ */
+
+/*!
+ * @defgroup sccops Symmetric Cipher Context Operations
+ *
+ * These operations should be the only access to the #fsl_shw_scco_t
+ * type/struct, as the internal members of that object are subject to change
+ */
+
+/*! @defgroup accoops Authentication-Cipher Context Object Operations
+ *
+ * These functions operate on a #fsl_shw_acco_t.  Their purpose is to set
+ * flags, fields, etc., in order to control the operation of
+ * #fsl_shw_gen_encrypt() and #fsl_shw_auth_decrypt().
+ */
+
+	 /* @} *//************ END GROUPING of Object Manipulations *****************/
+
+/*! @defgroup miscfuns Miscellaneous Functions
+ *
+ * These functions are neither @ref opfuns nor @ref objman.  Their behavior
+ * does not depend upon the flags in the #fsl_shw_uco_t, yet they may involve
+ * more interaction with the library and the kernel than simply querying an
+ * object.
+ */
+
+/******************************************************************************
+ * Enumerations
+ *****************************************************************************/
+/*! @addtogroup consgrp
+    @} */
+
+/*!
+ * Flags for the state of the User Context Object (#fsl_shw_uco_t).
+ *
+ * These flags describe how the @ref opfuns will operate.
+ */
+typedef enum fsl_shw_user_ctx_flags {
+	FSL_UCO_BLOCKING_MODE,	/*!< API will block the caller until operation
+				   completes.  The result will be available in the
+				   return code.  If this is not set, user will have
+				   to get results using #fsl_shw_get_results(). */
+	FSL_UCO_CALLBACK_MODE,	/*!< User wants callback (at the function specified
+				   with #fsl_shw_uco_set_callback()) when the
+				   operation completes.  This flag is valid only if
+				   #FSL_UCO_BLOCKING_MODE is not set. */
+} fsl_shw_user_ctx_flags_t;
+
+/*!
+ * Return code for FSL_SHW library.
+ *
+ * These codes may be returned from a function call.  In non-blocking mode,
+ * they will appear as the status in a Result Object.
+ */
+typedef enum fsl_shw_return {
+	FSL_RETURN_OK_S = 0,	/*!< No error.  As a function return code in
+				   Non-blocking mode, this may simply mean that
+				   the operation was accepted for eventual
+				   execution. */
+	FSL_RETURN_ERROR_S,	/*!< Failure for non-specific reason. */
+	FSL_RETURN_NO_RESOURCE_S,	/*!< Operation failed because some resource was
+					   not able to be allocated. */
+	FSL_RETURN_BAD_ALGORITHM_S,	/*!< Crypto algorithm unrecognized or
+					   improper. */
+	FSL_RETURN_BAD_MODE_S,	/*!< Crypto mode unrecognized or improper. */
+	FSL_RETURN_BAD_FLAG_S,	/*!< Flag setting unrecognized or
+				   inconsistent. */
+	FSL_RETURN_BAD_KEY_LENGTH_S,	/*!< Improper or unsupported key length for
+					   algorithm. */
+	FSL_RETURN_BAD_KEY_PARITY_S,	/*!< Improper parity in a (DES, TDES) key. */
+	FSL_RETURN_BAD_DATA_LENGTH_S,	/*!< Improper or unsupported data length for
+					   algorithm or internal buffer. */
+	FSL_RETURN_AUTH_FAILED_S,	/*!< Authentication failed in
+					   authenticate-decrypt operation. */
+	FSL_RETURN_MEMORY_ERROR_S,	/*!< A memory error occurred. */
+	FSL_RETURN_INTERNAL_ERROR_S	/*!< An error internal to the hardware
+					   occurred. */
+} fsl_shw_return_t;
+
+/*!
+ * Algorithm Identifier.
+ *
+ * Selection of algorithm will determine how large the block size of the
+ * algorithm is.   Context size is the same length unless otherwise specified.
+ * Selection of algorithm also affects the allowable key length.
+ */
+typedef enum fsl_shw_key_alg {
+	FSL_KEY_ALG_HMAC,	/*!< Key will be used to perform an HMAC.  Key
+				   size is 1 to 64 octets.  Block size is 64
+				   octets. */
+	FSL_KEY_ALG_AES,	/*!< Advanced Encryption Standard (Rijndael).
+				   Block size is 16 octets.  Key size is 16
+				   octets.  (The single choice of key size is a
+				   Sahara platform limitation.) */
+	FSL_KEY_ALG_DES,	/*!< Data Encryption Standard.  Block size is
+				   8 octets.  Key size is 8 octets. */
+	FSL_KEY_ALG_TDES,	/*!< 2- or 3-key Triple DES.  Block size is 8
+				   octets.  Key size is 16 octets for 2-key
+				   Triple DES, and 24 octets for 3-key. */
+	FSL_KEY_ALG_ARC4	/*!< ARC4.  No block size.  Context size is 259
+				   octets.  Allowed key size is 1-16 octets.
+				   (The choices for key size are a Sahara
+				   platform limitation.) */
+} fsl_shw_key_alg_t;
+
+/*!
+ * Mode selector for Symmetric Ciphers.
+ *
+ * The selection of mode determines how a cryptographic algorithm will be
+ * used to process the plaintext or ciphertext.
+ *
+ * For all modes which are run block-by-block (that is, all but
+ * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
+ * length which is multiple of the block size.  Except for #FSL_SYM_MODE_CTR,
+ * these block-by-block algorithms must also be passed a total number of octets
+ * which is a multiple of the block size.
+ *
+ * In modes which require that the total number of octets of data be a multiple
+ * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
+ * has a total number of octets which are not a multiple of the block size, the
+ * user must perform any necessary padding to get to the correct data length.
+ */
+typedef enum fsl_shw_sym_mode {
+	/*!
+	 * Stream.  There is no associated block size.  Any request to process data
+	 * may be of any length.  This mode is only for ARC4 operations, and is
+	 * also the only mode used for ARC4.
+	 */
+	FSL_SYM_MODE_STREAM,
+
+	/*!
+	 * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+	 * length of the data stream must be a multiple of the block size.  This
+	 * mode may be used for DES, 3DES, and AES.  The block size is determined
+	 * by the algorithm.
+	 */
+	FSL_SYM_MODE_ECB,
+	/*!
+	 * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+	 * then "chained" with the previous block by an XOR function.  Requires
+	 * context to start the XOR (previous block).  This mode may be used for
+	 * DES, 3DES, and AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CBC,
+	/*!
+	 * Counter.  The counter is encrypted, then XORed with a block of data.
+	 * The counter is then incremented (using modulus arithmetic) for the next
+	 * block. The final operation may be non-multiple of block size.  This mode
+	 * may be used for AES.  The block size is determined by the algorithm.
+	 */
+	FSL_SYM_MODE_CTR,
+} fsl_shw_sym_mode_t;
+
+/*!
+ * Algorithm selector for Cryptographic Hash functions.
+ *
+ * Selection of algorithm determines how large the context and digest will be.
+ * Context is the same size as the digest (resulting hash), unless otherwise
+ * specified.
+ */
+typedef enum fsl_shw_hash_alg {
+	FSL_HASH_ALG_MD5,	/*!< MD5 algorithm.  Digest is 16 octets. */
+	FSL_HASH_ALG_SHA1,	/*!< SHA-1 (aka SHA or SHA-160) algorithm.
+				   Digest is 20 octets. */
+	FSL_HASH_ALG_SHA224,	/*!< SHA-224 algorithm.  Digest is 28 octets,
+				   though context is 32 octets. */
+	FSL_HASH_ALG_SHA256	/*!< SHA-256 algorithm.  Digest is 32
+				   octets. */
+} fsl_shw_hash_alg_t;
+
+/*!
+ * The type of Authentication-Cipher function which will be performed.
+ */
+typedef enum fsl_shw_acc_mode {
+	/*!
+	 * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
+	 * be non-multiple of block size.  This mode may be used for AES.
+	 */
+	FSL_ACC_MODE_CCM
+} fsl_shw_acc_mode_t;
+
+/*!
+ * The operation which controls the behavior of #fsl_shw_establish_key().
+ *
+ * These values are passed to #fsl_shw_establish_key().
+ */
+typedef enum fsl_shw_key_wrap {
+	FSL_KEY_WRAP_CREATE,	/*!< Generate a key from random values. */
+	FSL_KEY_WRAP_ACCEPT,	/*!< Use the provided clear key. */
+	FSL_KEY_WRAP_UNWRAP	/*!< Unwrap a previously wrapped key. */
+} fsl_shw_key_wrap_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Flags which control a Hash operation.
+ *
+ *  These may be combined by ORing them together.  See #fsl_shw_hco_set_flags()
+ * and #fsl_shw_hco_clear_flags().
+ */
+typedef enum fsl_shw_hash_ctx_flags {
+	FSL_HASH_FLAGS_INIT = 1,	/*!< Context is empty.  Hash is started
+					   from scratch, with a message-processed
+					   count of zero. */
+	FSL_HASH_FLAGS_SAVE = 2,	/*!< Retrieve context from hardware after
+					   hashing.  If used with the
+					   #FSL_HASH_FLAGS_FINALIZE flag, the final
+					   digest value will be saved in the
+					   object. */
+	FSL_HASH_FLAGS_LOAD = 4,	/*!< Place context into hardware before
+					   hashing. */
+	FSL_HASH_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final digest
+					   operation.  If user message is
+					   pre-padded, this flag should not be
+					   used. */
+} fsl_shw_hash_ctx_flags_t;
+
+/*!
+ * Flags which control an HMAC operation.
+ *
+ * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
+ * and #fsl_shw_hmco_clear_flags().
+ */
+typedef enum fsl_shw_hmac_ctx_flags {
+	FSL_HMAC_FLAGS_INIT = 1,	/*!< Message context is empty.  HMAC is
+					   started from scratch (with key) or from
+					   precompute of inner hash, depending on
+					   whether
+					   #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is
+					   set. */
+	FSL_HMAC_FLAGS_SAVE = 2,	/*!< Retrieve ongoing context from hardware
+					   after hashing.  If used with the
+					   #FSL_HMAC_FLAGS_FINALIZE flag, the final
+					   digest value (HMAC) will be saved in the
+					   object. */
+	FSL_HMAC_FLAGS_LOAD = 4,	/*!< Place ongoing context into hardware
+					   before hashing. */
+	FSL_HMAC_FLAGS_FINALIZE = 8,	/*!< PAD message and perform final HMAC
+					   operations of inner and outer hashes. */
+	FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16	/*!< This means that the context
+						   contains precomputed inner and outer
+						   hash values. */
+} fsl_shw_hmac_ctx_flags_t;
+
+/*!
+ * Flags to control use of the #fsl_shw_scco_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
+ */
+typedef enum fsl_shw_sym_ctx_flags {
+	/*!
+	 * Context is empty.  In ARC4, this means that the S-Box needs to be
+	 * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
+	 * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+	 * initial CTR value of zero is desired.
+	 */
+	FSL_SYM_CTX_INIT = 1,
+	/*!
+	 * Load context from object into hardware before running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_LOAD = 2,
+	/*!
+	 * Save context from hardware into object after running cipher.  In
+	 * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+	 */
+	FSL_SYM_CTX_SAVE = 4,
+	/*!
+	 * Context (SBox) is to be unwrapped and wrapped on each use.
+	 * This flag is unsupported.
+	 * */
+	FSL_SYM_CTX_PROTECT = 8,
+} fsl_shw_sym_ctx_flags_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_sko_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
+ */
+typedef enum fsl_shw_key_flags {
+	FSL_SKO_KEY_IGNORE_PARITY = 1,	/*!< If algorithm is DES or 3DES, do not
+					   validate the key parity bits. */
+	FSL_SKO_KEY_PRESENT = 2,	/*!< Clear key is present in the object. */
+	FSL_SKO_KEY_ESTABLISHED = 4,	/*!< Key has been established for use.  This
+					   feature is not available for all
+					   platforms, nor for all algorithms and
+					   modes. */
+} fsl_shw_key_flags_t;
+
+/*!
+ * Type of value which is associated with an established key.
+ */
+typedef uint64_t key_userid_t;
+
+/*!
+ * Flags which describe the state of the #fsl_shw_acco_t.
+ *
+ * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
+ * together, provide for a one-shot operation.
+ */
+typedef enum fsl_shw_auth_ctx_flags {
+	FSL_ACCO_CTX_INIT = 1,	/*!< Initialize Context(s) */
+	FSL_ACCO_CTX_LOAD = 2,	/*!< Load intermediate context(s).
+				   This flag is unsupported. */
+	FSL_ACCO_CTX_SAVE = 4,	/*!< Save intermediate context(s).
+				   This flag is unsupported. */
+	FSL_ACCO_CTX_FINALIZE = 8,	/*!< Create MAC during this operation. */
+	FSL_ACCO_NIST_CCM = 0x10,	/*!< Formatting of CCM input data is
+					   performed by calls to
+					   #fsl_shw_ccm_nist_format_ctr_and_iv() and
+					   #fsl_shw_ccm_nist_update_ctr_and_iv().  */
+} fsl_shw_auth_ctx_flags_t;
+
+/*!
+ *  Modulus Selector for CTR modes.
+ *
+ * The incrementing of the Counter value may be modified by a modulus.  If no
+ * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
+ */
+typedef enum fsl_shw_ctr_mod {
+	FSL_CTR_MOD_8,		/*!< Run counter with modulus of 2^8. */
+	FSL_CTR_MOD_16,		/*!< Run counter with modulus of 2^16. */
+	FSL_CTR_MOD_24,		/*!< Run counter with modulus of 2^24. */
+	FSL_CTR_MOD_32,		/*!< Run counter with modulus of 2^32. */
+	FSL_CTR_MOD_40,		/*!< Run counter with modulus of 2^40. */
+	FSL_CTR_MOD_48,		/*!< Run counter with modulus of 2^48. */
+	FSL_CTR_MOD_56,		/*!< Run counter with modulus of 2^56. */
+	FSL_CTR_MOD_64,		/*!< Run counter with modulus of 2^64. */
+	FSL_CTR_MOD_72,		/*!< Run counter with modulus of 2^72. */
+	FSL_CTR_MOD_80,		/*!< Run counter with modulus of 2^80. */
+	FSL_CTR_MOD_88,		/*!< Run counter with modulus of 2^88. */
+	FSL_CTR_MOD_96,		/*!< Run counter with modulus of 2^96. */
+	FSL_CTR_MOD_104,	/*!< Run counter with modulus of 2^104. */
+	FSL_CTR_MOD_112,	/*!< Run counter with modulus of 2^112. */
+	FSL_CTR_MOD_120,	/*!< Run counter with modulus of 2^120. */
+	FSL_CTR_MOD_128		/*!< Run counter with modulus of 2^128. */
+} fsl_shw_ctr_mod_t;
+
+	  /*! @} *//* consgrp */
+
+/******************************************************************************
+ * Data Structures
+ *****************************************************************************/
+/*! @addtogroup strgrp
+    @{ */
+
+/* REQ-S2LRD-PINTFC-COA-IBO-001 */
+/*!
+ * Application Initialization Object
+ *
+ * This object, the operations on it, and its interaction with the driver are
+ * TBD.
+ */
+typedef struct fsl_sho_ibo {
+} fsl_sho_ibo_t;
+
+/* REQ-S2LRD-PINTFC-COA-UCO-001 */
+/*!
+ * User Context Object
+ *
+ * This object must be initialized by a call to #fsl_shw_uco_init().  It must
+ * then be passed to #fsl_shw_register_user() before it can be used in any
+ * calls besides those in @ref ucoops.
+ *
+ * It contains the user's configuration for the API, for instance whether an
+ * operation should block, or instead should call back the user upon completion
+ * of the operation.
+ *
+ * See @ref ucoops for further information.
+ */
+typedef struct fsl_shw_uco {	/* fsl_shw_user_context_object */
+} fsl_shw_uco_t;
+
+/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
+/*!
+ * Result Object
+ *
+ * This object will contain success and failure information about a specific
+ * cryptographic request which has been made.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref rops.
+ */
+typedef struct fsl_shw_result {	/* fsl_shw_result */
+} fsl_shw_result_t;
+
+/* REQ-S2LRD-PINTFC-COA-SKO-001 */
+/*!
+ * Secret Key Object
+ *
+ * This object contains a key for a cryptographic operation, and information
+ * about its current state, its intended usage, etc.  It may instead contain
+ * information about a protected key, or an indication to use a platform-
+ * specific secret key.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref skoops.
+ */
+typedef struct fsl_shw_sko {	/* fsl_shw_secret_key_object */
+} fsl_shw_sko_t;
+
+/* REQ-S2LRD-PINTFC-COA-CO-001 */
+/*!
+ * Platform Capabilities Object
+ *
+ * This object will contain information about the cryptographic features of the
+ * platform which the program is running on.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.
+ *
+ * See @ref pcoops.
+ */
+typedef struct fsl_shw_pco {	/* fsl_shw_platform_capabilities_object */
+} fsl_shw_pco_t;
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/*!
+ * Hash Context Object
+ *
+ * This object contains information to control hashing functions.
+
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref hcops.
+ */
+typedef struct fsl_shw_hco {	/* fsl_shw_hash_context_object */
+} fsl_shw_hco_t;
+
+/*!
+ * HMAC Context Object
+ *
+ * This object contains information to control HMAC functions.
+
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref hmcops.
+ */
+typedef struct fsl_shw_hmco {	/* fsl_shw_hmac_context_object */
+} fsl_shw_hmco_t;
+
+/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
+/*!
+ * Symmetric Cipher Context Object
+ *
+ * This object contains information to control Symmetric Ciphering encrypt and
+ * decrypt functions in #FSL_SYM_MODE_STREAM (ARC4), #FSL_SYM_MODE_ECB,
+ * #FSL_SYM_MODE_CBC, and #FSL_SYM_MODE_CTR modes and the
+ * #fsl_shw_symmetric_encrypt() and #fsl_shw_symmetric_decrypt() functions.
+ * CCM mode is controlled with the #fsl_shw_acco_t object.
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref sccops.
+ */
+typedef struct fsl_shw_scco {	/* fsl_shw_symmetric_cipher_context_object */
+} fsl_shw_scco_t;
+
+/*!
+ * Authenticate-Cipher Context Object
+
+ * An object for controlling the function of, and holding information about,
+ * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
+ * #fsl_shw_auth_decrypt().
+ *
+ * No direct access to its members should be made by programs.  Instead, the
+ * object should be manipulated using the provided functions.  See @ref
+ * accoops.
+ */
+typedef struct fsl_shw_acco {	/* fsl_shw_authenticate_cipher_context_object */
+} fsl_shw_acco_t;
+	  /*! @} *//* strgrp */
+
+/******************************************************************************
+ * Access Macros for Objects
+ *****************************************************************************/
+/*! @addtogroup pcoops
+    @{ */
+
+/*!
+ * Get FSL SHW API version
+ *
+ * @param      pc_info   The Platform Capababilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the API is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the API is to be stored.
+ */
+void fsl_shw_pco_get_version(const fsl_shw_pco_t * pc_info,
+			     uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get underlying driver version.
+ *
+ * @param      pc_info   The Platform Capababilities Object to query.
+ * @param[out] major     A pointer to where the major version
+ *                       of the driver is to be stored.
+ * @param[out] minor     A pointer to where the minor version
+ *                       of the driver is to be stored.
+ */
+void fsl_shw_pco_get_driver_version(const fsl_shw_pco_t * pc_info,
+				    uint32_t * major, uint32_t * minor);
+
+/*!
+ * Get list of symmetric algorithms supported.
+ *
+ * @param pc_info   The Platform Capababilities Object to query.
+ * @param[out] algorithms A pointer to where to store the location of
+ *                        the list of algorithms.
+ * @param[out] algorithm_count A pointer to where to store the number of
+ *                             algorithms in the list at @a algorithms.
+ */
+void fsl_shw_pco_get_sym_algorithms(const fsl_shw_pco_t * pc_info,
+				    fsl_shw_key_alg_t * algorithms[],
+				    uint8_t * algorithm_count);
+
+/*!
+ * Get list of symmetric modes supported.
+ *
+ * @param pc_info         The Platform Capababilities Object to query.
+ * @param[out] modes      A pointer to where to store the location of
+ *                        the list of modes.
+ * @param[out] mode_count A pointer to where to store the number of
+ *                        algorithms in the list at @a modes.
+ */
+void fsl_shw_pco_get_sym_modes(const fsl_shw_pco_t * pc_info,
+			       fsl_shw_sym_mode_t * modes[],
+			       uint8_t * mode_count);
+
+/*!
+ * Get list of hash algorithms supported.
+ *
+ * @param pc_info         The Platform Capababilities Object to query.
+ * @param[out] algorithms A pointer which will be set to the list of
+ *                        algorithms.
+ * @param[out] algorithm_count The number of algorithms in the list at @a
+ *                             algorithms.
+ */
+void fsl_shw_pco_get_hash_algorithms(const fsl_shw_pco_t * pc_info,
+				     fsl_shw_hash_alg_t * algorithms[],
+				     uint8_t * algorithm_count);
+
+/*!
+ * Determine whether the combination of a given symmetric algorithm and a given
+ * mode is supported.
+ *
+ * @param pc_info    The Platform Capababilities Object to query.
+ * @param algorithm  A Symmetric Cipher algorithm.
+ * @param mode       A Symmetric Cipher mode.
+ *
+ * @return 0 if combination is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_sym_supported(const fsl_shw_pco_t * pc_info,
+				    fsl_shw_key_alg_t algorithm,
+				    fsl_shw_sym_mode_t mode);
+
+/*!
+ * Determine whether a given Encryption-Authentication mode is supported.
+ *
+ * @param pc_info   The Platform Capababilities Object to query.
+ * @param mode       The Authentication mode.
+ *
+ * @return 0 if mode is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_auth_supported(const fsl_shw_pco_t * pc_info,
+				     fsl_shw_acc_mode_t mode);
+
+/*!
+ * Determine whether Black Keys (key establishment / wrapping) is supported.
+ *
+ * @param pc_info  The Platform Capababilities Object to query.
+ *
+ * @return 0 if wrapping is not supported, non-zero if supported.
+ */
+int fsl_shw_pco_check_black_key_supported(const fsl_shw_pco_t * pc_info);
+
+	  /*! @} *//* pcoops */
+
+/*! @addtogroup ucoops
+    @{ */
+
+/*!
+ * Initialize a User Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the User Context Object to initial values, and set the size
+ * of the results pool.  The mode will be set to a default of
+ * #FSL_UCO_BLOCKING_MODE.
+ *
+ * When using non-blocking operations, this sets the maximum number of
+ * operations which can be outstanding.  This number includes the counts of
+ * operations waiting to start, operation(s) being performed, and results which
+ * have not been retrieved.
+ *
+ * Changes to this value are ignored once user registration has completed.  It
+ * should be set to 1 if only blocking operations will ever be performed.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param pool_size    The maximum number of operations which can be
+ *                     outstanding.
+ */
+void fsl_shw_uco_init(fsl_shw_uco_t * user_ctx, uint16_t pool_size);
+
+/*!
+ * Set the User Reference for the User Context.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param reference    A value which will be passed back with a result.
+ */
+void fsl_shw_uco_set_reference(fsl_shw_uco_t * user_ctx, uint32_t reference);
+
+/*!
+ * Set the callback routine for the User Context.
+ *
+ * Note that the callback routine may be called when no results are available,
+ * and possibly even when no requests are oustanding.
+ *
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param callback_fn  The function the API will invoke when an operation
+ *                     completes.
+ */
+void fsl_shw_uco_set_callback(fsl_shw_uco_t * user_ctx,
+			      void (*callback_fn) (fsl_shw_uco_t * uco));
+
+/*!
+ * Set flags in the User Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+void fsl_shw_uco_set_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in the User Context.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param user_ctx     The User Context object to operate on.
+ * @param flags        ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+void fsl_shw_uco_clear_flags(fsl_shw_uco_t * user_ctx, uint32_t flags);
+
+	  /*! @} *//* ucoops */
+
+/*! @addtogroup rops
+    @{ */
+
+/*!
+ * Retrieve the status code from a Result Object.
+ *
+ * @param result   The result object to query.
+ *
+ * @return The status of the request.
+ */
+fsl_shw_return_t fsl_shw_ro_get_status(fsl_shw_result_t * result);
+
+/*!
+ * Retrieve the reference value from a Result Object.
+ *
+ * @param result   The result object to query.
+ *
+ * @return The reference associated with the request.
+ */
+uint32_t fsl_shw_ro_get_reference(fsl_shw_result_t * result);
+
+	 /* @} *//* rops */
+
+/*! @addtogroup skoops
+    @{ */
+
+/*!
+ * Initialize a Secret Key Object.
+ *
+ * This function must be called before performing any other operation with
+ * the Object.
+ *
+ * @param key_info  The Secret Key Object to be initialized.
+ * @param algorithm DES, AES, etc.
+ *
+ */
+void fsl_shw_sko_init(fsl_shw_sko_t * key_info, fsl_shw_key_alg_t algorithm);
+
+/*!
+ * Store a cleartext key in the key object.
+ *
+ * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
+ * resetting the #FSL_SKO_KEY_ESTABLISHED flag.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param key          A pointer to the beginning of the key.
+ * @param key_length   The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+void fsl_shw_sko_set_key(fsl_shw_sko_t * key_object,
+			 const uint8_t * key, uint16_t key_length);
+
+/*!
+ * Set a size for the key.
+ *
+ * This function would normally be used when the user wants the key to be
+ * generated from a random source.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param key_length   The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+void fsl_shw_sko_set_key_length(fsl_shw_sko_t * key_object,
+				uint16_t key_length);
+
+/*!
+ * Set the User ID associated with the key.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param userid       The User ID to identify authorized users of the key.
+ */
+void fsl_shw_sko_set_user_id(fsl_shw_sko_t * key_object, key_userid_t userid);
+
+/*!
+ * Set the establish key handle into a key object.
+ *
+ * The @a userid field will be used to validate the access to the unwrapped
+ * key.  This feature is not available for all platforms, nor for all
+ * algorithms and modes.
+ *
+ * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT
+ * flag will be cleared).
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param userid       The User ID to verify this user is an authorized user of
+ *                     the key.
+ * @param handle       A @a handle from #fsl_shw_sko_get_established_info.
+ */
+void fsl_shw_sko_set_established_info(fsl_shw_sko_t * key_object,
+				      key_userid_t userid, uint32_t handle);
+
+/*!
+ * Extract the algorithm from a key object.
+ *
+ * @param      key_info  The Key Object to be queried.
+ * @param[out] algorithm A pointer to the location to store the algorithm.
+ */
+void fsl_shw_sko_get_algorithm(const fsl_shw_sko_t * key_info,
+			       fsl_shw_key_alg_t * algorithm);
+
+/*!
+ * Retrieve the established-key handle from a key object.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param handle       The location to store the @a handle of the unwrapped
+ *                     key.
+ */
+void fsl_shw_sko_get_established_info(fsl_shw_sko_t * key_object,
+				      uint32_t * handle);
+
+/*!
+ * Determine the size of a wrapped key based upon the cleartext key's length.
+ *
+ * This function can be used to calculate the number of octets that
+ * #fsl_shw_extract_key() will write into the location at @a covered_key.
+ *
+ * If zero is returned at @a length, this means that the key length in
+ * @a key_info is not supported.
+ *
+ * @param      key_info         Information about a key to be wrapped.
+ * @param      length           Location to store the length of a wrapped
+ *                              version of the key in @a key_info.
+ */
+void fsl_shw_sko_calculate_wrapped_size(const fsl_shw_sko_t * key_info,
+					uint32_t * length);
+
+/*!
+ * Set some flags in the key object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                     are to be set.
+ */
+void fsl_shw_sko_set_flags(fsl_shw_sko_t * key_object, uint32_t flags);
+
+/*!
+ * Clear some flags in the key object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param key_object   A variable of type #fsl_shw_sko_t.
+ * @param flags        (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                      are to be reset.
+ */
+void fsl_shw_sko_clear_flags(fsl_shw_sko_t * key_object, uint32_t flags);
+
+	  /*! @} *//* end skoops */
+
+/*****************************************************************************/
+
+/*! @addtogroup hcops
+    @{ */
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 - partially */
+/*!
+ * Initialize a Hash Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the hash
+ * context object.
+ *
+ * @param      hash_ctx  The hash context to operate upon.
+ * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                       #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+void fsl_shw_hco_init(fsl_shw_hco_t * hash_ctx, fsl_shw_hash_alg_t algorithm);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-001 */
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 */
+/*!
+ * Get the current hash value and message length from the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hash_ctx  The hash context to query.
+ * @param[out] digest    Pointer to the location of @a length octets where to
+ *                       store a copy of the current value of the digest.
+ * @param      length    Number of octets of hash value to copy.
+ * @param[out] msg_length Pointer to the location to store the number of octets
+ *                        already hashed.
+ */
+void fsl_shw_hco_get_digest(const fsl_shw_hco_t * hash_ctx, uint8_t * digest,
+			    uint8_t length, uint32_t * msg_length);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-002 - partially */
+/*!
+ * Get the hash algorithm from the hash context object.
+ *
+ * @param      hash_ctx  The hash context to query.
+ * @param[out] algorithm Pointer to where the algorithm is to be stored.
+ */
+void fsl_shw_hco_get_info(const fsl_shw_hco_t * hash_ctx,
+			  fsl_shw_hash_alg_t * algorithm);
+
+/*****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-003 */
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-004 */
+/*!
+ * Set the current hash value and message length in the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hash_ctx  The hash context to operate upon.
+ * @param      context   Pointer to buffer of appropriate length to copy into
+ *                       the hash context object.
+ * @param      msg_length The number of octets of the message which have
+ *                        already been hashed.
+ *
+ */
+void fsl_shw_hco_set_digest(fsl_shw_hco_t * hash_ctx, const uint8_t * context,
+			    uint32_t msg_length);
+
+/*!
+ * Set flags in a Hash Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hash_ctx   The hash context to be operated on.
+ * @param flags      The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+void fsl_shw_hco_set_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in a Hash Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hash_ctx   The hash context to be operated on.
+ * @param flags      The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+void fsl_shw_hco_clear_flags(fsl_shw_hco_t * hash_ctx, uint32_t flags);
+
+	  /*! @} *//* end hcops */
+
+/*****************************************************************************/
+
+/*! @addtogroup hmcops
+    @{ */
+
+/*!
+ * Initialize an HMAC Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the HMAC
+ * context object.
+ *
+ * @param      hmac_ctx  The HMAC context to operate upon.
+ * @param      algorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                       #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+void fsl_shw_hmco_init(fsl_shw_hmco_t * hmac_ctx, fsl_shw_hash_alg_t algorithm);
+
+/*!
+ * Set flags in an HMAC Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hmac_ctx   The HMAC context to be operated on.
+ * @param flags      The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+void fsl_shw_hmco_set_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
+
+/*!
+ * Clear flags in an HMAC Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hmac_ctx   The HMAC context to be operated on.
+ * @param flags      The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+void fsl_shw_hmco_clear_flags(fsl_shw_hmco_t * hmac_ctx, uint32_t flags);
+
+/*! @} */
+
+/*****************************************************************************/
+
+/*! @addtogroup sccops
+    @{ */
+
+/*!
+ * Initialize a Symmetric Cipher Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  This will set the @a mode and @a algorithm and initialize the
+ * Object.
+ *
+ * @param sym_ctx   The context object to operate on.
+ * @param algorithm The cipher algorithm this context will be used with.
+ * @param mode      #FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
+ *
+ */
+void fsl_shw_scco_init(fsl_shw_scco_t * sym_ctx,
+		       fsl_shw_key_alg_t algorithm, fsl_shw_sym_mode_t mode);
+
+/*!
+ * Set the flags for a Symmetric Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param flags    The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_scco_set_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
+
+/*!
+ * Clear some flags in a Symmetric Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param flags    The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_scco_clear_flags(fsl_shw_scco_t * sym_ctx, uint32_t flags);
+
+/*!
+ * Set the Context (IV) for a Symmetric Cipher Context.
+ *
+ * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
+ * context (the S-Box and pointers) for ARC4.  The full context size will
+ * be copied.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param context  A pointer to the buffer which contains the context.
+ *
+ */
+void fsl_shw_scco_set_context(fsl_shw_scco_t * sym_ctx, uint8_t * context);
+
+/*!
+ * Get the Context for a Symmetric Cipher Context.
+ *
+ * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
+ * retrieve context (the S-Box and pointers) for ARC4.  The full context
+ * will be copied.
+ *
+ * @param      sym_ctx  The context object to operate on.
+ * @param[out] context  Pointer to location where context will be stored.
+ */
+void fsl_shw_scco_get_context(const fsl_shw_scco_t * sym_ctx,
+			      uint8_t * context);
+
+/*!
+ * Set the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will set the Counter Value for CTR mode.
+ *
+ * @param sym_ctx  The context object to operate on.
+ * @param counter  The starting counter value.  The number of octets.
+ *                 copied will be the block size for the algorithm.
+ * @param modulus  The modulus for controlling the incrementing of the counter.
+ *
+ */
+void fsl_shw_scco_set_counter_info(fsl_shw_scco_t * sym_ctx,
+				   const uint8_t * counter,
+				   fsl_shw_ctr_mod_t modulus);
+
+/*!
+ * Get the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will retrieve the Counter Value is for CTR mode.
+ *
+ * @param sym_ctx         The context object to query.
+ * @param[out] counter    Pointer to location to store the current counter
+ *                        value.  The number of octets copied will be the
+ *                        block size for the algorithm.
+ * @param[out] modulus    Pointer to location to store the modulus.
+ *
+ */
+void fsl_shw_scco_get_counter_info(const fsl_shw_scco_t * sym_ctx,
+				   uint8_t * counter,
+				   fsl_shw_ctr_mod_t * modulus);
+
+	  /*! @} *//* end sccops */
+
+/*****************************************************************************/
+
+/*! @addtogroup accoops
+    @{ */
+
+/*!
+ * Initialize a Authentication-Cipher Context.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param mode         The mode for this object (only #FSL_ACC_MODE_CCM
+ *                     supported).
+ */
+void fsl_shw_acco_init(fsl_shw_acco_t * auth_object, fsl_shw_acc_mode_t mode);
+
+/*!
+ * Set the flags for a Authentication-Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param flags        The flags to set (one or more from
+ *                     #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_acco_set_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
+
+/*!
+ * Clear some flags in a Authentication-Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param flags        The flags to reset (one or more from
+ *                     #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+void fsl_shw_acco_clear_flags(fsl_shw_acco_t * auth_object, uint32_t flags);
+
+/*!
+ * Set up the Authentication-Cipher Object for CCM mode.
+ *
+ * This will set the @a auth_object for CCM mode and save the @a ctr,
+ * and @a mac_length.  This function can be called instead of
+ * #fsl_shw_acco_init().
+ *
+ * The paramater @a ctr is Counter Block 0, (counter value 0), which is for the
+ * MAC.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param algorithm    Cipher algorithm.  Only AES is supported.
+ * @param ctr          The initial counter value.
+ * @param mac_length   The number of octets used for the MAC.  Valid values are
+ *                     4, 6, 8, 10, 12, 14, and 16.
+ */
+void fsl_shw_acco_set_ccm(fsl_shw_acco_t * auth_object,
+			  fsl_shw_key_alg_t algorithm,
+			  const uint8_t * ctr, uint8_t mac_length);
+
+/*!
+ * Format the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will also set the IV and CTR values per Appendix A of NIST
+ * Special Publication 800-38C (May 2004).  It will also perform the
+ * #fsl_shw_acco_set_ccm() operation with information derived from this set of
+ * parameters.
+ *
+ * Note this function assumes the algorithm is AES.  It initializes the
+ * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
+ * flags to be #FSL_ACCO_NIST_CCM.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param t_length     The number of octets used for the MAC.  Valid values are
+ *                     4, 6, 8, 10, 12, 14, and 16.
+ * @param ad_length    Number of octets of Associated Data (may be zero).
+ * @param q_length     A value for the size of the length of @a q field.  Valid
+ *                     values are 1-8.
+ * @param n            The Nonce (packet number or other changing value). Must
+ *                     be (15 - @a q_length) octets long.
+ * @param q            The value of Q (size of the payload in octets).
+ *
+ */
+void fsl_shw_ccm_nist_format_ctr_and_iv(fsl_shw_acco_t * auth_object,
+					uint8_t t_length,
+					uint32_t ad_length,
+					uint8_t q_length,
+					const uint8_t * n, uint32_t q);
+
+/*!
+ * Update the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will set the IV and CTR values per Appendix A of NIST Special
+ * Publication 800-38C (May 2004).
+ *
+ * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
+ * previously been called on the @a auth_object.
+ *
+ * @param auth_object  Pointer to object to operate on.
+ * @param n             The Nonce (packet number or other changing value). Must
+ *                      be (15 - @a q_length) octets long.
+ * @param q             The value of Q (size of the payload in octets).
+ *
+ */
+void fsl_shw_ccm_nist_update_ctr_and_iv(fsl_shw_acco_t * auth_object,
+					const uint8_t * n, uint32_t q);
+
+	 /* @} *//* accoops */
+
+/******************************************************************************
+ * Library functions
+ *****************************************************************************/
+
+/*! @addtogroup miscfuns
+    @{ */
+
+/* REQ-S2LRD-PINTFC-API-GEN-003 */
+/*!
+ * Determine the hardware security capabilities of this platform.
+ *
+ * Though a user context object is passed into this function, it will always
+ * act in a non-blocking manner.
+ *
+ * @param  user_ctx   The user context which will be used for the query.
+ *
+ * @return  A pointer to the capabilities object.
+ */
+extern fsl_shw_pco_t *fsl_shw_get_capabilities(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-004 */
+/*!
+ * Create an association between the the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which will be used for this association.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-005 */
+/*!
+ * Destroy the association between the the user and the provider of the API.
+ *
+ * @param  user_ctx   The user context which is no longer needed.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t * user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-006 */
+/*!
+ * Retrieve results from earlier operations.
+ *
+ * @param         user_ctx     The user's context.
+ * @param         result_size  The number of array elements of @a results.
+ * @param[in,out] results      Pointer to first of the (array of) locations to
+ *                             store results.
+ * @param[out]    result_count Pointer to store the number of results which
+ *                             were returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t * user_ctx,
+					    uint16_t result_size,
+					    fsl_shw_result_t results[],
+					    uint16_t * result_count);
+
+	  /*! @} *//* miscfuns */
+
+/*! @addtogroup opfuns
+    @{ */
+
+/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+/*!
+ * Encrypt a stream of data with a symmetric-key algorithm.
+ *
+ * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+ * flags of the @a sym_ctx object will control part of the operation of this
+ * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+ * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
+ * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+ * means to update the object's context information after the operation has
+ * been performed.
+ *
+ * All of the data for an operation can be run through at once using the
+ * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+ * a @a length for the whole of the data.
+ *
+ * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+ * would "pick up" where the previous call left off, allowing the user to
+ * perform the larger function in smaller steps.
+ *
+ * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+ * be a multiple of the block size for the algorithm being used.  For proper
+ * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+ * block size until the last operation on the total octet stream.
+ *
+ * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+ * the key before any data is available.  This may be done by running this
+ * function with a @a length of zero, with the init & save flags flags on in
+ * the @a sym_ctx.  Subsequent operations would then run as normal with the
+ * load and save flags.  Note that they key object is still required.
+ *
+ * @param         user_ctx  A user context from #fsl_shw_register_user().
+ * @param         key_info  Key and algorithm  being used for this operation.
+ * @param[in,out] sym_ctx   Info on cipher mode, state of the cipher.
+ * @param         length   Length, in octets, of the pt (and ct).
+ * @param         pt       pointer to plaintext to be encrypted.
+ * @param[out]    ct       pointer to where to store the resulting ciphertext.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ *
+ */
+extern fsl_shw_return_t fsl_shw_symmetric_encrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * pt,
+						  uint8_t * ct);
+
+/* PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+/*!
+ * Decrypt a stream of data with a symmetric-key algorithm.
+ *
+ * In ARC4, and also in #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_CTR modes, the
+ * flags of the @a sym_ctx object will control part of the operation of this
+ * function.  The #FSL_SYM_CTX_INIT flag means that there is no context info in
+ * the object.  The #FSL_SYM_CTX_LOAD means to use information in the
+ * @a sym_ctx at the start of the operation, and the #FSL_SYM_CTX_SAVE flag
+ * means to update the object's context information after the operation has
+ * been performed.
+ *
+ * All of the data for an operation can be run through at once using the
+ * #FSL_SYM_CTX_INIT or #FSL_SYM_CTX_LOAD flags, as appropriate, and then using
+ * a @a length for the whole of the data.
+ *
+ * If a #FSL_SYM_CTX_SAVE flag were added, an additional call to the function
+ * would "pick up" where the previous call left off, allowing the user to
+ * perform the larger function in smaller steps.
+ *
+ * In #FSL_SYM_MODE_CBC and #FSL_SYM_MODE_ECB modes, the @a length must always
+ * be a multiple of the block size for the algorithm being used.  For proper
+ * operation in #FSL_SYM_MODE_CTR mode, the @a length must be a multiple of the
+ * block size until the last operation on the total octet stream.
+ *
+ * Some users of ARC4 may want to compute the context (S-Box and pointers) from
+ * the key before any data is available.  This may be done by running this
+ * function with a @a length of zero, with the #FSL_SYM_CTX_INIT &
+ * #FSL_SYM_CTX_SAVE flags on in the @a sym_ctx.  Subsequent operations would
+ * then run as normal with the load & save flags.  Note that they key object is
+ * still required.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      key_info The key and algorithm being used in this operation.
+ * @param[in,out] sym_ctx Info on cipher mode, state of the cipher.
+ * @param      length   Length, in octets, of the ct (and pt).
+ * @param      ct       pointer to ciphertext to be decrypted.
+ * @param[out] pt       pointer to where to store the resulting plaintext.
+ *
+ * @return    A return code of type #fsl_shw_return_t
+ *
+ */
+extern fsl_shw_return_t fsl_shw_symmetric_decrypt(fsl_shw_uco_t * user_ctx,
+						  fsl_shw_sko_t * key_info,
+						  fsl_shw_scco_t * sym_ctx,
+						  uint32_t length,
+						  const uint8_t * ct,
+						  uint8_t * pt);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+/*!
+ * Hash a stream of data with a cryptographic hash algorithm.
+ *
+ * The flags in the @a hash_ctx control the operation of this function.
+ *
+ * Hashing functions work on 64 octets of message at a time.  Therefore, when
+ * any partial hashing of a long message is performed, the message @a length of
+ * each segment must be a multiple of 64.  When ready to
+ * #FSL_HASH_FLAGS_FINALIZE the hash, the @a length may be any value.
+ *
+ * With the #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_FINALIZE flags on, a
+ * one-shot complete hash, including padding, will be performed.  The @a length
+ * may be any value.
+ *
+ * The first octets of a data stream can be hashed by setting the
+ * #FSL_HASH_FLAGS_INIT and #FSL_HASH_FLAGS_SAVE flags.  The @a length must be
+ * a multiple of 64.
+ *
+ * The flag #FSL_HASH_FLAGS_LOAD is used to load a context previously saved by
+ * #FSL_HASH_FLAGS_SAVE.  The two in combination will allow a (multiple-of-64
+ * octets) 'middle sequence' of the data stream to be hashed with the
+ * beginning.  The @a length must again be a multiple of 64.
+ *
+ * Since the flag #FSL_HASH_FLAGS_LOAD is used to load a context previously
+ * saved by #FSL_HASH_FLAGS_SAVE, the #FSL_HASH_FLAGS_LOAD and
+ * #FSL_HASH_FLAGS_FINALIZE flags, used together, can be used to finish the
+ * stream.  The @a length may be any value.
+ *
+ * If the user program wants to do the padding for the hash, it can leave off
+ * the #FSL_HASH_FLAGS_FINALIZE flag.  The @a length must then be a multiple of
+ * 64 octets.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param[in,out] hash_ctx Hashing algorithm and state of the cipher.
+ * @param      msg       Pointer to the data to be hashed.
+ * @param      length    Length, in octets, of the @a msg.
+ * @param[out] result    If not null, pointer to where to store the hash
+ *                       digest.
+ * @param      result_len Number of octets to store in @a result.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hash(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_hco_t * hash_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+/*!
+ * Precompute the Key hashes for an HMAC operation.
+ *
+ * This function may be used to calculate the inner and outer precomputes,
+ * which are the hash contexts resulting from hashing the XORed key for the
+ * 'inner hash' and the 'outer hash', respectively, of the HMAC function.
+ *
+ * After execution of this function, the @a hmac_ctx will contain the
+ * precomputed inner and outer contexts, so that they may be used by
+ * #fsl_shw_hmac().  The flags of @a hmac_ctx will be updated with
+ * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT to mark their presence.  In addtion, the
+ * #FSL_HMAC_FLAGS_INIT flag will be set.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      key_info  The key being used in this operation.  Key must be
+ *                       1 to 64 octets long.
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
+ *                         algorithm, the operation of this function.
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hmac_precompute(fsl_shw_uco_t * user_ctx,
+						fsl_shw_sko_t * key_info,
+						fsl_shw_hmco_t * hmac_ctx);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+/*!
+ * Continue, finalize, or one-shot an HMAC operation.
+ *
+ * There are a number of ways to use this function.  The flags in the
+ * @a hmac_ctx object will determine what operations occur.
+ *
+ * If #FSL_HMAC_FLAGS_INIT is set, then the hash will be started either from
+ * the @a key_info, or from the precomputed inner hash value in the
+ * @a hmac_ctx, depending on the value of #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT.
+ *
+ * If, instead, #FSL_HMAC_FLAGS_LOAD is set, then the hash will be continued
+ * from the ongoing inner hash computation in the @a hmac_ctx.
+ *
+ * If #FSL_HMAC_FLAGS_FINALIZE are set, then the @a msg will be padded, hashed,
+ * the outer hash will be performed, and the @a result will be generated.
+ *
+ * If the #FSL_HMAC_FLAGS_SAVE flag is set, then the (ongoing or final) digest
+ * value will be stored in the ongoing inner hash computation field of the @a
+ * hmac_ctx.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param key_info       If #FSL_HMAC_FLAGS_INIT is set in the @a hmac_ctx,
+ *                       this is the key being used in this operation, and the
+ *                       IPAD.  If #FSL_HMAC_FLAGS_INIT is set in the @a
+ *                       hmac_ctx and @a key_info is NULL, then
+ *                       #fsl_shw_hmac_precompute() has been used to populate
+ *                       the @a inner_precompute and @a outer_precompute
+ *                       contexts.  If #FSL_HMAC_FLAGS_INIT is not set, this
+ *                       parameter is ignored.
+
+ * @param[in,out] hmac_ctx The context which controls, by its flags and
+ *                       algorithm, the operation of this function.
+ * @param      msg               Pointer to the message to be hashed.
+ * @param      length            Length, in octets, of the @a msg.
+ * @param[out] result            Pointer, of @a result_len octets, to where to
+ *                               store the HMAC.
+ * @param      result_len        Length of @a result buffer.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_hmac(fsl_shw_uco_t * user_ctx,
+				     fsl_shw_sko_t * key_info,
+				     fsl_shw_hmco_t * hmac_ctx,
+				     const uint8_t * msg,
+				     uint32_t length,
+				     uint8_t * result, uint32_t result_len);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Get random data.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      length    The number of octets of @a data being requested.
+ * @param[out] data      A pointer to a location of @a length octets to where
+ *                       random data will be returned.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_get_random(fsl_shw_uco_t * user_ctx,
+					   uint32_t length, uint8_t * data);
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+/*!
+ * Add entropy to random number generator.
+ *
+ * @param      user_ctx  A user context from #fsl_shw_register_user().
+ * @param      length    Number of bytes at @a data.
+ * @param      data      Entropy to add to random number generator.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_add_entropy(fsl_shw_uco_t * user_ctx,
+					    uint32_t length, uint8_t * data);
+
+/*!
+ * Perform Generation-Encryption by doing a Cipher and a Hash.
+ *
+ * Generate the authentication value @a auth_value as well as encrypt the @a
+ * payload into @a ct (the ciphertext).  This is a one-shot function, so all of
+ * the @a auth_data and the total message @a payload must passed in one call.
+ * This also means that the flags in the @a auth_ctx must be #FSL_ACCO_CTX_INIT
+ * and #FSL_ACCO_CTX_FINALIZE.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      auth_ctx         Controlling object for Authenticate-decrypt.
+ * @param      cipher_key_info  The key being used for the cipher part of this
+ *                              operation.  In CCM mode, this key is used for
+ *                              both parts.
+ * @param      auth_key_info    The key being used for the authentication part
+ *                              of this operation.  In CCM mode, this key is
+ *                              ignored and may be NULL.
+ * @param      auth_data_length Length, in octets, of @a auth_data.
+ * @param      auth_data        Data to be authenticated but not encrypted.
+ * @param      payload_length   Length, in octets, of @a payload.
+ * @param      payload          Pointer to the plaintext to be encrypted.
+ * @param[out] ct               Pointer to the where the encrypted @a payload
+ *                              will be stored.  Must be @a payload_length
+ *                              octets long.
+ * @param[out] auth_value       Pointer to where the generated authentication
+ *                              field will be stored. Must be as many octets as
+ *                              indicated by MAC length in the @a function_ctx.
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_gen_encrypt(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_acco_t * auth_ctx,
+					    fsl_shw_sko_t * cipher_key_info,
+					    fsl_shw_sko_t * auth_key_info,
+					    uint32_t auth_data_length,
+					    const uint8_t * auth_data,
+					    uint32_t payload_length,
+					    const uint8_t * payload,
+					    uint8_t * ct, uint8_t * auth_value);
+
+/*!
+ * Perform Authentication-Decryption in Cipher + Hash.
+ *
+ * This function will perform a one-shot decryption of a data stream as well as
+ * authenticate the authentication value.  This is a one-shot function, so all
+ * of the @a auth_data and the total message @a payload must passed in one
+ * call.  This also means that the flags in the @a auth_ctx must be
+ * #FSL_ACCO_CTX_INIT and #FSL_ACCO_CTX_FINALIZE.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      auth_ctx         Controlling object for Authenticate-decrypt.
+ * @param      cipher_key_info  The key being used for the cipher part of this
+ *                              operation.  In CCM mode, this key is used for
+ *                              both parts.
+ * @param      auth_key_info    The key being used for the authentication part
+ *                              of this operation.  In CCM mode, this key is
+ *                              ignored and may be NULL.
+ * @param      auth_data_length Length, in octets, of @a auth_data.
+ * @param      auth_data        Data to be authenticated but not decrypted.
+ * @param      payload_length   Length, in octets, of @a ct and @a pt.
+ * @param      ct               Pointer to the encrypted input stream.
+ * @param      auth_value       The (encrypted) authentication value which will
+ *                              be authenticated.  This is the same data as the
+ *                              (output) @a auth_value argument to
+ *                              #fsl_shw_gen_encrypt().
+ * @param[out] payload          Pointer to where the plaintext resulting from
+ *                              the decryption will be stored.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_auth_decrypt(fsl_shw_uco_t * user_ctx,
+					     fsl_shw_acco_t * auth_ctx,
+					     fsl_shw_sko_t * cipher_key_info,
+					     fsl_shw_sko_t * auth_key_info,
+					     uint32_t auth_data_length,
+					     const uint8_t * auth_data,
+					     uint32_t payload_length,
+					     const uint8_t * ct,
+					     const uint8_t * auth_value,
+					     uint8_t * payload);
+
+/*!
+ * Place a key into a protected location for use only by cryptographic
+ * algorithms.
+ *
+ * This only needs to be used to a) unwrap a key, or b) set up a key which
+ * could be wrapped with a later call to #fsl_shw_extract_key().  Normal
+ * cleartext keys can simply be placed into #fsl_shw_sko_t key objects with
+ * #fsl_shw_sko_set_key() and used directly.
+ *
+ * The maximum key size supported for wrapped/unwrapped keys is 32 octets.
+ * (This is the maximum reasonable key length on Sahara - 32 octets for an HMAC
+ * key based on SHA-256.)  The key size is determined by the @a key_info.  The
+ * expected length of @a key can be determined by
+ * #fsl_shw_sko_calculate_wrapped_size()
+ *
+ * The protected key will not be available for use until this operation
+ * successfully completes.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param[in,out] key_info      The information about the key to be which will
+ *                              be established.  In the create case, the key
+ *                              length must be set.
+ * @param      establish_type   How @a key will be interpreted to establish a
+ *                              key for use.
+ * @param key                   If @a establish_type is #FSL_KEY_WRAP_UNWRAP,
+ *                              this is the location of a wrapped key.  If
+ *                              @a establish_type is #FSL_KEY_WRAP_CREATE, this
+ *                              parameter can be @a NULL.  If @a establish_type
+ *                              is #FSL_KEY_WRAP_ACCEPT, this is the location
+ *                              of a plaintext key.
+ */
+extern fsl_shw_return_t fsl_shw_establish_key(fsl_shw_uco_t * user_ctx,
+					      fsl_shw_sko_t * key_info,
+					      fsl_shw_key_wrap_t establish_type,
+					      const uint8_t * key);
+
+/*!
+ * Wrap a key and retrieve the wrapped value.
+ *
+ * A wrapped key is a key that has been cryptographically obscured.  It is
+ * only able to be used with #fsl_shw_establish_key().
+ *
+ * This function will also release the key (see #fsl_shw_release_key()) so
+ * that it must be re-established before reuse.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ * @param[out] covered_key      The location to store the wrapped key.
+ *                              (This size is based upon the maximum key size
+ *                              of 32 octets).
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info,
+					    uint8_t * covered_key);
+
+/*!
+ * De-establish a key so that it can no longer be accessed.
+ *
+ * The key will need to be re-established before it can again be used.
+ *
+ * This feature is not available for all platforms, nor for all algorithms and
+ * modes.
+ *
+ * @param      user_ctx         A user context from #fsl_shw_register_user().
+ * @param      key_info         The information about the key to be deleted.
+ *
+ * @return    A return code of type #fsl_shw_return_t.
+ */
+extern fsl_shw_return_t fsl_shw_release_key(fsl_shw_uco_t * user_ctx,
+					    fsl_shw_sko_t * key_info);
+
+	  /*! @} *//* opfuns */
+
+/* Insert example code into the API documentation. */
+
+/*!
+ * @example apitest.c
+ */
+
+/*!
+ * @example sym.c
+ */
+
+/*!
+ * @example rand.c
+ */
+
+/*!
+ * @example hash.c
+ */
+
+/*!
+ * @example hmac1.c
+ */
+
+/*!
+ * @example hmac2.c
+ */
+
+/*!
+ * @example gen_encrypt.c
+ */
+
+/*!
+ * @example auth_decrypt.c
+ */
+
+/*!
+ * @example wrapped_key.c
+ */
+
+#endif				/* API_DOC */
+
+#endif				/* FSL_SHW_H */
diff --git a/test/mxc_scc2/partition_tests.sh b/test/mxc_scc2/partition_tests.sh
new file mode 100644
index 0000000..6195a05
--- /dev/null
+++ b/test/mxc_scc2/partition_tests.sh
@@ -0,0 +1,31 @@
+#!/bin/sh
+
+#set -x
+
+# Initialize the test accounting environment
+. test_subs.sh
+
+OWNER_ID=01234567fedcba98
+KEY_VALUE8=ffeeddcc00112233
+KEY_VALUE16=ffaaeebbdd44cc550066117722883399
+SHORT_KEY=1234
+
+############################################################################
+#
+# Tests
+#
+############################################################################
+# Test strategy - Run partition encrypt/decrypt tests
+
+echo Test partition
+pos_test scc2_test.out -Lp
+
+echo
+echo "************************************************************************"
+echo
+echo "Tests complete"
+echo
+
+print_test_results
+
+return
diff --git a/test/mxc_scc2/sahara.h b/test/mxc_scc2/sahara.h
new file mode 100644
index 0000000..333f496
--- /dev/null
+++ b/test/mxc_scc2/sahara.h
@@ -0,0 +1,2323 @@
+/*
+ * Copyright 2005-2008 Freescale Semiconductor, Inc. All rights reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+ * @file sahara.h
+ *
+ * File which implements the FSL_SHW API when used on Sahara
+ */
+/**
+ * @if USE_MAINPAGE
+ * @mainpage Sahara2 implemtation of FSL Security Hardware API
+ * @endif
+ *
+ */
+
+#define _DIAG_DRV_IF
+#define _DIAG_SECURITY_FUNC
+#define _DIAG_ADAPTOR
+
+#ifndef SAHARA2_API_H
+#define SAHARA2_API_H
+
+
+#ifdef DIAG_SECURITY_FUNC
+#include <diagnostic.h>
+#endif /* DIAG_SECURITY_FUNC */
+
+/* This is a Linux flag... ? */
+#ifndef __KERNEL__
+#include <inttypes.h>
+#include <stdlib.h>
+#include <memory.h>
+#else
+#include "portable_os.h"
+#endif
+
+
+/* This definition may need a new name, and needs to go somewhere which
+ * can determine platform, kernel vs. user, os, etc.
+ */
+#define copy_bytes(out, in, len) memcpy(out, in, len)
+
+
+/* Does this belong here? */
+#ifndef SAHARA_DEVICE
+#define SAHARA_DEVICE "/dev/sahara"
+#endif
+
+
+/**
+*******************************************************************************
+* @defgroup lnkflags Link Flags
+*
+* @brief Flags to show information about link data and link segments
+*
+******************************************************************************/
+/** @addtogroup lnkflags
+ * @{
+ */
+
+/**
+*******************************************************************************
+* This flag indicates that the data in a link is owned by the security
+* function component and this memory will be freed by the security function
+* component. To be used as part of the flag field of the sah_Link structure.
+******************************************************************************/
+#define SAH_OWNS_LINK_DATA          0x01
+
+/**
+*******************************************************************************
+* The data in a link is not owned by the security function component and
+* therefore it will not attempt to free this memory. To be used as part of the
+* flag field of the sah_Link structure.
+******************************************************************************/
+#define SAH_USES_LINK_DATA          0x02
+
+/**
+*******************************************************************************
+* The data in this link will change when the descriptor gets executed.
+******************************************************************************/
+#define SAH_OUTPUT_LINK             0x04
+
+/**
+*******************************************************************************
+* The ptr and length in this link are really 'established key' info.  They
+* are to be converted to ptr/length before putting on request queue.
+******************************************************************************/
+#define SAH_KEY_IS_HIDDEN           0x08
+
+/**
+*******************************************************************************
+* The link structure has been appended to the previous one by the driver.  It
+* needs to be removed before leaving the driver (and returning to API).
+******************************************************************************/
+#define SAH_REWORKED_LINK           0x10
+
+/**
+*******************************************************************************
+* The length and data fields of this link contain the slot and user id
+* used to access the SCC stored key
+******************************************************************************/
+#define SAH_STORED_KEY_INFO         0x20
+
+
+/**
+*******************************************************************************
+* The Data field points to a physical address, and does not need to be
+* processed by the driver.  Honored only in Kernel API.
+******************************************************************************/
+#define SAH_PREPHYS_DATA            0x40
+
+
+/**
+*******************************************************************************
+* The link was inserted during the Physicalise procedure.  It is tagged so
+* it can be removed during DePhysicalise, thereby returning to the caller an
+* intact chain.
+******************************************************************************/
+#define SAH_LINK_INSERTED_LINK      0x80
+
+
+
+/**
+*******************************************************************************
+* The Data field points to the location of the key, which is in a secure
+* partition held by the user.  The memory address needs to be converted to
+* kernel space manually, by looking through the partitions that the user holds.
+******************************************************************************/
+#define SAH_IN_USER_KEYSTORE       0x100
+
+
+
+/**
+*******************************************************************************
+* sah_Link_Flags
+*
+* Type to be used for flags associated with a Link in security function.
+* These flags are used internally by the security function component only.
+*
+* Values defined at @ref lnkflags
+*
+* @brief typedef for flags field of sah_Link
+******************************************************************************/
+typedef uint32_t sah_Link_Flags;
+
+
+
+/*
+*******************************************************************************
+* Security Parameters Related Structures
+*
+* All of structures associated with API parameters
+*
+******************************************************************************/
+
+/*
+*******************************************************************************
+* Common Types
+*
+* All of structures used across several classes of crytography
+******************************************************************************/
+
+/**
+*******************************************************************************
+* @brief Indefinite precision integer used for security operations on SAHARA
+* accelerator. The data will always be in little Endian format.
+******************************************************************************/
+typedef uint8_t * sah_Int;
+
+/**
+*******************************************************************************
+* @brief Byte array used for block cipher and hash digest/MAC operations on
+* SAHARA accelerator. The Endian format will be as specified by the function
+* using the sah_Oct_Str.
+******************************************************************************/
+typedef uint8_t * sah_Oct_Str;
+
+
+/**
+ * A queue of descriptor heads -- used to hold requests waiting for user to
+ * pick up the results. */
+typedef struct sah_Queue
+{
+    int count;                  /**< # entries in queue  */
+    struct sah_Head_Desc  *head; /**< first entry in queue  */
+    struct sah_Head_Desc  *tail; /**< last entry in queue   */
+} sah_Queue;
+
+
+/******************************************************************************
+ * Enumerations
+ *****************************************************************************/
+/**
+ * Flags for the state of the User Context Object (#fsl_shw_uco_t).
+ */
+typedef enum fsl_shw_user_ctx_flags_t
+{
+    /**
+     * API will block the caller until operation completes.  The result will be
+     * available in the return code.  If this is not set, user will have to get
+     * results using #fsl_shw_get_results().
+     */
+    FSL_UCO_BLOCKING_MODE = 0x01,
+    /**
+     * User wants callback (at the function specified with
+     * #fsl_shw_uco_set_callback()) when the operation completes.  This flag is
+     * valid only if #FSL_UCO_BLOCKING_MODE is not set.
+     */
+    FSL_UCO_CALLBACK_MODE = 0x02,
+    /** Do not free descriptor chain after driver (adaptor) finishes */
+    FSL_UCO_SAVE_DESC_CHAIN = 0x04,
+    /**
+     * User has made at least one request with callbacks requested, so API is
+     * ready to handle others.
+     */
+    FSL_UCO_CALLBACK_SETUP_COMPLETE = 0x08,
+    /**
+     * (virtual) pointer to descriptor chain is completely linked with physical
+     * (DMA) addresses, ready for the hardware.  This flag should not be used
+     * by FSL SHW API programs.
+     */
+    FSL_UCO_CHAIN_PREPHYSICALIZED = 0x10,
+    /**
+     * The user has changed the context but the changes have not been copied to
+     * the kernel driver.
+     */
+    FSL_UCO_CONTEXT_CHANGED = 0x20,
+    /** Internal Use.  This context belongs to a user-mode API user. */
+    FSL_UCO_USERMODE_USER = 0x40,
+} fsl_shw_user_ctx_flags_t;
+
+
+/**
+ * Return code for FSL_SHW library.
+ *
+ * These codes may be returned from a function call.  In non-blocking mode,
+ * they will appear as the status in a Result Object.
+ */
+typedef enum fsl_shw_return_t
+{
+    /**
+     * No error.  As a function return code in Non-blocking mode, this may
+     * simply mean that the operation was accepted for eventual execution.
+     */
+    FSL_RETURN_OK_S = 0,
+    /** Failure for non-specific reason. */
+    FSL_RETURN_ERROR_S,
+   /**
+    * Operation failed because some resource was not able to be allocated.
+    */
+    FSL_RETURN_NO_RESOURCE_S,
+    /** Crypto algorithm unrecognized or improper. */
+    FSL_RETURN_BAD_ALGORITHM_S,
+    /** Crypto mode unrecognized or improper. */
+    FSL_RETURN_BAD_MODE_S,
+    /** Flag setting unrecognized or inconsistent. */
+    FSL_RETURN_BAD_FLAG_S,
+    /** Improper or unsupported key length for algorithm. */
+    FSL_RETURN_BAD_KEY_LENGTH_S,
+    /** Improper parity in a (DES, TDES) key. */
+    FSL_RETURN_BAD_KEY_PARITY_S,
+    /**
+     * Improper or unsupported data length for algorithm or internal buffer.
+     */
+    FSL_RETURN_BAD_DATA_LENGTH_S,
+    /** Authentication / Integrity Check code check failed. */
+    FSL_RETURN_AUTH_FAILED_S,
+    /** A memory error occurred. */
+    FSL_RETURN_MEMORY_ERROR_S,
+    /** An error internal to the hardware occurred. */
+    FSL_RETURN_INTERNAL_ERROR_S,
+    /** ECC detected Point at Infinity */
+    FSL_RETURN_POINT_AT_INFINITY_S,
+    /** ECC detected No Point at Infinity */
+    FSL_RETURN_POINT_NOT_AT_INFINITY_S,
+    /** GCD is One */
+    FSL_RETURN_GCD_IS_ONE_S,
+    /** GCD is not One */
+    FSL_RETURN_GCD_IS_NOT_ONE_S,
+    /** Candidate is Prime */
+    FSL_RETURN_PRIME_S,
+    /** Candidate is not Prime */
+    FSL_RETURN_NOT_PRIME_S,
+    /** N register loaded improperly with even value */
+    FSL_RETURN_EVEN_MODULUS_ERROR_S,
+    /** Divisor is zero. */
+    FSL_RETURN_DIVIDE_BY_ZERO_ERROR_S,
+    /** Bad Exponent or Scalar value for Point Multiply */
+    FSL_RETURN_BAD_EXPONENT_ERROR_S,
+    /** RNG hardware problem. */
+    FSL_RETURN_OSCILLATOR_ERROR_S,
+    /** RNG hardware problem. */
+    FSL_RETURN_STATISTICS_ERROR_S,
+} fsl_shw_return_t;
+
+
+/**
+ * Algorithm Identifier.
+ *
+ * Selection of algorithm will determine how large the block size of the
+ * algorithm is.   Context size is the same length unless otherwise specified.
+ * Selection of algorithm also affects the allowable key length.
+ */
+typedef enum fsl_shw_key_alg_t
+{
+    /**
+     * Key will be used to perform an HMAC.  Key size is 1 to 64 octets.  Block
+     * size is 64 octets.
+     */
+    FSL_KEY_ALG_HMAC,
+    /**
+     * Advanced Encryption Standard (Rijndael).  Block size is 16 octets.  Key
+     * size is 16 octets.  (The single choice of key size is a Sahara platform
+     * limitation.)
+     */
+    FSL_KEY_ALG_AES,
+    /**
+     * Data Encryption Standard.  Block size is 8 octets.  Key size is 8
+     * octets.
+     */
+    FSL_KEY_ALG_DES,
+    /**
+     * 2- or 3-key Triple DES.  Block size is 8 octets.  Key size is 16 octets
+     * for 2-key Triple DES, and 24 octets for 3-key.
+     */
+    FSL_KEY_ALG_TDES,
+    /**
+     * ARC4.  No block size.  Context size is 259 octets.  Allowed key size is
+     * 1-16 octets.  (The choices for key size are a Sahara platform
+     * limitation.)
+     */
+    FSL_KEY_ALG_ARC4,
+} fsl_shw_key_alg_t;
+
+
+/**
+ * Mode selector for Symmetric Ciphers.
+ *
+ * The selection of mode determines how a cryptographic algorithm will be
+ * used to process the plaintext or ciphertext.
+ *
+ * For all modes which are run block-by-block (that is, all but
+ * #FSL_SYM_MODE_STREAM), any partial operations must be performed on a text
+ * length which is multiple of the block size.  Except for #FSL_SYM_MODE_CTR,
+ * these block-by-block algorithms must also be passed a total number of octets
+ * which is a multiple of the block size.
+ *
+ * In modes which require that the total number of octets of data be a multiple
+ * of the block size (#FSL_SYM_MODE_ECB and #FSL_SYM_MODE_CBC), and the user
+ * has a total number of octets which are not a multiple of the block size, the
+ * user must perform any necessary padding to get to the correct data length.
+ */
+typedef enum fsl_shw_sym_mode_t
+{
+    /**
+     * Stream.  There is no associated block size.  Any request to process data
+     * may be of any length.  This mode is only for ARC4 operations, and is
+     * also the only mode used for ARC4.
+     */
+    FSL_SYM_MODE_STREAM,
+
+    /**
+     * Electronic Codebook.  Each block of data is encrypted/decrypted.  The
+     * length of the data stream must be a multiple of the block size.  This
+     * mode may be used for DES, 3DES, and AES.  The block size is determined
+     * by the algorithm.
+     */
+    FSL_SYM_MODE_ECB,
+    /**
+     * Cipher-Block Chaining.  Each block of data is encrypted/decrypted and
+     * then "chained" with the previous block by an XOR function.  Requires
+     * context to start the XOR (previous block).  This mode may be used for
+     * DES, 3DES, and AES.  The block size is determined by the algorithm.
+     */
+    FSL_SYM_MODE_CBC,
+    /**
+     * Counter.  The counter is encrypted, then XORed with a block of data.
+     * The counter is then incremented (using modulus arithmetic) for the next
+     * block. The final operation may be non-multiple of block size.  This mode
+     * may be used for AES.  The block size is determined by the algorithm.
+     */
+    FSL_SYM_MODE_CTR,
+} fsl_shw_sym_mode_t;
+
+
+/**
+ * Algorithm selector for Cryptographic Hash functions.
+ *
+ * Selection of algorithm determines how large the context and digest will be.
+ * Context is the same size as the digest (resulting hash), unless otherwise
+ * specified.
+ */
+typedef enum fsl_shw_hash_alg_t
+{
+    /** MD5 algorithm.  Digest is 16 octets. */
+    FSL_HASH_ALG_MD5,
+    /** SHA-1 (aka SHA or SHA-160) algorithm. Digest is 20 octets. */
+    FSL_HASH_ALG_SHA1,
+    /**
+     * SHA-224 algorithm.  Digest is 28 octets, though context is 32 octets.
+     */
+    FSL_HASH_ALG_SHA224,
+    /** SHA-256 algorithm.  Digest is 32 octets. */
+    FSL_HASH_ALG_SHA256
+} fsl_shw_hash_alg_t;
+
+
+/**
+ * The type of Authentication-Cipher function which will be performed.
+ */
+typedef enum fsl_shw_acc_mode_t
+{
+    /**
+     * CBC-MAC for Counter.  Requires context and modulus.  Final operation may
+     * be non-multiple of block size.  This mode may be used for AES.
+     */
+    FSL_ACC_MODE_CCM,
+    /**
+     * SSL mode.  Not supported.  Combines HMAC and encrypt (or decrypt).
+     * Needs one key object for encryption, another for the HMAC.  The usual
+     * hashing and symmetric encryption algorithms are supported.
+     */
+    FSL_ACC_MODE_SSL,
+} fsl_shw_acc_mode_t;
+
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/**
+ * Flags which control a Hash operation.
+ */
+typedef enum fsl_shw_hash_ctx_flags_t
+{
+    /**
+     * Context is empty.  Hash is started from scratch, with a
+     * message-processed count of zero.
+     */
+    FSL_HASH_FLAGS_INIT = 0x01,
+    /**
+     *  Retrieve context from hardware after hashing.  If used with the
+     *  #FSL_HASH_FLAGS_FINALIZE flag, the final digest value will be saved in
+     *  the object.
+     */
+    FSL_HASH_FLAGS_SAVE = 0x02,
+    /** Place context into hardware before hashing. */
+    FSL_HASH_FLAGS_LOAD = 0x04,
+    /**
+     * PAD message and perform final digest operation.  If user message is
+     * pre-padded, this flag should not be used.
+     */
+    FSL_HASH_FLAGS_FINALIZE = 0x08,
+} fsl_shw_hash_ctx_flags_t;
+
+
+/**
+ * Flags which control an HMAC operation.
+ *
+ * These may be combined by ORing them together.  See #fsl_shw_hmco_set_flags()
+ * and #fsl_shw_hmco_clear_flags().
+ */
+typedef enum fsl_shw_hmac_ctx_flags_t
+{
+    /**
+     * Message context is empty.  HMAC is started from scratch (with key) or
+     * from precompute of inner hash, depending on whether
+     * #FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT is set.
+     */
+    FSL_HMAC_FLAGS_INIT = 1,
+    /**
+     * Retrieve ongoing context from hardware after hashing.  If used with the
+     * #FSL_HMAC_FLAGS_FINALIZE flag, the final digest value (HMAC) will be
+     * saved in the object.
+     */
+    FSL_HMAC_FLAGS_SAVE = 2,
+    /** Place ongoing context into hardware before hashing. */
+    FSL_HMAC_FLAGS_LOAD = 4,
+    /**
+     * PAD message and perform final HMAC operations of inner and outer
+     * hashes.
+     */
+    FSL_HMAC_FLAGS_FINALIZE = 8,
+    /**
+     * This means that the context contains precomputed inner and outer hash
+     * values.
+     */
+    FSL_HMAC_FLAGS_PRECOMPUTES_PRESENT = 16,
+} fsl_shw_hmac_ctx_flags_t;
+
+
+
+/**
+ * Flags to control use of the #fsl_shw_scco_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_scco_set_flags() and #fsl_shw_scco_clear_flags()
+ */
+typedef enum fsl_shw_sym_ctx_flags_t
+{
+    /**
+     * Context is empty.  In ARC4, this means that the S-Box needs to be
+     * generated from the key.  In #FSL_SYM_MODE_CBC mode, this allows an IV of
+     * zero to be specified.  In #FSL_SYM_MODE_CTR mode, it means that an
+     * initial CTR value of zero is desired.
+     */
+    FSL_SYM_CTX_INIT = 1,
+    /**
+     * Load context from object into hardware before running cipher.  In
+     * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+     */
+    FSL_SYM_CTX_LOAD = 2,
+    /**
+     * Save context from hardware into object after running cipher.  In
+     * #FSL_SYM_MODE_CTR mode, this would refer to the Counter Value.
+     */
+    FSL_SYM_CTX_SAVE = 4,
+    /**
+     * Context (SBox) is to be unwrapped and wrapped on each use.
+     * This flag is unsupported.
+     * */
+    FSL_SYM_CTX_PROTECT = 8,
+} fsl_shw_sym_ctx_flags_t;
+
+
+/**
+ * Flags which describe the state of the #fsl_shw_sko_t.
+ *
+ * These may be ORed together to get the desired effect.
+ * See #fsl_shw_sko_set_flags() and #fsl_shw_sko_clear_flags()
+ */
+typedef enum fsl_shw_key_flags_t
+{
+    /** If algorithm is DES or 3DES, do not validate the key parity bits. */
+    FSL_SKO_KEY_IGNORE_PARITY = 1,
+    /** Clear key is present in the object. */
+    FSL_SKO_KEY_PRESENT = 2,
+   /**
+    * Key has been established for use.  This feature is not available for all
+    * platforms, nor for all algorithms and modes.
+    */
+    FSL_SKO_KEY_ESTABLISHED = 4,
+} fsl_shw_key_flags_t;
+
+
+/**
+ * Type of value which is associated with an established key.
+ */
+typedef uint64_t key_userid_t;
+
+
+/**
+ * Flags which describe the state of the #fsl_shw_acco_t.
+ *
+ * The @a FSL_ACCO_CTX_INIT and @a FSL_ACCO_CTX_FINALIZE flags, when used
+ * together, provide for a one-shot operation.
+ */
+typedef enum fsl_shw_auth_ctx_flags_t
+{
+    /** Initialize Context(s) */
+    FSL_ACCO_CTX_INIT = 1,
+    /** Load intermediate context(s). This flag is unsupported. */
+    FSL_ACCO_CTX_LOAD = 2,
+    /** Save intermediate context(s). This flag is unsupported. */
+    FSL_ACCO_CTX_SAVE = 4,
+    /** Create MAC during this operation. */
+    FSL_ACCO_CTX_FINALIZE = 8,
+   /**
+    * Formatting of CCM input data is performed by calls to
+    * #fsl_shw_ccm_nist_format_ctr_and_iv() and
+    * #fsl_shw_ccm_nist_update_ctr_and_iv().
+    */
+    FSL_ACCO_NIST_CCM = 0x10,
+}  fsl_shw_auth_ctx_flags_t;
+
+
+/**
+ * The operation which controls the behavior of #fsl_shw_establish_key().
+ *
+ * These values are passed to #fsl_shw_establish_key().
+ */
+typedef enum fsl_shw_key_wrap_t
+{
+    /** Generate a key from random values. */
+    FSL_KEY_WRAP_CREATE,
+    /** Use the provided clear key. */
+    FSL_KEY_WRAP_ACCEPT,
+    /** Unwrap a previously wrapped key. */
+    FSL_KEY_WRAP_UNWRAP
+} fsl_shw_key_wrap_t;
+
+
+/**
+ *  Modulus Selector for CTR modes.
+ *
+ * The incrementing of the Counter value may be modified by a modulus.  If no
+ * modulus is needed or desired for AES, use #FSL_CTR_MOD_128.
+ */
+typedef enum fsl_shw_ctr_mod_t
+{
+    FSL_CTR_MOD_8,              /**< Run counter with modulus of 2^8. */
+    FSL_CTR_MOD_16,             /**< Run counter with modulus of 2^16. */
+    FSL_CTR_MOD_24,             /**< Run counter with modulus of 2^24. */
+    FSL_CTR_MOD_32,             /**< Run counter with modulus of 2^32. */
+    FSL_CTR_MOD_40,             /**< Run counter with modulus of 2^40. */
+    FSL_CTR_MOD_48,             /**< Run counter with modulus of 2^48. */
+    FSL_CTR_MOD_56,             /**< Run counter with modulus of 2^56. */
+    FSL_CTR_MOD_64,             /**< Run counter with modulus of 2^64. */
+    FSL_CTR_MOD_72,             /**< Run counter with modulus of 2^72. */
+    FSL_CTR_MOD_80,             /**< Run counter with modulus of 2^80. */
+    FSL_CTR_MOD_88,             /**< Run counter with modulus of 2^88. */
+    FSL_CTR_MOD_96,             /**< Run counter with modulus of 2^96. */
+    FSL_CTR_MOD_104,            /**< Run counter with modulus of 2^104. */
+    FSL_CTR_MOD_112,            /**< Run counter with modulus of 2^112. */
+    FSL_CTR_MOD_120,            /**< Run counter with modulus of 2^120. */
+    FSL_CTR_MOD_128             /**< Run counter with modulus of 2^128. */
+} fsl_shw_ctr_mod_t;
+
+/**
+ * Permissions flags for Secure Partitions
+ */
+typedef enum fsl_shw_permission_t
+{
+/** SCM Access Permission: Do not zeroize/deallocate partition on SMN Fail state */
+    FSL_PERM_NO_ZEROIZE =       0x80000000,
+/** SCM Access Permission: Enforce trusted key read in  */
+    FSL_PERM_TRUSTED_KEY_READ = 0x40000000,
+/** SCM Access Permission: Ignore Supervisor/User mode in permission determination */
+    FSL_PERM_HD_S =             0x00000800,
+/** SCM Access Permission: Allow Read Access to  Host Domain */
+    FSL_PERM_HD_R =             0x00000400,
+/** SCM Access Permission: Allow Write Access to  Host Domain */
+    FSL_PERM_HD_W =             0x00000200,
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
+    FSL_PERM_HD_X =             0x00000100,
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+    FSL_PERM_TH_R =             0x00000040,
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+    FSL_PERM_TH_W =             0x00000020,
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
+    FSL_PERM_OT_R =             0x00000004,
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
+    FSL_PERM_OT_W =             0x00000002,
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+    FSL_PERM_OT_X =             0x00000001,
+} fsl_shw_permission_t;
+
+
+
+/******************************************************************************
+ * Data Structures
+ *****************************************************************************/
+
+/**
+ *
+ * @brief Structure type for descriptors
+ *
+ * The first five fields are passed to the hardware.
+ *
+ *****************************************************************************/
+#ifndef USE_NEW_PTRS /* Experimental */
+
+typedef struct sah_Desc {
+	uint32_t header;	/*!< descriptor header value */
+	uint32_t len1;		/*!< number of data bytes in 'ptr1' buffer */
+	void *ptr1;		/*!< pointer to first sah_Link structure */
+	uint32_t len2;		/*!< number of data bytes in 'ptr2' buffer */
+	void *ptr2;		/*!< pointer to second sah_Link structure */
+	struct sah_Desc *next;	/*!< pointer to next descriptor */
+#ifdef __KERNEL__		/* This needs a better test */
+	/* These two must be last.  See sah_Copy_Descriptors */
+	struct sah_Desc *virt_addr;	/*!< Virtual (kernel) address of this
+					   descriptor. */
+	dma_addr_t dma_addr;	/*!< Physical (bus) address of this
+				   descriptor.  */
+	void *original_ptr1;	/*!< user's pointer to ptr1 */
+	void *original_ptr2;	/*!< user's pointer to ptr2 */
+	struct sah_Desc *original_next;	/*!< user's pointer to next */
+#endif
+} sah_Desc;
+
+#else
+
+typedef struct sah_Desc
+{
+    uint32_t          header;   /**< descriptor header value */
+    uint32_t          len1;     /**< number of data bytes in 'ptr1' buffer */
+    uint32_t          hw_ptr1;  /**< pointer to first sah_Link structure */
+    uint32_t          len2;     /**< number of data bytes in 'ptr2' buffer */
+    uint32_t          hw_ptr2;  /**< pointer to second sah_Link structure */
+    uint32_t          hw_next;  /**< pointer to next descriptor */
+    struct sah_Link * ptr1;     /**< (virtual) pointer to first sah_Link structure */
+    struct sah_Link * ptr2;     /**< (virtual) pointer to first sah_Link structure */
+    struct sah_Desc * next;     /**< (virtual) pointer to next descriptor */
+#ifdef __KERNEL__ /* This needs a better test */
+    /* These two must be last.  See sah_Copy_Descriptors */
+    struct sah_Desc * virt_addr; /**< Virtual (kernel) address of this
+                                    descriptor. */
+    dma_addr_t        dma_addr; /**< Physical (bus) address of this
+                                   descriptor.  */
+#endif
+} sah_Desc;
+
+#endif
+
+
+/**
+*******************************************************************************
+* @brief The first descriptor in a chain
+******************************************************************************/
+typedef struct sah_Head_Desc
+{
+    sah_Desc              desc; /**< whole struct - must be first */
+    struct fsl_shw_uco_t* user_info; /**< where result pool lives */
+    uint32_t              user_ref; /**< at time of request */
+    uint32_t              uco_flags; /**< at time of request */
+    uint32_t              status; /**<  Status of queue entry */
+    uint32_t              error_status; /**< If error, register from Sahara */
+    uint32_t              fault_address; /**< If error, register from Sahara */
+    uint32_t              op_status; /**< If error, register from Sahara */
+    fsl_shw_return_t      result; /**< Result of running descriptor  */
+    struct sah_Head_Desc* next; /**< Next in queue  */
+    struct sah_Head_Desc* prev; /**< previous in queue  */
+    struct sah_Head_Desc* user_desc; /**< For API async get_results */
+    void*                 out1_ptr; /**< For async post-processing  */
+    void*                 out2_ptr; /**< For async post-processing  */
+    uint32_t              out_len; /**< For async post-processing  */
+} sah_Head_Desc;
+
+/**
+ * @brief Structure type for links
+ *
+ * The first three fields are used by hardware.
+ *****************************************************************************/
+#ifndef USE_NEW_PTRS
+
+typedef struct sah_Link {
+	size_t len;		/*!< len of 'data' buffer in bytes */
+	uint8_t *data;		/*!< buffer to store data */
+	struct sah_Link* next;	/*!< pointer to the next sah_Link storing
+				 * data */
+	sah_Link_Flags flags;	/*!< indicates the component that created the
+				 * data buffer. Security Function internal
+				 * information */
+	key_userid_t ownerid;	/*!< Auth code for established key */
+	uint32_t slot;		/*!< Location of the the established key */
+#ifdef __KERNEL__		/* This needs a better test */
+	/* These two elements must be last.  See sah_Copy_Links() */
+	struct sah_Link* virt_addr;
+	dma_addr_t dma_addr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+	struct page* vm_info;
+#endif
+	uint8_t* original_data;	/*!< user's version of data pointer */
+	struct sah_Link* original_next;	/*!< user's version of next pointer */
+#ifdef SAH_COPY_DATA
+	uint8_t *copy_data;	/*!< Virtual address of acquired buffer */
+#endif
+#endif				/* kernel-only */
+} sah_Link;
+
+#else
+
+typedef struct sah_Link
+{
+    /** len of 'data' buffer in bytes */
+    size_t            len;
+     /** buffer to store data */
+    uint32_t          hw_data;
+    /** Physical address */
+    uint32_t          hw_next;
+    /**
+     * indicates the component that created the data buffer. Security Function
+     * internal information
+     */
+    sah_Link_Flags    flags;
+     /** (virtual) pointer to data */
+    uint8_t *         data;
+    /** (virtual) pointer to the next sah_Link storing data */
+    struct sah_Link*  next;
+    /** Auth code for established key */
+    key_userid_t      ownerid;
+    /** Location of the the established key */
+    uint32_t          slot;
+#ifdef __KERNEL__ /* This needs a better test */
+    /* These two elements must be last.  See sah_Copy_Links() */
+    struct sah_Link * virt_addr;
+    dma_addr_t        dma_addr;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+    struct page  *    vm_info;
+#endif
+#endif /* kernel-only */
+} sah_Link;
+
+#endif
+
+
+
+/**
+ * Initialization Object
+ */
+typedef struct fsl_sho_ibo_t
+{
+} fsl_sho_ibo_t;
+
+
+/* Imported from Sahara1 driver -- is it needed forever? */
+/**
+*******************************************************************************
+* FIELDS
+*
+*   void * ref - parameter to be passed into the memory function calls
+*
+*   void * (*malloc)(void *ref, size_t n) - pointer to user's malloc function
+*
+*   void   (*free)(void *ref, void *ptr)  - pointer to user's free function
+*
+*   void * (*memcpy)(void *ref, void *dest, const void *src, size_t n) -
+*                                         pointer to user's memcpy function
+*
+*   void * (*memset)(void *ref, void *ptr, int ch, size_t n) - pointer to
+*                                         user's memset function
+*
+* @brief Structure for API memory utilities
+******************************************************************************/
+typedef struct sah_Mem_Util
+{
+    /** Who knows.  Vestigial. */
+    void * mu_ref;
+    /** Acquire buffer of size n bytes */
+    void * (*mu_malloc)(void *ref, size_t n);
+    /** Acquire a sah_Head_Desc */
+    sah_Head_Desc * (*mu_alloc_head_desc)(void *ref);
+    /* Acquire a sah_Desc */
+    sah_Desc * (*mu_alloc_desc)(void *ref);
+    /* Acquire a sah_Link */
+    sah_Link * (*mu_alloc_link)(void *ref);
+    /** Free buffer at ptr */
+    void   (*mu_free)(void *ref, void *ptr);
+    /** Free sah_Head_Desc at ptr */
+    void   (*mu_free_head_desc)(void *ref, sah_Head_Desc *ptr);
+    /** Free sah_Desc at ptr */
+    void   (*mu_free_desc)(void *ref, sah_Desc *ptr);
+    /** Free sah_Link at ptr */
+    void   (*mu_free_link)(void *ref, sah_Link *ptr);
+    /** Funciton which will copy n bytes from src to dest  */
+    void * (*mu_memcpy)(void *ref, void *dest, const void *src, size_t n);
+    /** Set all n bytes of ptr to ch */
+    void * (*mu_memset)(void *ref, void *ptr, int ch, size_t n);
+} sah_Mem_Util;
+
+
+/**
+ * Secure Partition information
+ *
+ * TODO: move this, rename it!
+ */
+typedef struct fsl_shw_spo_t
+{
+    uint32_t                user_base;
+    void*                   kernel_base;
+    struct fsl_shw_spo_t*   next;
+} fsl_shw_spo_t;
+
+
+/* REQ-S2LRD-PINTFC-COA-UCO-001 */
+/**
+ * User Context Object
+ */
+typedef struct fsl_shw_uco_t
+{
+    int           sahara_openfd;    /**< this should be kernel-only?? */
+    sah_Mem_Util* mem_util;     /**< Memory utility fns  */
+    uint32_t      user_ref;     /**< User's reference */
+    void (*callback)(struct fsl_shw_uco_t* uco); /**< User's callback fn  */
+    uint32_t      flags;             /**< from fsl_shw_user_ctx_flags_t */
+    unsigned      pool_size;    /**< maximum size of user pool */
+#ifdef __KERNEL__
+    sah_Queue     result_pool;  /**< where non-blocking results go */
+    os_process_handle_t  process; /**< remember for signalling User mode */
+    fsl_shw_spo_t* partition;    /**< chain of secure partitions owned by
+                                          the user */
+#else
+    struct fsl_shw_uco_t* next; /**< To allow user-mode chaining of contexts,
+                                 for signalling.  */
+#endif
+} fsl_shw_uco_t;
+
+
+/* REQ-S2LRD-PINTFC-API-GEN-006  ??  */
+/**
+ * Result object
+ */
+typedef struct fsl_shw_result_t
+{
+    uint32_t         user_ref;
+    fsl_shw_return_t code;
+    uint32_t         detail1;
+    uint32_t         detail2;
+    sah_Head_Desc*   user_desc;
+} fsl_shw_result_t;
+
+
+/**
+ * Keystore Object
+ */
+typedef struct fsl_shw_kso_t
+{
+#ifdef __KERNEL__
+    os_lock_t       lock;           /**< Pointer to lock that controls access to
+                                      the keystore. */
+#endif
+    void*           user_data;      /**< Pointer to user structure that handles
+                                      the internals of the keystore. */
+    fsl_shw_return_t (*data_init)        (fsl_shw_uco_t* user_ctx,
+                                          void** user_data);
+    void             (*data_cleanup)     (fsl_shw_uco_t* user_ctx,
+                                          void** user_data);
+    fsl_shw_return_t (*slot_verify_access)(void* user_data, uint64_t owner_id,
+                                          uint32_t slot);
+    fsl_shw_return_t (*slot_alloc)       (void* user_data, uint32_t size_bytes,
+                                          uint64_t owner_id, uint32_t* slot);
+    fsl_shw_return_t (*slot_dealloc)     (void* user_data,
+                                          uint64_t owner_id, uint32_t slot);
+    void*            (*slot_get_address) (void* user_data, uint32_t slot);
+    uint32_t         (*slot_get_base)    (void* user_data, uint32_t slot);
+    uint32_t         (*slot_get_offset)  (void* user_data, uint32_t slot);
+    uint32_t         (*slot_get_slot_size)  (void* user_data, uint32_t slot);
+} fsl_shw_kso_t;
+
+
+/* REQ-S2LRD-PINTFC-COA-SKO-001 */
+/**
+ * Secret Key Context Object
+ */
+typedef struct fsl_shw_sko_t
+{
+    uint32_t                flags;
+    fsl_shw_key_alg_t       algorithm;
+    key_userid_t            userid;
+    uint32_t                handle;
+    uint16_t                key_length;
+    uint8_t                 key[64];
+    struct fsl_shw_kso_t*   keystore;   /**< If present, key is in keystore */
+} fsl_shw_sko_t;
+
+
+/* REQ-S2LRD-PINTFC-COA-CO-001 */
+/**
+ * @brief Platform Capability Object
+ */
+typedef struct fsl_shw_pco_t
+{  /* Consider turning these constants into symbols */
+    int api_major;
+    int api_minor;
+    int driver_major;
+    int driver_minor;
+    fsl_shw_key_alg_t  sym_algorithms[4];
+    fsl_shw_sym_mode_t sym_modes[4];
+    fsl_shw_hash_alg_t hash_algorithms[4];
+    uint8_t sym_support[5][4];  /* indexed by key alg then mode */
+
+    int scc_driver_major;
+    int scc_driver_minor;
+    int scm_version;            /**< Version from SCM Configuration register */
+    int smn_version;            /**< Version from SMN Status register */
+    int block_size_bytes;       /**< Number of bytes per block of RAM; also
+                                   block size of the crypto algorithm. */
+    union {
+        struct {
+            int black_ram_size_blocks;  /**< Number of blocks of Black RAM */
+            int red_ram_size_blocks;    /**< Number of blocks of Red RAM */
+        } scc_info;
+        struct {
+            int partition_size_bytes;   /**< Number of bytes in each partition */
+            int partition_count;        /**< Number of partitions on this platform */
+        } scc2_info;
+    };
+} fsl_shw_pco_t;
+
+
+/* REQ-S2LRD-PINTFC-COA-HCO-001 */
+/**
+ * Hash Context Object
+ */
+typedef struct fsl_shw_hco_t /* fsl_shw_hash_context_object */
+{
+    fsl_shw_hash_alg_t       algorithm;
+    uint32_t                 flags;
+    uint8_t                  digest_length; /* in bytes */
+    uint8_t                  context_length; /* in bytes */
+    uint8_t                  context_register_length; /* in bytes */
+    uint32_t                 context[9]; /* largest digest + msg size */
+} fsl_shw_hco_t;
+
+
+/**
+ * HMAC Context Object
+ */
+typedef struct fsl_shw_hmco_t /* fsl_shw_hmac_context_object */
+{
+    fsl_shw_hash_alg_t       algorithm;
+    uint32_t                 flags;
+    uint8_t                  digest_length; /**< in bytes */
+    uint8_t                  context_length; /**< in bytes */
+    uint8_t                  context_register_length; /**< in bytes */
+    uint32_t                 ongoing_context[9]; /**< largest digest + msg
+                                                    size */
+    uint32_t                 inner_precompute[9]; /**< largest digest + msg
+                                                      size */
+    uint32_t                 outer_precompute[9]; /**< largest digest + msg
+                                                      size */
+} fsl_shw_hmco_t;
+
+
+/* REQ-S2LRD-PINTFC-COA-SCCO-001 */
+/**
+ * Symmetric Crypto Context Object Context Object
+ */
+typedef struct fsl_shw_scco_t
+{
+    uint32_t                flags;
+    unsigned                block_size_bytes; /* double duty block&ctx size */
+    fsl_shw_sym_mode_t      mode;
+    /* Could put modulus plus 16-octet context in union with arc4
+       sbox+ptrs... */
+    fsl_shw_ctr_mod_t       modulus_exp;
+    uint8_t                 context[259];
+} fsl_shw_scco_t;
+
+
+/**
+ * Authenticate-Cipher Context Object
+
+ * An object for controlling the function of, and holding information about,
+ * data for the authenticate-cipher functions, #fsl_shw_gen_encrypt() and
+ * #fsl_shw_auth_decrypt().
+ */
+typedef struct fsl_shw_acco_t
+{
+    uint32_t                 flags; /**< See #fsl_shw_auth_ctx_flags_t for
+                                       meanings */
+    fsl_shw_acc_mode_t       mode; /**< CCM only */
+    uint8_t                  mac_length; /**< User's value for length  */
+    unsigned                 q_length; /**< NIST parameter - */
+    fsl_shw_scco_t           cipher_ctx_info; /**< For running
+                                                 encrypt/decrypt. */
+    union {
+        fsl_shw_scco_t       CCM_ctx_info; /**< For running the CBC in
+                                              AES-CCM.  */
+        fsl_shw_hco_t        hash_ctx_info; /**< For running the hash */
+    } auth_info;                /**< "auth" info struct  */
+    uint8_t                  unencrypted_mac[16]; /**< max block size... */
+} fsl_shw_acco_t;
+
+
+/**
+ *  Used by Sahara API to retrieve completed non-blocking results.
+ */
+typedef struct sah_results {
+    unsigned         requested; /**< number of results requested */
+    unsigned         *actual;   /**< number of results obtained */
+    fsl_shw_result_t *results;  /**< pointer to memory to hold results */
+}  sah_results;
+
+
+/******************************************************************************
+ * Access Macros for Objects
+ *****************************************************************************/
+/**
+ * Get FSL SHW API version
+ *
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the API is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the API is to be stored.
+ */
+#define fsl_shw_pco_get_version(pcobject, pcmajor, pcminor)                   \
+{                                                                             \
+    *(pcmajor) = (pcobject)->api_major;                                       \
+    *(pcminor) = (pcobject)->api_minor;                                       \
+}
+
+
+/**
+ * Get underlying driver version.
+ *
+ * @param      pcobject  The Platform Capababilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the driver is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the driver is to be stored.
+ */
+#define fsl_shw_pco_get_driver_version(pcobject, pcmajor, pcminor)            \
+{                                                                             \
+    *(pcmajor) = (pcobject)->driver_major;                                    \
+    *(pcminor) = (pcobject)->driver_minor;                                    \
+}
+
+
+/**
+ * Get list of symmetric algorithms supported.
+ *
+ * @param pcobject           The Platform Capababilities Object to query.
+ * @param[out] pcalgorithms  A pointer to where to store the location of
+ *                           the list of algorithms.
+ * @param[out] pcacount      A pointer to where to store the number of
+ *                           algorithms in the list at @a algorithms.
+ */
+#define fsl_shw_pco_get_sym_algorithms(pcobject, pcalgorithms, pcacount)      \
+{                                                                             \
+    *(pcalgorithms) = (pcobject)->sym_algorithms;                             \
+    *(pcacount) = sizeof((pcobject)->sym_algorithms)/4;                       \
+}
+
+
+/**
+ * Get list of symmetric modes supported.
+ *
+ * @param pcobject        The Platform Capababilities Object to query.
+ * @param[out] gsmodes    A pointer to where to store the location of
+ *                        the list of modes.
+ * @param[out] gsacount   A pointer to where to store the number of
+ *                        algorithms in the list at @a modes.
+ */
+#define fsl_shw_pco_get_sym_modes(pcobject, gsmodes, gsacount)                \
+{                                                                             \
+    *(gsmodes) = (pcobject)->sym_modes;                                       \
+    *(gsacount) = sizeof((pcobject)->sym_modes)/4;                            \
+}
+
+
+/**
+ * Get list of hash algorithms supported.
+ *
+ * @param pcobject           The Platform Capababilities Object to query.
+ * @param[out] gsalgorithms  A pointer which will be set to the list of
+ *                           algorithms.
+ * @param[out] gsacount      The number of algorithms in the list at @a
+ *                           algorithms.
+ */
+#define fsl_shw_pco_get_hash_algorithms(pcobject, gsalgorithms, gsacount)     \
+{                                                                             \
+    *(gsalgorithms) = (pcobject)->hash_algorithms;                            \
+    *(gsacount) = sizeof((pcobject)->hash_algorithms)/4;                      \
+}
+
+
+/**
+ * Determine whether the combination of a given symmetric algorithm and a given
+ * mode is supported.
+ *
+ * @param pcobject   The Platform Capababilities Object to query.
+ * @param pcalg      A Symmetric Cipher algorithm.
+ * @param pcmode     A Symmetric Cipher mode.
+ *
+ * @return 0 if combination is not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_sym_supported(pcobject, pcalg, pcmode)              \
+    ((pcobject)->sym_support[pcalg][pcmode])
+
+
+
+/**
+ * Determine whether a given Encryption-Authentication mode is supported.
+ *
+ * @param pcobject  The Platform Capababilities Object to query.
+ * @param pcmode    The Authentication mode.
+ *
+ * @return 0 if mode is not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_auth_supported(pcobject, pcmode)                    \
+    ((pcmode == FSL_ACC_MODE_CCM) ? 1 : 0)
+
+
+/**
+ * Determine whether Black Keys (key establishment / wrapping) is supported.
+ *
+ * @param pcobject  The Platform Capababilities Object to query.
+ *
+ * @return 0 if wrapping is not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_black_key_supported(pcobject)                     \
+    1
+
+
+/**
+ * Get FSL SHW SCC driver version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @param[out] pcmajor   A pointer to where the major version
+ *                       of the SCC driver is to be stored.
+ * @param[out] pcminor   A pointer to where the minor version
+ *                       of the SCC driver is to be stored.
+ */
+#define fsl_shw_pco_get_scc_driver_version(pcobject, pcmajor, pcminor)        \
+{                                                                             \
+    *(pcmajor) = (pcobject)->scc_driver_major;                                \
+    *(pcminor) = (pcobject)->scc_driver_minor;                                \
+}
+
+
+/**
+ * Get SCM hardware version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The SCM hardware version
+ */
+#define fsl_shw_pco_get_scm_version(pcobject)                                 \
+    ((pcobject)->scm_version)
+
+
+/**
+ * Get SMN hardware version
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The SMN hardware version
+ */
+#define fsl_shw_pco_get_smn_version(pcobject)                                 \
+    ((pcobject)->smn_version)
+
+
+/**
+ * Get the size of an SCM block, in bytes
+ *
+ * @param      pcobject  The Platform Capabilities Object to query.
+ * @return               The size of an SCM block, in bytes.
+ */
+#define fsl_shw_pco_get_scm_block_size(pcobject)                              \
+    ((pcobject)->block_size_bytes)
+
+
+/**
+ * Get size of Black and Red RAM memory
+ *
+ * @param      pcobject    The Platform Capabilities Object to query.
+ * @param[out] black_size  A pointer to where the size of the Black RAM, in
+ *                         blocks, is to be placed.
+ * @param[out] red_size    A pointer to where the size of the Red RAM, in
+ *                         blocks, is to be placed.
+ */
+#define fsl_shw_pco_get_smn_size(pcobject, black_size, red_size)              \
+{                                                                             \
+    if ((pcobject)->scm_version == 1) {                                       \
+        *(black_size) = (pcobject)->scc_info.black_ram_size_blocks;           \
+        *(red_size)   = (pcobject)->scc_info.red_ram_size_blocks;             \
+    } else {                                                                  \
+        *(black_size) = 0;                                                    \
+        *(red_size)   = 0;                                                    \
+    }                                                                         \
+}
+
+
+/**
+ * Determine whether Secure Partitions are supported
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return 0 if secure partitions are not supported, non-zero if supported.
+ */
+#define fsl_shw_pco_check_spo_supported(pcobject)                           \
+    ((pcobject)->scm_version == 2)
+
+
+/**
+ * Get the size of a Secure Partitions
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return Partition size, in bytes.  0 if Secure Partitions not supported.
+ */
+#define fsl_shw_pco_get_spo_size_bytes(pcobject)                            \
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_size_bytes) : 0 )
+
+
+/**
+ * Get the number of Secure Partitions on this platform
+ *
+ * @param pcobject   The Platform Capabilities Object to query.
+ *
+ * @return Number of partitions. 0 if Secure Paritions not supported.  Note
+ *         that this returns the total number of partitions, not all may be
+ *         available to the user.
+ */
+#define fsl_shw_pco_get_spo_count(pcobject)                                 \
+    (((pcobject)->scm_version == 2) ?                                       \
+        ((pcobject)->scc2_info.partition_count) : 0 )
+
+
+/**
+ * Initialize a User Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the User Context Object to initial values, and set the size
+ * of the results pool.  The mode will be set to a default of
+ * #FSL_UCO_BLOCKING_MODE.
+ *
+ * When using non-blocking operations, this sets the maximum number of
+ * operations which can be outstanding.  This number includes the counts of
+ * operations waiting to start, operation(s) being performed, and results which
+ * have not been retrieved.
+ *
+ * Changes to this value are ignored once user registration has completed.  It
+ * should be set to 1 if only blocking operations will ever be performed.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param usize        The maximum number of operations which can be
+ *                     outstanding.
+ */
+#ifdef __KERNEL__
+#define fsl_shw_uco_init(ucontext, usize)                                     \
+{                                                                             \
+      (ucontext)->pool_size = usize;                                          \
+      (ucontext)->flags = FSL_UCO_BLOCKING_MODE;                              \
+      (ucontext)->sahara_openfd = -1;                                         \
+      (ucontext)->mem_util = NULL;                                            \
+      (ucontext)->partition = NULL;                                           \
+      (ucontext)->callback = NULL;                                            \
+}
+#else
+#define fsl_shw_uco_init(ucontext, usize)                                     \
+{                                                                             \
+      (ucontext)->pool_size = usize;                                          \
+      (ucontext)->flags = FSL_UCO_BLOCKING_MODE;                              \
+      (ucontext)->sahara_openfd = -1;                                         \
+      (ucontext)->mem_util = NULL;                                            \
+      (ucontext)->callback = NULL;                                            \
+}
+#endif
+
+
+/**
+ * Set the User Reference for the User Context.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uref         A value which will be passed back with a result.
+ */
+#define fsl_shw_uco_set_reference(ucontext, uref)                             \
+      (ucontext)->user_ref = uref
+
+
+/**
+ * Set the User Reference for the User Context.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param ucallback    The function the API will invoke when an operation
+ *                     completes.
+ */
+#define fsl_shw_uco_set_callback(ucontext, ucallback)                         \
+      (ucontext)->callback = ucallback
+
+
+/**
+ * Set flags in the User Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+#define fsl_shw_uco_set_flags(ucontext, uflags)                               \
+      (ucontext)->flags |= (uflags)
+
+
+/**
+ * Clear flags in the User Context.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param ucontext     The User Context object to operate on.
+ * @param uflags       ORed values from #fsl_shw_user_ctx_flags_t.
+ */
+#define fsl_shw_uco_clear_flags(ucontext, uflags)                             \
+      (ucontext)->flags &= ~(uflags)
+
+
+/**
+ * Retrieve the reference value from a Result Object.
+ *
+ * @param robject  The result object to query.
+ *
+ * @return The reference associated with the request.
+ */
+#define fsl_shw_ro_get_reference(robject)                                    \
+       (robject)->user_ref
+
+
+/**
+ * Retrieve the status code from a Result Object.
+ *
+ * @param robject  The result object to query.
+ *
+ * @return The status of the request.
+ */
+#define fsl_shw_ro_get_status(robject)                                       \
+       (robject)->code
+
+
+/**
+ * Initialize a Secret Key Object.
+ *
+ * This function must be called before performing any other operation with
+ * the Object.
+ *
+ * @param skobject     The Secret Key Object to be initialized.
+ * @param skalgorithm  DES, AES, etc.
+ *
+ */
+#define fsl_shw_sko_init(skobject,skalgorithm)                               \
+{                                                                            \
+       (skobject)->algorithm = skalgorithm;                                  \
+       (skobject)->flags = 0;                                                \
+       (skobject)->keystore = NULL;                                          \
+}
+
+
+/**
+ * Store a cleartext key in the key object.
+ *
+ * This has the side effect of setting the #FSL_SKO_KEY_PRESENT flag and
+ * resetting the #FSL_SKO_KEY_ESTABLISHED flag.
+ *
+ * @param skobject     A variable of type #fsl_shw_sko_t.
+ * @param skkey        A pointer to the beginning of the key.
+ * @param skkeylen     The length, in octets, of the key.  The value should be
+ *                     appropriate to the key size supported by the algorithm.
+ *                     64 octets is the absolute maximum value allowed for this
+ *                     call.
+ */
+#define fsl_shw_sko_set_key(skobject, skkey, skkeylen)                       \
+{                                                                            \
+       (skobject)->key_length = skkeylen;                                    \
+       copy_bytes((skobject)->key, skkey, skkeylen);                         \
+       (skobject)->flags |= FSL_SKO_KEY_PRESENT;                             \
+       (skobject)->flags &= ~FSL_SKO_KEY_ESTABLISHED;                        \
+}
+
+/**
+ * Set a size for the key.
+ *
+ * This function would normally be used when the user wants the key to be
+ * generated from a random source.
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skkeylen   The length, in octets, of the key.  The value should be
+ *                   appropriate to the key size supported by the algorithm.
+ *                   64 octets is the absolute maximum value allowed for this
+ *                   call.
+ */
+#define fsl_shw_sko_set_key_length(skobject, skkeylen)                       \
+       (skobject)->key_length = skkeylen;
+
+
+/**
+ * Set the User ID associated with the key.
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skuserid   The User ID to identify authorized users of the key.
+ */
+#define fsl_shw_sko_set_user_id(skobject, skuserid)                           \
+       (skobject)->userid = (skuserid)
+
+/**
+ * Establish a user Keystore to hold the key.
+ */
+#define fsl_shw_sko_set_keystore(skobject, user_keystore)                     \
+       (skobject)->keystore = (user_keystore)
+
+
+
+/**
+ * Set the establish key handle into a key object.
+ *
+ * The @a userid field will be used to validate the access to the unwrapped
+ * key.  This feature is not available for all platforms, nor for all
+ * algorithms and modes.
+ *
+ * The #FSL_SKO_KEY_ESTABLISHED will be set (and the #FSL_SKO_KEY_PRESENT flag
+ * will be cleared).
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skuserid   The User ID to verify this user is an authorized user of
+ *                   the key.
+ * @param skhandle   A @a handle from #fsl_shw_sko_get_established_info.
+ */
+#define fsl_shw_sko_set_established_info(skobject, skuserid, skhandle)        \
+{                                                                             \
+       (skobject)->userid = (skuserid);                                       \
+       (skobject)->handle = (skhandle);                                       \
+       (skobject)->flags |= FSL_SKO_KEY_ESTABLISHED;                          \
+       (skobject)->flags &=                                                   \
+                       ~(FSL_SKO_KEY_PRESENT);   \
+}
+
+
+/**
+ * Retrieve the established-key handle from a key object.
+ *
+ * @param skobject   A variable of type #fsl_shw_sko_t.
+ * @param skhandle   The location to store the @a handle of the unwrapped
+ *                   key.
+ */
+#define fsl_shw_sko_get_established_info(skobject, skhandle)                  \
+       *(skhandle) = (skobject)->handle
+
+
+/**
+ * Extract the algorithm from a key object.
+ *
+ * @param      skobject     The Key Object to be queried.
+ * @param[out] skalgorithm  A pointer to the location to store the algorithm.
+ */
+#define fsl_shw_sko_get_algorithm(skobject, skalgorithm)                      \
+       *(skalgorithm) = (skobject)->algorithm
+
+
+/**
+ * Determine the size of a wrapped key based upon the cleartext key's length.
+ *
+ * This function can be used to calculate the number of octets that
+ * #fsl_shw_extract_key() will write into the location at @a covered_key.
+ *
+ * If zero is returned at @a length, this means that the key length in
+ * @a key_info is not supported.
+ *
+ * @param      wkeyinfo         Information about a key to be wrapped.
+ * @param      wkeylen          Location to store the length of a wrapped
+ *                              version of the key in @a key_info.
+ */
+#define fsl_shw_sko_calculate_wrapped_size(wkeyinfo, wkeylen)                 \
+{                                                                             \
+     if ((wkeyinfo)->key_length > 32) {                                       \
+         *(wkeylen) = 0;                                                      \
+     } else {                                                                 \
+         *(wkeylen) = 66;                                                     \
+     }                                                                        \
+}
+
+
+/**
+ * Set some flags in the key object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param skobject     A variable of type #fsl_shw_sko_t.
+ * @param skflags      (One or more) ORed members of #fsl_shw_key_flags_t which
+ *                     are to be set.
+ */
+#define fsl_shw_sko_set_flags(skobject, skflags)                              \
+      (skobject)->flags |= (skflags)
+
+
+/**
+ * Clear some flags in the key object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param skobject      A variable of type #fsl_shw_sko_t.
+ * @param skflags       (One or more) ORed members of #fsl_shw_key_flags_t
+ *                      which are to be reset.
+ */
+#define fsl_shw_sko_clear_flags(skobject, skflags)                            \
+      (skobject)->flags &= ~(skflags)
+
+
+/**
+ * Initialize a Hash Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the hash
+ * context object.
+ *
+ * @param      hcobject    The hash context to operate upon.
+ * @param      hcalgorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                         #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+#define fsl_shw_hco_init(hcobject, hcalgorithm)                               \
+{                                                                             \
+     (hcobject)->algorithm = hcalgorithm;                                     \
+     (hcobject)->flags = 0;                                                   \
+     switch (hcalgorithm) {                                                   \
+     case FSL_HASH_ALG_MD5:                                                   \
+         (hcobject)->digest_length = 16;                                      \
+         (hcobject)->context_length = 16;                                     \
+         (hcobject)->context_register_length = 24;                            \
+         break;                                                               \
+     case FSL_HASH_ALG_SHA1:                                                  \
+         (hcobject)->digest_length = 20;                                      \
+         (hcobject)->context_length = 20;                                     \
+         (hcobject)->context_register_length = 24;                            \
+         break;                                                               \
+     case FSL_HASH_ALG_SHA224:                                                \
+         (hcobject)->digest_length = 28;                                      \
+         (hcobject)->context_length = 32;                                     \
+         (hcobject)->context_register_length = 36;                            \
+         break;                                                               \
+     case FSL_HASH_ALG_SHA256:                                                \
+         (hcobject)->digest_length = 32;                                      \
+         (hcobject)->context_length = 32;                                     \
+         (hcobject)->context_register_length = 36;                            \
+         break;                                                               \
+     default:                                                                 \
+         /* error ! */                                                        \
+         (hcobject)->digest_length = 1;                                       \
+         (hcobject)->context_length = 1;                                      \
+         (hcobject)->context_register_length = 1;                             \
+         break;                                                               \
+     }                                                                        \
+}
+
+
+/**
+ * Get the current hash value and message length from the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hcobject   The hash context to query.
+ * @param[out] hccontext  Pointer to the location of @a length octets where to
+ *                        store a copy of the current value of the digest.
+ * @param      hcclength  Number of octets of hash value to copy.
+ * @param[out] hcmsglen   Pointer to the location to store the number of octets
+ *                        already hashed.
+ */
+#define fsl_shw_hco_get_digest(hcobject, hccontext, hcclength, hcmsglen)      \
+{                                                                             \
+     copy_bytes(hccontext, (hcobject)->context, hcclength);                   \
+         if ((hcobject)->algorithm == FSL_HASH_ALG_SHA224                     \
+             || (hcobject)->algorithm == FSL_HASH_ALG_SHA256) {               \
+             *(hcmsglen) = (hcobject)->context[8];                            \
+         } else {                                                             \
+             *(hcmsglen) = (hcobject)->context[5];                            \
+         }                                                                    \
+}
+
+
+/**
+ * Get the hash algorithm from the hash context object.
+ *
+ * @param      hcobject    The hash context to query.
+ * @param[out] hcalgorithm Pointer to where the algorithm is to be stored.
+ */
+#define fsl_shw_hco_get_info(hcobject, hcalgorithm)                           \
+{                                                                             \
+     *(hcalgorithm) = (hcobject)->algorithm;                                  \
+}
+
+
+/**
+ * Set the current hash value and message length in the hash context object.
+ *
+ * The algorithm must have already been specified.  See #fsl_shw_hco_init().
+ *
+ * @param      hcobject  The hash context to operate upon.
+ * @param      hccontext Pointer to buffer of appropriate length to copy into
+ *                       the hash context object.
+ * @param      hcmsglen  The number of octets of the message which have
+ *                        already been hashed.
+ *
+ */
+#define fsl_shw_hco_set_digest(hcobject, hccontext, hcmsglen)                 \
+{                                                                             \
+     copy_bytes((hcobject)->context, hccontext, (hcobject)->context_length);  \
+     if (((hcobject)->algorithm == FSL_HASH_ALG_SHA224)                       \
+         || ((hcobject)->algorithm == FSL_HASH_ALG_SHA256)) {                 \
+         (hcobject)->context[8] = hcmsglen;                                   \
+     } else {                                                                 \
+         (hcobject)->context[5] = hcmsglen;                                   \
+     }                                                                        \
+}
+
+
+/**
+ * Set flags in a Hash Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The hash context to be operated on.
+ * @param hcflags    The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+#define fsl_shw_hco_set_flags(hcobject, hcflags)                              \
+      (hcobject)->flags |= (hcflags)
+
+
+/**
+ * Clear flags in a Hash Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The hash context to be operated on.
+ * @param hcflags    The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hash_ctx_flags_t.
+ */
+#define fsl_shw_hco_clear_flags(hcobject, hcflags)                            \
+      (hcobject)->flags &= ~(hcflags)
+
+
+
+/**
+ * Initialize an HMAC Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  It sets the current message length and hash algorithm in the HMAC
+ * context object.
+ *
+ * @param      hcobject    The HMAC context to operate upon.
+ * @param      hcalgorithm The hash algorithm to be used (#FSL_HASH_ALG_MD5,
+ *                         #FSL_HASH_ALG_SHA256, etc).
+ *
+ */
+#define fsl_shw_hmco_init(hcobject, hcalgorithm)                              \
+    fsl_shw_hco_init(hcobject, hcalgorithm)
+
+
+/**
+ * Set flags in an HMAC Context Object.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The HMAC context to be operated on.
+ * @param hcflags    The flags to be set in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+#define fsl_shw_hmco_set_flags(hcobject, hcflags)                             \
+      (hcobject)->flags |= (hcflags)
+
+
+/**
+ * Clear flags in an HMAC Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param hcobject   The HMAC context to be operated on.
+ * @param hcflags    The flags to be reset in the context.  These can be ORed
+ *                   members of #fsl_shw_hmac_ctx_flags_t.
+ */
+#define fsl_shw_hmco_clear_flags(hcobject, hcflags)                           \
+      (hcobject)->flags &= ~(hcflags)
+
+
+/**
+ * Initialize a Symmetric Cipher Context Object.
+ *
+ * This function must be called before performing any other operation with the
+ * Object.  This will set the @a mode and @a algorithm and initialize the
+ * Object.
+ *
+ * @param scobject  The context object to operate on.
+ * @param scalg     The cipher algorithm this context will be used with.
+ * @param scmode    #FSL_SYM_MODE_CBC, #FSL_SYM_MODE_ECB, etc.
+ *
+ */
+#define fsl_shw_scco_init(scobject, scalg, scmode)                            \
+{                                                                             \
+      register uint32_t bsb;   /* block-size bytes */                         \
+                                                                              \
+      switch (scalg) {                                                        \
+      case FSL_KEY_ALG_AES:                                                   \
+          bsb = 16;                                                           \
+          break;                                                              \
+      case FSL_KEY_ALG_DES:                                                   \
+          /* fall through */                                                  \
+      case FSL_KEY_ALG_TDES:                                                  \
+          bsb = 8;                                                            \
+          break;                                                              \
+      case FSL_KEY_ALG_ARC4:                                                  \
+          bsb = 259;                                                          \
+          break;                                                              \
+      case FSL_KEY_ALG_HMAC:                                                  \
+          bsb = 1;  /* meaningless */                                         \
+          break;                                                              \
+      default:                                                                \
+          bsb = 00;                                                           \
+      }                                                                       \
+      (scobject)->block_size_bytes = bsb;                                     \
+      (scobject)->mode = scmode;                                              \
+      (scobject)->flags = 0;                                                  \
+}
+
+
+/**
+ * Set the flags for a Symmetric Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param scobject The context object to operate on.
+ * @param scflags  The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_scco_set_flags(scobject, scflags)                             \
+       (scobject)->flags |= (scflags)
+
+
+/**
+ * Clear some flags in a Symmetric Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param scobject The context object to operate on.
+ * @param scflags  The flags to reset (one or more values from
+ *                 #fsl_shw_sym_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_scco_clear_flags(scobject, scflags)                           \
+       (scobject)->flags &= ~(scflags)
+
+
+/**
+ * Set the Context (IV) for a Symmetric Cipher Context.
+ *
+ * This is to set the context/IV for #FSL_SYM_MODE_CBC mode, or to set the
+ * context (the S-Box and pointers) for ARC4.  The full context size will
+ * be copied.
+ *
+ * @param scobject  The context object to operate on.
+ * @param sccontext A pointer to the buffer which contains the context.
+ *
+ */
+#define fsl_shw_scco_set_context(scobject, sccontext)                         \
+       copy_bytes((scobject)->context, sccontext,                             \
+                  (scobject)->block_size_bytes)
+
+/**
+ * Get the Context for a Symmetric Cipher Context.
+ *
+ * This is to retrieve the context/IV for #FSL_SYM_MODE_CBC mode, or to
+ * retrieve context (the S-Box and pointers) for ARC4.  The full context
+ * will be copied.
+ *
+ * @param      scobject  The context object to operate on.
+ * @param[out] sccontext Pointer to location where context will be stored.
+ */
+#define fsl_shw_scco_get_context(scobject, sccontext)                         \
+       copy_bytes(sccontext, (scobject)->context, (scobject)->block_size_bytes)
+
+
+/**
+ * Set the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will set the Counter Value for CTR mode.
+ *
+ * @param scobject  The context object to operate on.
+ * @param sccounter The starting counter value.  The number of octets.
+ *                  copied will be the block size for the algorithm.
+ * @param scmodulus The modulus for controlling the incrementing of the
+ *                  counter.
+ *
+ */
+#define fsl_shw_scco_set_counter_info(scobject, sccounter, scmodulus)        \
+       {                                                                     \
+           if ((sccounter) != NULL) {                                        \
+               copy_bytes((scobject)->context, sccounter,                    \
+                          (scobject)->block_size_bytes);                     \
+           }                                                                 \
+           (scobject)->modulus_exp = scmodulus;                              \
+       }
+
+
+/**
+ * Get the Counter Value for a Symmetric Cipher Context.
+ *
+ * This will retrieve the Counter Value is for CTR mode.
+ *
+ * @param     scobject    The context object to query.
+ * @param[out] sccounter  Pointer to location to store the current counter
+ *                        value.  The number of octets copied will be the
+ *                        block size for the algorithm.
+ * @param[out] scmodulus  Pointer to location to store the modulus.
+ *
+ */
+#define fsl_shw_scco_get_counter_info(scobject, sccounter, scmodulus)        \
+       {                                                                     \
+           if ((sccounter) != NULL) {                                        \
+               copy_bytes(sccounter, (scobject)->context,                    \
+                          (scobject)->block_size_bytes);                     \
+           }                                                                 \
+           if ((scmodulus) != NULL) {                                        \
+               *(scmodulus) = (scobject)->modulus_exp;                       \
+           }                                                                 \
+       }
+
+
+/**
+ * Initialize a Authentication-Cipher Context.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acmode    The mode for this object (only #FSL_ACC_MODE_CCM
+ *                  supported).
+ */
+#define fsl_shw_acco_init(acobject, acmode)                                   \
+   {                                                                          \
+       (acobject)->flags = 0;                                                 \
+       (acobject)->mode = (acmode);                                           \
+   }
+
+
+/**
+ * Set the flags for a Authentication-Cipher Context.
+ *
+ * Turns on the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acflags   The flags to set (one or more from
+ *                  #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_acco_set_flags(acobject, acflags)                             \
+       (acobject)->flags |= (acflags)
+
+
+/**
+ * Clear some flags in a Authentication-Cipher Context Object.
+ *
+ * Turns off the flags specified in @a flags.  Other flags are untouched.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acflags   The flags to reset (one or more from
+ *                  #fsl_shw_auth_ctx_flags_t ORed together).
+ *
+ */
+#define fsl_shw_acco_clear_flags(acobject, acflags)                           \
+       (acobject)->flags &= ~(acflags)
+
+
+/**
+ * Set up the Authentication-Cipher Object for CCM mode.
+ *
+ * This will set the @a auth_object for CCM mode and save the @a ctr,
+ * and @a mac_length.  This function can be called instead of
+ * #fsl_shw_acco_init().
+ *
+ * The paramater @a ctr is Counter Block 0, (counter value 0), which is for the
+ * MAC.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acalg     Cipher algorithm.  Only AES is supported.
+ * @param accounter The initial counter value.
+ * @param acmaclen  The number of octets used for the MAC.  Valid values are
+ *                  4, 6, 8, 10, 12, 14, and 16.
+ */
+/* Do we need to stash the +1 value of the CTR somewhere? */
+#define fsl_shw_acco_set_ccm(acobject, acalg, accounter, acmaclen)            \
+{                                                                             \
+      (acobject)->flags = 0;                                                  \
+      (acobject)->mode = FSL_ACC_MODE_CCM;                                    \
+      (acobject)->auth_info.CCM_ctx_info.block_size_bytes = 16;               \
+      (acobject)->cipher_ctx_info.block_size_bytes = 16;                      \
+      (acobject)->mac_length = acmaclen;                                      \
+      fsl_shw_scco_set_counter_info(&(acobject)->cipher_ctx_info, accounter,  \
+            FSL_CTR_MOD_128);                                                 \
+}
+
+
+/**
+ * Format the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will also set the IV and CTR values per Appendix A of NIST
+ * Special Publication 800-38C (May 2004).  It will also perform the
+ * #fsl_shw_acco_set_ccm() operation with information derived from this set of
+ * parameters.
+ *
+ * Note this function assumes the algorithm is AES.  It initializes the
+ * @a auth_object by setting the mode to #FSL_ACC_MODE_CCM and setting the
+ * flags to be #FSL_ACCO_NIST_CCM.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param act       The number of octets used for the MAC.  Valid values are
+ *                  4, 6, 8, 10, 12, 14, and 16.
+ * @param acad      Number of octets of Associated Data (may be zero).
+ * @param acq       A value for the size of the length of @a q field.  Valid
+ *                  values are 1-8.
+ * @param acN       The Nonce (packet number or other changing value). Must
+ *                  be (15 - @a q_length) octets long.
+ * @param acQ       The value of Q (size of the payload in octets).
+ *
+ */
+/* Do we need to stash the +1 value of the CTR somewhere? */
+#define fsl_shw_ccm_nist_format_ctr_and_iv(acobject, act, acad, acq, acN, acQ)\
+    {                                                                         \
+        uint64_t Q = acQ;                                                     \
+        uint8_t bflag = ((acad)?0x40:0) | ((((act)-2)/2)<<3) | ((acq)-1);     \
+        unsigned i;                                                           \
+        uint8_t* qptr = (acobject)->auth_info.CCM_ctx_info.context + 15;      \
+        (acobject)->auth_info.CCM_ctx_info.block_size_bytes = 16;             \
+        (acobject)->cipher_ctx_info.block_size_bytes = 16;                    \
+        (acobject)->mode = FSL_ACC_MODE_CCM;                                  \
+        (acobject)->flags  = FSL_ACCO_NIST_CCM;                               \
+                                                                              \
+        /* Store away the MAC length (after calculating actual value */       \
+        (acobject)->mac_length = (act);                                       \
+        /* Set Flag field in Block 0 */                                       \
+        *((acobject)->auth_info.CCM_ctx_info.context) = bflag;                \
+        /* Set Nonce field in Block 0 */                                      \
+        copy_bytes((acobject)->auth_info.CCM_ctx_info.context+1, acN,         \
+                   15-(acq));                                                 \
+        /* Set Flag field in ctr */                                           \
+        *((acobject)->cipher_ctx_info.context) = (acq)-1;                     \
+        /* Update the Q (payload length) field of Block0 */                   \
+        (acobject)->q_length = acq;                                           \
+        for (i = 0; i < (acq); i++) {                                         \
+            *qptr-- = Q & 0xFF;                                               \
+            Q >>= 8;                                                          \
+        }                                                                     \
+        /* Set the Nonce field of the ctr */                                  \
+        copy_bytes((acobject)->cipher_ctx_info.context+1, acN, 15-(acq));     \
+        /* Clear the block counter field of the ctr */                        \
+        memset((acobject)->cipher_ctx_info.context+16-(acq), 0, (acq)+1);     \
+     }
+
+
+/**
+ * Update the First Block (IV) & Initial Counter Value per NIST CCM.
+ *
+ * This function will set the IV and CTR values per Appendix A of NIST Special
+ * Publication 800-38C (May 2004).
+ *
+ * Note this function assumes that #fsl_shw_ccm_nist_format_ctr_and_iv() has
+ * previously been called on the @a auth_object.
+ *
+ * @param acobject  Pointer to object to operate on.
+ * @param acN       The Nonce (packet number or other changing value). Must
+ *                  be (15 - @a q_length) octets long.
+ * @param acQ       The value of Q (size of the payload in octets).
+ *
+ */
+/* Do we need to stash the +1 value of the CTR somewhere? */
+#define fsl_shw_ccm_nist_update_ctr_and_iv(acobject, acN, acQ)                \
+     {                                                                        \
+        uint64_t Q = acQ;                                                     \
+        unsigned i;                                                           \
+        uint8_t* qptr = (acobject)->auth_info.CCM_ctx_info.context + 15;      \
+                                                                              \
+        /* Update the Nonce field field of Block0 */                          \
+        copy_bytes((acobject)->auth_info.CCM_ctx_info.context+1, acN,         \
+               15 - (acobject)->q_length);                                    \
+        /* Update the Q (payload length) field of Block0 */                   \
+        for (i = 0; i < (acobject)->q_length; i++) {                          \
+            *qptr-- = Q & 0xFF;                                               \
+            Q >>= 8;                                                          \
+        }                                                                     \
+        /* Update the Nonce field of the ctr */                               \
+        copy_bytes((acobject)->cipher_ctx_info.context+1, acN,                \
+               15 - (acobject)->q_length);                                    \
+     }
+
+
+/******************************************************************************
+ * Library functions
+ *****************************************************************************/
+/* REQ-S2LRD-PINTFC-API-GEN-003 */
+extern fsl_shw_pco_t* fsl_shw_get_capabilities(fsl_shw_uco_t* user_ctx);
+
+
+/* REQ-S2LRD-PINTFC-API-GEN-004 */
+extern fsl_shw_return_t fsl_shw_register_user(fsl_shw_uco_t* user_ctx);
+
+/* REQ-S2LRD-PINTFC-API-GEN-005 */
+extern fsl_shw_return_t fsl_shw_deregister_user(fsl_shw_uco_t* user_ctx);
+
+
+/* REQ-S2LRD-PINTFC-API-GEN-006 */
+extern fsl_shw_return_t fsl_shw_get_results(fsl_shw_uco_t* user_ctx,
+                                            unsigned result_size,
+                                            fsl_shw_result_t results[],
+                                            unsigned* result_count);
+
+extern fsl_shw_return_t fsl_shw_establish_key(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_key_wrap_t establish_type,
+                                const uint8_t* key);
+
+extern fsl_shw_return_t fsl_shw_extract_key(fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                uint8_t* covered_key);
+
+extern fsl_shw_return_t fsl_shw_release_key(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info);
+
+extern void *fsl_shw_smalloc(fsl_shw_uco_t* user_ctx,
+                             uint32_t size,
+                             const uint8_t *UMID,
+                             uint32_t permissions);
+
+extern fsl_shw_return_t fsl_shw_sfree(
+                                fsl_shw_uco_t* user_ctx,
+                                void *address);
+
+extern fsl_shw_return_t fsl_shw_diminish_perms(
+                                fsl_shw_uco_t* user_ctx,
+                                void *address,
+                                uint32_t permissions);
+
+
+#ifndef __KERNEL__
+#ifdef FSL_HAVE_SCC2
+
+#define scc_engage_partition(address, UMID, permissions)                    \
+{                                                                           \
+    uint8_t* UMID_base = address + 0x10;                                    \
+    uint32_t* MAP_base = address;                                           \
+    uint8_t i;                                                              \
+                                                                            \
+    for(i = 0; i < 16; i++)                                                 \
+        UMID_base[i] = UMID[i];                                             \
+                                                                            \
+    MAP_base[0] = permissions;                                              \
+                                                                            \
+    /* TODO: check to see that the partition is engaged */                  \
+}
+
+#else /* FSL_HAVE_SCC2 */
+
+#define scc_engage_partition(address, UMD, permissions)                     \
+{                                                                           \
+    (void)address;                                                          \
+    (void)UMID;                                                             \
+    (void)permissions;                                                      \
+}
+
+#endif /* FSL_HAVE_SCC2 */
+#endif /* __KERNEL__ */
+
+
+
+extern fsl_shw_return_t do_system_keystore_slot_alloc(
+        fsl_shw_uco_t* user_ctx,
+        uint32_t key_lenth,
+        uint64_t ownerid,
+        uint32_t *slot);
+
+extern fsl_shw_return_t do_system_keystore_slot_dealloc(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot);
+
+extern fsl_shw_return_t do_system_keystore_slot_load(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot,
+        const uint8_t *key,
+        uint32_t key_length);
+
+extern fsl_shw_return_t do_system_keystore_slot_encrypt(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot,
+        uint32_t key_length,
+        uint8_t* black_data);
+
+extern fsl_shw_return_t do_system_keystore_slot_decrypt(
+        fsl_shw_uco_t* user_ctx,
+        uint64_t ownerid,
+        uint32_t slot,
+        uint32_t key_length,
+        const uint8_t* black_data);
+
+
+
+extern fsl_shw_return_t
+do_scc_encrypt_region(fsl_shw_uco_t* user_ctx,
+                      void* partition_base, uint32_t offset,
+                      uint32_t length, uint8_t* black_data,
+                      uint64_t owner_id);
+
+extern fsl_shw_return_t
+do_scc_decrypt_region(fsl_shw_uco_t* user_ctx,
+                      void* partition_base, uint32_t offset,
+                      uint32_t length, const uint8_t* black_data,
+                      uint64_t owner_id);
+
+extern fsl_shw_return_t
+system_keystore_get_slot_info(uint64_t owner_id, uint32_t slot, uint32_t *address,
+                              uint32_t *slot_size_bytes);
+
+
+
+/* REQ-S2LRD-PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+extern fsl_shw_return_t fsl_shw_symmetric_encrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_scco_t* sym_ctx,
+                                uint32_t length,
+                                const uint8_t* pt,
+                                uint8_t* ct);
+
+/* PINTFC-API-BASIC-SYM-002 */
+/* PINTFC-API-BASIC-SYM-ARC4-001 */
+/* PINTFC-API-BASIC-SYM-ARC4-002 */
+extern fsl_shw_return_t fsl_shw_symmetric_decrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_scco_t* sym_ctx,
+                                uint32_t length,
+                                const uint8_t* ct,
+                                uint8_t* pt);
+
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HASH-005 */
+extern fsl_shw_return_t fsl_shw_hash(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_hco_t* hash_ctx,
+                                const uint8_t* msg,
+                                uint32_t length,
+                                uint8_t* result,
+                                uint32_t result_len);
+
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-001 */
+extern fsl_shw_return_t fsl_shw_hmac_precompute(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_hmco_t* hmac_ctx);
+
+
+/* REQ-S2LRD-PINTFC-API-BASIC-HMAC-002 */
+extern fsl_shw_return_t fsl_shw_hmac(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_sko_t* key_info,
+                                fsl_shw_hmco_t* hmac_ctx,
+                                const uint8_t* msg,
+                                uint32_t length,
+                                uint8_t* result,
+                                uint32_t result_len);
+
+
+/* REQ-S2LRD-PINTFC-API-BASIC-RNG-002 */
+extern fsl_shw_return_t fsl_shw_get_random(
+                                fsl_shw_uco_t* user_ctx,
+                                uint32_t length,
+                                uint8_t* data);
+
+
+extern fsl_shw_return_t fsl_shw_add_entropy(
+                                fsl_shw_uco_t* user_ctx,
+                                uint32_t length,
+                                uint8_t* data);
+
+extern fsl_shw_return_t fsl_shw_gen_encrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_acco_t* auth_ctx,
+                                fsl_shw_sko_t* cipher_key_info,
+                                fsl_shw_sko_t* auth_key_info,
+                                uint32_t auth_data_length,
+                                const uint8_t* auth_data,
+                                uint32_t payload_length,
+                                const uint8_t* payload,
+                                uint8_t* ct,
+                                uint8_t* auth_value);
+
+
+extern fsl_shw_return_t fsl_shw_auth_decrypt(
+                                fsl_shw_uco_t* user_ctx,
+                                fsl_shw_acco_t* auth_ctx,
+                                fsl_shw_sko_t* cipher_key_info,
+                                fsl_shw_sko_t* auth_key_info,
+                                uint32_t auth_data_length,
+                                const uint8_t* auth_data,
+                                uint32_t payload_length,
+                                const uint8_t* ct,
+                                const uint8_t* auth_value,
+                                uint8_t* payload);
+
+fsl_shw_return_t sah_Append_Desc (
+    const sah_Mem_Util *mu,
+    sah_Head_Desc **desc_head,
+    const uint32_t header,
+    sah_Link *link1,
+    sah_Link *link2);
+
+/* Utility Function leftover from sahara1 API */
+void sah_Descriptor_Chain_Destroy(
+    const sah_Mem_Util    * mu,
+    sah_Head_Desc        ** desc_chain);
+
+/* Utility Function leftover from sahara1 API */
+fsl_shw_return_t sah_Descriptor_Chain_Execute(
+    sah_Head_Desc *desc_chain,
+    fsl_shw_uco_t *user_ctx);
+
+fsl_shw_return_t sah_Append_Link(
+    const sah_Mem_Util *mu,
+    sah_Link *link,
+    uint8_t *p,
+    const size_t length,
+    const sah_Link_Flags flags);
+
+fsl_shw_return_t sah_Create_Link(
+    const sah_Mem_Util *mu,
+    sah_Link **link,
+    uint8_t *p,
+    const size_t length,
+    const sah_Link_Flags flags);
+
+fsl_shw_return_t sah_Create_Key_Link(
+    const sah_Mem_Util *mu,
+    sah_Link **link,
+    fsl_shw_sko_t* key_info);
+
+void sah_Destroy_Link(
+    const sah_Mem_Util *mu,
+    sah_Link * link);
+
+void sah_Postprocess_Results(
+    fsl_shw_uco_t* user_ctx,
+    sah_results* result_info);
+
+
+#endif /* SAHARA2_API_H */
diff --git a/test/mxc_scc2/scc2_setup.sh b/test/mxc_scc2/scc2_setup.sh
new file mode 100644
index 0000000..1a379d8
--- /dev/null
+++ b/test/mxc_scc2/scc2_setup.sh
@@ -0,0 +1,109 @@
+#!/bin/sh
+## This command should be checked for error status.  It has numerous side
+## effects relating to exportation of symbols
+##
+## The command 'scc2_test' must be in its PATH
+
+
+############################################################################
+#
+# Internal functions
+#
+############################################################################
+
+# Initialize variable names for Register offsets
+init_offsets()
+{
+    SCM_VERSION=0000
+    SCM_INTERRUPT_CTRL=0008
+    SCM_COMMAND_STATUS=000C
+    SCM_ERROR_STATUS=0010
+    SCM_DMA_FAULT_ADDR=0014
+    SCM_PARTITION_OWNERS=0018
+    SCM_PARTITIONS_ENGAGED=001C
+    SCM_UNIQUE_NO_0=0020
+    SCM_UNIQUE_NO_1=0024
+    SCM_UNIQUE_NO_2=0028
+    SCM_UNIQUE_NO_3=002C
+    SCM_ZEROIZE_CMD=0050
+    SCM_CIPHER_CMD=0055
+    SCM_CIPHER_BLACK_START=0058
+    SCM_INTERNAL_DEBUG=005C
+    SCM_CIPHER_IV_0=0060
+    SCM_CIPHER_IV_1=0064
+    SCM_CIPHER_IV_2=0068
+    SCM_CIPHER_IV_3=006C
+    SCM_SMID_BASE=0080
+    SCM_MAP_BASE=0084
+
+    SMN_STATUS=0100
+    SMN_COMMAND=0104
+    SMN_SEQUENCE_START=0108
+    SMN_SEQUENCE_END=010C
+    SMN_SEQUENCE_CHECK=0110
+    SMN_BIT_COUNT=0114
+    SMN_BB_INCREMENT=0118
+    SMN_BB_DECREMENT=011C
+    SMN_COMPARE_SIZE=0120
+    SMN_PLAINTEXT_CHECK=0124
+    SMN_CIPHERTEXT_CHECK=0128
+    SMN_TIMER_IV=012C
+    SMN_TIMER_CTRL=0130
+    SMN_SECURITY_VIOLATION=0134
+    SMN_SECURITY_TIMER=0138
+    SMN_HAC=013C
+}
+
+
+## Export the SCC register symbols to the shell
+do_exports()
+{
+    export SCM_VERSION
+    export SCM_INTERRUPT_CTRL
+    export SCM_COMMAND_STATUS
+    export SCM_ERROR_STATUS
+    export SCM_DMA_FAULT_ADDR
+    export SCM_PARTITION_OWNERS
+    export SCM_PARTITIONS_ENGAGED
+    export SCM_UNIQUE_NO_0
+    export SCM_UNIQUE_NO_1
+    export SCM_UNIQUE_NO_2
+    export SCM_UNIQUE_NO_3
+    export SCM_ZEROIZE_CMD
+    export SCM_CIPHER_CMD
+    export SCM_CIPHER_BLACK_START
+    export SCM_INTERNAL_DEBUG
+    export SCM_CIPHER_IV_0
+    export SCM_CIPHER_IV_1
+    export SCM_CIPHER_IV_2
+    export SCM_CIPHER_IV_3
+    export SCM_SMID_BASE
+    export SCM_MAP_BASE
+
+    export SMN_STATUS
+    export SMN_COMMAND
+    export SMN_SEQUENCE_START
+    export SMN_SEQUENCE_END
+    export SMN_SEQUENCE_CHECK
+    export SMN_BIT_COUNT
+    export SMN_BB_INCREMENT
+    export SMN_BB_DECREMENT
+    export SMN_COMPARE_SIZE
+    export SMN_PLAINTEXT_CHECK
+    export SMN_CIPHERTEXT_CHECK
+    export SMN_TIMER_IV
+    export SMN_TIMER_CTRL
+    export SMN_SECURITY_VIOLATION
+    export SMN_SECURITY_TIMER
+    export SMN_HAC
+
+    return 0
+}
+
+setup_offsets()
+{
+    init_offsets
+    do_exports
+
+    return 0
+}
diff --git a/test/mxc_scc2/scc2_test.c b/test/mxc_scc2/scc2_test.c
new file mode 100644
index 0000000..64d5f2b
--- /dev/null
+++ b/test/mxc_scc2/scc2_test.c
@@ -0,0 +1,1474 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/**
+ * @file scc2_test.c
+ * @brief This is a test program for the SCC driver.
+ *
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+#include <sys/errno.h>
+#include <sys/mman.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <inttypes.h>
+#include "fsl_shw.h"
+#include "scc2_test_driver.h"
+
+/* test routines */
+void display_configuration(int device);
+int check_safe_registers(int device);
+int dump_registers(int device);
+int run_aic_tests(int scc_fd);
+int run_cipher_tests(int scc_fd);
+void run_timer_tests(int device, uint32_t);
+void set_software_alarm(int device);
+
+/* utility print functions */
+void print_ram_data (uint32_t *ram, uint32_t address, int count);
+void print_smn_status_register(uint32_t);
+void print_scm_version_register(uint32_t);
+void print_scm_control_register(uint32_t);
+void print_scm_status_register(uint32_t);
+void print_scm_part_owner_register(uint32_t);
+void print_scm_part_engaged_register(uint32_t);
+void print_scm_acc_register(uint32_t);
+void print_scm_error_status_register(uint32_t);
+char *get_smn_state_name(const uint8_t);
+void print_smn_timer_control_register(const uint32_t);
+void print_smn_command_register(const uint32_t);
+void print_scc_debug_detector_register(uint32_t);
+void print_scc_return_code(const scc_return_t);
+
+/* utility register access functions */
+int write_scc_register(int device, uint32_t address, uint32_t value);
+int read_scc_register(int device, uint32_t address, uint32_t *value);
+
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+int debug = FALSE;
+
+
+/** Secret which is going to be encrypted and decrtyped.  See also
+ *  #init_plaintext */
+uint8_t plaintext[4096] = {0xca, 0xbb, 0xad, 0xba,
+                           0xde, 0xad, 0xbe, 0xef,
+                           0xdb, 0xea, 0x11, 0xbe,
+                           'A', 'B', 'C', 'D',
+                           0x73, 0x1c, 0xab, 0xad,
+                           0xab, 0xad, 0xac, 0x24
+};
+
+
+/** Set up full */
+void
+init_plaintext()
+{
+    int i;
+
+    /* Starting after precompiled values, fill up the rest */
+    for (i = 24; i < sizeof(plaintext); i++) {
+        plaintext[i] = i % 256;
+    }
+}
+
+
+/** Normal number of bytes to encrypt */
+#define DEFAULT_PLAINTEXT_LENGTH 16
+
+
+/** */
+int plaintext_length = DEFAULT_PLAINTEXT_LENGTH;
+
+
+/** */
+int byte_offset = 0;
+
+
+/** Normal number of bytes of padding to add to ciphertext storage */
+#define DEFAULT_PADDING_ALLOWANCE 32
+
+int encrypt_padding_allowance = DEFAULT_PADDING_ALLOWANCE;
+
+int decrypt_padding_allowance = 0;
+
+/** */
+scc_verify_t check_mode = SCC_VERIFY_MODE_NONE;
+
+/** */
+int encrypt_only = FALSE;
+
+/** */
+int inject_crc_error = FALSE;
+
+/** */
+int superbrief_read_register = FALSE;
+
+/* miscellaneous utility functions */
+scc_configuration_access *get_scc_configuration(int);
+
+
+/*****************************************************************************
+ *  main
+ ****************************************************************************/
+int
+main(int arg_count,             /* # command-line arguments */
+     char*arg_list[])            /* pointers to command-line arguments */
+{
+    /* Declare and initialize variables */
+    int scc_fd;                 /* The SCC device */
+    char *scc_device_path = "/dev/scc2_test";
+    int argument_switch;
+    int test_switch;
+    uint32_t timer_value = 0x5f0000;
+    char *test_to_run = "Crps"; /* default list of tests to be run in order */
+    int test_status = 0;
+
+    init_plaintext();
+
+    /* Open up the SCC device */
+    /* Yes, I know, there is a command option to change the device path. */
+    scc_fd = open(scc_device_path, O_RDWR);
+    if (scc_fd < 0) {
+        perror("Cannot open SCC device");
+        exit (1);
+    }
+
+    /* Process command line arguments - until we come up empty */
+    while ( (argument_switch = getopt(arg_count, arg_list, "L:P:R:S:T:W:"))
+            != EOF ) {
+        switch (argument_switch) {
+        case 'L':               /* List tests to run */
+            test_to_run = optarg;
+            break;
+        case 'P':               /* set Path of SCC device */
+            scc_device_path = optarg;
+            break;
+        case 'R':               /* Read a specific register */
+            {
+                unsigned int offset;
+                uint32_t value;
+                int err;
+
+                /* get the offset */
+                if (sscanf(optarg, "%x", &offset) != 1) {
+                    fprintf(stderr, "improper use of -R %s\n", optarg);
+                }
+                else {
+                    err = read_scc_register(scc_fd, offset, &value);
+                    if (!err) {
+                        if (superbrief_read_register) {
+                            printf("%08x\n", value);
+                        }
+                        else {
+                            printf("0x%05x: %08x\n", offset, value);
+                        }
+                    }
+                    else {
+                        test_status = 1;
+                        perror("Reading register: ");
+                    }
+                }
+            }
+            test_to_run = "";
+            break;
+        case 'S':               /* (re)set a switch */
+            switch (*(optarg+1)) {
+            case 'c':
+                if (*optarg == '+') {
+                    if (strlen(optarg) > 2) {
+                        if (sscanf(optarg+2, "%x", &inject_crc_error) != 1) {
+                            fprintf(stderr, "improper hex value with -S+c\n");
+                            inject_crc_error = 0x1959;
+                        }
+                    }
+                    else {      /* arbitrary change */
+                        inject_crc_error = 0x1959;
+                    }
+                }
+                else {
+                    inject_crc_error = 0;
+                }
+                break;
+            case 'D':
+                if (*optarg == '+') {
+                    debug = TRUE;
+                }
+                else {
+                    debug = FALSE;
+                }
+                break;
+            case 'e':
+                if (*optarg == '+') {
+                    encrypt_only = TRUE;
+                }
+                else {
+                    encrypt_only = FALSE;
+                }
+                break;
+            case 'l':
+                if (*optarg == '+') {
+                    plaintext_length = atoi(optarg+2);
+                    if (plaintext_length > sizeof(plaintext)) {
+                        plaintext_length = sizeof(plaintext);
+                        fprintf(stderr,
+                                "plaintext size too large. Using %ld\n",
+                                (long)plaintext_length);
+                    }
+                }
+                else {
+                    plaintext_length = DEFAULT_PLAINTEXT_LENGTH;
+                }
+                break;
+            case 'o':           /* byte offset */
+                if (*optarg == '+') {
+                    byte_offset = atoi(optarg+2);
+                }
+                else {
+                    byte_offset = 0;
+                }
+                break;
+            case 'p':           /* ciphertext padding allowance */
+                if (*optarg == '+') {
+                    encrypt_padding_allowance = atoi(optarg+2);
+                }
+                else {
+                    decrypt_padding_allowance = atoi(optarg+2);
+                }
+                break;
+            case 'Q':           /* superbrief read register (quiet) */
+                if (*optarg == '+') {
+                    superbrief_read_register = TRUE;
+                }
+                else {
+                    superbrief_read_register = FALSE;
+                }
+                break;
+            case 'v':           /* verification */
+                if (*optarg == '+') {
+                    check_mode = SCC_VERIFY_MODE_CCITT_CRC;
+                }
+                else {
+                    check_mode = SCC_VERIFY_MODE_NONE;
+                }
+                break;
+            default:
+                fprintf(stderr, "unknown switch %c\n", *(optarg+1));
+            }
+            break;
+        case 'T':               /* change Timer Initial Value */
+            timer_value = 44;   /* code this up! */
+            break;
+        case 'W':               /* write a specific register */
+            {
+                unsigned int offset;
+                unsigned int value;
+                int err;
+
+                if (sscanf(optarg, "%x:%x", &offset, &value) != 2) {
+                    fprintf(stderr, "improper use of -W (%s)\n", optarg);
+                }
+                else {
+                    err = write_scc_register(scc_fd, offset, value);
+                    if (!err) {
+                        err = read_scc_register(scc_fd, offset, &value);
+                        if (!err) {
+                            printf("0x%05x => %08x\n", offset, value);
+                        }
+                        else {
+                            perror("Reading register after write: ");
+                        }
+                    }
+                    else {
+                        test_status = 1;
+                        perror("Writing register: ");
+                    }
+                }
+            }
+            test_to_run = "";
+            break;
+        default:
+            fprintf(stderr, "Usage: scc2_test [-P sccpath] [-T timerIV]"
+                    " [-Roff] [Woff:hex_value]\n"
+                    " [-Sopt] where options can be\n"
+                    "    c(corrupt ciphertext before decrypting)\n"
+                    "    D(print debug messages)\n"
+                    "    l(set Length of plaintext for cipher test)\n"
+                    "    m(+set/-reset CBC mode)\n"
+                    "    o(change byte offset of ciphertext)"
+                    "    Q(brief output mode)"
+                    " [-L tests] where tests can be\n"
+                    "    a(set sw alarm)\n"
+                    "    c(run AIC checks)\n"
+                    "    C(show config)\n"
+                    "    p(partition/encrypt/decrypt)\n"
+                    "    r(print Registers)\n"
+                    "    s(print Safe registers)\n"
+                    "    t(test timer)\n"
+                    );
+            exit(1);
+            break;
+        }
+    }
+
+
+    /* loop through all of the requested tests, running each in turn */
+    while ((test_switch = *test_to_run++) != 0) {
+        printf("\n");
+
+        switch (test_switch) {
+        case 'a':
+            set_software_alarm(scc_fd);
+            break;
+        case 'c':
+            run_aic_tests(scc_fd);
+            break;
+        case 'C':
+            display_configuration(scc_fd);
+            break;
+        case 'p':
+            test_status |= run_cipher_tests(scc_fd);
+            break;
+        case 'r':
+            test_status |= dump_registers(scc_fd);
+            break;
+        case 's':               /* the always available ones */
+            test_status |= check_safe_registers(scc_fd);
+            break;
+        case 't':
+            run_timer_tests(scc_fd, timer_value);
+            break;
+        default:
+            fprintf(stderr, "Test switch %c unknown\n", test_switch);
+        }
+
+    }
+
+    close(scc_fd);
+
+    exit(test_status != 0);
+
+}  /* End of Main */
+
+
+void
+display_configuration(int scc_fd) {
+    scc_configuration_access *config;
+
+    config = get_scc_configuration(scc_fd);
+    if (config == NULL) {
+        perror("\nCannot display SCC Configuration");
+    }
+    else {
+        printf("SCM version: %d, SMN version: %d, driver version %d.%d\n",
+               config->scm_version, config->smn_version,
+               config->driver_major_version, config->driver_minor_version);
+        printf("SCM block size is %d bytes, Black has %d blocks, "
+               "Red has %d blocks\n", config->block_size,
+               config->black_ram_size, config->red_ram_size);
+    }
+}
+
+
+
+/* Print values and verify access of all 'always available' registers */
+int
+check_safe_registers(int scc_fd) {
+    int status;
+    uint32_t value;
+    int had_error = 0;
+
+    status = read_scc_register(scc_fd, SMN_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Status                      (0x%08x): ",
+               SMN_STATUS_REG, value);
+        print_smn_status_register(value);
+    }
+    else {
+        printf("(Could not get SCM Status Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_VERSION_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Version Register:           (0x%08x): ",
+               SCM_VERSION_REG, value);
+        print_scm_version_register(value);
+    } else {
+        had_error++;
+        printf("(Could not get SCM Version Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Status                      (0x%08x): ",
+               SCM_STATUS_REG, value);
+        print_scm_status_register(value);
+    }
+    else {
+        printf("(Could not get SCM Status Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_ERR_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Error Register              (0x%08x): ",
+               SCM_ERR_STATUS_REG, value);
+        print_scm_error_status_register(value);
+    }
+    else {
+        printf("(Could not get SCM Error Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_INT_CTL_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Interrupt Control Register:  0x%08x\n",
+               SCM_INT_CTL_REG, value);
+    }
+    else {
+        printf("(Could not get SCM Interrupt Control Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_FAULT_ADR_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Fault Address Register:      0x%08x\n",
+               SCM_FAULT_ADR_REG, value);
+    }
+    else {
+        printf("(Could not get SCM Fault Add Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_PART_OWNERS_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Partition Owner Register:   (0x%08x): ",
+               SCM_PART_OWNERS_REG, value);
+        print_scm_part_owner_register(value);
+    }
+    else {
+        printf("(Could not get SCM Partition Owner Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_PART_ENGAGED_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Partition Engaged Register: (0x%08x): ",
+               SCM_PART_ENGAGED_REG, value);
+        print_scm_part_engaged_register(value);
+    }
+    else {
+        printf("(Could not get SCM Partition Engaged Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_C_BLACK_ST_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Cipher Black RAM Start Register: 0x%08x\n",
+               SCM_C_BLACK_ST_REG, value);
+    }
+    else {
+        printf("(Could not get SCM Cipher Black RAM Start Register)\n");
+        had_error++;
+    }
+
+    return (had_error != 0);
+}
+
+
+int
+dump_registers(int scc_fd)
+{
+    int status;
+    uint32_t value;
+    uint32_t config;
+    uint32_t engaged;
+    uint32_t owned;
+    int part_count;
+    int i;
+    int had_error = 0;
+
+    status = read_scc_register(scc_fd, SCM_VERSION_REG, &config);
+    if (!status) {
+        printf("(%04X) SCM Version Register:          (0x%08x): ",
+               SCM_VERSION_REG, config);
+        print_scm_version_register(config);
+    } else {
+        had_error++;
+        printf("(Could not get SCM Version Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_INT_CTL_REG, &value);
+    if (!status)
+        printf("(%04X) SCM Interrupt Control Register: 0x%08x\n",
+               SCM_INT_CTL_REG, value);
+    else {
+        had_error++;
+        printf("(Could not get SCM Interrupt Control Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Status Register:           (0x%08x): ",
+               SCM_STATUS_REG, value);
+        print_scm_status_register(value);
+    } else {
+        had_error++;
+        printf("(Could not get SCM Status Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_ERR_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Error Status Register      (0x%08x): ",
+               SCM_ERR_STATUS_REG, value);
+        print_scm_error_status_register(value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SCM Error Status Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_FAULT_ADR_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Fault Address:              0x%08x\n",
+                SCM_FAULT_ADR_REG, value);
+    }
+    else {
+        printf("(Could not get SCM Fault Address Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_PART_OWNERS_REG, &owned);
+    if (!status) {
+        printf("(%04X) SCM Partition Owner Register:  (0x%08x): ",
+                SCM_PART_OWNERS_REG, owned);
+        print_scm_part_owner_register(owned);
+    }
+    else {
+        printf("(Could not get SCM Partition Owner Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_PART_ENGAGED_REG, &engaged);
+    if (!status) {
+        printf("(%04X) SCM Partition Engaged Register: (0x%08x): ",
+               SCM_PART_ENGAGED_REG, engaged);
+        print_scm_part_engaged_register(engaged);
+    }
+    else {
+        printf("(Could not get SCM Partition Engaged Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_UNIQUE_ID0_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Unique ID0 Register:     0x%08x\n",
+               SCM_UNIQUE_ID0_REG, value);
+    }
+    else {
+        printf("(Could not get SCM Unique ID0 Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SCM_UNIQUE_ID1_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Unique ID1 Register:     0x%08x\n",
+               SCM_UNIQUE_ID1_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SCM Unique ID1 Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_UNIQUE_ID2_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Unique ID2 Register:     0x%08x\n",
+               SCM_UNIQUE_ID2_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SCM Unique ID2 Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_UNIQUE_ID3_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Unique ID3 Register:     0x%08x\n",
+               SCM_UNIQUE_ID3_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SCM Unique ID3 Register)\n");
+    }
+
+    status = read_scc_register(scc_fd,  SCM_C_BLACK_ST_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Black Start Register:     0x%08x\n",
+                SCM_C_BLACK_ST_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SCM Black Start Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SCM_DBG_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SCM Debug Status Register:     0x%08x\n",
+               SCM_DBG_STATUS_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SCM Debug Status Register)\n");
+    }
+
+    for (i = 0; i < 4; i++) {
+        unsigned iv_reg = SCM_AES_CBC_IV0_REG + 4*i;
+
+        status = read_scc_register(scc_fd, iv_reg, &value);
+        if (!status) {
+            printf("(%04X) SCM AES CBC IV%d Register:     0x%08x\n",
+                   iv_reg, i, value);
+        }
+        else {
+            had_error++;
+            printf("(Could not get SCM AES CBC IV%d Register)\n", i);
+        }
+    }
+
+    part_count = ((config & SCM_VER_NP_MASK) >> SCM_VER_NP_SHIFT) + 1;
+    for (i = 0; i < part_count; i++) {
+        unsigned smid_reg = SCM_SMID0_REG + 8*i;
+        unsigned acc_reg = SCM_ACC0_REG + 8*i;
+        uint32_t smid_value;
+        uint32_t acc_value;
+
+        status = read_scc_register(scc_fd, smid_reg, &smid_value);
+        if (!status) {
+            printf("(%04X) SCM SMID%d Register:     0x%08x\n",
+                   smid_reg, i, smid_value);
+        }
+        else {
+            had_error++;
+            printf("(Could not get SCM SMID%d Register)\n", i);
+        }
+
+        status = read_scc_register(scc_fd, acc_reg, &acc_value);
+        if (!status) {
+            printf("(%04X) SCM ACC%d Register:     (0x%08x): ",
+                   acc_reg, i, acc_value);
+            print_scm_acc_register(acc_value);
+        }
+        else {
+            had_error++;
+            printf("(Could not get SCM ACC%d Register)\n", i);
+        }
+    }
+
+    printf("\n");               /* Visually divide the halves */
+
+    status = read_scc_register(scc_fd, SMN_STATUS_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Status Register            (0x%08x): ",
+               SMN_STATUS_REG, value);
+        print_smn_status_register(value);
+    }
+    else {
+        printf("(Could not get SMN Status Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SMN_SEQ_START_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Sequence Start Register:    0x%08x\n",
+               SMN_SEQ_START_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Sequence Start Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_SEQ_END_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Sequence End Register:      0x%08x\n",
+               SMN_SEQ_END_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Sequence End Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_SEQ_CHECK_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Sequence Check Register:    0x%08x\n",
+               SMN_SEQ_CHECK_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Sequence Check Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_BB_CNT_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Bit Count Register:         0x%08x\n",
+               SMN_BB_CNT_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Bit Count Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_BB_INC_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Bit Bank Inc Size Register: 0x%08x\n",
+               SMN_BB_INC_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Bit Bank Inc Size Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_COMPARE_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Compare  Size Register:     0x%08x\n",
+               SMN_COMPARE_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Compare Size Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_PT_CHK_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Plaintext  Check Register:  0x%08x\n",
+               SMN_PT_CHK_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Plaintext Check Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_CT_CHK_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Ciphertext  Check Register: 0x%08x\n",
+               SMN_CT_CHK_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Ciphertext Check Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_TIMER_IV_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Timer IV Register:          0x%08x\n",
+               SMN_TIMER_IV_REG, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Timer IV Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_TIMER_CTL_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN Timer Control Register     (0x%08x): ",
+               SMN_TIMER_CTL_REG, value);
+        print_smn_timer_control_register(value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Timer Control Register)\n");
+    }
+
+    status = read_scc_register(scc_fd, SMN_HAC_REG, &value);
+    if (!status) {
+        printf("(%04X) SMN High Assurance Control Register:   (0x%08x)\n",
+               SMN_HAC_REG, value);
+    }
+    else {
+        printf("(Could not get SMN High Assurance Control Register)\n");
+        had_error++;
+    }
+
+    status = read_scc_register(scc_fd, SMN_REG_BANK_SIZE, &value);
+    if (!status) {
+        printf("(%04X) SMN Register Bank Size:            (0x%08x)\n",
+               SMN_REG_BANK_SIZE, value);
+    }
+    else {
+        had_error++;
+        printf("(Could not get SMN Register Bank Size)\n");
+    }
+
+    return (had_error != 0);
+}
+
+
+/***********************************************************************
+ set_software_alarm()
+ **********************************************************************/
+void set_software_alarm(int scc_fd) {
+    int status;
+
+    status = ioctl(scc_fd, SCC2_TEST_SET_ALARM, NULL);
+}
+
+
+/***********************************************************************
+ run_timer_tests()
+ **********************************************************************/
+void run_timer_tests(int scc_fd, uint32_t timer_iv) {
+    uint32_t value;
+    int i;
+    int a = 0;
+
+    printf ("Writing 0x%x into SMN_TIMER_IV\n", timer_iv);
+    write_scc_register(scc_fd, SMN_TIMER_IV_REG, timer_iv);
+
+    /* this operation should move the initial value to the timer reg */
+    printf ("Loading timer using SMN_TIMER_CONTROL\n");
+    write_scc_register(scc_fd, SMN_TIMER_CTL_REG, SMN_TIMER_LOAD_TIMER);
+
+    read_scc_register(scc_fd, SMN_TIMER_REG, &value);
+    printf ("SMN_TIMER value: 0x%x\n", value);
+
+    printf ("Starting timer using SMN_TIMER_CONTROL\n");
+    write_scc_register(scc_fd, SMN_TIMER_CTL_REG, SMN_TIMER_START_TIMER);
+
+    /*
+     * Kill some time
+     */
+    for (i = 0; i < 100000; i++) {
+        ++a;
+    };
+    i = 0;
+
+    /* now stop the timer */
+    printf("Stopping the timer\n");
+    read_scc_register(scc_fd, SMN_TIMER_CTL_REG, &value);
+    write_scc_register(scc_fd, SMN_TIMER_CTL_REG,
+                       value & ~SMN_TIMER_STOP_MASK);
+
+    /* and see how much time we ran off */
+    read_scc_register(scc_fd, SMN_TIMER_REG, &value);
+    printf ("SMN_TIMER value: 0x%x\n", value);
+
+}
+
+/***********************************************************************
+ run_aic_tests()
+ **********************************************************************/
+int
+run_aic_tests(int scc_fd) {
+    uint32_t value;
+
+    /* This series of writes generates FAIL mode !!! */
+    write_scc_register(scc_fd, SMN_SEQ_START_REG, 4);
+    write_scc_register(scc_fd, SMN_SEQ_END_REG, 5);
+    write_scc_register(scc_fd, SMN_SEQ_CHECK_REG, 5);
+
+    read_scc_register(scc_fd, SMN_STATUS_REG, &value);
+    printf("SMN Status: ");
+    print_smn_status_register(value);
+
+
+    return 0;
+}
+
+/***********************************************************************
+ * write_scc_register
+ **********************************************************************/
+int
+write_scc_register(int device,  /* OS device connect */
+                   uint32_t reg, /* The register to be written */
+                   uint32_t value) /* The value to store */
+{
+    scc_reg_access register_access;
+    int status;
+
+    register_access.reg_offset = reg;
+    register_access.reg_data = value;
+
+    status = ioctl(device, SCC2_TEST_WRITE_REG, &register_access);
+    if (status != IOCTL_SCC2_OK) {
+        perror("Ioctl SCC2_TEST_WRITE_REG failed: ");
+    }
+
+    return status;
+}
+
+
+/***********************************************************************
+ * read_scc_register
+ **********************************************************************/
+int
+read_scc_register(int device, /* OS device connect */
+                  uint32_t reg, /* The register to be written */
+                  uint32_t *value) /* The location for return value */
+{
+    scc_reg_access register_access;
+    int status;
+
+    register_access.reg_offset = reg;
+    status = ioctl(device, SCC2_TEST_READ_REG, &register_access);
+    if (status != IOCTL_SCC2_OK) {
+        perror("Ioctl SCC2_TEST_READ_REG failed: ");
+    }
+    else {
+        *value = register_access.reg_data;
+    }
+
+    return status;
+}
+
+
+/***********************************************************************
+ get_scc_configuration()
+ **********************************************************************/
+scc_configuration_access*
+get_scc_configuration(int scc_fd) {
+    static scc_configuration_access *config = NULL;
+    int status;
+
+    if (config == NULL) {
+        config = calloc(1, sizeof(scc_configuration_access));
+        if (config != NULL) {
+            status = ioctl(scc_fd, SCC2_TEST_GET_CONFIGURATION, config);
+            if (status != IOCTL_SCC2_OK) {
+                perror("Ioctl SCC_GET_CONFIGURATION failed: ");
+                free (config);
+                config = NULL;
+            }
+        }
+    }
+
+    return config;
+}
+
+
+static uint8_t secret_data[64] = "All mimsy were the borogoves... All mimsy were the borogoves...";
+
+/**
+ * Do the encrypt-decrypt part of the partition/cipher tests
+ */
+int
+do_enc_dec(int scc_fd, uint32_t part_virtual_addr)
+{
+    int status;
+    scc_part_cipher_access cipher_info;
+    uint8_t encrypted_secret[sizeof(secret_data)];
+    uint8_t decrypted_secret[sizeof(secret_data)];
+
+    /* Load our secret into the Red RAM */
+    cipher_info.virt_address = part_virtual_addr;
+    cipher_info.red_offset = 48;
+    cipher_info.black_address = secret_data;
+    cipher_info.size_bytes = sizeof(secret_data);
+    status = ioctl(scc_fd, SCC2_TEST_LOAD_PART, &cipher_info);
+    if (status != 0) {
+        printf("ioctl to write to Red RAM returned %d\n", status);
+        goto out;
+    }
+
+    /* Encrypt it into encrypted_secret */
+    memset(encrypted_secret, 0, sizeof(encrypted_secret));
+    cipher_info.iv = (uint64_t)0x12345678ull;
+    cipher_info.black_address = encrypted_secret;
+    status = ioctl(scc_fd, SCC2_TEST_ENCRYPT_PART, &cipher_info);
+    if (status != 0) {
+        printf("ioctl to encrypt region returned %d\n", status);
+        goto out;
+    }
+    if (cipher_info.scc_status != SCC_RET_OK) {
+        printf("scc_encrypt_region returned %d\n", status);
+        status = 1;
+        goto out;
+    }
+
+    /* Decrypt it into the Red RAM */
+    cipher_info.red_offset = 16;
+    status = ioctl(scc_fd, SCC2_TEST_DECRYPT_PART, &cipher_info);
+    if (status != 0) {
+        printf("ioctl to decrypt region returned %d\n", status);
+        goto out;
+    }
+    if (cipher_info.scc_status != SCC_RET_OK) {
+        printf("scc_decrypt_region returned %d\n", status);
+        status = 1;
+        goto out;
+    }
+
+    /* Read back our secret from the Red RAM */
+    memset(decrypted_secret, 0, sizeof(decrypted_secret));
+    cipher_info.black_address = decrypted_secret;
+    status = ioctl(scc_fd, SCC2_TEST_READ_PART, &cipher_info);
+    if (status != 0) {
+        printf("ioctl to read from Red RAM returned %d\n", status);
+        goto out;
+    }
+
+    if (memcmp(secret_data, decrypted_secret, sizeof(secret_data)) != 0) {
+        printf("Decrypt did not retrieve plaintext data\n", status);
+        status = 1;
+        goto out;
+    }
+
+ out:
+    return status;
+}
+
+/**
+ * Run partition-level functions through their paces
+ */
+int
+run_cipher_tests(int scc_fd)
+{
+    int i;
+    int status;
+    scc_partition_access part_info;
+    scc_partition_access part_copy;
+    uint32_t part_virt;
+    uint8_t umid[16];
+
+    part_info.virt_address = 0; /* signal for cleanup */
+    part_info.smid = 0;
+
+    memset(umid, 0, sizeof(umid));
+    umid[sizeof(umid) - 1] = 0x42;
+
+    printf("Beginning partition / cipher tests\n");
+
+    status = ioctl(scc_fd, SCC2_TEST_ALLOC_PART, &part_info);
+    if (status != IOCTL_SCC2_OK) {
+        printf("ioctl for part alloc returned %d\n", status);
+        goto cleanup;
+    }
+    if (part_info.scc_status != SCC_RET_OK) {
+        printf("scc2_alloc_part() returned %d while trying to find partition\n", part_info.scc_status);
+        status = 1;
+        goto cleanup;
+    }
+
+    /* Now we need to engage the partition */
+    part_info.umid = umid;
+    part_info.permissions = 0x700; /* me, me, me */
+    status = ioctl(scc_fd, SCC2_TEST_ENGAGE_PART, &part_info);
+    if (status != IOCTL_SCC2_OK) {
+        printf("ioctl for part engage returned %d\n", status);
+        goto cleanup;
+    }
+    if (part_info.scc_status != SCC_RET_OK) {
+        printf("scc2_engage_part() returned %d while trying to engage partition\n", part_info.scc_status);
+        status = 1;
+        goto cleanup;
+    }
+
+    part_copy = part_info;
+
+    for(i = 0; i < 10; i++) {
+        status = do_enc_dec(scc_fd, part_info.virt_address);
+        if (status != IOCTL_SCC2_OK) {
+            goto cleanup;
+        }
+    }
+
+    status = ioctl(scc_fd, SCC2_TEST_RELEASE_PART, &part_info);
+    if (status != IOCTL_SCC2_OK) {
+        printf("ioctl for part release returned %d\n", status);
+        goto cleanup;
+    }
+    if (part_info.scc_status != SCC_RET_OK) {
+        printf("scc2_dealloc_part() returned %d while trying to deallocate partition\n", part_info.scc_status);
+        status = 1;
+        goto cleanup;
+    }
+    part_info.virt_address = 0; /* so cleanup knows it is gone */
+
+    /* Try to deallocate it again... */
+    status = ioctl(scc_fd, SCC2_TEST_RELEASE_PART, &part_copy);
+    if (status != IOCTL_SCC2_OK) {
+        printf("ioctl for second part release returned %d\n", status);
+        goto cleanup;
+    }
+    if (part_copy.scc_status == SCC_RET_OK) {
+        printf("scc2_dealloc_part() returned %d while trying second deallocate\n", part_copy.scc_status);
+        status = 1;
+        goto cleanup;
+    }
+    printf("Partition/cipher test is successful\n");
+
+ cleanup:
+    if (part_info.virt_address != 0) {
+        int err_status = ioctl(scc_fd, SCC2_TEST_RELEASE_PART, &part_info);
+        if (err_status != IOCTL_SCC2_OK) {
+            printf("ioctl for part release returned %d while trying to cleanup\n", status);
+        } else {
+            if (part_info.scc_status != SCC_RET_OK) {
+                printf("scc_dealloc_part() returned %d while trying to cleanup\n", part_info.scc_status);
+            }
+        }
+    }
+
+    return status;
+}
+
+
+/* print_ram_data
+ *
+ * Print eight words per line, starting at ram, as though they
+ * started at address, until count words have been printed
+ *
+ */
+void
+print_ram_data (uint32_t *ram, uint32_t address, int count)
+{
+    int i;
+
+    for (i = 0; i < count; i++) {
+        if (i%8 == 0) {
+            printf("(%04X) ", address+i*4); /* print byte address */
+        }
+
+        printf("%08x ", *ram++); /* print a word */
+
+        if (i%8 == 7) {
+            printf("\n");       /* end of line - do newline */
+        }
+        else if (i%8 == 3) {
+            printf (" ");      /* add space in the middle */
+        }
+    }
+
+    if (count%8 != 0) {         /* if didn't have mod8 words... */
+        printf("\n");
+    }
+}
+
+
+/** Interpret the SMN Status register and print out the 'on' bits and State */
+void
+print_smn_status_register(uint32_t status)
+{
+    int version_id;
+    uint8_t state;
+
+    version_id = (status&SMN_STATUS_VERSION_ID_MASK)
+        >> SMN_STATUS_VERSION_ID_SHIFT;
+    state = (status&SMN_STATUS_STATE_MASK) >> SMN_STATUS_STATE_SHIFT;
+    printf("Version %d %s%s%s%s%s%s%s%s%s%s%s%s%s\n",
+           (status & SMN_STATUS_VERSION_ID_MASK) >> SMN_STATUS_VERSION_ID_SHIFT,
+           (status & SMN_STATUS_ILLEGAL_MASTER) ? "IllMaster " : "",
+           (status & SMN_STATUS_SCAN_EXIT) ? "ScanExit " : "",
+           (status & SMN_STATUS_PERIP_INIT) ? "PeripInit " : "",
+           (status & SMN_STATUS_SMN_ERROR) ? "SMNError " : "",
+           (status & SMN_STATUS_SOFTWARE_ALARM) ? "SWAlarm " : "",
+           (status & SMN_STATUS_TIMER_ERROR) ? "TimerErr " : "",
+           (status & SMN_STATUS_PC_ERROR) ? "PTCTErr " : "",
+           (status & SMN_STATUS_BITBANK_ERROR) ? "BitbankErr " : "",
+           (status & SMN_STATUS_ASC_ERROR) ? "ASCErr " : "",
+           (status & SMN_STATUS_SECURITY_POLICY_ERROR) ? "SecPlcyErr " : "",
+           (status & SMN_STATUS_SEC_VIO_ACTIVE_ERROR) ? "SecVioAct " : "",
+           (status & SMN_STATUS_INTERNAL_BOOT) ? "IntBoot " : "",
+           get_smn_state_name(state));
+}
+
+
+/** Interpret the state (a field of the SMN State register) and return its
+ *  name
+**/
+char *
+get_smn_state_name(const uint8_t state)
+{
+    switch (state) {
+    case SMN_STATE_START:
+        return "START";
+    case SMN_STATE_ZEROIZE_RAM:
+        return "ZEROIZE";
+    case SMN_STATE_HEALTH_CHECK:
+        return "HEALTH CHECK";
+    case SMN_STATE_FAIL:
+        return "FAIL";
+    case SMN_STATE_SECURE:
+        return "SECURE";
+    case SMN_STATE_NON_SECURE:
+        return "NON-SECURE";
+    default:
+        return "UNKNOWN";
+    }
+}
+
+static char* srs_names[] =
+{
+	"SRS_Reset",
+	"SRS_All_Ready",
+	"SRS_ZeroizeBusy",
+	"SRS_CipherBusy",
+	"SRS_AllBusy",
+	"SRS_ZeroizeDoneCipherReady",
+	"SRS_CipherDoneZeroizeReady",
+	"SRS_ZeroizeDoneCipherBusy",
+	"SRS_CipherDoneZeroizeBusy",
+	"SRS_UNKNOWN_STATE_9",
+	"SRS_TransitionalA",
+	"SRS_TransitionalB",
+	"SRS_TransitionalC",
+	"SRS_TransitionalD",
+	"SRS_AllDone",
+	"SRS_UNKNOWN_STATE_E",
+	"SRS_FAIL"
+};
+
+
+void
+print_scm_version_register(uint32_t version)
+{
+    printf("Bpp: %u, Bpcb: %u, np: %u, maj: %u, min: %u\n",
+           1 << ((version & SCM_VER_BPP_MASK) >> SCM_VER_BPP_SHIFT),
+           ((version & SCM_VER_BPCB_MASK) >> SCM_VER_BPCB_SHIFT) + 1,
+           ((version & SCM_VER_NP_MASK) >> SCM_VER_NP_SHIFT) + 1,
+           (version & SCM_VER_MAJ_MASK) >> SCM_VER_MAJ_SHIFT,
+           (version & SCM_VER_MIN_MASK) >> SCM_VER_MIN_SHIFT);
+}
+
+
+/** Interpret the SCM Status register and print out the 'on' bits */
+void
+print_scm_status_register(uint32_t status)
+{
+    printf("%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
+           (status & SCM_STATUS_KST_DEFAULT_KEY) ? "KST_DefaultKey " : "",
+           /* reserved */
+           (status & SCM_STATUS_KST_WRONG_KEY) ? "KST_WrongKey " : "",
+           (status & SCM_STATUS_KST_BAD_KEY) ? "KST_BadKey " : "",
+           (status & SCM_STATUS_ERR) ? "Error " : "",
+           (status & SCM_STATUS_MSS_FAIL) ? "MSS_FailState " : "",
+           (status & SCM_STATUS_MSS_SEC) ? "MSS_SecureState " : "",
+           (status & SCM_STATUS_RSS_FAIL) ? "RSS_FailState " : "",
+           (status & SCM_STATUS_RSS_SEC) ? "RSS_SecureState " : "",
+           (status & SCM_STATUS_RSS_INIT) ? "RSS_Initializing " : "",
+           (status & SCM_STATUS_UNV) ? "UID_Invalid " : "",
+           (status & SCM_STATUS_BIG) ? "BigEndian " : "",
+           (status & SCM_STATUS_USK) ? "SecretKey " : "",
+           srs_names[(status & SCM_STATUS_SRS_MASK) >> SCM_STATUS_SRS_SHIFT]);
+}
+
+
+/** Interpret the SCM Control register and print its meaning */
+void
+print_scm_control_register(uint32_t control)
+{
+    printf("TBD\n");
+}
+
+/**
+ * Names of the SCM Error Codes
+ */
+static
+char* scm_err_code[] =
+{
+	"Unknown_0",
+	"UnknownAddress",
+	"UnknownCommand",
+	"ReadPermErr",
+	"WritePermErr",
+	"DMAErr",
+	"EncBlockLenOvfl",
+	"KeyNotEngaged",
+	"ZeroizeCmdQOvfl",
+	"CipherCmdQOvfl",
+	"ProcessIntr",
+	"WrongKey",
+	"DeviceBusy",
+	"DMAUnalignedAddr",
+	"Unknown_E",
+	"Unknown_F",
+};
+
+void
+print_scm_error_status_register(uint32_t error)
+{
+    if (error == 0)
+        printf("\n");
+    else
+        printf("%s%sErrorCode: %s, SMSState: %s, SCMState: %s\n",
+               (error & SCM_ERRSTAT_ILM) ? "ILM, " : "",
+               (error & SCM_ERRSTAT_SUP) ? "SUP, " : "",
+               scm_err_code[(error & SCM_ERRSTAT_ERC_MASK) >> SCM_ERRSTAT_ERC_SHIFT],
+               get_smn_state_name((error & SCM_ERRSTAT_SMS_MASK) >> SCM_ERRSTAT_SMS_SHIFT),
+               srs_names[(error & SCM_ERRSTAT_SRS_MASK) >> SCM_ERRSTAT_SRS_SHIFT]);
+}
+
+void
+print_scm_part_owner_register(uint32_t value)
+{
+    int i;
+
+    for (i = 15; i >= 0; i--) {
+        unsigned op = (value >> (SCM_POWN_SHIFT*i)) & SCM_POWN_MASK;
+        switch (op) {
+        case SCM_POWN_PART_FREE:
+            break;
+        case SCM_POWN_PART_UNUSABLE:
+            printf("un%02d ", i);
+            break;
+        case SCM_POWN_PART_OTHER:
+            printf("ot%02d ", i);
+            break;
+        case SCM_POWN_PART_OWNED:
+            printf("rd%02d ", i);
+            break;
+        }
+    }
+    printf("\n");
+}
+
+
+void
+print_scm_part_engaged_register(uint32_t value)
+{
+    printf("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
+           (value & 0x8000) ? "15 " : "",
+           (value & 0x4000) ? "14 " : "",
+           (value & 0x2000) ? "13 " : "",
+           (value & 0x1000) ? "12 " : "",
+           (value & 0x0800) ? "11 " : "",
+           (value & 0x0400) ? "10 " : "",
+           (value & 0x0200) ? "9 " : "",
+           (value & 0x0100) ? "8 " : "",
+           (value & 0x0080) ? "7 " : "",
+           (value & 0x0040) ? "6 " : "",
+           (value & 0x0020) ? "5 " : "",
+           (value & 0x0010) ? "4 " : "",
+           (value & 0x0008) ? "3 " : "",
+           (value & 0x0004) ? "2 " : "",
+           (value & 0x0002) ? "1 " : "",
+           (value & 0x0001) ? "0" : "");
+}
+
+void
+print_scm_acc_register(uint32_t value)
+{
+    printf("%s%s%s%s%s%s%s%s%s%s%s\n",
+           (value & FSL_PERM_NO_ZEROIZE) ? "NO_ZERO " : "",
+           (value & FSL_PERM_TRUSTED_KEY_READ) ? "TRUSTED_KEY " : "",
+           (value & FSL_PERM_HD_S) ? "SUP_DIS " : "",
+           (value & FSL_PERM_HD_R) ? "HD_RD " : "",
+           (value & FSL_PERM_HD_W) ? "HD_WR " : "",
+           (value & FSL_PERM_HD_X) ? "HD_EX " : "",
+           (value & FSL_PERM_TH_R) ? "TH_RD " : "",
+           (value & FSL_PERM_TH_W) ? "TH_WR " : "",
+           (value & FSL_PERM_OT_R) ? "OT_RD " : "",
+           (value & FSL_PERM_OT_W) ? "OT_WR " : "",
+           (value & FSL_PERM_OT_X) ? "OT_EX" : "");
+}
+
+void
+print_smn_command_register(uint32_t command)
+{
+    printf("TBD\n");
+#if 0
+    if (command&SMN_COMMAND_ZEROS_MASK) {
+        printf(" zeroes: 0x%08x", debug&SMN_COMMAND_ZEROS_MASK);
+    }
+    printf("%s%s%s%s\n",
+           (command&SMN_COMMAND_CLEAR_INTERRUPT) ? " CLEAR_INTERRUPT" : "",
+           (command&SMN_COMMAND_CLEAR_BIT_BANK) ? " CLEAR_BITBANK" : "",
+           (command&SMN_COMMAND_ENABLE_INTERRUPT) ? " ENABLE_INTERRUPT" : "",
+           (command&SMN_COMMAND_SET_SOFTWARE_ALARM) ? " SET_SOFWARE_ALARM" : ""
+           );
+#endif
+}
+
+
+void
+print_smn_timer_control_register(uint32_t control)
+{
+    printf("%s\n",
+           (control&SMN_TIMER_START_TIMER) ? "STARTED" : "");
+}
+
+
+/** generate human-readable interpretation of the SMN Debug Detector
+    Register
+*/
+void
+print_scc_debug_detector_register(uint32_t debug)
+{
+    if (debug&SMN_DBG_ZEROS_MASK) {
+        printf(" zeroes: 0x%08x", debug&SMN_DBG_ZEROS_MASK);
+    }
+    printf("%s%s%s%s%s%s%s%s%s%s%s%s\n",
+           (debug & 1) ? " SV1" : "",
+           (debug & 2) ? " SV2" : "",
+           (debug & 4) ? " SV3" : "",
+           (debug & 8) ? " SV4" : "",
+           (debug & 16) ? " SV5" : "",
+           (debug & 32) ? " SV6" : "",
+           (debug & 64) ? " LSV7" : "",
+           (debug & 128) ? " LSV8" : "",
+           (debug & 256) ? " LSV9" : "",
+           (debug & 512) ? " LSV10" : "",
+           (debug & 1024) ? " LSV11" : "",
+           (debug & 2048) ?  " LSV12" : "");
+}
+
+
+/** print an interpretation (the symbol name) of @c code */
+void
+print_scc_return_code(scc_return_t code)
+{
+    char *msg = NULL;
+
+    switch (code) {
+    case SCC_RET_OK:
+        msg = "SCC_RET_OK";
+        break;
+    case SCC_RET_FAIL:
+        msg = "SCC_RET_FAIL";
+        break;
+    case SCC_RET_VERIFICATION_FAILED:
+        msg = "SCC_RET_VERIFICATION_FAILED";
+        break;
+    case SCC_RET_TOO_MANY_FUNCTIONS:
+        msg = "SCC_RET_TOO_MANY_FUNCTIONS";
+        break;
+    case SCC_RET_BUSY:
+        msg = "SCC_RET_BUSY";
+        break;
+    case SCC_RET_INSUFFICIENT_SPACE:
+        msg = "SCC_RET_INSUFFICIENT_SPACE";
+        break;
+    default:
+        break;
+    }
+
+    if (msg) {
+        printf("SCC return code: %s\n", msg);
+    }
+    else {
+        printf("SCC return code: %d\n", code);
+    }
+}
diff --git a/test/mxc_scc2/scc2_test_driver.h b/test/mxc_scc2/scc2_test_driver.h
new file mode 100644
index 0000000..4089aeb
--- /dev/null
+++ b/test/mxc_scc2/scc2_test_driver.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All rights reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*! @file scc2_test_driver.h
+ *
+ *  This header file provides definitions needed by the SCC2 test driver.
+ *
+ */
+
+
+#ifndef SCC2_TEST_DRIVER_H
+#define SCC2_TEST_DRIVER_H
+
+#ifdef __KERNEL__
+
+#include <portable_os.h>
+#include <asm/arch/hardware.h>
+
+#endif /* kernel */
+
+#include <asm/arch/mxc_scc2_driver.h>
+
+#ifndef SCC2_TEST_DRIVER_NAME
+
+/** /dev/xxx name for this device */
+#define SCC2_TEST_DRIVER_NAME "scc2_test"
+
+
+#endif /* kernel */
+
+
+/* User/Driver interface definitions */
+
+/**
+ * @defgroup ioctlreturns Ioctl Error Codes.
+ *
+ * These are the values returned by #scc_ioctl and placed into @c
+ * errno by @c ioctl. Porting opportunity.  These values were chosen to
+ * match standard Linux values.
+ */
+/** @addtogroup ioctlreturns */
+/** @{ */
+#define IOCTL_SCC2_OK             0      /**< @c ioctl completed successfully */
+#define IOCTL_SCC2_INVALID_CMD    ENOTTY /**< Invalid command passed. */
+#define IOCTL_SCC2_INVALID_MODE   EINVAL /**< Invalid cipher mode. */
+#define IOCTL_SCC2_SCM_BUSY       EBUSY  /**< SCM is busy */
+#define IOCTL_SCC2_IMPROPER_STATE EBADFD /**< Improper state for operation */
+#define IOCTL_SCC2_IMPROPER_ADDR  EFAULT /**< Improper address/offset passed */
+#define IOCTL_SCC2_NO_MEMORY      ENOMEM /**< Insufficient memory to process */
+#define IOCTL_SCC2_FAILURE        ESPIPE /**< Generic 'SCC2 error' error */
+/** @} */
+
+/*
+ * Interface definitions between user and driver
+ */
+
+/* This is a porting opportunity.  It identifies the 'unique' byte
+   value inserted into the IOCTL number.  It really only has to be
+   unique within the software used on a given device. */
+#ifndef SCC2_TEST_DRIVER_IOCTL_IDENTIFIER
+#define SCC2_TEST_DRIVER_IOCTL_IDENTIFIER 's'
+#endif
+
+/* Define SCC2 Driver Commands (Argument 2 of ioctl) */
+
+/** @defgroup ioctlcmds ioctl command (argument 2) values */
+/** @addtogroup ioctlcmds */
+/** @{ */
+/** ioctl cmd to return version and configuration information on driver and
+ *  SCC2 */
+#ifdef _IOW
+#undef _IOW
+#endif
+#ifdef _IOWR
+#undef _IOWR
+#endif
+#ifdef _IO
+#undef _IO
+#endif
+
+#define _IOW(x, y, z) y
+#define _IOWR(x, y, z) y
+#define _IO(x, y) y
+
+#define SCC2_TEST_GET_CONFIGURATION _IOW (SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 0, \
+         scc_configuration_access)
+/** ioctl cmd to test the scc_read_register() function of the SCC2 driver */
+#define SCC2_TEST_READ_REG         _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 1, \
+         scc_reg_access)
+/** ioctl cmd to test the scc_write_register() function of the SCC2 driver */
+#define SCC2_TEST_WRITE_REG        _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 2, \
+         scc_reg_access)
+/** ioctl cmd to test the scc_crypt() function of the SCC2 driver */
+#define SCC2_TEST_ENCRYPT          _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 3, \
+         scc_encrypt_decrypt)
+/** ioctl cmd to test the scc_crypt() function of the SCC2 driver */
+#define SCC2_TEST_DECRYPT          _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 4, \
+         scc_encrypt_decrypt)
+/** ioctl cmd to test the scc_set_sw_alarm() function of the SCC2 driver */
+#define SCC2_TEST_SET_ALARM        _IO  (SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 5)
+/** ioctl cmd to test the scc_zeroize_memories() function of the SCC2 driver */
+#define SCC2_TEST_ZEROIZE          _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 6, \
+         scc_return_t)
+/** ioctl cmd to test partition allocation function of the SCC2 driver */
+#define SCC2_TEST_ALLOC_PART       _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 12, \
+        scc_partition_access)
+/** ioctl cmd to test partition engagement function of the SCC2 driver */
+#define SCC2_TEST_ENGAGE_PART      _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 13, \
+        scc_partition_access)
+/** ioctl cmd to test partition cipher function of the SCC2 driver */
+#define SCC2_TEST_ENCRYPT_PART     _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 14, \
+        scc_part_cipher_access)
+#define SCC2_TEST_DECRYPT_PART     _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 15, \
+        scc_part_cipher_access)
+/** ioctl cmd to test partition allocation function of the SCC2 driver */
+#define SCC2_TEST_RELEASE_PART     _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 16, \
+        scc_partition_access)
+/** ioctl cmd to load data into an SCC2 partition */
+#define SCC2_TEST_LOAD_PART        _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 17, \
+        scc_part_cipher_access)
+/** ioctl cmd to lread data from an SCC2 partition */
+#define SCC2_TEST_READ_PART        _IOWR(SCC2_TEST_DRIVER_IOCTL_IDENTIFIER, 18, \
+        scc_part_cipher_access)
+
+/** @} */
+
+
+/** @defgroup ioctlStructs Special structs for argument 3 of ioctl
+ *
+ *
+ */
+/** @addtogroup ioctlStructs */
+/** @{ */
+
+/**
+ * ioctl structure for retrieving driver & SCC2 version ids, used
+ * with #SCC2_TEST_GET_CONFIGURATION.
+ */
+typedef struct {
+    int driver_major_version;   /**< Major version of the SCC2 driver code  */
+    int driver_minor_version;   /**< Minor version of the SCC2 driver code  */
+    int scm_version;            /**< from Configuration register */
+    int smn_version;            /**< from SMN Status register */
+    int block_size;             /**< bytes in a block */
+    int black_ram_size;         /**< number of blocks of Black RAM */
+    int red_ram_size;           /**< number of blocks of Red RAM */
+} scc_configuration_access;
+
+
+/**
+ * ioctl structure for accessing SCC2 registers, used with
+ * #SCC2_TEST_READ_REG and #SCC2_TEST_WRITE_REG.
+ */
+typedef struct {
+    uint32_t reg_offset;        /**< The register address from Memory Map */
+    uint32_t reg_data;          /**< Data to/from the register */
+    scc_return_t      function_return_code; /**< Straight from SCC2 driver */
+} scc_reg_access;
+
+
+/**
+ * ioctl structure for partition setup/teardown functions
+ */
+typedef struct {
+    uint32_t virt_address;      /**< Its virtual address */
+    union {
+        /* for allocate */
+        struct {
+            uint32_t smid;      /**< From user  */
+            uint32_t part_no;   /**< Which partition was allocated */
+            uint32_t phys_address; /**<Its physical address */
+        };
+        /* for engage */
+        struct {
+            const uint8_t* umid; /**< 16-byte UMID for partition, or NULL */
+            uint32_t permissions; /**< Mode register setting for initial access  */
+        };
+    };
+    scc_return_t scc_status;    /**< Returned status of call to scc2 driver */
+} scc_partition_access;
+
+/** @} */
+
+/**
+ * ioctl structure for partition encrypt/decrypt functions
+ */
+typedef struct {
+    uint32_t virt_address;      /**< Its virtual address */
+    uint32_t red_offset;        /**< Byte offset into partition */
+    uint8_t* black_address;     /**< Virtual address of Black data */
+    uint32_t size_bytes;        /**< Number of bytes of red/black data */
+    uint64_t iv;                /**< first half of IV for CBC mode; second half
+                                   is zero */
+    scc_return_t scc_status;    /**< Returned status of call to scc2 driver */
+} scc_part_cipher_access;
+
+#endif /* scc2_test_driver.h */
diff --git a/test/mxc_scc2/test_subs.sh b/test/mxc_scc2/test_subs.sh
new file mode 100644
index 0000000..48e7566
--- /dev/null
+++ b/test/mxc_scc2/test_subs.sh
@@ -0,0 +1,158 @@
+#!/bin/sh
+
+################################################################
+## @file test_subs.sh
+## This script provides some accounting methods for running
+## tests, checking their results, and tallying the results.
+#
+# To be of any value whatsoever, this script must be run in the
+# same process as the calling script, i.e. invoked by
+# . test_subs.sh
+#
+################################################################
+
+
+# Initialize counters
+test_count=0
+test_pass_count=0
+
+
+################################################################
+# fn start_test()
+################################################################
+##
+## Initialize a test and account for its launch.
+##
+## Arguments: Whatever 'test name' should be displayed
+##
+start_test()
+{
+
+    echo
+    echo "****************************************"
+    echo
+    echo Running test: $*
+
+    # Evaluate this arithmetically!
+    # (This seems to be the most 'portable' method)
+    test_count=$(($test_count+1))
+
+}
+
+
+################################################################
+# fn run_test()
+################################################################
+##
+## Run a test and account for its launch.
+##
+## Arguments: Whatever command line should be executed as the test.
+##
+## Note that quoted commands will NOT work well, as quotes
+## will be stripped.
+##
+run_test()
+{
+    start_test $*
+
+    # Actual test launch
+    $*
+
+    # return value is that of the test command
+    return
+}
+
+
+################################################################
+# fn pos_test()
+################################################################
+## Run a positive test -- verify no error
+##
+## Arguments: Whatever command line should be executed as the test.
+##
+## Note that quoted commands will NOT work well, as quotes
+## will be stripped.
+##
+pos_test()
+{
+
+    run_test $*
+    if [ $? -eq 0 ]; then
+        test_pass_count=$(($test_pass_count+1))
+        echo "Test Passed"
+    else
+        echo "Test Failed"
+    fi
+}
+
+
+################################################################
+#fn neg_test()
+################################################################
+## Run a negative test -- look for error
+##
+## Arguments: Whatever command line should be executed as the test.
+##
+## Note that quoted commands will NOT work well, as quotes
+## will be stripped.
+##
+neg_test()
+{
+    run_test $*
+    if [ $? -ne 0 ]; then
+        test_pass_count=$(($test_pass_count+1))
+        echo "Test Passed"
+    else
+        echo "Test Failed"
+    fi
+}
+
+
+################################################################
+# fn record_failure()
+################################################################
+##
+## Record a failed result of a test begun by #start_test
+##
+## Arguments: Message to print
+##
+record_failure()
+{
+    echo $*
+    echo "Test Failed"
+}
+
+
+################################################################
+# fn record_success()
+################################################################
+##
+## Record a successful result of a test begun by #start_test
+##
+## Arguments: Message to print
+##
+record_success()
+{
+    echo $*
+    echo "Test Passed"
+    test_pass_count=$(($test_pass_count+1))
+}
+
+
+################################################################
+# fn print_test_results()
+################################################################
+##
+## Print summary of all tests launched
+##
+print_test_results()
+{
+    echo ${test_pass_count} " tests passed out of " ${test_count} " launched"
+
+    if [ ${test_count} -eq ${test_pass_count} ]; then
+        return 0                # no errors
+    else
+        return 1                # At least one error
+    fi
+}
+
-- 
1.8.0

