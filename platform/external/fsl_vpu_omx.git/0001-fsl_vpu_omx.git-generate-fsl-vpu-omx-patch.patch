From 67a234421035d0710013649ab0fd75ccd3c6808d Mon Sep 17 00:00:00 2001
From: b18293 <b18293@freescale.com>
Date: Fri, 20 Jun 2014 07:41:21 +0800
Subject: [PATCH] fsl_vpu_omx.git: generate fsl vpu omx patch

---
 Android.mk                                         |   75 +
 OSAL/Makefile                                      |   25 +
 OSAL/ghdr/Log.h                                    |  161 +
 OSAL/ghdr/fsl_osal.h                               |  858 ++
 OSAL/ghdr/fsl_osal_types.h                         |   73 +
 OSAL/linux/Android.mk                              |   31 +
 OSAL/linux/Makefile                                |   54 +
 OSAL/linux/fsl_osal_linux_condition.cpp            |  174 +
 OSAL/linux/fsl_osal_linux_file.cpp                 |  964 +++
 OSAL/linux/fsl_osal_linux_mem.cpp                  |  162 +
 OSAL/linux/fsl_osal_linux_mutex.cpp                |  144 +
 OSAL/linux/fsl_osal_linux_sem.cpp                  |  150 +
 OSAL/linux/fsl_osal_linux_string.cpp               |  233 +
 OSAL/linux/fsl_osal_linux_thread.cpp               |   86 +
 OSAL/linux/fsl_osal_linux_time.cpp                 |   44 +
 OSAL/logger/Log.cpp                                |  147 +
 OpenMAXIL/ghdr/OMX_Audio.h                         | 1311 +++
 OpenMAXIL/ghdr/OMX_Common.h                        |   36 +
 OpenMAXIL/ghdr/OMX_Component.h                     |  579 ++
 OpenMAXIL/ghdr/OMX_ContentPipe.h                   |  197 +
 OpenMAXIL/ghdr/OMX_Core.h                          | 1431 ++++
 OpenMAXIL/ghdr/OMX_GraphManager.h                  |  291 +
 OpenMAXIL/ghdr/OMX_IVCommon.h                      |  920 +++
 OpenMAXIL/ghdr/OMX_Image.h                         |  328 +
 OpenMAXIL/ghdr/OMX_ImageConvert.h                  |   54 +
 OpenMAXIL/ghdr/OMX_Implement.h                     |  489 ++
 OpenMAXIL/ghdr/OMX_Index.h                         |  258 +
 OpenMAXIL/ghdr/OMX_MetadataExtractor.h             |   75 +
 OpenMAXIL/ghdr/OMX_Other.h                         |  337 +
 OpenMAXIL/ghdr/OMX_Recorder.h                      |  149 +
 OpenMAXIL/ghdr/OMX_Types.h                         |  347 +
 OpenMAXIL/ghdr/OMX_Video.h                         | 1060 +++
 OpenMAXIL/ghdr/PlatformResourceMgrItf.h            |   33 +
 OpenMAXIL/release/registry/Android.mk              |   27 +
 OpenMAXIL/release/registry/component_register      |  566 ++
 OpenMAXIL/release/registry/contentpipe_register    |   44 +
 OpenMAXIL/release/registry/core_register           |   23 +
 OpenMAXIL/src/component/common/Android.mk          |   47 +
 OpenMAXIL/src/component/common/AudioCoreParser.h   |  115 +
 OpenMAXIL/src/component/common/AudioFilter.cpp     |  426 +
 OpenMAXIL/src/component/common/AudioFilter.h       |   82 +
 OpenMAXIL/src/component/common/AudioParserBase.cpp | 1251 +++
 OpenMAXIL/src/component/common/AudioParserBase.h   |  106 +
 OpenMAXIL/src/component/common/AudioRender.cpp     | 1030 +++
 OpenMAXIL/src/component/common/AudioRender.h       |  105 +
 OpenMAXIL/src/component/common/AudioSource.cpp     |  618 ++
 OpenMAXIL/src/component/common/AudioSource.h       |   90 +
 OpenMAXIL/src/component/common/ComponentBase.cpp   | 1241 +++
 OpenMAXIL/src/component/common/ComponentBase.h     |  104 +
 OpenMAXIL/src/component/common/ComponentCommon.h   |  187 +
 OpenMAXIL/src/component/common/ExecutingState.cpp  |  226 +
 OpenMAXIL/src/component/common/ExecutingState.h    |   56 +
 OpenMAXIL/src/component/common/IdleState.cpp       |  241 +
 OpenMAXIL/src/component/common/IdleState.h         |   56 +
 OpenMAXIL/src/component/common/InvalidState.cpp    |  155 +
 OpenMAXIL/src/component/common/InvalidState.h      |   56 +
 OpenMAXIL/src/component/common/LoadedState.cpp     |  219 +
 OpenMAXIL/src/component/common/LoadedState.h       |   56 +
 OpenMAXIL/src/component/common/Makefile            |   52 +
 OpenMAXIL/src/component/common/Muxer.cpp           | 1135 +++
 OpenMAXIL/src/component/common/Muxer.h             |  146 +
 OpenMAXIL/src/component/common/Parser.cpp          | 1785 ++++
 OpenMAXIL/src/component/common/Parser.h            |  160 +
 OpenMAXIL/src/component/common/PauseState.cpp      |  241 +
 OpenMAXIL/src/component/common/PauseState.h        |   56 +
 OpenMAXIL/src/component/common/Port.cpp            |  867 ++
 OpenMAXIL/src/component/common/Port.h              |   88 +
 OpenMAXIL/src/component/common/State.cpp           |  805 ++
 OpenMAXIL/src/component/common/State.h             |   88 +
 OpenMAXIL/src/component/common/UniaDecoder.cpp     |  683 ++
 OpenMAXIL/src/component/common/UniaDecoder.h       |   75 +
 OpenMAXIL/src/component/common/VideoFilter.cpp     |  989 +++
 OpenMAXIL/src/component/common/VideoFilter.h       |  133 +
 OpenMAXIL/src/component/common/VideoRender.cpp     |  558 ++
 OpenMAXIL/src/component/common/VideoRender.h       |   90 +
 OpenMAXIL/src/component/common/VideoSource.cpp     |  785 ++
 OpenMAXIL/src/component/common/VideoSource.h       |  107 +
 .../src/component/common/WaitForResourcesState.cpp |  175 +
 .../src/component/common/WaitForResourcesState.h   |   54 +
 OpenMAXIL/src/component/common/file_stream.h       |   36 +
 OpenMAXIL/src/component/common/fsl_media_types.h   |  260 +
 OpenMAXIL/src/component/common/fsl_muxer.h         |  485 ++
 OpenMAXIL/src/component/common/fsl_parser.h        |  845 ++
 OpenMAXIL/src/component/common/fsl_types.h         |   57 +
 OpenMAXIL/src/component/common/fsl_unia.h          |  306 +
 .../src/component/common/video_frame_visitor.h     |   29 +
 OpenMAXIL/src/component/vpu_dec_v2/Android.mk      |   28 +
 OpenMAXIL/src/component/vpu_dec_v2/Makefile        |   39 +
 .../src/component/vpu_dec_v2/VpuDecComponent.cpp   | 4207 ++++++++++
 .../src/component/vpu_dec_v2/VpuDecComponent.h     |  247 +
 OpenMAXIL/src/component/vpu_enc/Android.mk         |   28 +
 OpenMAXIL/src/component/vpu_enc/Makefile           |   37 +
 .../src/component/vpu_enc/VpuEncComponent.cpp      | 3036 +++++++
 OpenMAXIL/src/component/vpu_enc/VpuEncComponent.h  |  200 +
 OpenMAXIL/src/component/vpu_wrapper/Android.mk     |   29 +
 OpenMAXIL/src/component/vpu_wrapper/makefile       |  102 +
 OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.c  | 8707 ++++++++++++++++++++
 OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.h  |  697 ++
 OpenMAXIL/src/core/Android.mk                      |   26 +
 OpenMAXIL/src/core/Makefile                        |   48 +
 OpenMAXIL/src/core/OMXCore.cpp                     | 1073 +++
 OpenMAXIL/src/core/OMXCore.h                       |   84 +
 OpenMAXIL/src/resource_mgr/Android.mk              |   25 +
 OpenMAXIL/src/resource_mgr/Makefile                |   47 +
 OpenMAXIL/src/resource_mgr/PlatformResourceMgr.cpp |  175 +
 OpenMAXIL/src/resource_mgr/PlatformResourceMgr.h   |   41 +
 OpenMAXIL/test/vpu_test/Android.mk                 |   22 +
 OpenMAXIL/test/vpu_test/Makefile                   |   50 +
 OpenMAXIL/test/vpu_test/vpu_test.cpp               |  789 ++
 codec_env.mk                                       |    1 +
 stagefright/Android.mk                             |   48 +
 stagefright/src/FSLRenderer.cpp                    |  175 +
 stagefright/src/FSLRenderer.h                      |   53 +
 stagefright/src/OMXFSLPlugin.cpp                   |  261 +
 stagefright/src/OMXFSLPlugin_new.cpp               |  745 ++
 utils/Android.mk                                   |   40 +
 utils/AudioTSManager.cpp                           |  214 +
 utils/AudioTSManager.h                             |   63 +
 utils/FadeInFadeOut.cpp                            |  268 +
 utils/FadeInFadeOut.h                              |   56 +
 utils/List.h                                       |  289 +
 utils/Makefile                                     |   67 +
 utils/Mem.cpp                                      |  348 +
 utils/Mem.h                                        |   60 +
 utils/Queue.cpp                                    |  327 +
 utils/Queue.h                                      |   93 +
 utils/RegistryAnalyser.cpp                         |  177 +
 utils/RegistryAnalyser.h                           |   58 +
 utils/RingBuffer.cpp                               |  220 +
 utils/RingBuffer.h                                 |   59 +
 utils/ShareLibarayMgr.cpp                          |  152 +
 utils/ShareLibarayMgr.h                            |   41 +
 utils/Tsm_wrapper.c                                |  536 ++
 utils/Tsm_wrapper.h                                |   36 +
 utils/Utils.h                                      |   59 +
 utils/audio_frame_parser/AacFrameParser.c          |   96 +
 utils/audio_frame_parser/AacFrameParser.h          |   28 +
 utils/audio_frame_parser/Ac3FrameParser.c          |  104 +
 utils/audio_frame_parser/Ac3FrameParser.h          |   28 +
 utils/audio_frame_parser/AudioFrameParser.c        |  110 +
 utils/audio_frame_parser/AudioFrameParser.h        |   55 +
 utils/audio_frame_parser/Mp3FrameParser.c          |  142 +
 utils/audio_frame_parser/Mp3FrameParser.h          |   28 +
 utils/colorconvert/include/cc16Wrapper.h           |   37 +
 utils/colorconvert/include/cczoomrotation16.h      |   70 +
 utils/colorconvert/include/cczoomrotationbase.h    |  242 +
 utils/colorconvert/include/colorconv_config.h      |   60 +
 utils/colorconvert/src/cczoomrotation16.cpp        | 6186 ++++++++++++++
 utils/colorconvert/src/cczoomrotationbase.cpp      |  356 +
 utils/id3_parser/Android.mk                        |   21 +
 utils/id3_parser/ID3.cpp                           |  789 ++
 utils/id3_parser/ID3.h                             |   98 +
 utils/mfw_gst_ts.c                                 |  744 ++
 utils/mfw_gst_ts.h                                 |  157 +
 154 files changed, 63027 insertions(+)
 create mode 100755 Android.mk
 create mode 100755 OSAL/Makefile
 create mode 100755 OSAL/ghdr/Log.h
 create mode 100755 OSAL/ghdr/fsl_osal.h
 create mode 100755 OSAL/ghdr/fsl_osal_types.h
 create mode 100755 OSAL/linux/Android.mk
 create mode 100755 OSAL/linux/Makefile
 create mode 100755 OSAL/linux/fsl_osal_linux_condition.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_file.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_mem.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_mutex.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_sem.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_string.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_thread.cpp
 create mode 100755 OSAL/linux/fsl_osal_linux_time.cpp
 create mode 100755 OSAL/logger/Log.cpp
 create mode 100755 OpenMAXIL/ghdr/OMX_Audio.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Common.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Component.h
 create mode 100755 OpenMAXIL/ghdr/OMX_ContentPipe.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Core.h
 create mode 100755 OpenMAXIL/ghdr/OMX_GraphManager.h
 create mode 100755 OpenMAXIL/ghdr/OMX_IVCommon.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Image.h
 create mode 100755 OpenMAXIL/ghdr/OMX_ImageConvert.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Implement.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Index.h
 create mode 100755 OpenMAXIL/ghdr/OMX_MetadataExtractor.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Other.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Recorder.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Types.h
 create mode 100755 OpenMAXIL/ghdr/OMX_Video.h
 create mode 100755 OpenMAXIL/ghdr/PlatformResourceMgrItf.h
 create mode 100755 OpenMAXIL/release/registry/Android.mk
 create mode 100755 OpenMAXIL/release/registry/component_register
 create mode 100755 OpenMAXIL/release/registry/contentpipe_register
 create mode 100755 OpenMAXIL/release/registry/core_register
 create mode 100755 OpenMAXIL/src/component/common/Android.mk
 create mode 100755 OpenMAXIL/src/component/common/AudioCoreParser.h
 create mode 100755 OpenMAXIL/src/component/common/AudioFilter.cpp
 create mode 100755 OpenMAXIL/src/component/common/AudioFilter.h
 create mode 100755 OpenMAXIL/src/component/common/AudioParserBase.cpp
 create mode 100755 OpenMAXIL/src/component/common/AudioParserBase.h
 create mode 100755 OpenMAXIL/src/component/common/AudioRender.cpp
 create mode 100755 OpenMAXIL/src/component/common/AudioRender.h
 create mode 100755 OpenMAXIL/src/component/common/AudioSource.cpp
 create mode 100755 OpenMAXIL/src/component/common/AudioSource.h
 create mode 100755 OpenMAXIL/src/component/common/ComponentBase.cpp
 create mode 100755 OpenMAXIL/src/component/common/ComponentBase.h
 create mode 100755 OpenMAXIL/src/component/common/ComponentCommon.h
 create mode 100755 OpenMAXIL/src/component/common/ExecutingState.cpp
 create mode 100755 OpenMAXIL/src/component/common/ExecutingState.h
 create mode 100755 OpenMAXIL/src/component/common/IdleState.cpp
 create mode 100755 OpenMAXIL/src/component/common/IdleState.h
 create mode 100755 OpenMAXIL/src/component/common/InvalidState.cpp
 create mode 100755 OpenMAXIL/src/component/common/InvalidState.h
 create mode 100755 OpenMAXIL/src/component/common/LoadedState.cpp
 create mode 100755 OpenMAXIL/src/component/common/LoadedState.h
 create mode 100755 OpenMAXIL/src/component/common/Makefile
 create mode 100755 OpenMAXIL/src/component/common/Muxer.cpp
 create mode 100755 OpenMAXIL/src/component/common/Muxer.h
 create mode 100755 OpenMAXIL/src/component/common/Parser.cpp
 create mode 100755 OpenMAXIL/src/component/common/Parser.h
 create mode 100755 OpenMAXIL/src/component/common/PauseState.cpp
 create mode 100755 OpenMAXIL/src/component/common/PauseState.h
 create mode 100755 OpenMAXIL/src/component/common/Port.cpp
 create mode 100755 OpenMAXIL/src/component/common/Port.h
 create mode 100755 OpenMAXIL/src/component/common/State.cpp
 create mode 100755 OpenMAXIL/src/component/common/State.h
 create mode 100755 OpenMAXIL/src/component/common/UniaDecoder.cpp
 create mode 100755 OpenMAXIL/src/component/common/UniaDecoder.h
 create mode 100755 OpenMAXIL/src/component/common/VideoFilter.cpp
 create mode 100755 OpenMAXIL/src/component/common/VideoFilter.h
 create mode 100755 OpenMAXIL/src/component/common/VideoRender.cpp
 create mode 100755 OpenMAXIL/src/component/common/VideoRender.h
 create mode 100755 OpenMAXIL/src/component/common/VideoSource.cpp
 create mode 100755 OpenMAXIL/src/component/common/VideoSource.h
 create mode 100755 OpenMAXIL/src/component/common/WaitForResourcesState.cpp
 create mode 100755 OpenMAXIL/src/component/common/WaitForResourcesState.h
 create mode 100755 OpenMAXIL/src/component/common/file_stream.h
 create mode 100755 OpenMAXIL/src/component/common/fsl_media_types.h
 create mode 100755 OpenMAXIL/src/component/common/fsl_muxer.h
 create mode 100755 OpenMAXIL/src/component/common/fsl_parser.h
 create mode 100755 OpenMAXIL/src/component/common/fsl_types.h
 create mode 100755 OpenMAXIL/src/component/common/fsl_unia.h
 create mode 100755 OpenMAXIL/src/component/common/video_frame_visitor.h
 create mode 100755 OpenMAXIL/src/component/vpu_dec_v2/Android.mk
 create mode 100755 OpenMAXIL/src/component/vpu_dec_v2/Makefile
 create mode 100755 OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.cpp
 create mode 100755 OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.h
 create mode 100755 OpenMAXIL/src/component/vpu_enc/Android.mk
 create mode 100755 OpenMAXIL/src/component/vpu_enc/Makefile
 create mode 100755 OpenMAXIL/src/component/vpu_enc/VpuEncComponent.cpp
 create mode 100755 OpenMAXIL/src/component/vpu_enc/VpuEncComponent.h
 create mode 100755 OpenMAXIL/src/component/vpu_wrapper/Android.mk
 create mode 100755 OpenMAXIL/src/component/vpu_wrapper/makefile
 create mode 100755 OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.c
 create mode 100755 OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.h
 create mode 100755 OpenMAXIL/src/core/Android.mk
 create mode 100755 OpenMAXIL/src/core/Makefile
 create mode 100755 OpenMAXIL/src/core/OMXCore.cpp
 create mode 100755 OpenMAXIL/src/core/OMXCore.h
 create mode 100755 OpenMAXIL/src/resource_mgr/Android.mk
 create mode 100755 OpenMAXIL/src/resource_mgr/Makefile
 create mode 100755 OpenMAXIL/src/resource_mgr/PlatformResourceMgr.cpp
 create mode 100755 OpenMAXIL/src/resource_mgr/PlatformResourceMgr.h
 create mode 100755 OpenMAXIL/test/vpu_test/Android.mk
 create mode 100755 OpenMAXIL/test/vpu_test/Makefile
 create mode 100755 OpenMAXIL/test/vpu_test/vpu_test.cpp
 create mode 100644 codec_env.mk
 create mode 100755 stagefright/Android.mk
 create mode 100755 stagefright/src/FSLRenderer.cpp
 create mode 100755 stagefright/src/FSLRenderer.h
 create mode 100755 stagefright/src/OMXFSLPlugin.cpp
 create mode 100755 stagefright/src/OMXFSLPlugin_new.cpp
 create mode 100755 utils/Android.mk
 create mode 100755 utils/AudioTSManager.cpp
 create mode 100755 utils/AudioTSManager.h
 create mode 100755 utils/FadeInFadeOut.cpp
 create mode 100755 utils/FadeInFadeOut.h
 create mode 100755 utils/List.h
 create mode 100755 utils/Makefile
 create mode 100755 utils/Mem.cpp
 create mode 100755 utils/Mem.h
 create mode 100755 utils/Queue.cpp
 create mode 100755 utils/Queue.h
 create mode 100755 utils/RegistryAnalyser.cpp
 create mode 100755 utils/RegistryAnalyser.h
 create mode 100755 utils/RingBuffer.cpp
 create mode 100755 utils/RingBuffer.h
 create mode 100755 utils/ShareLibarayMgr.cpp
 create mode 100755 utils/ShareLibarayMgr.h
 create mode 100755 utils/Tsm_wrapper.c
 create mode 100755 utils/Tsm_wrapper.h
 create mode 100755 utils/Utils.h
 create mode 100755 utils/audio_frame_parser/AacFrameParser.c
 create mode 100755 utils/audio_frame_parser/AacFrameParser.h
 create mode 100755 utils/audio_frame_parser/Ac3FrameParser.c
 create mode 100755 utils/audio_frame_parser/Ac3FrameParser.h
 create mode 100755 utils/audio_frame_parser/AudioFrameParser.c
 create mode 100755 utils/audio_frame_parser/AudioFrameParser.h
 create mode 100755 utils/audio_frame_parser/Mp3FrameParser.c
 create mode 100755 utils/audio_frame_parser/Mp3FrameParser.h
 create mode 100755 utils/colorconvert/include/cc16Wrapper.h
 create mode 100755 utils/colorconvert/include/cczoomrotation16.h
 create mode 100755 utils/colorconvert/include/cczoomrotationbase.h
 create mode 100755 utils/colorconvert/include/colorconv_config.h
 create mode 100755 utils/colorconvert/src/cczoomrotation16.cpp
 create mode 100755 utils/colorconvert/src/cczoomrotationbase.cpp
 create mode 100755 utils/id3_parser/Android.mk
 create mode 100755 utils/id3_parser/ID3.cpp
 create mode 100755 utils/id3_parser/ID3.h
 create mode 100755 utils/mfw_gst_ts.c
 create mode 100755 utils/mfw_gst_ts.h

diff --git a/Android.mk b/Android.mk
new file mode 100755
index 0000000..4555c74
--- /dev/null
+++ b/Android.mk
@@ -0,0 +1,75 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+
+# LOCAL_PATH will be changed by each Android.mk under this. So save it firstly
+FSL_OMX_PATH := $(LOCAL_PATH)
+
+include $(CLEAR_VARS)
+FSL_OMX_CFLAGS := -DANDROID_BUILD -D_POSIX_SOURCE -UDOMX_MEM_CHECK -Werror
+
+FSL_OMX_LDFLAGS := -Wl,--fatal-warnings
+
+FSL_OMX_INCLUDES := \
+	$(LOCAL_PATH)/OSAL/ghdr \
+	$(LOCAL_PATH)/utils \
+	$(LOCAL_PATH)/OpenMAXIL/ghdr \
+	$(LOCAL_PATH)/OpenMAXIL/src/component/common \
+	$(LOCAL_PATH)/../linux-lib/vpu \
+	$(LOCAL_PATH)/../../frameworks/native/include/media/hardware
+
+
+ANDROID_VERSION_LIST = -DFROYO=220 -DGINGER_BREAD=230 -DHONEY_COMB=300 \
+		       -DICS=400 -DJELLY_BEAN_42=420 -DJELLY_BEAN_43=430 -DKITKAT_44=440
+
+ifeq ($(findstring x2.2,x$(PLATFORM_VERSION)), x2.2)
+    ANDROID_VERSION_MACRO = 220
+endif
+ifeq ($(findstring x2.3,x$(PLATFORM_VERSION)), x2.3)
+    ANDROID_VERSION_MACRO = 230
+endif
+ifeq ($(findstring x3.,x$(PLATFORM_VERSION)), x3.)
+    ANDROID_VERSION_MACRO = 300
+endif
+ifeq ($(findstring x4.0,x$(PLATFORM_VERSION)), x4.0)
+    ANDROID_VERSION_MACRO = 400
+endif
+ifeq ($(findstring x4.2,x$(PLATFORM_VERSION)), x4.2)
+    ANDROID_VERSION_MACRO = 420
+endif
+ifeq ($(findstring x4.3,x$(PLATFORM_VERSION)), x4.3)
+    ANDROID_VERSION_MACRO = 430
+endif
+ifeq ($(findstring x4.4,x$(PLATFORM_VERSION)), x4.4)
+    ANDROID_VERSION_MACRO = 440
+endif
+
+FSL_OMX_CFLAGS += $(ANDROID_VERSION_LIST) -DANDROID_VERSION=$(ANDROID_VERSION_MACRO)
+
+ifeq ($(TARGET_BOARD_PLATFORM), imx5x)
+    FSL_OMX_INCLUDES += $(LOCAL_PATH)/../../hardware/imx/mx5x/libgralloc
+    FSL_OMX_CFLAGS += -DMX5X
+endif
+ifeq ($(TARGET_BOARD_PLATFORM), imx6)
+    FSL_OMX_INCLUDES += $(LOCAL_PATH)/../../hardware/imx/mx6/libgralloc_wrapper
+    FSL_OMX_CFLAGS += -DMX6X
+endif
+
+include $(FSL_OMX_PATH)/utils/id3_parser/Android.mk
+
+include $(FSL_OMX_PATH)/OSAL/linux/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/src/component/common/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/src/resource_mgr/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/src/core/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/release/registry/Android.mk
+ifeq ($(BOARD_HAVE_VPU),true)
+include $(FSL_OMX_PATH)/OpenMAXIL/src/component/vpu_wrapper/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/src/component/vpu_dec_v2/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/src/component/vpu_enc/Android.mk
+include $(FSL_OMX_PATH)/OpenMAXIL/test/vpu_test/Android.mk
+include $(FSL_OMX_PATH)/stagefright/Android.mk
+endif
+
+include $(FSL_OMX_PATH)/utils/Android.mk
+
+endif
diff --git a/OSAL/Makefile b/OSAL/Makefile
new file mode 100755
index 0000000..081b65f
--- /dev/null
+++ b/OSAL/Makefile
@@ -0,0 +1,25 @@
+#####################################################################################
+#
+#   Copyright (c) 2009, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will build whole OMX project.
+#
+######################################################################################
+
+
+all: 
+	$(MAKE) -C linux 
+
+clean:
+	$(MAKE) clean -C linux 
+
+
+
+
+
diff --git a/OSAL/ghdr/Log.h b/OSAL/ghdr/Log.h
new file mode 100755
index 0000000..06292f8
--- /dev/null
+++ b/OSAL/ghdr/Log.h
@@ -0,0 +1,161 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file Log.h
+ *
+ * @brief log information for debug
+ *
+ * @ingroup utils
+ */
+
+#ifndef Log_h
+#define Log_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <sys/time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "fsl_osal.h"
+
+
+
+/**
+ * LogLevel:
+ * @LOG_LEVEL_NONE: No debugging level specified or desired. Used to deactivate
+ *  debugging output.
+ * @LOG_LEVEL_ERROR: Error messages are to be used only when an error occured
+ *  that stops the application from keeping working correctly.
+ * @LOG_LEVEL_WARNING: Warning messages are to inform about abnormal behaviour
+ *  that could lead to problems or weird behaviour later on.
+ * @LOG_LEVEL_INFO: Informational messages should be used to keep the developer
+ *  updated about what is happening.
+ *  Examples where this should be used are when a typefind function has
+ *  successfully determined the type of the stream or when an mp3 plugin detects
+ *  the format to be used. ("This file has mono sound.")
+ * @LOG_LEVEL_DEBUG: Debugging messages should be used when something common
+ *  happens that is not the expected default behavior.
+ *  An example would be notifications about state changes or receiving/sending of
+ *  events.
+ * @LOG_LEVEL_BUFFER: Debugging messages should be used to trace the buffer
+ *  transport between component.
+ * @LOG_LEVEL_LOG: Log messages are messages that are very common but might be
+ *  useful to know. As a rule of thumb a pipeline that is iterating as expected
+ *  should never output anzthing else but LOG messages.
+ * @LOG_LEVEL_COUNT: The number of defined debugging levels.
+ *
+ * The level defines the importance of a debugging message. The more important a
+ * message is, the greater the probability that the debugging system outputs it.
+ */
+typedef enum {
+  LOG_LEVEL_NONE = 0,
+  LOG_LEVEL_ERROR,
+  LOG_LEVEL_WARNING,
+  LOG_LEVEL_INFO,
+  LOG_LEVEL_APIINFO,
+  LOG_LEVEL_DEBUG,
+  LOG_LEVEL_BUFFER,
+  LOG_LEVEL_LOG,
+  /* add more */
+  LOG_LEVEL_COUNT
+} LogLevel;
+
+extern fsl_osal_s32 nLogLevel;
+extern fsl_osal_file pLogFile;
+
+#define START do
+#define END while (0)
+
+#ifdef ANDROID_BUILD
+
+#ifdef LOG
+#undef LOG
+#endif
+
+#define LOG(LEVEL, ...)      START{ \
+    if (nLogLevel >= LEVEL) { \
+        LogOutput("LEVEL: %d FUNCTION: %s LINE: %d", LEVEL, __FUNCTION__, __LINE__); \
+        LogOutput(__VA_ARGS__); \
+    } \
+}END
+
+#define LOG_INS(LEVEL, ...)      START{ \
+    if (nLogLevel >= LEVEL) { \
+        LogOutput("LEVEL: %d FUNCTION: %s LINE: %d INSTANCE: %p ", LEVEL, \
+                 __FUNCTION__, __LINE__, this); \
+        LogOutput(__VA_ARGS__); \
+    } \
+}END
+
+#define printf LogOutput
+
+fsl_osal_void LogOutput(const fsl_osal_char *fmt, ...);
+
+#else
+
+#define LOG(LEVEL, ...)      START{ \
+	if (nLogLevel >= LEVEL) { \
+		if (NULL != pLogFile) { \
+			fprintf((FILE *)pLogFile, "LEVEL: %d FILE: %s FUNCTION: %s LINE: %d ", LEVEL, \
+					__FILE__, __FUNCTION__, __LINE__); \
+			fprintf((FILE *)pLogFile, __VA_ARGS__); \
+			fflush((FILE *)pLogFile); \
+		} \
+		else { \
+			fprintf(stdout, "LEVEL: %d FILE: %s FUNCTION: %s LINE: %d ", LEVEL, __FILE__, \
+					__FUNCTION__, __LINE__); \
+			fprintf(stdout, __VA_ARGS__); \
+			fflush(stdout); \
+		} \
+	} \
+}END
+
+#define LOG_INS(LEVEL, ...)      START{ \
+	if (nLogLevel >= LEVEL) { \
+		if (NULL != pLogFile) { \
+			fprintf((FILE *)pLogFile, "LEVEL: %d FILE: %s FUNCTION: %s LINE: %d INSTANCE: %p ", LEVEL, __FILE__, __FUNCTION__, __LINE__, this); \
+			fprintf((FILE *)pLogFile, __VA_ARGS__); \
+			fflush((FILE *)pLogFile); \
+		} \
+		else { \
+			fprintf(stdout, "LEVEL: %d FILE: %s FUNCTION: %s LINE: %d INSTANCE: %p ", LEVEL, \
+				__FILE__, __FUNCTION__, __LINE__, this); \
+			fprintf(stdout, __VA_ARGS__); \
+			fflush(stdout); \
+		} \
+	} \
+}END
+
+#endif
+#define LOG_ERROR(...)   LOG(LOG_LEVEL_ERROR, __VA_ARGS__) 
+#define LOG_WARNING(...) LOG(LOG_LEVEL_WARNING, __VA_ARGS__) 
+#define LOG_INFO(...)    LOG(LOG_LEVEL_INFO, __VA_ARGS__) 
+#define LOG_DEBUG(...)   LOG(LOG_LEVEL_DEBUG, __VA_ARGS__) 
+#define LOG_BUFFER(...)  LOG(LOG_LEVEL_BUFFER, __VA_ARGS__) 
+#define LOG_LOG(...)     LOG(LOG_LEVEL_LOG, __VA_ARGS__) 
+
+#define LOG_ERROR_INS(...)   LOG_INS(LOG_LEVEL_ERROR, __VA_ARGS__) 
+#define LOG_WARNING_INS(...) LOG_INS(LOG_LEVEL_WARNING, __VA_ARGS__) 
+#define LOG_INFO_INS(...)    LOG_INS(LOG_LEVEL_INFO, __VA_ARGS__) 
+#define LOG_DEBUG_INS(...)   LOG_INS(LOG_LEVEL_DEBUG, __VA_ARGS__) 
+#define LOG_BUFFER_INS(...)  LOG_INS(LOG_LEVEL_BUFFER, __VA_ARGS__) 
+#define LOG_LOG_INS(...)     LOG_INS(LOG_LEVEL_LOG, __VA_ARGS__) 
+
+fsl_osal_void LogInit(fsl_osal_s32 nLevel, fsl_osal_char *pFile);
+fsl_osal_void LogDeInit();
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OSAL/ghdr/fsl_osal.h b/OSAL/ghdr/fsl_osal.h
new file mode 100755
index 0000000..8de79da
--- /dev/null
+++ b/OSAL/ghdr/fsl_osal.h
@@ -0,0 +1,858 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*!
+ * @file fsl_osal.h
+ *
+ * @brief Defines the OS Abstraction layer APIs
+ *
+ * @ingroup osal
+ */
+
+#ifndef FSL_OSAL_H_
+#define FSL_OSAL_H_
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/** The OMX_OSAL_API is platform specific definitions used
+ *  to declare OMX function prototypes.  They are modified to meet the
+ *  requirements for a particular platform */
+#ifdef __WINCE_DLL
+#   ifdef __OMX_OSAL_EXPORTS
+#       define OMX_OSAL_API __declspec(dllexport)
+#   else
+#       define OMX_OSAL_API __declspec(dllimport)
+#   endif
+#else
+#   ifdef __OMX_OSAL_EXPORTS
+#       define OMX_OSAL_API
+#   else
+#       define OMX_OSAL_API extern
+#   endif
+#endif
+
+
+#include <fsl_osal_types.h>
+#include <unistd.h>
+
+#if defined ANDROID_BUILD || defined LINUX
+    #include <pthread.h>
+
+    #define  FSL_OSAL_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+    #define  FSL_OSAL_RECURSIVE_MUTEX_INITIALIZER PTHREAD_RECURSIVE_MUTEX_INITIALIZER   
+    #define  FSL_OSAL_ERRORCHECK_MUTEX_INITIALIZER PTHREAD_ERRORCHECK_MUTEX_INITIALIZER 
+
+    typedef pthread_mutex_t fsl_osal_mutex_t ;
+#endif
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///	Memory management APIS
+/////////////////////////////////////////////////////////////////////////////////////////////
+
+typedef enum efsl_osal_return_type
+{
+	E_FSL_OSAL_SUCCESS,		/*!< Successful operation */
+	E_FSL_OSAL_FAILURE,		/*!< Erroneous Operation */
+	E_FSL_OSAL_UNAVAILABLE, /*!< Requested resource not available */
+	E_FSL_OSAL_BUSY,		/*!< Mutex could not be acquired because it was currently locked*/
+	E_FSL_OSAL_INVALIDMODE,
+	E_FSL_OSAL_INVALIDPARAM,/*!< One of the parameter is invalid */
+	E_FSL_OSAL_INVALIDSTATE,/*!< The resource in invalid state.
+								 Eg: The calling task did not currently own the mutex */
+	E_FSL_OSAL_EOF, 		/*!< End of file reached */
+	E_FSL_OSAL_NOTSUPPORTED,/*!< The specified feature is not supported */
+	E_FSL_OSAL_UNKNOWN
+} efsl_osal_return_type_t;
+
+typedef fsl_osal_ptr fsl_osal_file;
+
+/*! Specifies the reference position for fseek API.
+ */
+typedef enum efsl_osal_seek_pos
+{
+	E_FSL_OSAL_SEEK_SET, 	/*!< start of the file */
+	E_FSL_OSAL_SEEK_CUR, 	/*!< current position  */
+	E_FSL_OSAL_SEEK_END 	/*!< end-of-file */
+}efsl_osal_seek_pos_t;
+
+/*! Initialize the OSAL system. OSAL should be initilalized beore calling
+ *	any of the osal APIs.
+ *
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_init(void);
+
+/*! De-Initialize the OSAL system
+ *
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_deinit(void);
+
+
+/*! Allocates the requested memory.
+ *
+ *	@param [In] size
+ *	    memory size need to allocateed.
+ *	@param [out] ptr
+ *		pointer to allocated memory if successfully allocated otherwise NULL.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+OMX_OSAL_API fsl_osal_ptr fsl_osal_malloc_new(fsl_osal_u32 size);
+
+/*! ReAllocates the requested memory.
+ *
+ *	@param [In] size
+ *	    memory size need to allocateed.
+ *	@param [In/out] ptr
+ *		pointer to allocated memory if successfully allocated otherwise NULL.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+OMX_OSAL_API fsl_osal_ptr fsl_osal_realloc_new(fsl_osal_ptr ptr, fsl_osal_u32 size);	
+
+
+/*! Releases the requested memory
+ *
+ *	@param [In] ptr
+ *		memory to be released.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_dealloc(fsl_osal_ptr ptr);
+
+/*!  The  fsl_osal_memset function fills the first size bytes of the memory area
+ *	 pointed to by ptr with the constant byte ch.
+ *
+ *	@param [In] ptr
+ *		pointer to memory.
+ *	@param [In] ch
+ *		The byte to be written.
+ *	@param [In] size
+ *		Size of memory to be updated.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ OMX_OSAL_API efsl_osal_return_type_t fsl_osal_memset(fsl_osal_ptr ptr,
+ 										 fsl_osal_char ch,
+ 										 fsl_osal_u32 size);
+
+/*!  The  fsl_osal_memcpy function copies 'size' bytes from memory area src to memory
+ *   area dest. The memory area is not overlappable.
+ *
+ *	@param [In] dest
+ *		destination location.
+ *	@param [In] src
+ *		source location.
+ *	@param [In] size
+ *		Size of memory to be copied.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ OMX_OSAL_API efsl_osal_return_type_t fsl_osal_memcpy(fsl_osal_ptr dest,
+ 										 fsl_osal_ptr src,
+ 										 fsl_osal_u32 size);
+
+/*!  The  fsl_osal_memmove function copies 'size' bytes from memory area src to memory
+ *   area dest. The memory area is overlappable.
+ *
+ *	@param [In] dest
+ *		destination location.
+ *	@param [In] src
+ *		source location.
+ *	@param [In] size
+ *		Size of memory to be copied.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ OMX_OSAL_API efsl_osal_return_type_t fsl_osal_memmove(fsl_osal_ptr dest,
+ 										 fsl_osal_ptr src,
+ 										 fsl_osal_u32 size);
+
+/*!  The  fsl_osal_memcmp function compare two memory.
+ *
+ *	@param [In] dest
+ *		destination location.
+ *	@param [In] src
+ *		source location.
+ *	@param [In] size
+ *		Size of memory to be copied.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ fsl_osal_s32 fsl_osal_memcmp(const fsl_osal_ptr ptr1,
+ 										 const fsl_osal_ptr ptr2,
+ 										 fsl_osal_u32 size);
+
+/*! String copy.
+ *
+ *	@param [out] dest
+ *		destination point for string copy.
+  *	@param [In] src
+ *		source point for string copy.
+ *	@return fsl_osal_char
+ *		return destination point.
+ */
+
+ OMX_OSAL_API fsl_osal_char *fsl_osal_strcpy(fsl_osal_char *dest, const fsl_osal_char *src);
+ 
+/*! String copy.
+ *
+ *	@param [out] dest
+ *		destination point for string copy.
+ *	@param [In] src
+ *		source point for string copy.
+ *	@param [In] n
+ *		Length.
+ *	@return fsl_osal_char
+ *		return destination point.
+ */
+
+  OMX_OSAL_API fsl_osal_char *fsl_osal_strncpy(fsl_osal_char *dest, const fsl_osal_char *src, fsl_osal_s32 n);
+
+/*! Search sub string.
+ *
+ *	@param [In] src1
+ *		string wants to be search.
+ *	@param [In] src2
+ *		the sub string.
+ *	@return fsl_osal_char
+ *		return sub string position .
+ */
+
+ fsl_osal_char *fsl_osal_strstr(const fsl_osal_char *src1, const fsl_osal_char *src2);
+ 
+ /*! String segmentation.
+ *
+ *	@param [in] s
+ *		string will be segmentation.
+  *	@param [In] delim
+ *		segmentation string.
+ *	@return fsl_osal_char
+ *		return segmentation point.
+ */
+
+  OMX_OSAL_API fsl_osal_char *fsl_osal_strtok(fsl_osal_char *s, const fsl_osal_char *delim);
+  
+ /*! Thread safe string segmentation.
+ *
+ *	@param [in] s
+ *		string will be segmentation.
+  *	@param [In] delim
+ *		segmentation string.
+ *	@return fsl_osal_char
+ *		return segmentation point.
+ */
+
+  OMX_OSAL_API fsl_osal_char *fsl_osal_strtok_r(fsl_osal_char *s, const fsl_osal_char *delim, fsl_osal_char ** pLast);
+   
+ /*! String find.
+ *
+ *	@param [in] s
+ *		string.
+  *	@param [In] c
+ *		char.
+ *	@return fsl_osal_char
+ *		return string point.
+ */
+
+ OMX_OSAL_API fsl_osal_char *fsl_osal_strrchr(const fsl_osal_char *s, fsl_osal_s32 c);
+ 
+/*! String compare.
+ *
+ *	@param [In] src1
+ *		the first string.
+ *	@param [In] src2
+ *		the second string.
+ *	@return fsl_osal_s32
+ *		return 0 if the string is same otherwise nonezero.
+ */
+
+ OMX_OSAL_API fsl_osal_s32 fsl_osal_strcmp(const fsl_osal_char *src1, const fsl_osal_char *src2);
+
+/*! String compare.
+ *
+ *	@param [In] src1
+ *		the first string.
+ *	@param [In] src2
+ *		the second string.
+ *	@param [In] n
+ *		string size to compare.
+ *	@return fsl_osal_s32
+ *		return 0 if the string is same otherwise nonezero.
+ */
+
+ fsl_osal_s32 fsl_osal_strncmp(const fsl_osal_char *src1, const fsl_osal_char *src2, fsl_osal_s32 n);
+
+ fsl_osal_s32 fsl_osal_strncasecmp(const fsl_osal_char *src1, const fsl_osal_char *src2, fsl_osal_s32 n);
+
+/*! String dump.
+ *
+ *	@param [In] src
+ *		source point for string copy.
+ *	@return dest
+ *		destination point for string copy.
+ *		return destination point.
+ */
+
+ fsl_osal_char *fsl_osal_strdup(const fsl_osal_char *src);
+
+ /*! String length.
+ *
+ *	@param [In] src
+ *		the input string.
+ *	@return fsl_osal_u32
+ *		The length of the input string, not include "\0".
+ */
+
+ OMX_OSAL_API fsl_osal_u32 fsl_osal_strlen(const fsl_osal_char *src);
+
+/*! Change char to integrate.
+ *
+ *	@param [In] src
+ *		the input string.
+ *	@return fsl_osal_s32
+ *		return the value.
+ */
+
+ OMX_OSAL_API fsl_osal_s32 fsl_osal_atoi(const fsl_osal_char *src);
+
+/*! Get envirement parameter.
+ *
+ *	@param [In] name
+ *		envirement name.
+ *	@return fsl_osal_char
+ *		return envirement string.
+ */
+
+ OMX_OSAL_API fsl_osal_char *fsl_osal_getenv_new(const fsl_osal_char *name);
+ 
+/////////////////////////////////////////////////////////////////////////////////////////////
+///	Task/Thread related APIS: synchronization, communication etc
+////////////////////////////////////////////////////////////////////////////////////////////
+
+/*!	OS specific synchronization object */
+typedef fsl_osal_ptr fsl_osal_mutex;
+typedef fsl_osal_ptr fsl_osal_sem;
+
+typedef enum
+{
+    fsl_osal_mutex_normal=0,
+    fsl_osal_mutex_recursive,
+    fsl_osal_mutex_errorcheck,
+    fsl_osal_mutex_default
+}fsl_osal_mutex_type;
+
+/*! Allocates and Initilizes the mutual exclusion object.
+ *
+ *	@param [out] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_UNAVAILABLE if mutex not available
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_mutex_init(fsl_osal_mutex *sync_obj, fsl_osal_mutex_type type);
+
+/*! De-initializes and Releases the mutex object.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@param [out] os_specific_error_code
+ *		Updated with OS specific error code if the API fails. This is valid only if
+ *		the return value is E_FSL_OSAL_SUCCESS.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_mutex_destroy(fsl_osal_mutex sync_obj);
+
+/*! Acquires the lock.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@param [out] os_specific_error_code
+ *		Updated with OS specific error code if the API fails. This is valid
+ *		only if the return value is E_FSL_OSAL_SUCCESS.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_UNAVAILABLE if mutex is locked the maximum number of times
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_mutex_lock(fsl_osal_mutex sync_obj);
+
+/*! Tries to acquire the lock. This is not a blocking call. E_FSL_OSAL_SUCCESS
+ *	indicates that the lock is acquired.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ *		E_FSL_OSAL_BUSY if mutex is already locked
+ *
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_mutex_trylock(fsl_osal_mutex sync_obj);
+
+/*! Releases the lock.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@param [out] os_specific_error_code
+ *		Updated with OS specific error code if the API fails. This is valid
+ *		only if the return value is E_FSL_OSAL_SUCCESS.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDSTATE if the calling task did not currently own the mutex
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_mutex_unlock(fsl_osal_mutex sync_obj);
+
+
+/*! Allocates and Initilizes the semaphore object.
+ *
+ *	@param [out] sem_obj
+ *		The semaphore object
+ *	@param [in] pshared
+ *		This argument indicates whether semaphore is shared across
+ *		processes.
+ *	@param [in] value
+ *		The value indicates the initial value of the
+ *		count associated with the semaphore.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_UNAVAILABLE if semaphore not available
+ *		E_FSL_OSAL_FAILURE if semaphore initialisation is unsuccessful
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sem_init(fsl_osal_sem *sem_obj,
+										  fsl_osal_s32 pshared,
+										  fsl_osal_u32 value);
+
+/*! This call suspends the calling thread until the
+ *	semaphore pointed to  by sem_obj has non-zero count.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sem_wait(fsl_osal_sem sem_obj);
+
+/*! The fsl_osal_sem_trywait call is a non-blocking variant of fsl_osal_sem_wait.
+ * 	If the semaphore pointed to by sem_obj has non-zero count, the count is
+ *	atomically decreased and fsl_osal_sem_trywait immediately returns 0.
+ *	If the semaphore count is zero, fsl_osal_sem_trywait immediately returns with error.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_FAILURE
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sem_trywait(fsl_osal_sem sem_obj);
+
+
+/*! The fsl_osal_sem_post method atomically increases the count of the
+ *	semaphore pointed to by sem_obj.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_INVALIDPARAM
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sem_post(fsl_osal_sem sem_obj);
+
+
+/*! The fsl_osal_sem_getvalue call stores  in  the  location
+ *	pointed to by sval the current count of the semaphore pointed to by sem_obj.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_FAILURE
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sem_getvalue(fsl_osal_sem sem_obj,
+											  fsl_osal_s32 *sval);
+
+/*! The fsl_osal_sem_destroy method destroys the semaphore object,
+ *	pointed to by sem_obj.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_FAILURE
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sem_destroy(fsl_osal_sem sem_obj);
+
+#ifndef __WINCE
+typedef fsl_osal_ptr (*thread_func)(fsl_osal_ptr);
+#else
+typedef fsl_osal_u32 (*thread_func)(fsl_osal_ptr);
+#endif
+
+/*! Creates a thread.
+ *
+ *	@param [out] thread
+ *		Identifier of newly created thread.
+ *	@param [in] start_routine
+ *		Function to be run in the new thread.
+ *	@param [in] arg
+ *		Arguments passed to the start_routine function.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if thread creation is failure
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_thread_create(fsl_osal_ptr *thread,
+												fsl_osal_ptr *attr,
+												thread_func func,
+												void *arg);
+
+/*! De-initializes and Releases the mutex object.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_thread_destroy(fsl_osal_ptr thread);
+
+/*! Get the current task/thread id.
+ *  *
+ *      @param [out] thread id
+ *      @return efsl_osal_return_type_t
+ *              E_FSL_OSAL_SUCCESS if success
+ *              E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_thread_self(fsl_osal_u32 *id);
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///	Input/Output related APIs
+/////////////////////////////////////////////////////////////////////////////////////////////
+/*! Opens a file.
+ *
+ *	@param [in] path
+ *		The location of file
+ *	@param [in] mode
+ *		Specifies whether read only, read write etc
+ *	@param [out] file_handle
+ *		Handle of the opened file
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ *		E_FSL_OSAL_INVALIDMODE if mode is invalid
+ *		E_FSL_OSAL_UNAVAILABLE if the file is not found
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fopen(const fsl_osal_char *path,
+									   const fsl_osal_char *mode,
+									   fsl_osal_file *file_handle);
+
+/*! Closes the given file.
+ *
+ *	@param [in] file_handle
+ *		Handle of the opened file
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fclose(fsl_osal_file file_handle);
+
+
+/*! Read from a file.
+ *
+ *	@param [out] buffer
+ *		The read operation will fill the data in this buffer
+ *	@param [in] size
+ *		Size of data to read.
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] actual_size
+ *		The actual size read.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ *		E_FSL_OSAL_EOF end of file reached
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fread(fsl_osal_ptr buffer,
+									   fsl_osal_s32 size,
+									   fsl_osal_file file_handle,
+									   fsl_osal_s32 *actual_size);
+
+/*! Writes the given buffer to the specified file.
+ *
+ *	@param [in] buffer
+ *		Data to write
+ *	@param [in] size
+ *		Size of data to write.
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] actual_size
+ *		The actual size writen.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ *		E_FSL_OSAL_INVALIDMODE if mode is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fwrite(const fsl_osal_ptr buffer,
+									    fsl_osal_s32 size,
+									    fsl_osal_file file_handle,
+									    fsl_osal_s32 *actual_size);
+
+
+/*! The fsl_osal_fseek function sets the file position indicator for the file
+ *  referred by file_handle.  The new position is obtained by adding offset bytes
+ *	to the position specified by whence.
+ *
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [in] offset
+ *		offset in number of bytes.
+ *	@param [in] whence
+ *		Reefence position.   .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid or if the file is not seakable.
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fseek(fsl_osal_file file_handle,
+									   fsl_osal_s64 offset,
+									   efsl_osal_seek_pos_t whence);
+
+/*! The fsl_osal_ftell function gets the current file position indicator for the file.
+ *
+ *	@param [in] file_handle
+ *		The file handle
+ *	@param [out] offset
+ *		The current offset
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE in case of error.
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_ftell(fsl_osal_file file_handle,
+									   fsl_osal_s64 *offset);
+
+/*! The fsl_osal_fflush function forces a write of buffered data.
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fflush(fsl_osal_file file_handle);
+
+
+/*! The fsl_osal_fdelete function removes the specified file
+ *
+ *	@param [in] file_name
+ *		The file name .  .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fdelete(const char *file_name);
+
+
+/*! The fsl_osal_fsize function gets the size of the specified file
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] actual_size
+ *		The file size .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fsize(fsl_osal_file file_handle, fsl_osal_s64 *file_size);
+
+
+/*! The fsl_osal_fexist function checks whether the specified file exists
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] result
+ *		The file exist or not .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fexist(const char *file_name, fsl_osal_s32 *result);
+
+
+/*! The fsl_osal_fsize function gets the size of the specified file
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] actual_size
+ *		The file size .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fspace(const char *path_name, fsl_osal_u64 *avail_space);
+
+
+/*! The fsl_osal_mkdir API creates a directory named pathname
+ *
+ *	@param [in] pathname
+ *		 directory name .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_NOTSUPPORTED if directory creation is not supported/permitted
+ *		E_FSL_OSAL_UNAVAILABLE if resources requred for creation are not available
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_mkdir(const char *pathname);
+
+
+/*! The fsl_osal_rmdir API removes a directory specified by pathname
+ *
+ *	@param [in] pathname
+ *		 directory name .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_NOTSUPPORTED if directory creation is not supported/permitted
+ *		E_FSL_OSAL_UNAVAILABLE if resources requred for creation are not available
+ */
+
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_rmdir(const char *pathname);
+
+/*! The fsl_osal_opendir API -  This API opens a directory and returns the directory handle. This handle should be used for other directory related APIs.
+ *
+ *	@param [in] pathname
+ *		 directory name .
+ *	@param [out] dir_handle
+ *		 directory handle.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDMODE if directory open modes are invalid
+ *		E_FSL_OSAL_UNAVAILABLE if resources requred for creation are not available
+ *		E_FSL_OSAL_INVALIDSTATE if file system not initialized
+ *		E_FSL_OSAL_INVALIDPARAM if parameters are invalid
+ */
+
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_opendir(const char *pathname,fsl_osal_ptr *dir_handle);
+
+
+/*! The fsl_osal_closedir API -  This API closes the specified directory
+ *
+ *	@param [in] dir_handle
+ *		 directory handle.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDSTATE if file system not initialized
+ *		E_FSL_OSAL_INVALIDPARAM if parameters are invalid
+ */
+
+
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_closedir(fsl_osal_ptr dir_handle);
+
+/*! The fsl_osal_readdir API -  This API reads the open directory and writes the list of subdirectories in an array
+ *
+ *	@param [in] dir_handle
+ *		 directory handle.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDSTATE if file system not initialized
+ *
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_readdir(fsl_osal_ptr dir_handle);
+
+typedef struct {
+    fsl_osal_u32 sec;
+    fsl_osal_u32 usec;
+}fsl_osal_timeval;
+
+/*! Get system time.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created time.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if thread creation is failure
+ */
+efsl_osal_return_type_t fsl_osal_systime(fsl_osal_timeval *time);
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+///	Sleep API
+/////////////////////////////////////////////////////////////////////////////////////////////
+/*! Sleep the current task/thread.
+ *
+ *	@param [in] delay
+ *		Delay in milliseconds.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_sleep(fsl_osal_u32 delay);
+
+/*! Creates a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if thread creation is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_create(fsl_osal_ptr *cond);
+
+/*! Destroy a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if condition variable destroy is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_destroy(fsl_osal_ptr cond);
+
+/*! Timed wait a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@param [in] time
+ *		Wait time in microsecond.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if timed wait condition is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_timedwait(fsl_osal_ptr cond, fsl_osal_s32 time);
+
+/*! Signal a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if broadcast condition is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_signal(fsl_osal_ptr cond);
+
+/*! Broadcase a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if broadcast condition is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_broadcast(fsl_osal_ptr cond);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif 
+/* File EOF */
+
+
+
diff --git a/OSAL/ghdr/fsl_osal_types.h b/OSAL/ghdr/fsl_osal_types.h
new file mode 100755
index 0000000..a28ca7a
--- /dev/null
+++ b/OSAL/ghdr/fsl_osal_types.h
@@ -0,0 +1,73 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*!
+ * @file fsl_osal_types.h
+ *
+ * @brief Defines data types
+ *
+ * @ingroup osal
+ */
+
+#ifndef FSL_OSAL_TYPES_H_
+#define FSL_OSAL_TYPES_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*! fsl_osal_u8 8 bit unsigned data type */
+typedef unsigned char fsl_osal_u8;
+
+/*! fsl_osal_s8 8 bit signed data type */
+typedef signed char fsl_osal_s8;
+
+/*! fsl_osal_u16 is 16 bit unsigned data type */
+typedef unsigned short fsl_osal_u16;
+
+/*! fsl_osal_s16 is 16 bit signed data type*/
+typedef signed short fsl_osal_s16;
+
+/*! fsl_osal_u32 is 32 bit unsigned data type */
+typedef unsigned long fsl_osal_u32;
+
+/*! fsl_osal_s32 is 32 bit signed data type */
+typedef signed long fsl_osal_s32;
+
+/*! fsl_osal_u64 is 64 bit unsigned data type */
+typedef unsigned long long fsl_osal_u64;
+
+/*! fsl_osal_s64 is 64 bit signed data type */
+typedef signed long long fsl_osal_s64;
+
+/*! fsl_osal_char is an 8 bit data type */
+typedef char fsl_osal_char;
+
+/*! fsl_osal_float is an 32 bit data type */
+typedef float fsl_osal_float;
+
+/*! fsl generic pointer */
+typedef void* fsl_osal_ptr;
+
+/*! fsl_osal_void  */
+typedef void fsl_osal_void;
+
+/*!	boolean type*/
+typedef enum efsl_osal_bool
+{
+	E_FSL_OSAL_FALSE = 0,
+	E_FSL_OSAL_TRUE
+}efsl_osal_bool;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OSAL/linux/Android.mk b/OSAL/linux/Android.mk
new file mode 100755
index 0000000..545404d
--- /dev/null
+++ b/OSAL/linux/Android.mk
@@ -0,0 +1,31 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+        	fsl_osal_linux_file.cpp \
+		fsl_osal_linux_mem.cpp \
+		fsl_osal_linux_string.cpp \
+		fsl_osal_linux_mutex.cpp \
+		fsl_osal_linux_sem.cpp \
+		fsl_osal_linux_thread.cpp \
+		fsl_osal_linux_time.cpp \
+		fsl_osal_linux_condition.cpp \
+		../logger/Log.cpp
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+ 
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) 
+
+LOCAL_SHARED_LIBRARIES := libutils libc liblog
+
+LOCAL_PRELINK_MODULE := false
+	
+LOCAL_MODULE:= lib_omx_osal_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/OSAL/linux/Makefile b/OSAL/linux/Makefile
new file mode 100755
index 0000000..5df833d
--- /dev/null
+++ b/OSAL/linux/Makefile
@@ -0,0 +1,54 @@
+#####################################################################################
+#
+#   Copyright (c) 2009, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+# Set the root directory
+OMX_ROOT_DIR=../..
+
+# Set the BUILD information
+include $(OMX_ROOT_DIR)/Makefile.defines
+
+OSAL_SO_NAME= lib$(OSAL_LIB_NAME).so
+
+SOURCE_FILES = $(SRC_DIR)/fsl_osal_linux_file.cpp \
+	$(SRC_DIR)/fsl_osal_linux_mem.cpp \
+	$(SRC_DIR)/fsl_osal_linux_string.cpp \
+	$(SRC_DIR)/fsl_osal_linux_mutex.cpp \
+	$(SRC_DIR)/fsl_osal_linux_sem.cpp \
+	$(SRC_DIR)/fsl_osal_linux_thread.cpp \
+	$(SRC_DIR)/fsl_osal_linux_time.cpp \
+	$(SRC_DIR)/fsl_osal_linux_condition.cpp \
+	$(SRC_DIR)/../logger/Log.cpp
+
+OBJECTS = $(SOURCE_FILES:.cpp=.o)
+
+all: $(OSAL_SO_NAME)
+
+$(OSAL_SO_NAME):$(OBJECTS)
+	$(CXX) -shared -Wl,-soname,$(OSAL_SO_NAME) -o $(OSAL_SO_NAME) $(OBJECTS)  
+
+	mv $(OSAL_SO_NAME) $(RELEASE_LIB_DIR)/$(OSAL_SO_NAME)
+	@echo "-----------------------------------------------------------------------------------"
+
+.cpp.o:
+	$(CXX) $(CXXFLAGS) -o $@ -c $<
+
+clean:
+	@echo "cleaning ..."
+	rm  -f $(SRC_DIR)/*.o
+	rm  -f $(SRC_DIR)/../logger/*.o
+	rm  -f $(RELEASE_LIB_DIR)/$(OSAL_SO_NAME)
+			
+
+
diff --git a/OSAL/linux/fsl_osal_linux_condition.cpp b/OSAL/linux/fsl_osal_linux_condition.cpp
new file mode 100755
index 0000000..6aae5f2
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_condition.cpp
@@ -0,0 +1,174 @@
+
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_condition.c
+ *
+ * @brief Defines the OS Abstraction layer APIs for condition variable in Linux
+ *
+ * @ingroup osal
+ */
+
+#include <fsl_osal.h>
+#include <pthread.h>
+#include <time.h>
+#include <sys/time.h>
+#include <errno.h>
+#include "Log.h"
+
+typedef struct _CONDITION {
+    pthread_cond_t cv;
+    pthread_mutex_t mp;
+}CONDITION;
+
+/*! Creates a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if thread creation is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_create(fsl_osal_ptr *cond)
+{
+    fsl_osal_s32 ret = 0;
+    CONDITION *pCond = NULL;
+
+    pCond = (CONDITION*)fsl_osal_malloc_new(sizeof(CONDITION));
+    if(pCond == NULL) {
+        LOG_ERROR("Allocate condition variable failed.\n");
+        return E_FSL_OSAL_UNAVAILABLE;
+    }
+
+    ret = pthread_cond_init(&(pCond->cv), NULL);
+    if(ret != 0) {
+        printf("Creat condition variable failed.\n");
+        return E_FSL_OSAL_FAILURE;
+    }
+
+    ret = pthread_mutex_init(&(pCond->mp), NULL);
+    if(ret != 0) {
+        printf("Creat mutex for condition variable failed.\n");
+        return E_FSL_OSAL_FAILURE;
+    }
+
+    *cond = pCond;
+
+    return E_FSL_OSAL_SUCCESS;
+}
+
+/*! Destroy a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if condition variable destroy is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_destroy(fsl_osal_ptr cond)
+{
+    fsl_osal_s32 ret = 0;
+    CONDITION *pCond = NULL;
+
+    pCond = (CONDITION*)cond;
+    ret = pthread_mutex_destroy(&pCond->mp);
+    if(ret != 0) {
+        LOG_ERROR("Destroy mutex for condition variable failed.\n");
+        return E_FSL_OSAL_FAILURE;
+    }
+
+    ret = pthread_cond_destroy(&pCond->cv);
+    if(ret != 0) {
+        LOG_ERROR("Destroy condition variable failed.\n");
+        return E_FSL_OSAL_FAILURE;
+    }
+
+ 	fsl_osal_dealloc(pCond);
+
+    return E_FSL_OSAL_SUCCESS;
+}
+
+/*! Timed wait a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@param [in] time
+ *		Wait time in microsecond.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if timed wait condition is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_timedwait(fsl_osal_ptr cond, fsl_osal_s32 time)
+{
+    CONDITION *pCond = NULL;
+    struct timespec to;
+    fsl_osal_timeval tv;
+
+    pCond = (CONDITION*)cond;
+    pthread_mutex_lock(&pCond->mp);
+
+    fsl_osal_systime(&tv);
+
+    fsl_osal_s32 in = 0; 
+    in = (fsl_osal_s64)(tv.usec + time) / 1000000; 
+    tv.sec += in; 
+    tv.usec = (fsl_osal_s64)(tv.usec + time) - (in * 1000000); 
+
+    to.tv_sec = tv.sec;
+    to.tv_nsec = tv.usec * 1000;
+
+    pthread_cond_timedwait(&pCond->cv, &pCond->mp, &to);
+    pthread_mutex_unlock(&pCond->mp);
+
+    return E_FSL_OSAL_SUCCESS;
+}
+
+/*! Signal a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if broadcast condition is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_signal(fsl_osal_ptr cond)
+{
+    CONDITION *pCond = NULL;
+
+    pCond = (CONDITION*)cond;
+    pthread_mutex_lock(&pCond->mp);
+    pthread_cond_signal(&pCond->cv);
+    pthread_mutex_unlock(&pCond->mp);
+
+    return E_FSL_OSAL_SUCCESS;
+}
+
+/*! Broadcase a condition.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created condition.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if broadcast condition is failure
+ */
+efsl_osal_return_type_t fsl_osal_cond_broadcast(fsl_osal_ptr cond)
+{
+    CONDITION *pCond = NULL;
+
+    pCond = (CONDITION*)cond;
+    pthread_mutex_lock(&pCond->mp);
+    pthread_cond_broadcast(&pCond->cv);
+    pthread_mutex_unlock(&pCond->mp);
+
+    return E_FSL_OSAL_SUCCESS;
+}
+
+
+
diff --git a/OSAL/linux/fsl_osal_linux_file.cpp b/OSAL/linux/fsl_osal_linux_file.cpp
new file mode 100755
index 0000000..02599b8
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_file.cpp
@@ -0,0 +1,964 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_file.h
+ *
+ * @brief Defines the OS Abstraction layer APIs for file handling in Linux
+ *
+ * @ingroup osal
+ */
+
+#ifdef ANDROID_BUILD
+
+//#define USE_LIBC_IF
+
+ #include <string.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <sys/stat.h>
+ #include <sys/vfs.h>
+#ifndef USE_LIBC_IF
+ #include <fcntl.h>
+#endif
+ #include "Log.h"
+ #include "fsl_osal.h"
+
+//#define LOG_DEBUG printf
+/*! Opens a file.
+ *
+ *	@param [in] path
+ *		The location of file
+ *	@param [in] mode
+ *		Specifies whether read only, read write etc
+ *	@param [out] file_handle
+ *		Handle of the opened file
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_INVALIDMODE if mode is invalid
+ *		E_FSL_OSAL_UNAVAILABLE if the file is not found
+ */
+efsl_osal_return_type_t fsl_osal_fopen(const fsl_osal_char *path,
+									 const fsl_osal_char *mode,
+									 fsl_osal_file *file_handle)
+ {
+#ifdef USE_LIBC_IF
+ 	FILE *fp;
+ 	fp = fopen(path, mode);
+ 	if(fp == NULL)
+ 	{
+ 		//LOG_ERROR("\n Error in opening the file.");
+ 		return E_FSL_OSAL_UNAVAILABLE;
+ 	}
+ 	*file_handle = (void *)fp;
+#else
+        int fd;
+        fd = open(path, O_LARGEFILE | O_RDONLY);
+        if(fd < 0)
+ 	{
+ 		LOG_DEBUG("\n Error in opening the file.");
+ 		return E_FSL_OSAL_UNAVAILABLE;
+ 	}
+        *file_handle = (void *)fd;
+#endif
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Closes the given file.
+ *
+ *	@param [in] file_handle
+ *		Handle of the opened file
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_fclose(fsl_osal_file file_handle)
+ {
+#ifdef USE_LIBC_IF
+ 	FILE *fp;
+ 	if(file_handle == NULL)
+ 	{
+ 		LOG_ERROR("\n NULL pointer.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	fp = (FILE *)file_handle;
+ 	clearerr(fp);
+ 	if(fclose(fp) != 0)
+ 	{
+		LOG_ERROR("\n Error in closing file.");
+		return E_FSL_OSAL_UNKNOWN;
+	}
+#else
+        int mFd = (int)file_handle;
+        if (mFd >= 0) {
+            close(mFd);
+        }
+#endif
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Read from a file.
+ *
+ *	@param [out] buffer
+ *		The read operation will fill the data in this buffer
+ *	@param [in] size
+ *		Size of data to read.
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] actual_size
+ *		The actual size read.
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_EOF end of file reached
+ *		E_FSL_OSAL_FAILURE in case of error.
+ */
+efsl_osal_return_type_t fsl_osal_fread(fsl_osal_ptr buffer,
+									 fsl_osal_s32 size,
+									 fsl_osal_file file_handle,
+									 fsl_osal_s32 *actual_size)
+ {
+#ifdef USE_LIBC_IF
+ 	FILE *fp;
+
+ 	if(file_handle == NULL)
+ 	{
+ 		LOG_ERROR("\n NULL pointer.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	fp = (FILE *)file_handle;
+ 	clearerr(fp);
+  	
+ 	*actual_size = fread(buffer,1,size,fp);
+
+	if(feof(fp) != 0)
+ 	{
+		LOG_DEBUG("\n End of file reached.");
+		return E_FSL_OSAL_EOF;
+	}
+	
+ 	if(ferror(fp) != 0)
+ 	{
+		LOG_ERROR("\n Error in reading from file.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+#else
+        int ret;
+        int mFd = (int)file_handle;
+
+ 	if(mFd < 0 )
+ 	{
+ 		LOG_ERROR("\n Invalid fd.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+        ret = ::read(mFd, (void *)buffer, size);
+        if(ret < 0)
+ 	{
+		LOG_ERROR("\n Error in reading from file.");
+		return E_FSL_OSAL_FAILURE;
+	}
+
+        *actual_size = ret;
+#endif
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Writes the given buffer to the specified file.
+ *
+ *	@param [in] buffer
+ *		Data to write
+ *	@param [in] size
+ *		Size of data to write.
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] actual_size
+ *		The actual size writen.
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_INVALIDMODE if mode is invalid
+ *		E_FSL_OSAL_FAILURE in case of error.
+ */
+efsl_osal_return_type_t fsl_osal_fwrite(const fsl_osal_ptr buffer,
+									  fsl_osal_s32 size,
+									  fsl_osal_file file_handle,
+									  fsl_osal_s32 *actual_size)
+ {
+#ifdef USE_LIBC_IF
+ 	FILE *fp;
+
+ 	if(file_handle == NULL)
+ 	{
+ 		LOG_ERROR("\n NULL pointer.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	fp = (FILE*)file_handle;
+ 	clearerr(fp);
+ 	*actual_size = fwrite(buffer ,1, size, fp);
+ 	if(ferror(fp) != 0)
+ 	{
+		LOG_ERROR("\n Error in closing file.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	fflush(fp); 
+#else
+        int ret;
+        int mFd = (int)file_handle;
+ 	if(mFd < 0 )
+ 	{
+ 		LOG_ERROR("\n Invalid fd.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	ret = ::write(mFd, buffer, size);
+        if(ret < 0)
+ 	{
+		LOG_ERROR("\n Error in reading from file.");
+		return E_FSL_OSAL_FAILURE;
+	}
+
+        *actual_size = ret;
+#endif
+
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! The fsl_osal_fseek function sets the file position indicator for the file
+ *  referred by file_handle.  The new position is obtained by adding offset bytes
+ *	to the position specified by whence.
+ *
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [in] offset
+ *		offset in number of bytes.
+ *	@param [in] whence
+ *		Reefence position.   .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid or if the file is not seakable.
+ *		E_FSL_OSAL_FAILURE in case of error.
+ */
+
+efsl_osal_return_type_t fsl_osal_fseek(fsl_osal_file file_handle,
+									   fsl_osal_s64 offset,
+									   efsl_osal_seek_pos_t whence)
+{ 
+#ifdef USE_LIBC_IF
+	if(file_handle == NULL)
+	{
+		LOG_ERROR(" Error.Passing NULL pointer.\n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	if (whence == E_FSL_OSAL_SEEK_SET)
+	{
+		if(fseeko((FILE *)file_handle, offset, SEEK_SET) != 0)
+		{
+			LOG_ERROR(" Error in fseek.\n");
+			return E_FSL_OSAL_INVALIDPARAM;
+		}
+	}
+	else if(whence == E_FSL_OSAL_SEEK_END)
+	{
+		if(fseeko((FILE *)file_handle, offset, SEEK_END) != 0)
+		{
+			LOG_ERROR(" Error in fseek.\n");
+			return E_FSL_OSAL_INVALIDPARAM;
+		}
+	}
+	else if(whence == E_FSL_OSAL_SEEK_CUR)
+	{
+		if(fseeko((FILE *)file_handle, offset, SEEK_CUR) != 0)
+		{
+			LOG_ERROR(" Error in fseek.\n");
+			return E_FSL_OSAL_INVALIDPARAM;
+		}
+	}
+	else
+	{
+		LOG_ERROR(" Error. Invalid seek type.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+#else
+        int mFd = (int)file_handle;
+        if(mFd < 0)
+	{
+ 		LOG_ERROR("\n Invalid fd.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	if (whence == E_FSL_OSAL_SEEK_SET)
+	{
+                off64_t result = lseek64(mFd, offset, SEEK_SET);
+                if (result == -1) {
+                    LOG_ERROR("seek to %lld failed", offset);
+                    return E_FSL_OSAL_FAILURE;
+                }
+	}
+	else if(whence == E_FSL_OSAL_SEEK_END)
+	{
+                off64_t result = lseek64(mFd, offset, SEEK_END);
+                if (result == -1) {
+                    LOG_ERROR("seek to %lld failed", offset);
+                    return E_FSL_OSAL_FAILURE;
+                }
+	}
+	else if(whence == E_FSL_OSAL_SEEK_CUR)
+	{
+                off64_t result = lseek64(mFd, offset, SEEK_CUR);
+                if (result == -1) {
+                    LOG_ERROR("seek to %lld failed", offset);
+                    return E_FSL_OSAL_FAILURE;
+                }
+	}
+	else
+	{
+		LOG_ERROR(" Error. Invalid seek type.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+#endif
+
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_ftell function gets the current file position indicator for the file.
+ *
+ *	@param [in] file_handle
+ *		The file handle
+ *	@param [out] offset
+ *		The current offset
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE in case of error.
+ */
+efsl_osal_return_type_t fsl_osal_ftell(fsl_osal_file file_handle,
+									   fsl_osal_s64 *offset)
+{
+#ifdef USE_LIBC_IF
+	fsl_osal_s32 current_offset = 0;
+	current_offset = ftello((FILE *)file_handle);
+	if(current_offset == -1)
+		return E_FSL_OSAL_FAILURE;
+	*offset = current_offset;
+#else
+        int mFd = (int)file_handle;
+        if(mFd < 0)
+	{
+            LOG_ERROR("\n Invalid fd.");
+            return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+        *offset = lseek64(mFd, 0, SEEK_CUR);
+        if (*offset == -1) {
+            LOG_ERROR("ftell failed");
+            return E_FSL_OSAL_FAILURE;
+        }
+
+#endif
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_fflush function forces a write of buffered data.
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_fflush(fsl_osal_file file_handle)
+{
+#ifdef USE_LIBC_IF
+	if(file_handle == NULL)
+	{
+		LOG_ERROR(" Error.Passing NULL pointer.\n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+	if (fflush((FILE *)file_handle) != 0)
+	{
+		LOG_ERROR(" Error while flushing. \n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+#else
+
+        int mFd = (int)file_handle;
+        if (mFd < 0) {
+            LOG_ERROR("\n Invalid fd.");
+            return E_FSL_OSAL_INVALIDPARAM;
+        }
+        fsync(mFd);
+#endif
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_fsize function gets the size of the specified file
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] actual_size
+ *		The file size .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ *		E_FSL_OSAL_FAILURE if operation fails
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fsize(fsl_osal_file file_handle, fsl_osal_s64 *file_size)
+{
+        struct stat st;
+
+#ifdef USE_LIBC_IF
+	if (fstat(fileno((FILE *)file_handle), &st) != 0)
+		return E_FSL_OSAL_FAILURE;
+	
+#else
+        int mFd = (int)file_handle;
+        if (mFd < 0) {
+            LOG_ERROR("\n Invalid fd.");
+            return E_FSL_OSAL_INVALIDPARAM;
+        }
+
+	if (fstat(mFd, &st) != 0)
+            return E_FSL_OSAL_FAILURE;
+#endif
+	*file_size = st.st_size;
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_fexist function checks whether the specified file exists
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] result
+ *		The file exist or not .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fexist(const char *file_name, fsl_osal_s32 *result)
+{
+	struct stat st;
+	
+	*result = (stat(file_name,&st) == 0);
+
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_fsize function gets the size of the specified file
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] actual_size
+ *		The file size .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fspace(const char *path_name, fsl_osal_u64 *avail_space)
+{
+	struct statfs buf;
+	
+	if(statfs(path_name, &buf) < 0)
+		return E_FSL_OSAL_FAILURE;
+	
+	*avail_space = (long long)buf.f_bsize * buf.f_bavail;
+	
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_feof function  tests the end-of-file indicator
+ *	for the stream pointed to by stream
+ *
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] result
+ *		The return value of feof call.
+ *
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ *		E_FSL_OSAL_FAILURE if operation fails
+ */
+efsl_osal_return_type_t fsl_osal_feof(fsl_osal_file file_handle, fsl_osal_s32 *result)
+{
+#ifdef USE_LIBC_IF
+	if(file_handle == NULL)
+	{
+		LOG_ERROR(" Error.Passing NULL pointer.\n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+	*result = feof((FILE *)file_handle);
+#else
+        int ret;
+        fsl_osal_s64 pos, size;
+        int mFd = (int)file_handle;
+
+        if (mFd < 0) {
+            LOG_ERROR("\n Invalid fd.");
+            return E_FSL_OSAL_INVALIDPARAM;
+        }
+
+
+        if(fsl_osal_fsize(file_handle, &size)< 0){
+            return E_FSL_OSAL_FAILURE;
+        }
+        
+        if(fsl_osal_ftell(file_handle, &pos)< 0){
+            return E_FSL_OSAL_FAILURE;
+        }
+        
+        if(pos >= size)
+            *result = 1;
+        else
+            *result = 0;
+#endif
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_mkdir API creates a directory named pathname
+ *
+ *	@param [in] pathname
+ *		 directory name .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_NOTSUPPORTED if directory creation is not supported/permitted
+ *		E_FSL_OSAL_UNAVAILABLE if resources requred for creation are not available
+ */
+efsl_osal_return_type_t fsl_osal_mkdir(const char *pathname)
+{
+	FILE *fp;
+	char cmd[256];
+
+	fp = fopen(pathname, "r");
+	if (fp == 0)
+	{
+        strcpy(cmd, "mkdir -p ");
+        strcat(cmd, pathname);
+        return (efsl_osal_return_type_t)system(cmd);
+	}
+	else
+		fclose(fp);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+efsl_osal_return_type_t fsl_osal_init()
+{
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! De-Initialize the OSAL system
+ *
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+efsl_osal_return_type_t fsl_osal_deinit()
+{
+	return E_FSL_OSAL_SUCCESS;
+}
+
+#else
+
+#define __USE_LARGEFILE64
+#define _LARGEFILE_SOURCE
+#define _LARGEFILE64_SOURCE
+
+ #include <string.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <sys/stat.h>
+ #include <sys/vfs.h>
+ #include "Log.h"
+ #include "fsl_osal.h"
+
+/*! Opens a file.
+ *
+ *	@param [in] path
+ *		The location of file
+ *	@param [in] mode
+ *		Specifies whether read only, read write etc
+ *	@param [out] file_handle
+ *		Handle of the opened file
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_INVALIDMODE if mode is invalid
+ *		E_FSL_OSAL_UNAVAILABLE if the file is not found
+ */
+efsl_osal_return_type_t fsl_osal_fopen(const fsl_osal_char *path,
+									 const fsl_osal_char *mode,
+									 fsl_osal_file *file_handle)
+ {
+ 	FILE *fp;
+ 	fp = fopen64(path, mode);
+ 	if(fp == NULL)
+ 	{
+ 		//LOG_ERROR("\n Error in opening the file %s.", path);
+ 		return E_FSL_OSAL_UNAVAILABLE;
+ 	}
+ 	*file_handle = (void *)fp;
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Closes the given file.
+ *
+ *	@param [in] file_handle
+ *		Handle of the opened file
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_fclose(fsl_osal_file file_handle)
+ {
+ 	FILE *fp;
+ 	if(file_handle == NULL)
+ 	{
+ 		LOG_ERROR("\n NULL pointer.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	fp = (FILE *)file_handle;
+ 	clearerr(fp);
+ 	if(fclose(fp) != 0)
+ 	{
+		LOG_ERROR("\n Error in closing file.");
+		return E_FSL_OSAL_UNKNOWN;
+	}
+
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Read from a file.
+ *
+ *	@param [out] buffer
+ *		The read operation will fill the data in this buffer
+ *	@param [in] size
+ *		Size of data to read.
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] actual_size
+ *		The actual size read.
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_EOF end of file reached
+ */
+efsl_osal_return_type_t fsl_osal_fread(fsl_osal_ptr buffer,
+									 fsl_osal_s32 size,
+									 fsl_osal_file file_handle,
+									 fsl_osal_s32 *actual_size)
+ {
+ 	FILE *fp;
+
+ 	if(file_handle == NULL)
+ 	{
+ 		LOG_ERROR("\n NULL pointer.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	fp = (FILE *)file_handle;
+ 	clearerr(fp);
+  	
+ 	*actual_size = fread(buffer,1,size,fp);
+
+	if(feof(fp) != 0)
+ 	{
+		LOG_DEBUG("\n End of file reached.");
+		return E_FSL_OSAL_EOF;
+	}
+	
+ 	if(ferror(fp) != 0)
+ 	{
+		LOG_ERROR("\n Error in reading from file.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Writes the given buffer to the specified file.
+ *
+ *	@param [in] buffer
+ *		Data to write
+ *	@param [in] size
+ *		Size of data to write.
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] actual_size
+ *		The actual size writen.
+ *	@return efsl_osal_return_type
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_INVALIDMODE if mode is invalid
+ */
+efsl_osal_return_type_t fsl_osal_fwrite(const fsl_osal_ptr buffer,
+									  fsl_osal_s32 size,
+									  fsl_osal_file file_handle,
+									  fsl_osal_s32 *actual_size)
+ {
+ 	FILE *fp;
+
+ 	if(file_handle == NULL)
+ 	{
+ 		LOG_ERROR("\n NULL pointer.");
+ 		return E_FSL_OSAL_INVALIDPARAM;
+ 	}
+ 	fp = (FILE*)file_handle;
+ 	clearerr(fp);
+ 	*actual_size = fwrite(buffer ,1, size, fp);
+	LOG_DEBUG("actual_size: %d input size: %d\n", *actual_size, size);
+ 	if(ferror(fp) != 0)
+ 	{
+		LOG_ERROR("\n Error in closing file.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	fflush(fp); 
+
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! The fsl_osal_fseek function sets the file position indicator for the file
+ *  referred by file_handle.  The new position is obtained by adding offset bytes
+ *	to the position specified by whence.
+ *
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [in] offset
+ *		offset in number of bytes.
+ *	@param [in] whence
+ *		Reefence position.   .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid or if the file is not seakable.
+ */
+
+efsl_osal_return_type_t fsl_osal_fseek(fsl_osal_file file_handle,
+									   fsl_osal_s64 offset,
+									   efsl_osal_seek_pos_t whence)
+{ 
+	if(file_handle == NULL)
+	{
+		LOG_ERROR(" Error.Passing NULL pointer.\n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	if (whence == E_FSL_OSAL_SEEK_SET)
+	{
+		if(fseeko64((FILE *)file_handle, offset, SEEK_SET) != 0)
+		{
+			LOG_ERROR(" Error in fseek.\n");
+			return E_FSL_OSAL_INVALIDPARAM;
+		}
+	}
+	else if(whence == E_FSL_OSAL_SEEK_END)
+	{
+		if(fseeko64((FILE *)file_handle, offset, SEEK_END) != 0)
+		{
+			LOG_ERROR(" Error in fseek.\n");
+			return E_FSL_OSAL_INVALIDPARAM;
+		}
+	}
+	else if(whence == E_FSL_OSAL_SEEK_CUR)
+	{
+		if(fseeko64((FILE *)file_handle, offset, SEEK_CUR) != 0)
+		{
+			LOG_ERROR(" Error in fseek.\n");
+			return E_FSL_OSAL_INVALIDPARAM;
+		}
+	}
+	else
+	{
+		LOG_ERROR(" Error. Invalid seek type.");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_ftell function gets the current file position indicator for the file.
+ *
+ *	@param [in] file_handle
+ *		The file handle
+ *	@param [out] offset
+ *		The current offset
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE in case of error.
+ */
+efsl_osal_return_type_t fsl_osal_ftell(fsl_osal_file file_handle,
+									   fsl_osal_s64 *offset)
+{
+	fsl_osal_s64 current_offset = 0;
+	current_offset = ftello64((FILE *)file_handle);
+	if(current_offset == -1)
+		return E_FSL_OSAL_FAILURE;
+	*offset = current_offset;
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_fflush function forces a write of buffered data.
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_fflush(fsl_osal_file file_handle)
+{
+	if(file_handle == NULL)
+	{
+		LOG_ERROR(" Error.Passing NULL pointer.\n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+	if (fflush((FILE *)file_handle) != 0)
+	{
+		LOG_ERROR(" Error while flushing. \n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_fsize function gets the size of the specified file
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] actual_size
+ *		The file size .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fsize(fsl_osal_file file_handle, fsl_osal_s64 *file_size)
+{
+	struct stat64 st = {0};
+	
+	if (fstat64(fileno((FILE *)file_handle), &st) != 0)
+		return E_FSL_OSAL_FAILURE;
+	
+	*file_size = st.st_size;
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_fexist function checks whether the specified file exists
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] result
+ *		The file exist or not .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fexist(const char *file_name, fsl_osal_s32 *result)
+{
+	struct stat64 st = {0};
+	
+	*result = (stat64(file_name,&st) == 0);
+
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_fsize function gets the size of the specified file
+ *
+ *	@param [in] file_handle
+ *		The file handle .  .
+ *	@param [out] actual_size
+ *		The file size .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+OMX_OSAL_API efsl_osal_return_type_t fsl_osal_fspace(const char *path_name, fsl_osal_u64 *avail_space)
+{
+	struct statfs64 buf={0};
+	
+	if(statfs64(path_name, &buf) < 0)
+		return E_FSL_OSAL_FAILURE;
+	
+	*avail_space = (long long)buf.f_bsize * buf.f_bavail;
+	
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*! The fsl_osal_feof function  tests the end-of-file indicator
+ *	for the stream pointed to by stream
+ *
+ *	@param [in] file_handle
+ *		The file handle .
+ *	@param [out] result
+ *		The return value of feof call.
+ *
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if parameter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_feof(fsl_osal_file file_handle, fsl_osal_s32 *result)
+{
+	if(file_handle == NULL)
+	{
+		LOG_ERROR(" Error.Passing NULL pointer.\n");
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+
+	*result = feof((FILE *)file_handle);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_mkdir API creates a directory named pathname
+ *
+ *	@param [in] pathname
+ *		 directory name .
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_NOTSUPPORTED if directory creation is not supported/permitted
+ *		E_FSL_OSAL_UNAVAILABLE if resources requred for creation are not available
+ */
+efsl_osal_return_type_t fsl_osal_mkdir(const char *pathname)
+{
+	FILE *fp;
+	char cmd[256];
+
+	fp = fopen(pathname, "r");
+	if (fp == 0)
+	{
+        strcpy(cmd, "mkdir -p ");
+        strcat(cmd, pathname);
+        return (efsl_osal_return_type_t)system(cmd);
+	}
+	else
+		fclose(fp);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+efsl_osal_return_type_t fsl_osal_init()
+{
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! De-Initialize the OSAL system
+ *
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+efsl_osal_return_type_t fsl_osal_deinit()
+{
+	return E_FSL_OSAL_SUCCESS;
+}
+
+#endif
+
diff --git a/OSAL/linux/fsl_osal_linux_mem.cpp b/OSAL/linux/fsl_osal_linux_mem.cpp
new file mode 100755
index 0000000..a05a053
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_mem.cpp
@@ -0,0 +1,162 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_mem.c
+ *
+ * @brief Defines the OS Abstraction layer APIs for memory allocation in Linux
+ *
+ * @ingroup osal
+ */
+
+ #include <string.h>
+ #include <fsl_osal.h>
+ #include <malloc.h>
+
+/*! Allocates the requested memory.
+ *
+ *	@param [In] size
+ *	    memory size need to allocateed.
+ *	@param [out] ptr
+ *		pointer to allocated memory if successfully allocated otherwise NULL.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+
+ fsl_osal_ptr fsl_osal_malloc_new(fsl_osal_u32 size)
+ {
+    fsl_osal_ptr ptr;
+	ptr = (void *)malloc(size);
+ 	return ptr;
+ }
+
+/*! ReAllocates the requested memory.
+ *
+ *	@param [In] size
+ *	    memory size need to allocateed.
+ *	@param [In/out] ptr
+ *		pointer to allocated memory if successfully allocated otherwise NULL.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success otherwise E_FSL_OSAL_UNAVAILABLE
+ */
+fsl_osal_ptr fsl_osal_realloc_new(fsl_osal_ptr ptr, fsl_osal_u32 size) 
+{
+    fsl_osal_ptr ptr2;
+    ptr2 = (void *)realloc(ptr, size);
+
+    return ptr2;
+}
+
+/*! Releases the requested memory
+ *
+ *	@param [In] ptr
+ *		memory to be released.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ efsl_osal_return_type_t fsl_osal_dealloc(fsl_osal_ptr ptr)
+{
+    free(ptr);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*!  The  fsl_osal_memset function fills the first size bytes of the memory area
+ *	 pointed to by ptr with the constant byte ch.
+ *
+ *	@param [In] ptr
+ *		pointer to memory.
+ *	@param [In] ch
+ *		The byte to be written.
+ *	@param [In] size
+ *		Size of memory to be updated.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ efsl_osal_return_type_t fsl_osal_memset(fsl_osal_ptr ptr,
+ 										 fsl_osal_char ch,
+ 										 fsl_osal_u32 size)
+{
+	memset(ptr, ch, size);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*!  The  fsl_osal_memcpy function copies 'size' bytes from memory area src to memory
+ *   area dest.
+ *
+ *	@param [In] dest
+ *		destination location.
+ *	@param [In] src
+ *		source location.
+ *	@param [In] size
+ *		Size of memory to be copied.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ efsl_osal_return_type_t fsl_osal_memcpy(fsl_osal_ptr dest,
+ 										 fsl_osal_ptr src,
+ 										 fsl_osal_u32 size)
+{
+	if( (dest == NULL) || (src == NULL) )
+	{
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	memcpy(dest, src, size);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+
+/*!  The  fsl_osal_memmove function copies 'size' bytes from memory area src to memory
+ *   area dest. The memory area is overlappable.
+ *
+ *	@param [In] dest
+ *		destination location.
+ *	@param [In] src
+ *		source location.
+ *	@param [In] size
+ *		Size of memory to be copied.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ efsl_osal_return_type_t fsl_osal_memmove(fsl_osal_ptr dest,
+ 										 fsl_osal_ptr src,
+ 										 fsl_osal_u32 size)
+{
+	if( (dest == NULL) || (src == NULL) )
+	{
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	memmove(dest, src, size);
+	return E_FSL_OSAL_SUCCESS;
+}
+
+/*!  The  fsl_osal_memcmp function compare two memory.
+ *
+ *	@param [In] dest
+ *		destination location.
+ *	@param [In] src
+ *		source location.
+ *	@param [In] size
+ *		Size of memory to be copied.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ */
+ fsl_osal_s32 fsl_osal_memcmp(const fsl_osal_ptr ptr1,
+ 										 const fsl_osal_ptr ptr2,
+ 										 fsl_osal_u32 size)
+{
+	if( (ptr1 == NULL) || (ptr2 == NULL) )
+	{
+		return E_FSL_OSAL_INVALIDPARAM;
+	}
+	return memcmp(ptr1, ptr2, size);
+}
+
+
+/* File EOF */
+
diff --git a/OSAL/linux/fsl_osal_linux_mutex.cpp b/OSAL/linux/fsl_osal_linux_mutex.cpp
new file mode 100755
index 0000000..629054c
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_mutex.cpp
@@ -0,0 +1,144 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_mutex.c
+ *
+ * @brief Defines the OS Abstraction layer APIs for mutex mechanisms in Linux
+ *
+ * @ingroup osal
+ */
+
+ #include <fsl_osal.h>
+ #include <pthread.h>
+ #include "Log.h"
+
+/*! Allocates and Initilizes the mutual exclusion object.
+ *
+ *	@param [out] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_UNAVAILABLE if mutex not available
+ */
+efsl_osal_return_type_t fsl_osal_mutex_init(fsl_osal_mutex *sync_obj, fsl_osal_mutex_type type)
+{
+     pthread_mutexattr_t attr;
+     
+ 	*sync_obj = (pthread_mutex_t *)fsl_osal_malloc_new(sizeof(pthread_mutex_t));
+ 	if(*sync_obj == NULL)
+ 	{
+ 		LOG_ERROR("\n malloc of mutex object failed.");
+ 		return E_FSL_OSAL_UNAVAILABLE;
+ 	}
+    
+    pthread_mutexattr_init(&attr);     
+    switch(type)
+    {
+        case fsl_osal_mutex_normal:
+            pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_NORMAL);
+            break;
+        case fsl_osal_mutex_recursive:
+            pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_RECURSIVE_NP);
+            break;
+        case fsl_osal_mutex_errorcheck:
+            pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_ERRORCHECK_NP);
+            break;
+        default:
+            pthread_mutexattr_settype(&attr,PTHREAD_MUTEX_NORMAL);
+            break;
+    }
+    
+ 	pthread_mutex_init((pthread_mutex_t *)(*sync_obj), &attr);
+
+ 	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! De-initializes and Releases the mutex object.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_mutex_destroy(fsl_osal_mutex sync_obj)
+ {
+
+ 	if (pthread_mutex_destroy((pthread_mutex_t *)sync_obj) != 0)
+ 	{
+ 		LOG_ERROR("\n Error in destroying mutex.");
+ 		return E_FSL_OSAL_INVALIDPARAM ;
+ 	}
+
+ 	fsl_osal_dealloc(sync_obj);
+
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Acquires the lock.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_mutex_lock(fsl_osal_mutex sync_obj)
+ {
+ 	if ( (pthread_mutex_lock((pthread_mutex_t *)sync_obj)) != 0)
+ 	{
+ 		LOG_ERROR("\n Error in locking the mutex");
+ 		return E_FSL_OSAL_INVALIDPARAM ;
+ 	}
+
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Tries to acquire the lock. This is not a blocking call. E_FSL_OSAL_SUCCESS
+ *	indicates that the lock is acquired.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ *		E_FSL_OSAL_BUSY if mutex is already locked
+ *
+ */
+efsl_osal_return_type_t fsl_osal_mutex_trylock(fsl_osal_mutex sync_obj)
+ {
+ 	if ( (pthread_mutex_trylock((pthread_mutex_t *)sync_obj)) != 0)
+ 	{
+ 		//LOG_ERROR("\n Error while trying to lock the mutex.");
+ 		return E_FSL_OSAL_BUSY ;
+ 	}
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Releases the lock.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@param [out] os_specific_error_code
+ *		Updated with OS specific error code if the API fails. This is valid
+ *		only if the return value is E_FSL_OSAL_SUCCESS.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_mutex_unlock(fsl_osal_mutex sync_obj)
+ {
+ 	if ( (pthread_mutex_unlock((pthread_mutex_t *)sync_obj)) != 0)
+ 	{
+ 		LOG_ERROR("\n Error while trying to unlock the mutex.");
+ 		return E_FSL_OSAL_INVALIDPARAM ;
+ 	}
+ 	return E_FSL_OSAL_SUCCESS;
+ }
diff --git a/OSAL/linux/fsl_osal_linux_sem.cpp b/OSAL/linux/fsl_osal_linux_sem.cpp
new file mode 100755
index 0000000..19b8eb4
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_sem.cpp
@@ -0,0 +1,150 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_sem.c
+ *
+ * @brief Defines the OS Abstraction layer APIs for semaphore mechanisms in Linux
+ *
+ * @ingroup osal
+ */
+
+ #include <fsl_osal.h>
+ #include <semaphore.h>
+ #include "Log.h"
+
+/*! Allocates and Initilizes the semaphore object.
+ *
+ *	@param [out] sem_obj
+ *		The semaphore object
+ *	@param [in] pshared
+ *		This argument indicates whether semaphore is shared across
+ *		processes.
+ *	@param [in] value
+ *		The value indicates the initial value of the
+ *		count associated with the semaphore.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_UNAVAILABLE if semaphore not available
+ *		E_FSL_OSAL_FAILURE if semaphore initialisation is unsuccessful
+ */
+efsl_osal_return_type_t fsl_osal_sem_init(fsl_osal_sem *sem_obj,
+										  fsl_osal_s32 pshared,
+										  fsl_osal_u32 value)
+{
+ 	*sem_obj = (sem_t *)fsl_osal_malloc_new(sizeof(sem_t));
+ 	if(*sem_obj == NULL)
+ 	{
+ 		LOG_ERROR("\n Creation of semaphore failed.");
+ 		return E_FSL_OSAL_UNAVAILABLE;
+ 	}
+ 	if(sem_init((sem_t *)(*sem_obj), pshared, value) != 0)
+ 		return E_FSL_OSAL_FAILURE;
+
+ 	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_sem_destroy method destroys the semaphore object,
+ *	pointed to by sem_obj.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_INVALIDPARAM
+ */
+
+efsl_osal_return_type_t fsl_osal_sem_destroy(fsl_osal_sem sem_obj)
+{
+#ifdef ANDROID_BUILD
+        /* workaround for android semaphore usage */
+        fsl_osal_sem_post(sem_obj);
+#endif
+
+ 	if (sem_destroy((sem_t *)sem_obj) != 0)
+ 	{
+ 		LOG_ERROR("\n Error in destroying semaphore.");
+ 		return E_FSL_OSAL_INVALIDPARAM ;
+ 	}
+
+ 	fsl_osal_dealloc(sem_obj);
+ 	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! This call suspends the calling thread until the
+ *	semaphore pointed to  by sem_obj has non-zero count.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ */
+efsl_osal_return_type_t fsl_osal_sem_wait(fsl_osal_sem sem_obj)
+{
+ 	sem_wait((sem_t *)sem_obj);
+ 	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_sem_trywait call is a non-blocking variant of fsl_osal_sem_wait.
+ * 	If the semaphore pointed to by sem_obj has non-zero count, the count is
+ *	atomically decreased and fsl_osal_sem_trywait immediately returns 0.
+ *	If the semaphore count is zero, fsl_osal_sem_trywait immediately returns with error.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_FAILURE
+ */
+efsl_osal_return_type_t fsl_osal_sem_trywait(fsl_osal_sem sem_obj)
+{
+ 	if ( (sem_trywait((sem_t *)sem_obj)) != 0)
+ 		return E_FSL_OSAL_FAILURE ;
+
+ 	return E_FSL_OSAL_SUCCESS;
+}
+
+/*! The fsl_osal_sem_post method atomically increases the count of the
+ *	semaphore pointed to by sem_obj.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_INVALIDPARAM
+ */
+efsl_osal_return_type_t fsl_osal_sem_post(fsl_osal_sem sem_obj)
+ {
+ 	if ( (sem_post((sem_t *)sem_obj)) != 0)
+ 	{
+ 		LOG_ERROR("\n Error while signalling to the semaphore.");
+ 		return E_FSL_OSAL_INVALIDPARAM ;
+ 	}
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! The fsl_osal_sem_getvalue call stores  in  the  location
+ *	pointed to by sval the current count of the semaphore pointed to by sem_obj.
+ *
+ *	@param [in] sem_obj
+ *		The semaphore object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS
+ *		E_FSL_OSAL_FAILURE
+ */
+efsl_osal_return_type_t fsl_osal_sem_getvalue(fsl_osal_sem sem_obj,
+											  fsl_osal_s32 *sval)
+{
+ 	*sval = sem_getvalue((sem_t *)sem_obj, (int *)sval);
+ 	return E_FSL_OSAL_SUCCESS;
+}
+
+
+
+
diff --git a/OSAL/linux/fsl_osal_linux_string.cpp b/OSAL/linux/fsl_osal_linux_string.cpp
new file mode 100755
index 0000000..2066081
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_string.cpp
@@ -0,0 +1,233 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_string.cpp
+ *
+ * @brief Defines the OS Abstraction layer APIs for string in Linux
+ *
+ * @ingroup osal
+ */
+
+ #include <string.h>
+ #include <stdlib.h>
+ #include <fsl_osal.h>
+ #include <malloc.h>
+
+/*! String copy.
+ *
+ *	@param [out] dest
+ *		destination point for string copy.
+  *	@param [In] src
+ *		source point for string copy.
+ *	@return fsl_osal_char
+ *		return destination point.
+ */
+
+ fsl_osal_char *fsl_osal_strcpy(fsl_osal_char *dest, const fsl_osal_char *src)
+ {
+	fsl_osal_char *ret;
+	ret = strcpy(dest, src);
+ 	return ret;
+ }
+
+/*! String copy.
+ *
+ *	@param [out] dest
+ *		destination point for string copy.
+ *	@param [In] src
+ *		source point for string copy.
+ *	@param [In] n
+ *		Length.
+ *	@return fsl_osal_char
+ *		return destination point.
+ */
+
+ fsl_osal_char *fsl_osal_strncpy(fsl_osal_char *dest, const fsl_osal_char *src, fsl_osal_s32 n)
+ {
+	fsl_osal_char *ret;
+	ret = strncpy(dest, src, n);
+ 	return ret;
+ }
+
+/*! Search sub string.
+ *
+ *	@param [In] src1
+ *		string wants to be search.
+ *	@param [In] src2
+ *		the sub string.
+ *	@return fsl_osal_char
+ *		return sub string position .
+ */
+
+ fsl_osal_char *fsl_osal_strstr(const fsl_osal_char *src1, const fsl_osal_char *src2)
+ {
+	fsl_osal_char *ret;
+	ret = (fsl_osal_char *)strstr(src1, src2);
+ 	return ret;
+ }
+
+
+/*! String segmentation.
+ *
+ *	@param [in] s
+ *		string will be segmentation.
+  *	@param [In] delim
+ *		segmentation string.
+ *	@return fsl_osal_char
+ *		return segmentation point.
+ */
+
+ fsl_osal_char *fsl_osal_strtok(fsl_osal_char *s, const fsl_osal_char *delim)
+ {
+	fsl_osal_char *ret;
+	ret = strtok(s, delim);
+ 	return ret;
+ }
+
+/*! Thread safe string segmentation.
+ *
+ *	@param [in] s
+ *		string will be segmentation.
+  *	@param [In] delim
+ *		segmentation string.
+ *	@return fsl_osal_char
+ *		return segmentation point.
+ */
+
+ fsl_osal_char *fsl_osal_strtok_r(fsl_osal_char *s, const fsl_osal_char *delim, fsl_osal_char **pLast)
+ {
+	fsl_osal_char *ret;
+	ret = strtok_r(s, delim, pLast);
+ 	return ret;
+ }
+
+/*! String find.
+ *
+ *	@param [in] s
+ *		string.
+  *	@param [In] c
+ *		char.
+ *	@return fsl_osal_char
+ *		return string point.
+ */
+
+ fsl_osal_char *fsl_osal_strrchr(const fsl_osal_char *s, fsl_osal_s32 c)
+ {
+	fsl_osal_char *ret;
+	ret = (fsl_osal_char *)strrchr(s, c);
+ 	return ret;
+ }
+
+
+/*! String length.
+ *
+ *	@param [In] src
+ *		the input string.
+ *	@return fsl_osal_u32
+ *		The length of the input string, not include "\0".
+ */
+
+ fsl_osal_u32 fsl_osal_strlen(const fsl_osal_char *src)
+ {
+	fsl_osal_u32 ret;
+	ret = strlen(src);
+ 	return ret;
+ }
+
+/*! String compare.
+ *
+ *	@param [In] src1
+ *		the first string.
+ *	@param [In] src2
+ *		the second string.
+ *	@return fsl_osal_s32
+ *		return 0 if the string is same otherwise nonezero.
+ */
+
+ fsl_osal_s32 fsl_osal_strcmp(const fsl_osal_char *src1, const fsl_osal_char *src2)
+ {
+	fsl_osal_s32 ret;
+	ret = strcmp(src1, src2);
+ 	return ret;
+ }
+
+/*! String compare.
+ *
+ *	@param [In] src1
+ *		the first string.
+ *	@param [In] src2
+ *		the second string.
+ *	@param [In] n
+ *		string size to compare.
+ *	@return fsl_osal_s32
+ *		return 0 if the string is same otherwise nonezero.
+ */
+
+ fsl_osal_s32 fsl_osal_strncmp(const fsl_osal_char *src1, const fsl_osal_char *src2, fsl_osal_s32 n)
+ {
+	fsl_osal_s32 ret;
+	ret = strncmp(src1, src2, n);
+ 	return ret;
+ }
+
+
+ fsl_osal_s32 fsl_osal_strncasecmp(const fsl_osal_char *src1, const fsl_osal_char *src2, fsl_osal_s32 n)
+ {
+	fsl_osal_s32 ret;
+	ret = strncasecmp(src1, src2, n);
+ 	return ret;
+ }
+
+/*! String dump.
+ *
+ *	@param [In] src
+ *		source point for string copy.
+ *	@return dest
+ *		destination point for string copy.
+ *		return destination point.
+ */
+
+ fsl_osal_char *fsl_osal_strdup(const fsl_osal_char *src)
+ {
+	return strdup(src);
+ }
+
+/*! Change char to integrate.
+ *
+ *	@param [In] src
+ *		the input string.
+ *	@return fsl_osal_s32
+ *		return the value.
+ */
+
+ fsl_osal_s32 fsl_osal_atoi(const fsl_osal_char *src)
+ {
+	fsl_osal_s32 ret;
+	ret = atoi(src);
+ 	return ret;
+ }
+
+
+/*! Get envirement parameter.
+ *
+ *	@param [In] name
+ *		envirement name.
+ *	@return fsl_osal_char
+ *		return envirement string.
+ */
+
+ fsl_osal_char *fsl_osal_getenv_new(const fsl_osal_char *name)
+ {
+	fsl_osal_char *pEnvValue;
+	pEnvValue = getenv(name);
+ 	return pEnvValue;
+ }
+
+
diff --git a/OSAL/linux/fsl_osal_linux_thread.cpp b/OSAL/linux/fsl_osal_linux_thread.cpp
new file mode 100755
index 0000000..be47265
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_thread.cpp
@@ -0,0 +1,86 @@
+
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_thread.c
+ *
+ * @brief Defines the OS Abstraction layer APIs for thread functions in Linux
+ *
+ * @ingroup osal
+ */
+
+ #include <unistd.h> 
+ #include <fsl_osal.h>
+ #include <pthread.h>
+
+/*! Creates a thread.
+ *
+ *	@param [out] thread
+ *		Identifier of newly created thread.
+ *	@param [in] start_routine
+ *		Function to be run in the new thread.
+ *	@param [in] arg
+ *		Arguments passed to the start_routine function.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if thread creation is failure
+ */
+efsl_osal_return_type_t fsl_osal_thread_create(fsl_osal_ptr *thread, fsl_osal_ptr *ATTR, thread_func func, void *arg)
+ {
+	/* Create a new thread. The new thread will run the function start_routine. */
+
+    pthread_create((pthread_t *)thread, (const pthread_attr_t *)ATTR, func, arg);
+    
+    return E_FSL_OSAL_SUCCESS;
+ }
+
+
+/*! De-initializes and Releases the mutex object.
+ *
+ *	@param [in] sync_obj
+ *		The mutex object
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_thread_destroy(fsl_osal_ptr thread)
+ {
+
+	pthread_join((pthread_t)thread, NULL);
+ 	return E_FSL_OSAL_SUCCESS;
+ }
+
+/*! Get the current task/thread id.
+ *  *
+ *      @param [out] thread id
+ *      @return efsl_osal_return_type_t
+ *              E_FSL_OSAL_SUCCESS if success
+ *              E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_thread_self(fsl_osal_u32 *id)
+{
+    *id = pthread_self();
+    return E_FSL_OSAL_SUCCESS;
+}
+
+/*! Sleep the current task/thread.
+ *  *
+ *      @param [in] delay
+ *              delay in milliseconds.
+ *      @return efsl_osal_return_type_t
+ *              E_FSL_OSAL_SUCCESS if success
+ *              E_FSL_OSAL_INVALIDPARAM if paramter is invalid
+ */
+efsl_osal_return_type_t fsl_osal_sleep(fsl_osal_u32 delay)
+{
+    usleep(delay);
+    return E_FSL_OSAL_SUCCESS;
+}
+
diff --git a/OSAL/linux/fsl_osal_linux_time.cpp b/OSAL/linux/fsl_osal_linux_time.cpp
new file mode 100755
index 0000000..3feef1b
--- /dev/null
+++ b/OSAL/linux/fsl_osal_linux_time.cpp
@@ -0,0 +1,44 @@
+
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file fsl_osal_linux_time.c
+ *
+ * @brief Defines the OS Abstraction layer APIs for time in Linux
+ *
+ * @ingroup osal
+ */
+
+#include <sys/time.h>
+#include "fsl_osal.h"
+#include "Log.h"
+
+/*! Get system time.
+ *
+ *	@param [out] cond
+ *		Identifier of newly created time.
+ *	@return efsl_osal_return_type_t
+ *		E_FSL_OSAL_SUCCESS if success
+ *		E_FSL_OSAL_FAILURE if thread creation is failure
+ */
+efsl_osal_return_type_t fsl_osal_systime(fsl_osal_timeval *time)
+{
+    struct timeval tv;
+
+    if(time == NULL)
+        return E_FSL_OSAL_FAILURE;
+
+    gettimeofday(&tv, NULL);
+    time->sec = tv.tv_sec;
+    time->usec = tv.tv_usec;
+
+    return E_FSL_OSAL_SUCCESS;
+}
+
diff --git a/OSAL/logger/Log.cpp b/OSAL/logger/Log.cpp
new file mode 100755
index 0000000..b210a34
--- /dev/null
+++ b/OSAL/logger/Log.cpp
@@ -0,0 +1,147 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file Log.cpp
+ *
+ * @brief log information for debug
+ *
+ * @ingroup utils
+ */
+
+
+#ifdef ANDROID_BUILD
+#include <android/log.h>
+#endif
+#include "Log.h"
+
+fsl_osal_s32 nLogLevel = LOG_LEVEL_ERROR;
+fsl_osal_file pLogFile = NULL;
+
+static void ReadLogLevel(fsl_osal_char *LogLevelFile)
+{
+	efsl_osal_return_type_t ret;
+	fsl_osal_char symbol;
+	fsl_osal_s32 ReadLen = 0;
+	FILE *pfile = NULL;
+
+	if (LogLevelFile == NULL)
+	{
+		return;
+	}
+
+	ret = fsl_osal_fopen(LogLevelFile, "r", (fsl_osal_file *)&pfile);
+	if (ret != E_FSL_OSAL_SUCCESS)
+	{
+		return;
+	}
+
+	ret = fsl_osal_fread(&symbol, 1, pfile, &ReadLen);
+	if (ret != E_FSL_OSAL_SUCCESS && ret != E_FSL_OSAL_EOF)
+	{
+		fsl_osal_fclose(pfile);
+		return;
+	}
+
+	if (ReadLen < 1)
+	{
+		fsl_osal_fclose(pfile);
+		return;
+	}
+
+	nLogLevel = fsl_osal_atoi(&symbol);
+
+	fsl_osal_fclose(pfile);
+}
+
+fsl_osal_void LogInit(fsl_osal_s32 nLevel, fsl_osal_char *pFile)
+{
+	const fsl_osal_char *pDebugLevelEnv = (fsl_osal_char *)"LOG_LEVEL";
+	const fsl_osal_char *pLogFileEnv = (fsl_osal_char *)"LOG_FILE";
+	fsl_osal_char *cTemp = NULL;
+
+	if (nLevel >= LOG_LEVEL_NONE && nLevel < LOG_LEVEL_COUNT)
+		nLogLevel = nLevel;
+	else
+	{
+		cTemp = fsl_osal_getenv_new(pDebugLevelEnv);
+		if( (cTemp != NULL) )
+		{
+			nLogLevel = fsl_osal_atoi(cTemp);
+		}
+		else
+		{
+#ifdef ANDROID_BUILD
+			fsl_osal_char *LogLevelFile = (fsl_osal_char*)"/data/omx_log_level";
+#else
+			fsl_osal_char *LogLevelFile = (fsl_osal_char*)"/etc/omx_log_level";
+#endif
+			ReadLogLevel(LogLevelFile);
+		}
+	}
+
+	if (nLogLevel < LOG_LEVEL_NONE || nLogLevel >= LOG_LEVEL_COUNT)
+	{
+		nLogLevel = LOG_LEVEL_NONE;
+		printf("Log level is [0, 6]\n");
+	}
+
+	if (NULL != pFile)
+		cTemp = pFile;
+	else
+		cTemp = fsl_osal_getenv_new(pLogFileEnv);
+	if( (cTemp != NULL) )
+	{
+		if (NULL != pLogFile)
+		{
+			fsl_osal_fclose(pLogFile);
+			pLogFile = NULL;
+		}
+
+		if(fsl_osal_fopen(cTemp, "wb", &pLogFile) != E_FSL_OSAL_SUCCESS)
+		{
+			printf("Can not open debug log file %s! \n", cTemp);
+			return;
+		}
+	}
+
+	return;
+}
+
+fsl_osal_void LogDeInit()
+{
+
+	if (NULL != pLogFile)
+	{
+		fsl_osal_fclose(pLogFile);
+		pLogFile = NULL;
+	}
+
+	return;
+}
+
+#ifdef ANDROID_BUILD
+
+#define LOG_BUF_SIZE 1024
+
+fsl_osal_void LogOutput(const fsl_osal_char *fmt, ...)
+{
+    va_list ap;
+    fsl_osal_char buf[LOG_BUF_SIZE];
+
+    va_start(ap, fmt);
+    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
+    va_end(ap);
+
+    __android_log_write(ANDROID_LOG_INFO, "OMXPlayer", buf);
+
+    return;
+}
+
+#endif
diff --git a/OpenMAXIL/ghdr/OMX_Audio.h b/OpenMAXIL/ghdr/OMX_Audio.h
new file mode 100755
index 0000000..d4f2c04
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Audio.h
@@ -0,0 +1,1311 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Audio.h - OpenMax IL version 1.1.2
+ *  The structures needed by Audio components to exchange
+ *  parameters and configuration data with the componenmilts.
+ */
+
+#ifndef OMX_Audio_h
+#define OMX_Audio_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup midi MIDI
+ * @ingroup audio
+ */
+ 
+/** @defgroup effects Audio effects
+ * @ingroup audio
+ */
+
+/** @defgroup audio OpenMAX IL Audio Domain
+ * Structures for OpenMAX IL Audio domain
+ * @{
+ */
+
+/** Enumeration used to define the possible audio codings.  
+ *  If "OMX_AUDIO_CodingUnused" is selected, the coding selection must 
+ *  be done in a vendor specific way.  Since this is for an audio 
+ *  processing element this enum is relevant.  However, for another 
+ *  type of component other enums would be in this area.
+ */
+typedef enum OMX_AUDIO_CODINGTYPE {
+    OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
+    OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
+    OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
+    OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
+    OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
+    OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
+    OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
+    OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
+    OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
+    OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
+    OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
+    OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
+    OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
+    OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
+    OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
+    OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
+    OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
+    OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
+    OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
+    OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
+    OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
+    OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
+    OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
+    OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
+    OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
+    OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
+    OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
+    OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+    OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CodingMax = 0x7FFFFFFF
+} OMX_AUDIO_CODINGTYPE;
+
+
+/** The PortDefinition structure is used to define all of the parameters 
+ *  necessary for the compliant component to setup an input or an output audio 
+ *  path.  If additional information is needed to define the parameters of the
+ *  port (such as frequency), additional structures must be sent such as the
+ *  OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
+ */
+typedef struct OMX_AUDIO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;            /**< MIME type of data for the port */
+    OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
+                                               for an output device, 
+                                               otherwise this field is 0 */
+    OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is 
+                                          supported by the OMX component */
+    OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this 
+                                          port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PORTDEFINITIONTYPE;
+
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_AUDIO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nPortIndex;             /**< Indicates which port to set */
+    OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
+} OMX_AUDIO_PARAM_PORTFORMATTYPE;
+
+
+/** PCM mode type  */ 
+typedef enum OMX_AUDIO_PCMMODETYPE { 
+    OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */ 
+    OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */ 
+    OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */ 
+    OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_PCMModeMax = 0x7FFFFFFF 
+} OMX_AUDIO_PCMMODETYPE; 
+
+
+typedef enum OMX_AUDIO_CHANNELTYPE {
+    OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
+    OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
+    OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
+    OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
+    OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
+    OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
+    OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
+    OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
+    OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
+    OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
+    OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelMax  = 0x7FFFFFFF 
+} OMX_AUDIO_CHANNELTYPE;
+
+#define OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
+#define OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
+
+/** PCM format description */ 
+typedef struct OMX_AUDIO_PARAM_PCMMODETYPE { 
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
+    OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */ 
+    OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed or unsigned */ 
+    OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */ 
+    OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for 
+                                           non-interleaved data (e.g. block data) */ 
+    OMX_U32 nBitPerSample;            /**< Bit per sample */ 
+    OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for 
+                                           variable or unknown sampling rate. */ 
+    OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */ 
+    OMX_AUDIO_CHANNELTYPE eChannelMapping[OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
+
+} OMX_AUDIO_PARAM_PCMMODETYPE; 
+
+
+/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
+ * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC. 
+ */
+typedef enum OMX_AUDIO_CHANNELMODETYPE {
+    OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those 
+                                          two channels changes accordingly to each channel information */
+    OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between 
+                                           2 channels for higher compression gain */
+    OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half 
+                                           the bitrate of the overall bitrate */
+    OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
+    OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
+} OMX_AUDIO_CHANNELMODETYPE;
+
+
+typedef enum OMX_AUDIO_MP3STREAMFORMATTYPE {
+    OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
+    OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MP3STREAMFORMATTYPE;
+
+/** MP3 params */
+typedef struct OMX_AUDIO_PARAM_MP3TYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+    OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
+} OMX_AUDIO_PARAM_MP3TYPE;
+
+
+typedef enum OMX_AUDIO_AACSTREAMFORMATTYPE {
+    OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
+    OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
+    OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
+    OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
+    OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
+    OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
+    OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
+    OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_AACSTREAMFORMATTYPE;
+
+
+/** AAC mode type.  Note that the term profile is used with the MPEG-2
+ * standard and the term object type and profile is used with MPEG-4 */
+typedef enum OMX_AUDIO_AACPROFILETYPE{
+  OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
+  OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
+  OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
+  OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
+  OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
+  OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
+  OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
+  OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
+  OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
+  OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
+  OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+} OMX_AUDIO_AACPROFILETYPE;
+
+
+/** AAC tool usage (for nAACtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for encoder configuration and optional as decoder info output.
+ * For MP3, OMX_AUDIO_CHANNELMODETYPE is sufficient. */
+#define OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
+#define OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
+#define OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
+#define OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
+#define OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
+#define OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
+#define OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
+
+/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for ER encoder configuration and optional as decoder info output */
+#define OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
+#define OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
+#define OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
+#define OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
+#define OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
+
+
+/** AAC params */
+typedef struct OMX_AUDIO_PARAM_AACPROFILETYPE {
+    OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port that this structure applies to */
+    OMX_U32 nChannels;             /**< Number of channels */
+    OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
+                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
+                                        Use 0 to let encoder decide */
+    OMX_U32 nAACtools;             /**< AAC tool usage */
+    OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
+    OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
+    OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+} OMX_AUDIO_PARAM_AACPROFILETYPE;
+
+
+/** VORBIS params */
+typedef struct OMX_AUDIO_PARAM_VORBISTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
+                                   rate or unknown bit rates. Encoding is set to the
+                                   bitrate closest to specified  value (in bps) */
+    OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
+    OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
+
+    OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   variable or unknown sampling rate. */
+    OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
+                                   limit the audio signal. Use 0 to let encoder decide */
+    OMX_S32 nQuality;		  /**< Sets encoding quality to n, between -1 (low) and 10 (high).
+                                   In the default mode of operation, teh quality level is 3.
+                                   Normal quality range is 0 - 10. */
+    OMX_BOOL bManaged;		  /**< Set  bitrate  management  mode. This turns off the
+                                   normal VBR encoding, but allows hard or soft bitrate
+                                   constraints to be enforced by the encoder. This mode can
+                                   be slower, and may also be lower quality. It is
+                                   primarily useful for streaming. */
+    OMX_BOOL bDownmix;		  /**< Downmix input from stereo to mono (has no effect on 
+                                   non-stereo streams). Useful for lower-bitrate encoding. */     
+} OMX_AUDIO_PARAM_VORBISTYPE;
+
+
+/** WMA Version */
+typedef enum OMX_AUDIO_WMAFORMATTYPE {
+  OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
+  OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
+  OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
+  OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
+  OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAFORMATTYPE;
+
+
+/** WMA Profile */
+typedef enum OMX_AUDIO_WMAPROFILETYPE {
+  OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
+  OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
+  OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
+  OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
+  OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+} OMX_AUDIO_WMAPROFILETYPE;
+
+
+/** WMA params */
+typedef struct OMX_AUDIO_PARAM_WMATYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U16 nChannels;        /**< Number of channels */
+    OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
+                                   rate or unknown bit rates */
+    OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
+	OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
+    OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
+    OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
+    OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
+    OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
+} OMX_AUDIO_PARAM_WMATYPE;
+
+/** 
+ * RealAudio format
+ */
+typedef enum OMX_AUDIO_RAFORMATTYPE {
+    OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
+    OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
+    OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
+    OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
+    OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
+    OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
+    OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
+    OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
+    OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_RAFORMATTYPE;
+
+/** RA (Real Audio) params */ 
+typedef struct OMX_AUDIO_PARAM_RATYPE { 
+    OMX_U32 nSize;              /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels */ 
+    OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */ 
+    OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */ 
+    OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */ 
+    OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */ 
+    OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */ 
+    OMX_U32 nNumRegions;        /**< is the number of regions value */ 
+    OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
+} OMX_AUDIO_PARAM_RATYPE; 
+
+
+/** SBC Allocation Method Type */
+typedef enum OMX_AUDIO_SBCALLOCMETHODTYPE {
+  OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
+  OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+  OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
+} OMX_AUDIO_SBCALLOCMETHODTYPE;
+
+
+/** SBC params */
+typedef struct OMX_AUDIO_PARAM_SBCTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_U32 nChannels;         /**< Number of channels */
+    OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
+                                    rate or unknown bit rates */
+    OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    OMX_U32 nBlocks;           /**< Number of blocks */
+    OMX_U32 nSubbands;         /**< Number of subbands */
+    OMX_U32 nBitPool;          /**< Bitpool value */
+    OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
+    OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
+} OMX_AUDIO_PARAM_SBCTYPE;
+
+
+/** ADPCM stream format parameters */ 
+typedef struct OMX_AUDIO_PARAM_ADPCMTYPE { 
+    OMX_U32 nSize;              /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
+                                     necessarily the same as the number of channels 
+                                     to be rendered. */ 
+    OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */ 
+    OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for 
+                                    variable or unknown sampling rate. */ 
+} OMX_AUDIO_PARAM_ADPCMTYPE; 
+
+
+/** G723 rate */
+typedef enum OMX_AUDIO_G723RATE {
+    OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
+    OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
+    OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G723RATE;
+
+
+/** G723 - Sample rate must be 8 KHz */
+typedef struct OMX_AUDIO_PARAM_G723TYPE { 
+    OMX_U32 nSize;                /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */ 
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not 
+                                       necessarily the same as the number of channels 
+                                       to be rendered. */ 
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */ 
+    OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */ 
+    OMX_BOOL bPostFilter;         /**< Enable Post Filter */ 
+} OMX_AUDIO_PARAM_G723TYPE; 
+
+
+/** ITU G726 (ADPCM) rate */
+typedef enum OMX_AUDIO_G726MODE {
+    OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
+    OMX_AUDIO_G726Mode16,          /**< 16 kbps */
+    OMX_AUDIO_G726Mode24,          /**< 24 kbps */
+    OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
+    OMX_AUDIO_G726Mode40,          /**< 40 kbps */
+    OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
+} OMX_AUDIO_G726MODE;
+
+
+/** G.726 stream format parameters - must be at 8KHz */ 
+typedef struct OMX_AUDIO_PARAM_G726TYPE { 
+    OMX_U32 nSize;              /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */ 
+    OMX_U32 nChannels;          /**< Number of channels in the data stream (not 
+                                     necessarily the same as the number of channels 
+                                     to be rendered. */ 
+     OMX_AUDIO_G726MODE eG726Mode;
+} OMX_AUDIO_PARAM_G726TYPE; 
+
+
+/** G729 coder type */
+typedef enum OMX_AUDIO_G729TYPE {
+    OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
+    OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
+    OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
+    OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
+    OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_G729Max = 0x7FFFFFFF
+} OMX_AUDIO_G729TYPE;
+
+
+/** G729 stream format parameters - fixed 6KHz sample rate */
+typedef struct OMX_AUDIO_PARAM_G729TYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nChannels;        /**< Number of channels in the data stream (not
+                                   necessarily the same as the number of channels
+                                   to be rendered. */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_AUDIO_G729TYPE eBitType;
+} OMX_AUDIO_PARAM_G729TYPE;
+
+
+/** AMR Frame format */ 
+typedef enum OMX_AUDIO_AMRFRAMEFORMATTYPE { 
+    OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance 
+                                                   (Standard) Format */ 
+    OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface 
+                                                   Format 1 */ 
+    OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface 
+                                                   Format 2*/ 
+    OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage 
+                                                   Format */ 
+    OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time 
+                                                   Transport Protocol Payload Format */ 
+    OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */ 
+    OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF 
+} OMX_AUDIO_AMRFRAMEFORMATTYPE; 
+
+
+/** AMR band mode */
+typedef enum OMX_AUDIO_AMRBANDMODETYPE {
+    OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
+    OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
+    OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
+    OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */ 
+    OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
+    OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
+    OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
+    OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
+    OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
+    OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
+    OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
+    OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */ 
+    OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */ 
+    OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
+    OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
+    OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
+    OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
+    OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */      
+    OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
+} OMX_AUDIO_AMRBANDMODETYPE;
+     
+
+/** AMR Discontinuous Transmission mode */ 
+typedef enum OMX_AUDIO_AMRDTXMODETYPE { 
+    OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */ 
+    OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using 
+                                             Voice Activity Detector 1 (VAD1) is enabled */ 
+    OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using 
+                                             Voice Activity Detector 2 (VAD2) is enabled */       
+    OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between 
+                                             Off, VAD1 or VAD2 modes */ 
+
+    OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
+
+    OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF 
+} OMX_AUDIO_AMRDTXMODETYPE; 
+ 
+
+/** AMR params */
+typedef struct OMX_AUDIO_PARAM_AMRTYPE {
+    OMX_U32 nSize;                          /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
+    OMX_U32 nPortIndex;                     /**< port that this structure applies to */
+    OMX_U32 nChannels;                      /**< Number of channels */
+    OMX_U32 nBitRate;                       /**< Bit rate read only field */
+    OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */ 
+    OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
+    OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
+} OMX_AUDIO_PARAM_AMRTYPE;
+
+
+/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMFRTYPE;
+
+
+/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMHRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMHRTYPE;
+
+
+/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_GSMEFRTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_GSMEFRTYPE;
+
+
+/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAFRTYPE;
+
+
+/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_TDMAEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_TDMAEFRTYPE;
+
+
+/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCFRTYPE;
+
+
+/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCEFRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCEFRTYPE;
+
+/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_PDCHRTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} OMX_AUDIO_PARAM_PDCHRTYPE;
+
+
+/** CDMA Rate types */
+typedef enum OMX_AUDIO_CDMARATETYPE {
+    OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
+    OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
+    OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
+    OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
+    OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
+    OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
+    OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
+} OMX_AUDIO_CDMARATETYPE;
+
+
+/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP8TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
+                                       rate or unknown bit rates */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP8TYPE;
+
+
+/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_QCELP13TYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} OMX_AUDIO_PARAM_QCELP13TYPE;
+
+
+/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_EVRCTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
+    OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
+} OMX_AUDIO_PARAM_EVRCTYPE;
+
+
+/** SMV ( up to 8.55kbps coder) stream format parameters */
+typedef struct OMX_AUDIO_PARAM_SMVTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
+    OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
+    OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
+    OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
+    OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
+} OMX_AUDIO_PARAM_SMVTYPE;
+
+
+/** MIDI Format 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIFORMATTYPE
+{
+    OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
+    OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
+    OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
+    OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
+    OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
+    OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
+    OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
+    OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
+    OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIFORMATTYPE;
+
+
+/** MIDI params 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDITYPE {
+    OMX_U32 nSize;                 /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire 
+                                        MIDI file passed in, otherwise if 0x0, the MIDI data 
+                                        is merged and streamed (instead of passed as an 
+                                        entire MIDI file) */
+    OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
+                                        voices. A value of zero indicates that the default 
+                                        polyphony of the device is used  */                                    
+    OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound 
+                                        bank at initialization */
+    OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */                                                                           
+} OMX_AUDIO_PARAM_MIDITYPE;
+
+
+/** Type of the MIDI sound bank 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKTYPE {
+    OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
+    OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
+    OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
+    OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
+    OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
+    OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKTYPE;
+
+
+/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
+   OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
+   OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
+   OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+   OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
+
+
+/** MIDI params to load/unload user soundbank 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
+    OMX_U32 nDLSSize;         /**< Size in bytes */
+    OMX_PTR pDLSData;         /**< Pointer to DLS file data */
+    OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
+    OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
+} OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
+
+
+/** Structure for Live MIDI events and MIP messages. 
+ * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.) 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
+    OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
+                                   array for the MIP message buffer, where the size is 
+                                   indicated by nMidiEventSize */
+} OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
+
+
+/** MIDI sound bank/ program pair in a given channel 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
+    OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
+    OMX_U16 nIDSoundBank;       /**< Sound bank ID */
+    OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks 
+                                     by index if multiple banks are present */
+} OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
+
+
+/** MIDI control 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10 
+                                       format based on JAVA MMAPI (JSR-135) requirement */
+    OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
+                                       number based on JSR-135 requirement */
+    OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10 
+                                       fixed-point number based on JSR-135 requirement */
+    OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic 
+                                       voices. A value of zero indicates that the default 
+                                       polyphony of the device is used  */
+    OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
+    OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback 
+                                       will stop automatically.  Set to zero if not used */
+    OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
+    OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
+    OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
+    OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
+    OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
+
+} OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
+
+
+/** MIDI Playback States 
+ * @ingroup midi
+ */
+typedef enum OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
+  OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to 
+  													other defined states */
+  OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open. 
+                                                    The MIDI engine is currently processing 
+                                                    MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being 
+                                                    primed. The MIDI engine is currently 
+                                                    processing MIDI events. */
+  OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but 
+                                                    not playing. The MIDI engine is currently
+                                                    processing MIDI events. The transition to
+                                                    this state is only possible from the 
+                                                    OMX_AUDIO_MIDIPlayBackStatePlaying state,
+                                                    when the 'playback head' reaches the end
+                                                    of media data or the playback stops due
+                                                    to stop time set.*/
+  OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
+                                                    playing. The MIDI engine is currently
+                                                    processing MIDI events.*/
+  OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
+                                                    resource constraints */
+  OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
+                                                    SP-MIDI content constraints, there is
+                                                    no audible MIDI content during playback
+                                                    currently. The situation may change if
+                                                    resources are freed later.*/
+  OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
+} OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
+
+
+/** MIDI status 
+ * @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field. 
+                                     NOTE: May not return a meaningful value until the entire 
+                                     file is parsed and buffered.  */
+    OMX_U32 nDuration;          /**< The length of the currently open MIDI resource 
+                                     in milliseconds. NOTE: May not return a meaningful value 
+                                     until the entire file is parsed and buffered.  */  
+    OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played 
+                                     in milliseconds */
+    OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful 
+                                     value until the entire file is parsed and buffered. */
+    OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently 
+                                     open MIDI resource. NOTE: May not return a meaningful value 
+                                     until the entire file is parsed and buffered.  */
+    OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing 
+                                     MIDI resource. NOTE: May not return a meaningful value until 
+                                     the entire file is parsed and buffered. */
+    OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
+} OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
+
+
+/** MIDI Meta Event structure one per Meta Event.
+ *  MIDI Meta Events are like audio metadata, except that they are interspersed 
+ *  with the MIDI content throughout the file and are not localized in the header. 
+ *  As such, it is necessary to retrieve information about these Meta Events from 
+ *  the engine, as it encounters these Meta Events within the MIDI content. 
+ *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright, 
+ *  author, default tempo, etc.) scattered throughout the file. 
+ *  @ingroup midi
+ */
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{ 
+    OMX_U32 nSize;            /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
+    OMX_U32 nIndex;           /**< Index of Meta Event */ 
+    OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */ 
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+    OMX_U32 nTrack;           /**< track number for the meta event */
+    OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
+} OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE; 
+
+
+/** MIDI Meta Event Data structure - one per Meta Event. 
+ * @ingroup midi
+ */ 
+typedef struct OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{ 
+    OMX_U32 nSize;            /**< size of the structure in bytes */ 
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */ 
+    OMX_U32 nIndex;           /**< Index of Meta Event */ 
+    OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */ 
+    OMX_U8 nData[1];          /**< array of one or more bytes of meta data 
+                                   as indicated by the nMetaEventSize field */ 
+} OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE; 
+
+
+/** Audio Volume adjustment for a port */
+typedef struct OMX_AUDIO_CONFIG_VOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's volume.  Select the 
+                                     output port to adjust the master 
+                                     volume. */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) 
+                                     or logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  The values
+                                     for volume are in mB (millibels = 1/100 dB) relative
+                                     to a gain of 1 (e.g. the output is the same as the 
+                                     input level).  Values are in mB from nMax 
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the 
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+} OMX_AUDIO_CONFIG_VOLUMETYPE;
+
+
+/** Audio Volume adjustment for a channel */
+typedef struct OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's volume.  Select the 
+                                     output port to adjust the master 
+                                     volume. */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+                                     using OMX_ALL to apply volume settings
+                                     to all channels */
+    OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or 
+                                     logarithmic scale (mB) */
+    OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  
+                                     The values for volume are in mB 
+                                     (millibels = 1/100 dB) relative to a gain
+                                     of 1 (e.g. the output is the same as the 
+                                     input level).  Values are in mB from nMax 
+                                     (maximum volume) to nMin mB (typically negative).  
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the 
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
+
+
+/** Audio balance setting */
+typedef struct OMX_AUDIO_CONFIG_BALANCETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's balance.  Select the 
+                                     output port to adjust the master 
+                                     balance. */
+    OMX_S32 nBalance;           /**< balance setting for this port 
+                                     (-100 to 100, where -100 indicates
+                                     all left, and no right */
+} OMX_AUDIO_CONFIG_BALANCETYPE;
+
+
+/** Audio Port mute */
+typedef struct OMX_AUDIO_CONFIG_MUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< Port index indicating which port to 
+                                     set.  Select the input port to set 
+                                     just that port's mute.  Select the 
+                                     output port to adjust the master 
+                                     mute. */
+    OMX_BOOL bMute;             /**< Mute setting for this port */
+} OMX_AUDIO_CONFIG_MUTETYPE;
+
+
+/** Audio Channel mute */
+typedef struct OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_U32 nChannel;           /**< channel to select from 0 to N-1, 
+                                     using OMX_ALL to apply mute settings
+                                     to all channels */
+    OMX_BOOL bMute;             /**< Mute setting for this channel */
+    OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */ 
+} OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
+
+
+
+/** Enable / Disable for loudness control, which boosts bass and to a 
+ *  smaller extent high end frequencies to compensate for hearing
+ *  ability at the extreme ends of the audio spectrum
+ */ 
+typedef struct OMX_AUDIO_CONFIG_LOUDNESSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
+} OMX_AUDIO_CONFIG_LOUDNESSTYPE;
+
+
+/** Enable / Disable for bass, which controls low frequencies
+ */ 
+typedef struct OMX_AUDIO_CONFIG_BASSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for bass control */
+    OMX_S32 nBass;             /**< bass setting for the port, as a 
+                                    continuous value from -100 to 100  
+                                    (0 means no change in bass level)*/
+} OMX_AUDIO_CONFIG_BASSTYPE;
+
+
+/** Enable / Disable for treble, which controls high frequencies tones
+ */ 
+typedef struct OMX_AUDIO_CONFIG_TREBLETYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for treble control */
+    OMX_S32  nTreble;          /**< treble setting for the port, as a
+                                    continuous value from -100 to 100  
+                                    (0 means no change in treble level) */
+} OMX_AUDIO_CONFIG_TREBLETYPE;
+
+
+/** An equalizer is typically used for two reasons: to compensate for an 
+ *  sub-optimal frequency response of a system to make it sound more natural 
+ *  or to create intentionally some unnatural coloring to the sound to create
+ *  an effect.
+ *  @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_EQUALIZERTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
+    OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is 
+                                    N-1, where N is the number of bands, lower limit is 0 */
+    OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
+                                    read only element and is used to determine 
+                                    the lower, center and upper frequency of 
+                                    this band.  */
+    OMX_BS32 sBandLevel;       /**< band level in millibels */
+} OMX_AUDIO_CONFIG_EQUALIZERTYPE;
+
+
+/** Stereo widening mode type 
+ * @ingroup effects
+ */ 
+typedef enum OMX_AUDIO_STEREOWIDENINGTYPE {
+    OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
+    OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
+    OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
+} OMX_AUDIO_STEREOWIDENINGTYPE;
+
+
+/** Control for stereo widening, which is a special 2-channel
+ *  case of the audio virtualizer effect. For example, for 5.1-channel 
+ *  output, it translates to virtual surround sound. 
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
+    OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
+    OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
+                                    as a continuous value from 0 to 100  */
+} OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
+
+
+/** The chorus effect (or ``choralizer'') is any signal processor which makes
+ *  one sound source (such as a voice) sound like many such sources singing 
+ *  (or playing) in unison. Since performance in unison is never exact, chorus 
+ *  effects simulate this by making independently modified copies of the input 
+ *  signal. Modifications may include (1) delay, (2) frequency shift, and 
+ *  (3) amplitude modulation.
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_CHORUSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for chorus */
+    OMX_BU32 sDelay;           /**< average delay in milliseconds */
+    OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
+    OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of 
+                                    delay (i.e. 0 to 100) */
+    OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
+} OMX_AUDIO_CONFIG_CHORUSTYPE;
+
+
+/** Reverberation is part of the reflected sound that follows the early 
+ *  reflections. In a typical room, this consists of a dense succession of 
+ *  echoes whose energy decays exponentially. The reverberation effect structure 
+ *  as defined here includes both (early) reflections as well as (late) reverberations. 
+ * @ingroup effects
+ */
+typedef struct OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
+    OMX_U32 nSize;                /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
+    OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect 
+                                       (i.e. both early reflections and late 
+                                       reverberation) in millibels */
+    OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
+                                       relative to the intensity at low
+                                       frequencies in millibels */
+    OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
+                                       (relative to room value), in millibels */
+    OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative 
+                                       to the direct path, in milliseconds */
+    OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
+                                       relative to room level, in millibels */
+    OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection 
+                                       to the beginning of the late reverberation 
+                                       section, in milliseconds */
+    OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
+                                       frequencies, in milliseconds */
+    OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative 
+                                       to low frequency decay time in percent  */
+    OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is 
+                                       the frequency used as the reference for all 
+                                       the high-frequency settings above */
+
+} OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
+
+
+/** Possible settings for the Echo Cancelation structure to use 
+ * @ingroup effects
+ */
+typedef enum OMX_AUDIO_ECHOCANTYPE {
+   OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
+   OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation - 
+                                     echo from plastics and face */
+   OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for 
+                                     Hands Free operation */
+   OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for 
+                                     Car Kit (longer echo) */
+   OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
+} OMX_AUDIO_ECHOCANTYPE;
+
+
+/** Enable / Disable for echo cancelation, which removes undesired echo's
+ *  from the audio
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
+} OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
+
+
+/** Enable / Disable for noise reduction, which undesired noise from
+ * the audio
+ * @ingroup effects
+ */ 
+typedef struct OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
+} OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/OpenMAXIL/ghdr/OMX_Common.h b/OpenMAXIL/ghdr/OMX_Common.h
new file mode 100755
index 0000000..79e52d0
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Common.h
@@ -0,0 +1,36 @@
+/**
+ *  Copyright (c) 2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef _omx_common_h_
+#define _omx_common_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+typedef enum {
+    OMX_VIDEO_RENDER_IPULIB,
+    OMX_VIDEO_RENDER_OVERLAY,
+    OMX_VIDEO_RENDER_SURFACE,
+    OMX_VIDEO_RENDER_V4L,
+    OMX_VIDEO_RENDER_FB,
+    OMX_VIDEO_RENDER_EGL,
+    OMX_VIDEO_RENDER_NUM,
+}OMX_VIDEO_RENDER_TYPE;
+
+typedef struct {
+    const OMX_VIDEO_RENDER_TYPE type;
+    const char* name;
+}VIDEO_RENDER_MAP_ENTRY;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/OpenMAXIL/ghdr/OMX_Component.h b/OpenMAXIL/ghdr/OMX_Component.h
new file mode 100755
index 0000000..d595640
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Component.h
@@ -0,0 +1,579 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Component.h - OpenMax IL version 1.1.2
+ *  The OMX_Component header file contains the definitions used to define
+ *  the public interface of a component.  This header file is intended to
+ *  be used by both the application and the component.
+ */
+
+#ifndef OMX_Component_h
+#define OMX_Component_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Audio.h>
+#include <OMX_Video.h>
+#include <OMX_Image.h>
+#include <OMX_Other.h>
+
+/** @ingroup comp */
+typedef enum OMX_PORTDOMAINTYPE { 
+    OMX_PortDomainAudio, 
+    OMX_PortDomainVideo, 
+    OMX_PortDomainImage, 
+    OMX_PortDomainOther,
+    OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_PortDomainMax = 0x7ffffff
+} OMX_PORTDOMAINTYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_PORTDEFINITIONTYPE {
+    OMX_U32 nSize;                 /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    OMX_U32 nPortIndex;            /**< Port number the structure applies to */
+    OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
+    OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
+    OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
+    OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
+    OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
+                                        OMX_CommandPortEnable/OMX_CommandPortDisable.
+                                        When disabled a port is unpopulated. A disabled port
+                                        is not populated with buffers on a transition to IDLE. */
+    OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
+                                        nBufferCountActual. A disabled port is always unpopulated. 
+                                        An enabled port is populated on a transition to OMX_StateIdle
+                                        and unpopulated on a transition to loaded. */
+    OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
+    union {
+        OMX_AUDIO_PORTDEFINITIONTYPE audio;
+        OMX_VIDEO_PORTDEFINITIONTYPE video;
+        OMX_IMAGE_PORTDEFINITIONTYPE image;
+        OMX_OTHER_PORTDEFINITIONTYPE other;
+    } format;
+    OMX_BOOL bBuffersContiguous;
+    OMX_U32 nBufferAlignment;
+} OMX_PARAM_PORTDEFINITIONTYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_U32TYPE { 
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;               /**< port that this structure applies to */ 
+    OMX_U32 nU32;                     /**< U32 value */
+} OMX_PARAM_U32TYPE;
+
+/** @ingroup rpm */
+typedef enum OMX_SUSPENSIONPOLICYTYPE {
+    OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
+    OMX_SuspensionEnabled,  /**< Suspension allowed */   
+    OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_SuspensionPolicyMax = 0x7fffffff
+} OMX_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_PARAM_SUSPENSIONPOLICYTYPE {
+    OMX_U32 nSize;                  
+    OMX_VERSIONTYPE nVersion;        
+    OMX_SUSPENSIONPOLICYTYPE ePolicy;
+} OMX_PARAM_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef enum OMX_SUSPENSIONTYPE {
+    OMX_NotSuspended, /**< component is not suspended */
+    OMX_Suspended,    /**< component is suspended */
+    OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_SuspendMax = 0x7FFFFFFF
+} OMX_SUSPENSIONTYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_PARAM_SUSPENSIONTYPE {
+    OMX_U32 nSize;                  
+    OMX_VERSIONTYPE nVersion;       
+    OMX_SUSPENSIONTYPE eType;             
+} OMX_PARAM_SUSPENSIONTYPE ;
+
+typedef struct OMX_CONFIG_BOOLEANTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bEnabled;    
+} OMX_CONFIG_BOOLEANTYPE;
+
+/* Parameter specifying the content uri to use. */
+/** @ingroup cp */
+typedef struct OMX_PARAM_CONTENTURITYPE
+{
+    OMX_U32 nSize;                      /**< size of the structure in bytes, including
+                                             actual URI name */
+    OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
+    OMX_U8 contentURI[1];               /**< The URI name */
+} OMX_PARAM_CONTENTURITYPE;
+
+/* Parameter specifying the pipe to use. */
+/** @ingroup cp */
+typedef struct OMX_PARAM_CONTENTPIPETYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
+} OMX_PARAM_CONTENTPIPETYPE;
+
+/** @ingroup rpm */
+typedef struct OMX_RESOURCECONCEALMENTTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment 
+                                            methods (like degrading algorithm quality to 
+                                            lower resource consumption or functional bypass) 
+                                            on a component as a resolution to resource conflicts. */
+} OMX_RESOURCECONCEALMENTTYPE;
+
+
+/** @ingroup metadata */
+typedef enum OMX_METADATACHARSETTYPE {
+    OMX_MetadataCharsetUnknown = 0,
+    OMX_MetadataCharsetASCII,
+    OMX_MetadataCharsetBinary,
+    OMX_MetadataCharsetCodePage1252,
+    OMX_MetadataCharsetUTF8,
+    OMX_MetadataCharsetJavaConformantUTF8,
+    OMX_MetadataCharsetUTF7,
+    OMX_MetadataCharsetImapUTF7,
+    OMX_MetadataCharsetUTF16LE, 
+    OMX_MetadataCharsetUTF16BE,
+    OMX_MetadataCharsetGB12345,
+    OMX_MetadataCharsetHZGB2312,
+    OMX_MetadataCharsetGB2312,
+    OMX_MetadataCharsetGB18030,
+    OMX_MetadataCharsetGBK,
+    OMX_MetadataCharsetBig5,
+    OMX_MetadataCharsetISO88591,
+    OMX_MetadataCharsetISO88592,
+    OMX_MetadataCharsetISO88593,
+    OMX_MetadataCharsetISO88594,
+    OMX_MetadataCharsetISO88595,
+    OMX_MetadataCharsetISO88596,
+    OMX_MetadataCharsetISO88597,
+    OMX_MetadataCharsetISO88598,
+    OMX_MetadataCharsetISO88599,
+    OMX_MetadataCharsetISO885910,
+    OMX_MetadataCharsetISO885913,
+    OMX_MetadataCharsetISO885914,
+    OMX_MetadataCharsetISO885915,
+    OMX_MetadataCharsetShiftJIS,
+    OMX_MetadataCharsetISO2022JP,
+    OMX_MetadataCharsetISO2022JP1,
+    OMX_MetadataCharsetISOEUCJP,
+    OMX_MetadataCharsetSMS7Bit,
+    OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
+} OMX_METADATACHARSETTYPE;
+
+/** @ingroup metadata */
+typedef enum OMX_METADATASCOPETYPE
+{
+    OMX_MetadataScopeAllLevels,
+    OMX_MetadataScopeTopLevel,
+    OMX_MetadataScopePortLevel,
+    OMX_MetadataScopeNodeLevel,
+    OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataScopeTypeMax = 0x7fffffff
+} OMX_METADATASCOPETYPE;
+
+/** @ingroup metadata */
+typedef enum OMX_METADATASEARCHMODETYPE
+{
+    OMX_MetadataSearchValueSizeByIndex,
+    OMX_MetadataSearchItemByIndex,
+    OMX_MetadataSearchNextItemByKey,
+    OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MetadataSearchTypeMax = 0x7fffffff
+} OMX_METADATASEARCHMODETYPE;
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_METADATAITEMCOUNTTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_METADATASCOPETYPE eScopeMode;
+    OMX_U32 nScopeSpecifier;
+    OMX_U32 nMetadataItemCount;
+} OMX_CONFIG_METADATAITEMCOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_METADATAITEMTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_METADATASCOPETYPE eScopeMode;
+    OMX_U32 nScopeSpecifier;
+    OMX_U32 nMetadataItemIndex;  
+    OMX_METADATASEARCHMODETYPE eSearchMode;
+    OMX_METADATACHARSETTYPE eKeyCharset;
+    OMX_U8 nKeySizeUsed;
+    OMX_U8 nKey[128];
+    OMX_METADATACHARSETTYPE eValueCharset;
+    OMX_STRING sLanguageCountry;
+    OMX_U32 nValueMaxSize;
+    OMX_U32 nValueSizeUsed;
+    OMX_U8 nValue[1];
+} OMX_CONFIG_METADATAITEMTYPE;
+
+/* @ingroup metadata */
+typedef struct OMX_CONFIG_CONTAINERNODECOUNTTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;
+    OMX_U32 nParentNodeID;
+    OMX_U32 nNumNodes;
+} OMX_CONFIG_CONTAINERNODECOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_CONFIG_CONTAINERNODEIDTYPE
+{
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAllKeys;
+    OMX_U32 nParentNodeID;
+    OMX_U32 nNodeIndex; 
+    OMX_U32 nNodeID; 
+    OMX_STRING cNodeName;
+    OMX_BOOL bIsLeafType;
+} OMX_CONFIG_CONTAINERNODEIDTYPE;
+
+/** @ingroup metadata */
+typedef struct OMX_PARAM_METADATAFILTERTYPE 
+{ 
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_BOOL bAllKeys;	/* if true then this structure refers to all keys and 
+                         * the three key fields below are ignored */
+    OMX_METADATACHARSETTYPE eKeyCharset;
+    OMX_U32 nKeySizeUsed; 
+    OMX_U8   nKey [128]; 
+    OMX_U32 nLanguageCountrySizeUsed;
+    OMX_U8 nLanguageCountry[128];
+    OMX_BOOL bEnabled;	/* if true then key is part of filter (e.g. 
+                         * retained for query later). If false then
+                         * key is not part of filter */
+} OMX_PARAM_METADATAFILTERTYPE; 
+
+/** The OMX_HANDLETYPE structure defines the component handle.  The component 
+ *  handle is used to access all of the component's public methods and also
+ *  contains pointers to the component's private data area.  The component
+ *  handle is initialized by the OMX core (with help from the component)
+ *  during the process of loading the component.  After the component is
+ *  successfully loaded, the application can safely access any of the
+ *  component's public functions (although some may return an error because
+ *  the state is inappropriate for the access).
+ * 
+ *  @ingroup comp
+ */
+typedef struct OMX_COMPONENTTYPE
+{
+    /** The size of this structure, in bytes.  It is the responsibility
+        of the allocator of this structure to fill in this value.  Since
+        this structure is allocated by the GetHandle function, this
+        function will fill in this value. */
+    OMX_U32 nSize;
+
+    /** nVersion is the version of the OMX specification that the structure 
+        is built against.  It is the responsibility of the creator of this 
+        structure to initialize this value and every user of this structure 
+        should verify that it knows how to use the exact version of 
+        this structure found herein. */
+    OMX_VERSIONTYPE nVersion;
+
+    /** pComponentPrivate is a pointer to the component private data area.  
+        This member is allocated and initialized by the component when the 
+        component is first loaded.  The application should not access this 
+        data area. */
+    OMX_PTR pComponentPrivate;
+
+    /** pApplicationPrivate is a pointer that is a parameter to the 
+        OMX_GetHandle method, and contains an application private value 
+        provided by the IL client.  This application private data is 
+        returned to the IL Client by OMX in all callbacks */
+    OMX_PTR pApplicationPrivate;
+
+    /** refer to OMX_GetComponentVersion in OMX_core.h or the OMX IL 
+        specification for details on the GetComponentVersion method.
+     */
+    OMX_ERRORTYPE (*GetComponentVersion)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STRING pComponentName,
+            OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
+            OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
+            OMX_OUT OMX_UUIDTYPE* pComponentUUID);
+
+    /** refer to OMX_SendCommand in OMX_core.h or the OMX IL 
+        specification for details on the SendCommand method.
+     */
+    OMX_ERRORTYPE (*SendCommand)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_COMMANDTYPE Cmd,
+            OMX_IN  OMX_U32 nParam1,
+            OMX_IN  OMX_PTR pCmdData);
+
+    /** refer to OMX_GetParameter in OMX_core.h or the OMX IL 
+        specification for details on the GetParameter method.
+     */
+    OMX_ERRORTYPE (*GetParameter)(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nParamIndex,  
+            OMX_INOUT OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to OMX_SetParameter in OMX_core.h or the OMX IL 
+        specification for details on the SetParameter method.
+     */
+    OMX_ERRORTYPE (*SetParameter)(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nIndex,
+            OMX_IN  OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to OMX_GetConfig in OMX_core.h or the OMX IL 
+        specification for details on the GetConfig method.
+     */
+    OMX_ERRORTYPE (*GetConfig)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_INOUT OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to OMX_SetConfig in OMX_core.h or the OMX IL 
+        specification for details on the SetConfig method.
+     */
+    OMX_ERRORTYPE (*SetConfig)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_IN  OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to OMX_GetExtensionIndex in OMX_core.h or the OMX IL 
+        specification for details on the GetExtensionIndex method.
+     */
+    OMX_ERRORTYPE (*GetExtensionIndex)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_STRING cParameterName,
+            OMX_OUT OMX_INDEXTYPE* pIndexType);
+
+
+    /** refer to OMX_GetState in OMX_core.h or the OMX IL 
+        specification for details on the GetState method.
+     */
+    OMX_ERRORTYPE (*GetState)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STATETYPE* pState);
+
+    
+    /** The ComponentTunnelRequest method will interact with another OMX
+        component to determine if tunneling is possible and to setup the
+        tunneling.  The return codes for this method can be used to 
+        determine if tunneling is not possible, or if tunneling is not
+        supported.  
+        
+        Base profile components (i.e. non-interop) do not support this
+        method and should return OMX_ErrorNotImplemented 
+
+        The interop profile component MUST support tunneling to another 
+        interop profile component with a compatible port parameters.  
+        A component may also support proprietary communication.
+        
+        If proprietary communication is supported the negotiation of 
+        proprietary communication is done outside of OMX in a vendor 
+        specific way. It is only required that the proper result be 
+        returned and the details of how the setup is done is left 
+        to the component implementation.  
+    
+        When this method is invoked when nPort in an output port, the
+        component will:
+        1.  Populate the pTunnelSetup structure with the output port's 
+            requirements and constraints for the tunnel.
+
+        When this method is invoked when nPort in an input port, the
+        component will:
+        1.  Query the necessary parameters from the output port to 
+            determine if the ports are compatible for tunneling
+        2.  If the ports are compatible, the component should store
+            the tunnel step provided by the output port
+        3.  Determine which port (either input or output) is the buffer
+            supplier, and call OMX_SetParameter on the output port to
+            indicate this selection.
+        
+        The component will return from this call within 5 msec.
+    
+        @param [in] hComp
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the OMX_GetHandle method.
+        @param [in] nPort
+            nPort is used to select the port on the component to be used
+            for tunneling.
+        @param [in] hTunneledComp
+            Handle of the component to tunnel with.  This is the component 
+            handle returned by the call to the OMX_GetHandle method.  When
+            this parameter is 0x0 the component should setup the port for
+            communication with the application / IL Client.
+        @param [in] nPortOutput
+            nPortOutput is used indicate the port the component should
+            tunnel with.
+        @param [in] pTunnelSetup
+            Pointer to the tunnel setup structure.  When nPort is an output port
+            the component should populate the fields of this structure.  When
+            When nPort is an input port the component should review the setup
+            provided by the component with the output port.
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        @ingroup tun
+    */
+
+    OMX_ERRORTYPE (*ComponentTunnelRequest)(
+        OMX_IN  OMX_HANDLETYPE hComp,
+        OMX_IN  OMX_U32 nPort,
+        OMX_IN  OMX_HANDLETYPE hTunneledComp,
+        OMX_IN  OMX_U32 nTunneledPort,
+        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup); 
+
+    /** refer to OMX_UseBuffer in OMX_core.h or the OMX IL 
+        specification for details on the UseBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*UseBuffer)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes,
+            OMX_IN OMX_U8* pBuffer);
+
+    /** refer to OMX_AllocateBuffer in OMX_core.h or the OMX IL 
+        specification for details on the AllocateBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*AllocateBuffer)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes);
+
+    /** refer to OMX_FreeBuffer in OMX_core.h or the OMX IL 
+        specification for details on the FreeBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FreeBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_U32 nPortIndex,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to OMX_EmptyThisBuffer in OMX_core.h or the OMX IL 
+        specification for details on the EmptyThisBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyThisBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to OMX_FillThisBuffer in OMX_core.h or the OMX IL 
+        specification for details on the FillThisBuffer method.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillThisBuffer)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The SetCallbacks method is used by the core to specify the callback
+        structure from the application to the component.  This is a blocking
+        call.  The component will return from this call within 5 msec.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param [in] pCallbacks
+            pointer to an OMX_CALLBACKTYPE structure used to provide the 
+            callback information to the component
+        @param [in] pAppData
+            pointer to an application defined value.  It is anticipated that 
+            the application will pass a pointer to a data structure or a "this
+            pointer" in this area to allow the callback (in the application)
+            to determine the context of the call
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    OMX_ERRORTYPE (*SetCallbacks)(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_CALLBACKTYPE* pCallbacks, 
+            OMX_IN  OMX_PTR pAppData);
+
+    /** ComponentDeInit method is used to deinitialize the component
+        providing a means to free any resources allocated at component
+        initialization.  NOTE:  After this call the component handle is
+        not valid for further use.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @return OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    OMX_ERRORTYPE (*ComponentDeInit)(
+            OMX_IN  OMX_HANDLETYPE hComponent);
+
+    /** @ingroup buf */
+    OMX_ERRORTYPE (*UseEGLImage)(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN void* eglImage);
+
+    OMX_ERRORTYPE (*ComponentRoleEnum)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+		OMX_OUT OMX_U8 *cRole,
+		OMX_IN OMX_U32 nIndex);
+
+} OMX_COMPONENTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_ContentPipe.h b/OpenMAXIL/ghdr/OMX_ContentPipe.h
new file mode 100755
index 0000000..107faef
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_ContentPipe.h
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_ContentPipe.h - OpenMax IL version 1.1.2
+ *  The OMX_ContentPipe header file contains the definitions used to define
+ *  the public interface for content piples.  This header file is intended to
+ *  be used by the component.
+ */
+
+#ifndef OMX_CONTENTPIPE_H
+#define OMX_CONTENTPIPE_H
+
+#ifndef KD_EACCES
+/* OpenKODE error codes. CPResult values may be zero (indicating success
+   or one of the following values) */
+#define KD_EACCES (1)
+#define KD_EADDRINUSE (2)
+#define KD_EAGAIN (5)
+#define KD_EBADF (7)
+#define KD_EBUSY (8)
+#define KD_ECONNREFUSED (9)
+#define KD_ECONNRESET (10)
+#define KD_EDEADLK (11)
+#define KD_EDESTADDRREQ (12)
+#define KD_ERANGE (35)
+#define KD_EEXIST (13)
+#define KD_EFBIG (14)
+#define KD_EHOSTUNREACH (15)
+#define KD_EINVAL (17)
+#define KD_EIO (18)
+#define KD_EISCONN (20)
+#define KD_EISDIR (21)
+#define KD_EMFILE (22)
+#define KD_ENAMETOOLONG (23)
+#define KD_ENOENT (24)
+#define KD_ENOMEM (25)
+#define KD_ENOSPC (26)
+#define KD_ENOSYS (27)
+#define KD_ENOTCONN (28)
+#define KD_EPERM (33)
+#define KD_ETIMEDOUT (36)
+#define KD_EILSEQ (19)
+#define KD_ENETWORKFAIL (20)
+#endif
+
+/** Map types from OMX standard types only here so interface is as generic as possible. */
+typedef OMX_U32    CPresult;
+typedef char *     CPstring;  
+typedef void *     CPhandle;
+typedef OMX_U32    CPuint;
+typedef OMX_S32    CPint;  
+typedef OMX_S64    CPint64;  
+typedef char       CPbyte;  
+typedef OMX_BOOL   CPbool;
+
+/** enumeration of origin types used in the CP_PIPETYPE's Seek function 
+ * @ingroup cp
+ */
+typedef enum CP_ORIGINTYPE {
+    CP_OriginBegin,      
+    CP_OriginCur,      
+    CP_OriginEnd,      
+    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_OriginMax = 0X7FFFFFFF
+} CP_ORIGINTYPE;
+
+/** enumeration of contact access types used in the CP_PIPETYPE's Open function 
+ * @ingroup cp
+ */
+typedef enum CP_ACCESSTYPE {
+    CP_AccessRead,      
+    CP_AccessWrite,  
+    CP_AccessReadWrite ,  
+    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_AccessMax = 0X7FFFFFFF
+} CP_ACCESSTYPE;
+
+/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function 
+ * @ingroup cp
+ */
+typedef enum CP_CHECKBYTESRESULTTYPE
+{
+    CP_CheckBytesOk,                    /**< There are at least the request number 
+                                              of bytes available */
+    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes 
+                                              and presently lacks sufficient bytes. 
+                                              Client will be called when they are 
+                                              sufficient bytes are available. */
+    CP_CheckBytesInsufficientBytes  ,     /**< The pipe has retrieved all bytes 
+                                              but those available are less than those 
+                                              requested */
+    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
+                                              and no more bytes are available. */
+    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
+    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_CheckBytesMax = 0X7FFFFFFF
+} CP_CHECKBYTESRESULTTYPE;
+
+/** enumeration of content pipe events sent to the client callback. 
+ * @ingroup cp
+ */
+typedef enum CP_EVENTTYPE{
+    CP_BytesAvailable,      	    /** bytes requested in a CheckAvailableBytes call are now available*/
+    CP_Overflow,  		           /** enumeration of content pipe events sent to the client callback*/
+    CP_PipeDisconnected  ,  		    /** enumeration of content pipe events sent to the client callback*/
+    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_EventMax = 0X7FFFFFFF
+} CP_EVENTTYPE;
+
+/** content pipe definition 
+ * @ingroup cp
+ */
+typedef struct CP_PIPETYPE
+{
+    /** Open a content stream for reading or writing. */ 
+    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
+
+    /** Close a content stream. */ 
+    CPresult (*Close)( CPhandle hContent );
+
+    /** Create a content source and open it for writing. */ 
+    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
+
+    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
+    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
+
+    /** Seek to certain position in the content relative to the specified origin. */
+    CPresult (*SetPosition)( CPhandle  hContent, CPint64 nOffset, CP_ORIGINTYPE eOrigin);
+
+    /** Retrieve the current position relative to the start of the content. */
+    CPresult (*GetPosition)( CPhandle hContent, CPint64 *pPosition);
+
+    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
+    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize); 
+
+    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes. 
+       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
+       returns the size of the block actually read. Content pointer advances the by the returned size. 
+       Note: pipe provides pointer. This function is appropriate for large reads. The client must call 
+       ReleaseReadBuffer when done with buffer. 
+
+       In some cases the requested block may not reside in contiguous memory within the
+       pipe implementation. For instance if the pipe leverages a circular buffer then the requested 
+       block may straddle the boundary of the circular buffer. By default a pipe implementation 
+       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
+       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory 
+       boundary. Here the client may retrieve the data in segments over successive calls. */
+    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
+
+    /** Release a buffer obtained by ReadBuffer back to the pipe. */
+    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
+
+    /** Write data of the specified size to the content (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
+    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize); 
+
+    /** Retrieve a buffer allocated by the pipe used to write data to the content. 
+       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
+       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
+    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
+
+    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the 
+       the contents of the buffer to content and advance content pointer by the size of the buffer */
+    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
+
+    /** Register a per-handle client callback with the content pipe. */
+    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
+
+} CP_PIPETYPE;
+
+#endif
+
diff --git a/OpenMAXIL/ghdr/OMX_Core.h b/OpenMAXIL/ghdr/OMX_Core.h
new file mode 100755
index 0000000..19c03b6
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Core.h
@@ -0,0 +1,1431 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Core.h - OpenMax IL version 1.1.2
+ *  The OMX_Core header file contains the definitions used by both the
+ *  application and the component to access common items.
+ */
+
+#ifndef OMX_Core_h
+#define OMX_Core_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header shall include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Index.h>
+
+
+/** The OMX_COMMANDTYPE enumeration is used to specify the action in the
+ *  OMX_SendCommand macro.  
+ *  @ingroup core
+ */
+typedef enum OMX_COMMANDTYPE
+{
+    OMX_CommandStateSet,    /**< Change the component state */
+    OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
+    OMX_CommandPortDisable, /**< Disable a port on a component. */
+    OMX_CommandPortEnable,  /**< Enable a port on a component. */
+    OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
+    OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_CommandMax = 0X7FFFFFFF
+} OMX_COMMANDTYPE;
+
+
+
+/** The OMX_STATETYPE enumeration is used to indicate or change the component
+ *  state.  This enumeration reflects the current state of the component when
+ *  used with the OMX_GetState macro or becomes the parameter in a state change
+ *  command when used with the OMX_SendCommand macro.
+ *
+ *  The component will be in the Loaded state after the component is initially
+ *  loaded into memory.  In the Loaded state, the component is not allowed to
+ *  allocate or hold resources other than to build it's internal parameter
+ *  and configuration tables.  The application will send one or more
+ *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
+ *  component and the component will record each of these parameter and
+ *  configuration changes for use later.  When the application sends the
+ *  Idle command, the component will acquire the resources needed for the
+ *  specified configuration and will transition to the idle state if the
+ *  allocation is successful.  If the component cannot successfully
+ *  transition to the idle state for any reason, the state of the component
+ *  shall be fully rolled back to the Loaded state (e.g. all allocated 
+ *  resources shall be released).  When the component receives the command
+ *  to go to the Executing state, it shall begin processing buffers by
+ *  sending all input buffers it holds to the application.  While
+ *  the component is in the Idle state, the application may also send the
+ *  Pause command.  If the component receives the pause command while in the
+ *  Idle state, the component shall send all input buffers it holds to the 
+ *  application, but shall not begin processing buffers.  This will allow the
+ *  application to prefill buffers.
+ * 
+ *  @ingroup comp
+ */
+
+typedef enum OMX_STATETYPE
+{
+    OMX_StateInvalid,      /**< component has detected that it's internal data 
+                                structures are corrupted to the point that
+                                it cannot determine it's state properly */
+    OMX_StateLoaded,      /**< component has been loaded but has not completed
+                                initialization.  The OMX_SetParameter macro
+                                and the OMX_GetParameter macro are the only 
+                                valid macros allowed to be sent to the 
+                                component in this state. */
+    OMX_StateIdle,        /**< component initialization has been completed
+                                successfully and the component is ready to
+                                to start. */
+    OMX_StateExecuting,   /**< component has accepted the start command and
+                                is processing data (if data is available) */
+    OMX_StatePause,       /**< component has received pause command */
+    OMX_StateWaitForResources, /**< component is waiting for resources, either after 
+                                preemption or before it gets the resources requested.
+                                See specification for complete details. */
+    OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_StateMax = 0X7FFFFFFF
+} OMX_STATETYPE;
+
+/** The OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These 
+ *  errors should cover most of the common failure cases.  However, 
+ *  vendors are free to add additional error messages of their own as 
+ *  long as they follow these rules:
+ *  1.  Vendor error messages shall be in the range of 0x90000000 to
+ *      0x9000FFFF.
+ *  2.  Vendor error messages shall be defined in a header file provided
+ *      with the component.  No error messages are allowed that are
+ *      not defined.
+ */
+typedef enum OMX_ERRORTYPE
+{
+  OMX_ErrorNone = 0,
+
+  /** There were insufficient resources to perform the requested operation */
+  OMX_ErrorInsufficientResources = (OMX_S32) 0x80001000,
+
+  /** There was an error, but the cause of the error could not be determined */
+  OMX_ErrorUndefined = (OMX_S32) 0x80001001,
+
+  /** The component name string was not valid */
+  OMX_ErrorInvalidComponentName = (OMX_S32) 0x80001002,
+
+  /** No component with the specified name string was found */
+  OMX_ErrorComponentNotFound = (OMX_S32) 0x80001003,
+
+  /** The component specified did not have a "OMX_ComponentInit" or
+      "OMX_ComponentDeInit entry point */
+  OMX_ErrorInvalidComponent = (OMX_S32) 0x80001004,
+
+  /** One or more parameters were not valid */
+  OMX_ErrorBadParameter = (OMX_S32) 0x80001005,
+
+  /** The requested function is not implemented */
+  OMX_ErrorNotImplemented = (OMX_S32) 0x80001006,
+
+  /** The buffer was emptied before the next buffer was ready */
+  OMX_ErrorUnderflow = (OMX_S32) 0x80001007,
+
+  /** The buffer was not available when it was needed */
+  OMX_ErrorOverflow = (OMX_S32) 0x80001008,
+
+  /** The hardware failed to respond as expected */
+  OMX_ErrorHardware = (OMX_S32) 0x80001009,
+
+  /** The component is in the state OMX_StateInvalid */
+  OMX_ErrorInvalidState = (OMX_S32) 0x8000100A,
+
+  /** Stream is found to be corrupt */
+  OMX_ErrorStreamCorrupt = (OMX_S32) 0x8000100B,
+
+  /** Ports being connected are not compatible */
+  OMX_ErrorPortsNotCompatible = (OMX_S32) 0x8000100C,
+
+  /** Resources allocated to an idle component have been
+      lost resulting in the component returning to the loaded state */
+  OMX_ErrorResourcesLost = (OMX_S32) 0x8000100D,
+
+  /** No more indicies can be enumerated */
+  OMX_ErrorNoMore = (OMX_S32) 0x8000100E,
+
+  /** The component detected a version mismatch */
+  OMX_ErrorVersionMismatch = (OMX_S32) 0x8000100F,
+
+  /** The component is not ready to return data at this time */
+  OMX_ErrorNotReady = (OMX_S32) 0x80001010,
+
+  /** There was a timeout that occurred */
+  OMX_ErrorTimeout = (OMX_S32) 0x80001011,
+
+  /** This error occurs when trying to transition into the state you are already in */
+  OMX_ErrorSameState = (OMX_S32) 0x80001012,
+
+  /** Resources allocated to an executing or paused component have been 
+      preempted, causing the component to return to the idle state */
+  OMX_ErrorResourcesPreempted = (OMX_S32) 0x80001013, 
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
+      on a port restart) when it deems that it has waited an unusually long time for the supplier 
+      to send it an allocated buffer via a UseBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringAllocation = (OMX_S32) 0x80001014,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the deallocation of buffers (on a transition from the IDLE to LOADED state or 
+      on a port stop) when it deems that it has waited an unusually long time for the supplier 
+      to request the deallocation of a buffer header via a FreeBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringDeallocation = (OMX_S32) 0x80001015,
+
+  /** A supplier port sends this error to the IL client (via the EventHandler callback) 
+      during the stopping of a port (either on a transition from the IDLE to LOADED 
+      state or a port stop) when it deems that it has waited an unusually long time for 
+      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
+  OMX_ErrorPortUnresponsiveDuringStop = (OMX_S32) 0x80001016,
+
+  /** Attempting a state transtion that is not allowed */
+  OMX_ErrorIncorrectStateTransition = (OMX_S32) 0x80001017,
+
+  /* Attempting a command that is not allowed during the present state. */
+  OMX_ErrorIncorrectStateOperation = (OMX_S32) 0x80001018, 
+
+  /** The values encapsulated in the parameter or config structure are not supported. */
+  OMX_ErrorUnsupportedSetting = (OMX_S32) 0x80001019,
+
+  /** The parameter or config indicated by the given index is not supported. */
+  OMX_ErrorUnsupportedIndex = (OMX_S32) 0x8000101A,
+
+  /** The port index supplied is incorrect. */
+  OMX_ErrorBadPortIndex = (OMX_S32) 0x8000101B,
+
+  /** The port has lost one or more of its buffers and it thus unpopulated. */
+  OMX_ErrorPortUnpopulated = (OMX_S32) 0x8000101C,
+
+  /** Component suspended due to temporary loss of resources */
+  OMX_ErrorComponentSuspended = (OMX_S32) 0x8000101D,
+
+  /** Component suspended due to an inability to acquire dynamic resources */
+  OMX_ErrorDynamicResourcesUnavailable = (OMX_S32) 0x8000101E,
+
+  /** When the macroblock error reporting is enabled the component returns new error 
+  for every frame that has errors */
+  OMX_ErrorMbErrorsInFrame = (OMX_S32) 0x8000101F,
+
+  /** A component reports this error when it cannot parse or determine the format of an input stream. */
+  OMX_ErrorFormatNotDetected = (OMX_S32) 0x80001020, 
+
+  /** The content open operation failed. */
+  OMX_ErrorContentPipeOpenFailed = (OMX_S32) 0x80001021,
+
+  /** The content creation operation failed. */
+  OMX_ErrorContentPipeCreationFailed = (OMX_S32) 0x80001022,
+
+  /** Separate table information is being used */
+  OMX_ErrorSeperateTablesUsed = (OMX_S32) 0x80001023,
+
+  /** Tunneling is unsupported by the component*/
+  OMX_ErrorTunnelingUnsupported = (OMX_S32) 0x80001024,
+
+  OMX_ErrorKhronosExtensions = (OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+  OMX_ErrorVendorStartUnused = (OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
+  OMX_ErrorMax = 0x7FFFFFFF
+} OMX_ERRORTYPE;
+
+/** @ingroup core */
+typedef OMX_ERRORTYPE (* OMX_COMPONENTINITTYPE)(OMX_IN  OMX_HANDLETYPE hComponent);
+
+/** @ingroup core */
+typedef struct OMX_COMPONENTREGISTERTYPE
+{
+  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
+  OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+} OMX_COMPONENTREGISTERTYPE;
+
+/** @ingroup core */
+extern OMX_COMPONENTREGISTERTYPE OMX_ComponentRegistered[];
+
+/** @ingroup rpm */
+typedef struct OMX_PRIORITYMGMTTYPE {
+ OMX_U32 nSize;             /**< size of the structure in bytes */
+ OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+ OMX_U32 nGroupPriority;            /**< Priority of the component group */
+ OMX_U32 nGroupID;                  /**< ID of the component group */
+} OMX_PRIORITYMGMTTYPE;
+
+/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
+#define OMX_MAX_STRINGNAME_SIZE 128
+
+/** @ingroup comp */
+typedef struct OMX_PARAM_COMPONENTROLETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
+} OMX_PARAM_COMPONENTROLETYPE;
+
+/** End of Stream Buffer Flag: 
+  *
+  * A component sets EOS when it has no more data to emit on a particular 
+  * output port. Thus an output port shall set EOS on the last buffer it 
+  * emits. A component's determination of when an output port should 
+  * cease sending data is implemenation specific.
+  * @ingroup buf
+  */
+
+#define OMX_BUFFERFLAG_EOS 0x00000001 
+
+/** Start Time Buffer Flag: 
+ *
+ * The source of a stream (e.g. a demux component) sets the STARTTIME
+ * flag on the buffer that contains the starting timestamp for the
+ * stream. The starting timestamp corresponds to the first data that
+ * should be displayed at startup or after a seek.
+ * The first timestamp of the stream is not necessarily the start time.
+ * For instance, in the case of a seek to a particular video frame, 
+ * the target frame may be an interframe. Thus the first buffer of 
+ * the stream will be the intra-frame preceding the target frame and
+ * the starttime will occur with the target frame (with any other
+ * required frames required to reconstruct the target intervening).
+ *
+ * The STARTTIME flag is directly associated with the buffer's 
+ * timestamp ' thus its association to buffer data and its 
+ * propagation is identical to the timestamp's.
+ *
+ * When a Sync Component client receives a buffer with the 
+ * STARTTIME flag it shall perform a SetConfig on its sync port 
+ * using OMX_ConfigTimeClientStartTime and passing the buffer's
+ * timestamp.
+ * 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_STARTTIME 0x00000002
+
+ 
+
+/** Decode Only Buffer Flag: 
+ *
+ * The source of a stream (e.g. a demux component) sets the DECODEONLY
+ * flag on any buffer that should shall be decoded but should not be
+ * displayed. This flag is used, for instance, when a source seeks to 
+ * a target interframe that requires the decode of frames preceding the 
+ * target to facilitate the target's reconstruction. In this case the 
+ * source would emit the frames preceding the target downstream 
+ * but mark them as decode only.
+ *
+ * The DECODEONLY is associated with buffer data and propagated in a 
+ * manner identical to the buffer timestamp.
+ *
+ * A component that renders data should ignore all buffers with 
+ * the DECODEONLY flag set.
+ * 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DECODEONLY 0x00000004
+
+
+/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt 
+ * @ingroup buf
+ */
+
+#define OMX_BUFFERFLAG_DATACORRUPT 0x00000008
+
+/* End of Frame: The buffer contains exactly one end of frame and no data
+ *  occurs after the end of frame. This flag is an optional hint. The absence
+ *  of this flag does not imply the absence of an end of frame within the buffer. 
+ * @ingroup buf
+*/
+#define OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
+
+/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame ' 
+ *  a frame that has no dependency on any other frame information 
+ *  @ingroup buf
+ */
+#define OMX_BUFFERFLAG_SYNCFRAME 0x00000020
+
+/* Extra data present flag: there is extra data appended to the data stream
+ * residing in the buffer 
+ * @ingroup buf  
+ */
+#define OMX_BUFFERFLAG_EXTRADATA 0x00000040
+
+/** Codec Config Buffer Flag: 
+* OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
+* output port when all bytes in the buffer form part or all of a set of
+* codec specific configuration data.  Examples include SPS/PPS nal units
+* for OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
+* OMX_AUDIO_CodingAAC.  Any component that for a given stream sets 
+* OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
+* with frame data in the same buffer, and shall send all buffers
+* containing codec configuration bytes before any buffers containing
+* frame data that those configurations bytes describe.
+* If the stream format for a particular codec has a frame specific
+* header at the start of each frame, for example OMX_AUDIO_CodingMP3 or
+* OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
+* normal without setting OMX_BUFFERFLAG_CODECCONFIG.
+ * @ingroup buf
+ */
+#define OMX_BUFFERFLAG_CODECCONFIG 0x00000080
+
+
+
+/** @ingroup buf */
+typedef struct OMX_BUFFERHEADERTYPE
+{
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U8* pBuffer;            /**< Pointer to actual block of memory 
+                                     that is acting as the buffer */
+    OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
+    OMX_U32 nFilledLen;         /**< number of bytes currently in the 
+                                     buffer */
+    OMX_U32 nOffset;            /**< start offset of valid data in bytes from
+                                     the start of the buffer */
+    OMX_PTR pAppPrivate;        /**< pointer to any data the application
+                                     wants to associate with this buffer */
+    OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
+                                     wants to associate with this buffer */ 
+    OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
+                                     wants to associate with this buffer */
+    OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
+                                     wants to associate with this buffer */
+    OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a 
+                                              mark event upon processing this buffer. */
+    OMX_PTR pMarkData;          /**< Application specific data associated with 
+                                     the mark sent on a mark event to disambiguate 
+                                     this mark from others. */
+    OMX_U32 nTickCount;         /**< Optional entry that the component and
+                                     application can update with a tick count
+                                     when they access the component.  This
+                                     value should be in microseconds.  Since
+                                     this is a value relative to an arbitrary
+                                     starting point, this value cannot be used 
+                                     to determine absolute time.  This is an
+                                     optional entry and not all components
+                                     will update it.*/
+ OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample 
+                                     starting at the first logical sample 
+                                     boundary in the buffer. Timestamps of 
+                                     successive samples within the buffer may
+                                     be inferred by adding the duration of the 
+                                     of the preceding buffer to the timestamp
+                                     of the preceding buffer.*/
+  OMX_U32     nFlags;           /**< buffer specific flags */
+  OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using 
+                                     this buffer */
+  OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
+                                     this buffer */
+} OMX_BUFFERHEADERTYPE;
+
+/** The OMX_EXTRADATATYPE enumeration is used to define the 
+ * possible extra data payload types.
+ * NB: this enum is binary backwards compatible with the previous
+ * OMX_EXTRADATA_QUANT define.  This should be replaced with
+ * OMX_ExtraDataQuantization.
+ */
+typedef enum OMX_EXTRADATATYPE
+{
+   OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */        
+   OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
+   OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_ExtraDataMax = 0x7FFFFFFF
+} OMX_EXTRADATATYPE;
+
+
+typedef struct OMX_OTHER_EXTRADATATYPE  {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;
+    OMX_EXTRADATATYPE eType;       /* Extra Data type */
+    OMX_U32 nDataSize;   /* Size of the supporting data to follow */
+    OMX_U8  data[1];     /* Supporting data hint  */
+} OMX_OTHER_EXTRADATATYPE;
+
+/** @ingroup comp */
+typedef struct OMX_PORT_PARAM_TYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPorts;             /**< The number of ports for this component */
+    OMX_U32 nStartPortNumber;   /** first port number for this type of port */
+} OMX_PORT_PARAM_TYPE; 
+
+/** @ingroup comp */
+typedef enum OMX_EVENTTYPE
+{
+    OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
+    OMX_EventError,               /**< component has detected an error condition */
+    OMX_EventMark,                /**< component has detected a buffer mark */
+    OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
+    OMX_EventBufferFlag,          /**< component has detected an EOS */ 
+    OMX_EventResourcesAcquired,   /**< component has been granted resources and is
+                                       automatically starting the state change from
+                                       OMX_StateWaitForResources to OMX_StateIdle. */
+   OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
+   OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
+   OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
+   OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+   OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   OMX_EventMax = 0x7FFFFFFF
+} OMX_EVENTTYPE;
+
+typedef struct OMX_CALLBACKTYPE
+{
+    /** The EventHandler method is used to notify the application when an
+        event of interest occurs.  Events are defined in the OMX_EVENTTYPE
+        enumeration.  Please see that enumeration for details of what will
+        be returned for each type of event. Callbacks should not return
+        an error to the component, so if an error occurs, the application 
+        shall handle it internally.  This is a blocking call.
+
+        The application should return from this call within 5 msec to avoid
+        blocking the component for an excessively long period of time.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param eEvent
+            Event that the component wants to notify the application about.
+        @param nData1
+            nData will be the OMX_ERRORTYPE for an error event and will be 
+            an OMX_COMMANDTYPE for a command complete event and OMX_INDEXTYPE for a OMX_PortSettingsChanged event.
+         @param nData2
+            nData2 will hold further information related to the event. Can be OMX_STATETYPE for
+            a OMX_CommandStateSet command or port index for a OMX_PortSettingsChanged event.
+            Default value is 0 if not used. )
+        @param pEventData
+            Pointer to additional event-specific data (see spec for meaning).
+      */
+
+   OMX_ERRORTYPE (*EventHandler)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_EVENTTYPE eEvent,
+        OMX_IN OMX_U32 nData1,
+        OMX_IN OMX_U32 nData2,
+        OMX_IN OMX_PTR pEventData);
+
+    /** The EmptyBufferDone method is used to return emptied buffers from an
+        input port back to the application for reuse.  This is a blocking call 
+        so the application should not attempt to refill the buffers during this
+        call, but should queue them and refill them in another thread.  There
+        is no error return, so the application shall handle any errors generated
+        internally.  
+        
+        The application should return from this call within 5 msec.
+        
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was emptied.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*EmptyBufferDone)(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The FillBufferDone method is used to return filled buffers from an
+        output port back to the application for emptying and then reuse.  
+        This is a blocking call so the application should not attempt to 
+        empty the buffers during this call, but should queue the buffers 
+        and empty them in another thread.  There is no error return, so 
+        the application shall handle any errors generated internally.  The 
+        application shall also update the buffer header to indicate the
+        number of bytes placed into the buffer.  
+
+        The application should return from this call within 5 msec.
+        
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the 
+            pAppData parameter to the OMX_GetHandle method for the component.
+            This application defined value is provided so that the application 
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was filled.
+        @ingroup buf
+     */
+    OMX_ERRORTYPE (*FillBufferDone)(
+        OMX_OUT OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_PTR pAppData,
+        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
+
+} OMX_CALLBACKTYPE;
+
+/** The OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
+    preference when tunneling between two ports.
+    @ingroup tun buf
+*/
+typedef enum OMX_BUFFERSUPPLIERTYPE
+{
+    OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
+                                              or don't care */
+    OMX_BufferSupplyInput,             /**< input port supplies the buffers */
+    OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
+    OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_BufferSupplyMax = 0x7FFFFFFF
+} OMX_BUFFERSUPPLIERTYPE;
+
+
+/** buffer supplier parameter 
+ * @ingroup tun
+ */
+typedef struct OMX_PARAM_BUFFERSUPPLIERTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< port that this structure applies to */
+    OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
+} OMX_PARAM_BUFFERSUPPLIERTYPE;
+
+
+/**< indicates that buffers received by an input port of a tunnel 
+     may not modify the data in the buffers 
+     @ingroup tun
+ */
+#define OMX_PORTTUNNELFLAG_READONLY 0x00000001 
+
+
+/** The OMX_TUNNELSETUPTYPE structure is used to pass data from an output
+    port to an input port as part the two ComponentTunnelRequest calls
+    resulting from a OMX_SetupTunnel call from the IL Client. 
+    @ingroup tun
+ */   
+typedef struct OMX_TUNNELSETUPTYPE
+{
+    OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
+    OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
+} OMX_TUNNELSETUPTYPE; 
+
+/* OMX Component headers is included to enable the core to use
+   macros for functions into the component for OMX release 1.0.  
+   Developers should not access any structures or data from within
+   the component header directly */
+/* TO BE REMOVED - #include <OMX_Component.h> */
+
+/** GetComponentVersion will return information about the component.  
+    This is a blocking call.  This macro will go directly from the
+    application to the component (via a core macro).  The
+    component will return from this call within 5 msec.
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [out] pComponentName
+        pointer to an empty string of length 128 bytes.  The component 
+        will write its name into this string.  The name will be 
+        terminated by a single zero byte.  The name of a component will 
+        be 127 bytes or less to leave room for the trailing zero byte.  
+        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
+    @param [out] pComponentVersion
+        pointer to an OMX Version structure that the component will fill 
+        in.  The component will fill in a value that indicates the 
+        component version.  NOTE: the component version is NOT the same 
+        as the OMX Specification version (found in all structures).  The 
+        component version is defined by the vendor of the component and 
+        its value is entirely up to the component vendor.
+    @param [out] pSpecVersion
+        pointer to an OMX Version structure that the component will fill 
+        in.  The SpecVersion is the version of the specification that the 
+        component was built against.  Please note that this value may or 
+        may not match the structure's version.  For example, if the 
+        component was built against the 2.0 specification, but the 
+        application (which creates the structure is built against the 
+        1.0 specification the versions would be different.
+    @param [out] pComponentUUID
+        pointer to the UUID of the component which will be filled in by 
+        the component.  The UUID is a unique identifier that is set at 
+        RUN time for the component and is unique to each instantion of 
+        the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetComponentVersion(                            \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                                     \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetComponentVersion(  \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                 /* Macro End */
+
+
+/** Send a command to the component.  This call is a non-blocking call.
+    The component should check the parameters and then queue the command
+    to the component thread to be executed.  The component thread shall 
+    send the EventHandler() callback at the conclusion of the command. 
+    This macro will go directly from the application to the component (via
+    a core macro).  The component will return from this call within 5 msec.
+    
+    When the command is "OMX_CommandStateSet" the component will queue a
+    state transition to the new state idenfied in nParam.
+    
+    When the command is "OMX_CommandFlush", to flush a port's buffer queues,
+    the command will force the component to return all buffers NOT CURRENTLY 
+    BEING PROCESSED to the application, in the order in which the buffers 
+    were received.
+    
+    When the command is "OMX_CommandPortDisable" or 
+    "OMX_CommandPortEnable", the component's port (given by the value of
+    nParam) will be stopped or restarted. 
+    
+    When the command "OMX_CommandMarkBuffer" is used to mark a buffer, the
+    pCmdData will point to a OMX_MARKTYPE structure containing the component
+    handle of the component to examine the buffer chain for the mark.  nParam1
+    contains the index of the port on which the buffer mark is applied.
+
+    Specification text for more details. 
+    
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [in] Cmd
+        Command for the component to execute
+    @param [in] nParam
+        Parameter for the command to be executed.  When Cmd has the value 
+        OMX_CommandStateSet, value is a member of OMX_STATETYPE.  When Cmd has 
+        the value OMX_CommandFlush, value of nParam indicates which port(s) 
+        to flush. -1 is used to flush all ports a single port index will 
+        only flush that port.  When Cmd has the value "OMX_CommandPortDisable"
+        or "OMX_CommandPortEnable", the component's port is given by 
+        the value of nParam.  When Cmd has the value "OMX_CommandMarkBuffer"
+        the components pot is given by the value of nParam.
+    @param [in] pCmdData
+        Parameter pointing to the OMX_MARKTYPE structure when Cmd has the value
+        "OMX_CommandMarkBuffer".     
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SendCommand(                                    \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                                          \
+     ((OMX_COMPONENTTYPE*)hComponent)->SendCommand(         \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                          /* Macro End */
+
+
+/** The OMX_GetParameter macro will get one of the current parameter 
+    settings from the component.  This macro cannot only be invoked when 
+    the component is in the OMX_StateInvalid state.  The nParamIndex
+    parameter is used to indicate which structure is being requested from
+    the component.  The application shall allocate the correct structure 
+    and shall fill in the structure size and version information before 
+    invoking this macro.  When the parameter applies to a port, the
+    caller shall fill in the appropriate nPortIndex value indicating the
+    port on which the parameter applies. If the component has not had 
+    any settings changed, then the component should return a set of 
+    valid DEFAULT  parameters for the component.  This is a blocking 
+    call.  
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nParamIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentParameterStructure
+        Pointer to application allocated structure to be filled by the 
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_SetParameter macro will send an initialization parameter
+    structure to a component.  Each structure shall be sent one at a time,
+    in a separate invocation of the macro.  This macro can only be
+    invoked when the component is in the OMX_StateLoaded state, or the
+    port is disabled (when the parameter applies to a port). The 
+    nParamIndex parameter is used to indicate which structure is being
+    passed to the component.  The application shall allocate the 
+    correct structure and shall fill in the structure size and version 
+    information (as well as the actual data) before invoking this macro.
+    The application is free to dispose of this structure after the call
+    as the component is required to copy any data it shall retain.  This 
+    is a blocking call.  
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in] pComponentParameterStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetParameter(         \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The OMX_GetConfig macro will get one of the configuration structures 
+    from a component.  This macro can be invoked anytime after the 
+    component has been loaded.  The nParamIndex call parameter is used to 
+    indicate which structure is being requested from the component.  The 
+    application shall allocate the correct structure and shall fill in the 
+    structure size and version information before invoking this macro.  
+    If the component has not had this configuration parameter sent before, 
+    then the component should return a set of valid DEFAULT values for the 
+    component.  This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be filled.  This value is from the
+        OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentConfigStructure
+        pointer to application allocated structure to be filled by the 
+        component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+*/        
+#define OMX_GetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_SetConfig macro will send one of the configuration 
+    structures to a component.  Each structure shall be sent one at a time,
+    each in a separate invocation of the macro.  This macro can be invoked 
+    anytime after the component has been loaded.  The application shall 
+    allocate the correct structure and shall fill in the structure size 
+    and version information (as well as the actual data) before invoking 
+    this macro.  The application is free to dispose of this structure after 
+    the call as the component is required to copy any data it shall retain.  
+    This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nConfigIndex
+        Index of the structure to be sent.  This value is from the
+        OMX_INDEXTYPE enumeration above.
+    @param [in] pComponentConfigStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_SetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                           \
+    ((OMX_COMPONENTTYPE*)hComponent)->SetConfig(            \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The OMX_GetExtensionIndex macro will invoke a component to translate 
+    a vendor specific configuration or parameter string into an OMX 
+    structure index.  There is no requirement for the vendor to support 
+    this command for the indexes already found in the OMX_INDEXTYPE 
+    enumeration (this is done to save space in small components).  The 
+    component shall support all vendor supplied extension indexes not found
+    in the master OMX_INDEXTYPE enumeration.  This is a blocking call.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @param [in] cParameterName
+        OMX_STRING that shall be less than 128 characters long including
+        the trailing null byte.  This is the string that will get 
+        translated by the component into a configuration index.
+    @param [out] pIndexType
+        a pointer to a OMX_INDEXTYPE to receive the index value.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetExtensionIndex(                              \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetExtensionIndex(    \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                     /* Macro End */
+
+
+/** The OMX_GetState macro will invoke the component to get the current 
+    state of the component and place the state value into the location
+    pointed to by pState.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] pState
+        pointer to the location to receive the state.  The value returned
+        is one of the OMX_STATETYPE members 
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define OMX_GetState(                                       \
+        hComponent,                                         \
+        pState)                                             \
+    ((OMX_COMPONENTTYPE*)hComponent)->GetState(             \
+        hComponent,                                         \
+        pState)                         /* Macro End */
+
+
+/** The OMX_UseBuffer macro will request that the component use
+    a buffer (and allocate its own buffer header) already allocated 
+    by another component, or by the IL Client. This is a blocking 
+    call.
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to the buffer header
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+
+#define OMX_UseBuffer(                                      \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseBuffer(            \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)
+
+
+/** The OMX_AllocateBuffer macro will request that the component allocate 
+    a new buffer and buffer header.  The component will allocate the 
+    buffer and the buffer header and return a pointer to the buffer 
+    header.  This is a blocking call.
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive 
+        the pointer to the buffer header
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the 
+        buffer header structure.
+    @param [in] nSizeBytes
+        size of the buffer to allocate.  Used when bAllocateNew is true.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */    
+#define OMX_AllocateBuffer(                                 \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                                         \
+    ((OMX_COMPONENTTYPE*)hComponent)->AllocateBuffer(       \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                     /* Macro End */
+
+
+/** The OMX_FreeBuffer macro will release a buffer header from the component
+    which was allocated using either OMX_AllocateBuffer or OMX_UseBuffer. If  
+    the component allocated the buffer (see the OMX_UseBuffer macro) then 
+    the component shall free the buffer and buffer header. This is a 
+    blocking call. 
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FreeBuffer(                                     \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FreeBuffer(           \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_EmptyThisBuffer macro will send a buffer full of data to an 
+    input port of a component.  The buffer will be emptied by the component
+    and returned to the application via the EmptyBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then empty the buffer, later, at the proper 
+    time.  As expected, this macro may be invoked only while the component 
+    is in the OMX_StateExecuting.  If nPortIndex does not specify an input
+    port, the component shall return an error.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_EmptyThisBuffer(                                \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->EmptyThisBuffer(      \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The OMX_FillThisBuffer macro will send an empty buffer to an 
+    output port of a component.  The buffer will be filled by the component
+    and returned to the application via the FillBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then fill the buffer, later, at the proper 
+    time.  As expected, this macro may be invoked only while the component 
+    is in the OMX_ExecutingState.  If nPortIndex does not specify an output
+    port, the component shall return an error.  
+    
+    The component should return from this call within 5 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_FillThisBuffer(                                 \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((OMX_COMPONENTTYPE*)hComponent)->FillThisBuffer(       \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+
+/** The OMX_UseEGLImage macro will request that the component use
+    a EGLImage provided by EGL (and allocate its own buffer header)
+    This is a blocking call.
+    
+    The component should return from this call within 20 msec.
+    
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an OMX_BUFFERHEADERTYPE structure used to receive the 
+        pointer to the buffer header.  Note that the memory location used
+        for this buffer is NOT visible to the IL Client.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the 
+        buffer header structure.
+    @param [in] eglImage
+        eglImage contains the handle of the EGLImage to use as a buffer on the
+        specified port.  The component is expected to validate properties of 
+        the EGLImage against the configuration of the port to ensure the component
+        can use the EGLImage as a buffer.          
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define OMX_UseEGLImage(                                    \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)                                        \
+    ((OMX_COMPONENTTYPE*)hComponent)->UseEGLImage(          \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)
+
+/** The OMX_Init method is used to initialize the OMX core.  It shall be the
+    first call made into OMX and it should only be executed one time without
+    an interviening OMX_Deinit call.  
+    
+    The core should return from this call within 20 msec.
+
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Init(void);
+
+
+/** The OMX_Deinit method is used to deinitialize the OMX core.  It shall be 
+    the last call made into OMX. In the event that the core determines that 
+    thare are components loaded when this call is made, the core may return 
+    with an error rather than try to unload the components.
+        
+    The core should return from this call within 20 msec.
+    
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_Deinit(void);
+
+
+/** The OMX_ComponentNameEnum method will enumerate through all the names of
+    recognised valid components in the system. This function is provided
+    as a means to detect all the components in the system run-time. There is
+    no strict ordering to the enumeration order of component names, although
+    each name will only be enumerated once.  If the OMX core supports run-time
+    installation of new components, it is only requried to detect newly
+    installed components when the first call to enumerate component names
+    is made (i.e. when nIndex is 0x0).
+    
+    The core should return from this call in 20 msec.
+    
+    @param [out] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example 
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
+        assigned by the vendor, but shall start with "OMX." and then have 
+        the Vendor designation next.
+    @param [in] nNameLength
+        number of characters in the cComponentName string.  With all 
+        component name strings restricted to less than 128 characters 
+        (including the trailing null) it is recomended that the caller
+        provide a input string for the cComponentName of 128 characters.
+    @param [in] nIndex
+        number containing the enumeration index for the component. 
+        Multiple calls to OMX_ComponentNameEnum with increasing values
+        of nIndex will enumerate through the component names in the
+        system until OMX_ErrorNoMore is returned.  The value of nIndex
+        is 0 to (N-1), where N is the number of valid installed components
+        in the system.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  When the value of nIndex exceeds the number of 
+        components in the system minus 1, OMX_ErrorNoMore will be
+        returned. Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_ComponentNameEnum(
+    OMX_OUT OMX_STRING cComponentName,
+    OMX_IN  OMX_U32 nNameLength,
+    OMX_IN  OMX_U32 nIndex);
+
+
+/** The OMX_GetHandle method will locate the component specified by the
+    component name given, load that component into memory and then invoke
+    the component's methods to create an instance of the component.  
+    
+    The core should return from this call within 20 msec.
+    
+    @param [out] pHandle
+        pointer to an OMX_HANDLETYPE pointer to be filled in by this method.
+    @param [in] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example 
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are 
+        assigned by the vendor, but shall start with "OMX." and then have 
+        the Vendor designation next.
+    @param [in] pAppData
+        pointer to an application defined value that will be returned
+        during callbacks so that the application can identify the source
+        of the callback.
+    @param [in] pCallBacks
+        pointer to a OMX_CALLBACKTYPE structure that will be passed to the
+        component to initialize it with.  
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_GetHandle(
+    OMX_OUT OMX_HANDLETYPE* pHandle, 
+    OMX_IN  OMX_STRING cComponentName,
+    OMX_IN  OMX_PTR pAppData,
+    OMX_IN  OMX_CALLBACKTYPE* pCallBacks);
+
+
+/** The OMX_FreeHandle method will free a handle allocated by the OMX_GetHandle 
+    method.  If the component reference count goes to zero, the component will
+    be unloaded from memory.  
+    
+    The core should return from this call within 20 msec when the component is 
+    in the OMX_StateLoaded state.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_FreeHandle(
+    OMX_IN  OMX_HANDLETYPE hComponent);
+
+
+
+/** The OMX_SetupTunnel method will handle the necessary calls to the components
+    to setup the specified tunnel the two components.  NOTE: This is
+    an actual method (not a #define macro).  This method will make calls into
+    the component ComponentTunnelRequest method to do the actual tunnel 
+    connection.  
+
+    The ComponentTunnelRequest method on both components will be called. 
+    This method shall not be called unless the component is in the 
+    OMX_StateLoaded state except when the ports used for the tunnel are
+    disabled. In this case, the component may be in the OMX_StateExecuting,
+    OMX_StatePause, or OMX_StateIdle states. 
+
+    The core should return from this call within 20 msec.
+    
+    @param [in] hOutput
+        Handle of the component to be accessed.  Also this is the handle
+        of the component whose port, specified in the nPortOutput parameter
+        will be used the source for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a 
+        requirement that hOutput be the source for the data when
+        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
+        specified in hInput will have it's port specified in nPortInput
+        setup for communication with the application / IL client.
+    @param [in] nPortOutput
+        nPortOutput is used to select the source port on component to be
+        used in the tunnel. 
+    @param [in] hInput
+        This is the component to setup the tunnel with. This is the handle
+        of the component whose port, specified in the nPortInput parameter
+        will be used the destination for the tunnel. This is the component handle
+        returned by the call to the OMX_GetHandle function.  There is a 
+        requirement that hInput be the destination for the data when
+        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
+        specified in hOutput will have it's port specified in nPortPOutput
+        setup for communication with the application / IL client.
+    @param [in] nPortInput
+        nPortInput is used to select the destination port on component to be
+        used in the tunnel.
+    @return OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        When OMX_ErrorNotImplemented is returned, one or both components is 
+        a non-interop component and does not support tunneling.
+        
+        On failure, the ports of both components are setup for communication
+        with the application / IL Client.
+    @ingroup core tun
+ */
+OMX_API OMX_ERRORTYPE OMX_APIENTRY OMX_SetupTunnel(
+    OMX_IN  OMX_HANDLETYPE hOutput,
+    OMX_IN  OMX_U32 nPortOutput,
+    OMX_IN  OMX_HANDLETYPE hInput,
+    OMX_IN  OMX_U32 nPortInput);
+    
+/** @ingroup cp */
+OMX_API OMX_ERRORTYPE   OMX_GetContentPipe(
+    OMX_OUT OMX_HANDLETYPE *hPipe,
+    OMX_IN OMX_STRING szURI);
+
+/** The OMX_GetComponentsOfRole method will return the number of components that support the given
+    role and (if the compNames field is non-NULL) the names of those components. The call will fail if 
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the compNames field NULL to determine the number of component names
+        * second call this function with the compNames field pointing to an array of names allocated 
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+    
+    @param [in] role
+        This is generic standard component name consisting only of component class 
+        name and the type within that class (e.g. 'audio_decoder.aac').
+    @param [inout] pNumComps
+        This is used both as input and output. 
+ 
+        If compNames is NULL, the input is ignored and the output specifies how many components support
+        the given role.
+     
+        If compNames is not NULL, on input it bounds the size of the input structure and 
+        on output, it specifies the number of components string names listed within the compNames parameter.
+    @param [inout] compNames
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts 
+        a list of the names of all physical components that implement the specified standard component name. 
+        Each name is NULL terminated. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetComponentsOfRole ( 
+	OMX_IN      OMX_STRING role,
+    OMX_INOUT   OMX_U32 *pNumComps,
+    OMX_INOUT   OMX_U8  **compNames);
+
+/** The OMX_GetRolesOfComponent method will return the number of roles supported by the given
+    component and (if the roles field is non-NULL) the names of those roles. The call will fail if 
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the roles field NULL to determine the number of role names
+        * second call this function with the roles field pointing to an array of names allocated 
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] compName
+        This is the name of the component being queried about.
+    @param [inout] pNumRoles
+        This is used both as input and output. 
+ 
+        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
+     
+        If compNames is not NULL, on input it bounds the size of the input structure and 
+        on output, it specifies the number of roles string names listed within the roles parameter.
+    @param [out] roles
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings 
+        which accepts a list of the names of all standard components roles implemented on the 
+        specified component name. numComps indicates the number of names.
+    @ingroup core
+ */
+OMX_API OMX_ERRORTYPE OMX_GetRolesOfComponent ( 
+	OMX_IN      OMX_STRING compName, 
+    OMX_INOUT   OMX_U32 *pNumRoles,
+    OMX_OUT     OMX_U8 **roles);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/OpenMAXIL/ghdr/OMX_GraphManager.h b/OpenMAXIL/ghdr/OMX_GraphManager.h
new file mode 100755
index 0000000..e93ce74
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_GraphManager.h
@@ -0,0 +1,291 @@
+/**
+ *  Copyright (c) 2008-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef _omx_graphmanager_h_
+#define _omx_graphmanager_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "OMX_Core.h"
+#include "OMX_Component.h"
+#include "fsl_osal.h"
+#include "OMX_Common.h"
+
+#define   OMX_AUDIO_CodingAC3     (OMX_AUDIO_CodingVendorStartUnused + 2)
+
+extern OMX_BOOL bNewGMAvailable;
+
+extern OMX_PTR  pLoadedLib;
+
+typedef enum
+{
+    GM_AUDIO_STREAM_INDEX = 0,
+    GM_VIDEO_STREAM_INDEX = 1,
+    GM_SUBPIC_STREAM_INDEX = 2,
+    GM_MAX_STREAM_INDEX =3
+}GM_STREAM_INDEX;
+
+typedef enum
+{
+    GM_VIDEO_MODE_NORMAL = 0,
+    GM_VIDEO_MODE_FULLSCREEN = 1, 
+    GM_VIDEO_MODE_ZOOM = 2,
+}GM_VIDEO_MODE;
+
+typedef enum
+{
+    GM_STATUS_INDEX_VIDEO_DEVICE_SETTING = 1
+}GM_STATUS_INDEX;
+
+typedef enum
+{
+    GM_VIDEO_DEVICE_LCD = 0,
+    GM_VIDEO_DEVICE_TV_NTSC = 1,
+    GM_VIDEO_DEVICE_TV_PAL = 2,
+    GM_VIDEO_DEVICE_TV_720P = 3,
+}GM_VIDEO_DEVICE;
+
+
+
+
+typedef enum
+{
+    GM_EVENT_NONE,
+    GM_EVENT_EOS,
+    GM_EVENT_FF_EOS,
+    GM_EVENT_BW_BOS,
+    GM_EVENT_BUFFERING_UPDATE,
+    GM_EVENT_CORRUPTED_STREM,
+    GM_EVENT_RENDERING_START,
+    GM_EVENT_SUBTITLE,
+    GM_EVENT_NETWORK_FAIL
+}GM_EVENT;
+
+typedef struct 
+{
+	int streamCount;
+}GM_FILEINFO;
+
+typedef struct
+{
+    OMX_U32 nChannels;
+    OMX_U32 nBitRate;
+    OMX_U32 nSampleRate;
+    OMX_AUDIO_CODINGTYPE eEncoding;  
+}GM_AUDIO_INFO;
+
+typedef struct
+{
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    //OMX_U32 nBitrate;
+    float   xFramerate;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
+}GM_VIDEO_INFO;
+
+typedef struct
+{
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    //OMX_U32 nBitrate;
+    float   xFramerate;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+}GM_IMAGE_INFO;
+
+typedef struct 
+{
+	int streamIndex;
+	OMX_PORTDOMAINTYPE streamType;
+    union {
+        GM_AUDIO_INFO audio_info;
+        GM_VIDEO_INFO video_info;
+        GM_IMAGE_INFO image_info;
+    } streamFormat;
+}GM_STREAMINFO;
+
+typedef enum {
+    SUBTITLE_UNKNOWN,
+    SUBTITLE_TEXT,
+    SUBTITLE_BITMAP,
+}SUBTITLE_FMT;
+
+typedef struct {
+    SUBTITLE_FMT fmt;
+    OMX_U8 *pBuffer;
+    OMX_S32 nLen;
+    OMX_TICKS nTime;
+}GM_SUBTITLE_SAMPLE;
+
+typedef int (*GM_EVENTHANDLER)(void* context, GM_EVENT eventID, void* Eventpayload);
+
+#ifndef MFW_AVI_SUPPORT_DIVX_DRM
+	#define MFW_AVI_SUPPORT_DIVX_DRM
+#endif
+#ifdef MFW_AVI_SUPPORT_DIVX_DRM
+
+/**
+  *eFslUserInputType-the type of user input result under drm case
+  */
+typedef enum
+{
+	E_FSL_INPUT_NONE = 0,
+	E_FSL_INPUT_CONFIRM,
+	E_FSL_INPUT_CANCEL,
+} eFslDrmUserInputType;
+
+typedef struct 
+{
+    union {
+        OMX_BOOL bStatus;
+    } status;
+} GM_STATUS;
+/**
+  *sFslDrmInfo reserve the drm info which will be used by GUI.
+  */
+typedef struct
+{
+	OMX_S32			drmCode; 
+	OMX_BOOL isDrmFile; 
+	eFslDrmUserInputType userInput;
+	OMX_S32 use_limit;
+    OMX_S32 use_count;
+    OMX_U8 cgmsaSignal;
+    OMX_U8 acptbSignal;
+    OMX_U8 digitalProtectionSignal; 
+    OMX_BOOL bOutputProtection;
+	OMX_BOOL bDivxDrmPresent;
+} sFslDrmInfo;
+typedef OMX_S32 (*divxdrmcallback)(void* context, sFslDrmInfo* pFslDrmInfo);
+#endif
+typedef struct OMX_GraphManager OMX_GraphManager;
+
+typedef enum {
+    GM_STATE_NULL,
+    GM_STATE_LOADING,
+    GM_STATE_LOADED,
+    GM_STATE_PAUSE,
+    GM_STATE_PLAYING,
+    GM_STATE_EOS,
+    GM_STATE_STOP
+}GM_STATE;
+
+
+typedef enum {
+    OMX_VIDEO_SURFACE_NONE,
+    OMX_VIDEO_SURFACE_ISURFACE,
+    OMX_VIDEO_SURFACE_SURFACE,
+    OMX_VIDEO_SURFACE_TEXTURE,
+}OMX_VIDEO_SURFACE_TYPE;
+
+struct OMX_GraphManager
+{
+	OMX_BOOL (*preload)(OMX_GraphManager *h, const char *filename, int length);
+	OMX_BOOL (*load)(OMX_GraphManager *h, const char *filename, int length);
+	OMX_BOOL (*unLoad)(OMX_GraphManager *h);
+	
+	OMX_BOOL (*start)(OMX_GraphManager* h);
+	OMX_BOOL (*stop)(OMX_GraphManager* h);
+	OMX_BOOL (*pause)(OMX_GraphManager* h);
+	OMX_BOOL (*resume)(OMX_GraphManager* h);
+	OMX_BOOL (*seek)(OMX_GraphManager* h, OMX_TIME_SEEKMODETYPE mode, OMX_TICKS position);
+    OMX_BOOL (*setVolume)(OMX_GraphManager* h, OMX_BOOL up);
+
+    OMX_BOOL (*disableStream)(OMX_GraphManager* h, GM_STREAM_INDEX stream_index);
+	OMX_BOOL (*getFileInfo)(OMX_GraphManager* h, GM_FILEINFO* fileInfo);
+	OMX_BOOL (*getStreamInfo)(OMX_GraphManager* h, int streamIndex, GM_STREAMINFO* streamInfo);
+	OMX_BOOL (*getPosition)(OMX_GraphManager* h, OMX_TICKS* pUsec);
+	OMX_BOOL (*getDuration)(OMX_GraphManager* h, OMX_TICKS* pUsec);
+	OMX_BOOL (*getState)(OMX_GraphManager* h, GM_STATE *state);
+
+    OMX_BOOL (*getScreenShotInfo)(OMX_GraphManager* h, OMX_IMAGE_PORTDEFINITIONTYPE *pfmt, OMX_CONFIG_RECTTYPE *pCropRect);
+    OMX_BOOL (*getThumbnail)(OMX_GraphManager* h, OMX_TICKS pos, OMX_U8 *buf);
+    OMX_BOOL (*getSnapshot)(OMX_GraphManager* h, OMX_U8 *buf);
+	
+	OMX_BOOL (*registerEventHandler)(OMX_GraphManager* h, void* context, GM_EVENTHANDLER handler);
+	
+	OMX_BOOL (*dumpPipeLine)(OMX_GraphManager* h);
+	OMX_BOOL (*deleteIt)(OMX_GraphManager* h);
+    OMX_BOOL (*setPlaySpeed)(OMX_GraphManager* h, int speed);
+    OMX_BOOL (*getPlaySpeed)(OMX_GraphManager* h, int *speed);
+//settvout fullscreen and zoomin is obsoleted, replace with setvideodevice and setvideomode
+	OMX_BOOL (*settvout)(OMX_GraphManager* h, OMX_BOOL bTvOut, OMX_S32 tv_mode, OMX_BOOL bLayer2);
+//settvout fullscreen and zoomin is obsoleted, replace with setvideodevice and setvideomode
+
+	OMX_BOOL (*syssleep)(OMX_GraphManager* h, OMX_BOOL bsleep);
+#ifdef MFW_AVI_SUPPORT_DIVX_DRM
+	OMX_BOOL (*setdivxdrmcallback)(OMX_GraphManager* h, void* context, divxdrmcallback handler, void *pfunc);
+#endif
+	OMX_BOOL (*rotate)(OMX_GraphManager* h, OMX_S32 rotate);
+
+//settvout fullscreen and zoomin is obsoleted, replace with setvideodevice and setvideomode
+	OMX_BOOL (*fullscreen)(OMX_GraphManager* h, OMX_BOOL bzoomin, OMX_BOOL bkeepratio);
+	OMX_BOOL (*AdjustAudioVolume)(OMX_GraphManager* h, OMX_BOOL bVolumeUp);
+	OMX_BOOL (*AddRemoveAudioPP)(OMX_GraphManager* h, OMX_BOOL bAddComponent);
+	OMX_U32 (*GetAudioTrackNum)(OMX_GraphManager* h);
+	OMX_STRING (*GetAudioTrackName)(OMX_GraphManager* h, OMX_U32 nTrackIndex);
+	OMX_U32 (*GetCurAudioTrack)(OMX_GraphManager* h);
+	OMX_BOOL (*SelectAudioTrack)(OMX_GraphManager* h, OMX_U32 nSelectedTrack);
+	OMX_U32 (*GetSubtitleTrackNum)(OMX_GraphManager* h);
+	OMX_U32 (*GetSubtitleCurTrack)(OMX_GraphManager* h);
+	OMX_STRING (*GetSubtitleTrackName)(OMX_GraphManager* h, OMX_U32 nTrackIndex);
+	OMX_BOOL (*SelectSubtitleTrack)(OMX_GraphManager* h, OMX_U32 nSelectedTrack);
+	OMX_U32 (*GetSubtitleNextSample)(OMX_GraphManager* h, OMX_U8**ppData, OMX_S32* pFilledLen, OMX_TICKS* pTime);
+	OMX_U32 (*GetBandNumPEQ)(OMX_GraphManager* h);
+	OMX_BOOL (*SetAudioEffectPEQ)(OMX_GraphManager* h, OMX_U32 nBindIndex, OMX_U32 nFC, OMX_S32 nGain);
+	OMX_BOOL (*EnableDisablePEQ)(OMX_GraphManager* h, OMX_BOOL bAudioEffect);
+	OMX_BOOL (*zoomin)(OMX_GraphManager* h);
+    
+//new gm function to control video output device and mode
+    OMX_BOOL (*setvideodevice)(OMX_GraphManager * h, GM_VIDEO_DEVICE vDevice, OMX_BOOL bBlockMode);
+    OMX_BOOL (*setvideomode)(OMX_GraphManager * h, GM_VIDEO_MODE vMode);
+    OMX_BOOL (*querystatus)(OMX_GraphManager * h, GM_STATUS_INDEX statusIndex, GM_STATUS * pStatus);
+    OMX_BOOL (*force2lcd)(OMX_GraphManager * h);
+
+    OMX_BOOL (*setAudioSink)(OMX_GraphManager *h, OMX_PTR sink);
+    OMX_BOOL (*setDisplayRect)(OMX_GraphManager *h, OMX_CONFIG_RECTTYPE *pRect);
+    OMX_BOOL (*setVideoRect)(OMX_GraphManager *h, OMX_CONFIG_RECTTYPE *pRect);
+    OMX_BOOL (*setDisplayMode)(OMX_GraphManager *h, OMX_CONFIG_RECTTYPE *pInRect, OMX_CONFIG_RECTTYPE *pOutRect, GM_VIDEO_MODE eVideoMode,  GM_VIDEO_DEVICE tv_dev, OMX_U32 nRotate);
+    OMX_BOOL (*setVideoSurface)(OMX_GraphManager *h, OMX_PTR surface, OMX_VIDEO_SURFACE_TYPE type);
+    OMX_BOOL (*setVideoScalingMode)(OMX_GraphManager *h, OMX_S32 mode);
+    OMX_BOOL (*setVideoRenderType)(OMX_GraphManager *h, OMX_VIDEO_RENDER_TYPE type);
+    OMX_BOOL (*setAudioPassThrough)(OMX_GraphManager *h, OMX_BOOL bEnable);
+    OMX_BOOL (*getAudioTrackType)(OMX_GraphManager *h, OMX_U32 nTrackIndex, OMX_AUDIO_CODINGTYPE *pType);
+    OMX_BOOL (*addOutBandSubtitleSource)(OMX_GraphManager *h, OMX_STRING url, OMX_STRING type);
+    OMX_BOOL (*isSeekable)(OMX_GraphManager *h);
+
+	void* pData;
+};
+
+OMX_GraphManager* OMX_GraphManagerCreate();
+
+
+
+
+void gm_setheader(void* header, OMX_U32 size);
+#define NTSC    0
+#define PAL     1
+#define NV_MODE 2
+#define MAX_RATE_VIDEOONLY         (16)
+#ifndef Q16_SHIFT
+#define Q16_SHIFT           0x10000
+#endif
+#define OMX_CAT_LOG_ERROR_GRAPHMANAGER(fm, ...) OMX_CAT_LEVEL_LOG(OMX_DEBUG_GRAPH_MANAGER,OMX_LEVEL_ERROR,fm,##__VA_ARGS__)
+#define OMX_CAT_LOG_WARNING_GRAPHMANAGER(fm, ...) OMX_CAT_LEVEL_LOG(OMX_DEBUG_GRAPH_MANAGER,OMX_LEVEL_WARNING,fm,##__VA_ARGS__)
+#define OMX_CAT_LOG_INFO_GRAPHMANAGER(fm, ...) OMX_CAT_LEVEL_LOG(OMX_DEBUG_GRAPH_MANAGER,OMX_LEVEL_INFO,fm,##__VA_ARGS__)
+#define OMX_CAT_LOG_DEBUG_GRAPHMANAGER(fm, ...) OMX_CAT_LEVEL_LOG(OMX_DEBUG_GRAPH_MANAGER,OMX_LEVEL_DEBUG,fm,##__VA_ARGS__)
+#define OMX_CAT_LOG_DEBUG_BUFFER_GRAPHMANAGER(fm, ...) OMX_CAT_LEVEL_LOG(OMX_DEBUG_GRAPH_MANAGER,OMX_LEVEL_DEBUG_BUFFER,fm,##__VA_ARGS__)
+#define OMX_CAT_LOG_LOG_GRAPHMANAGER(fm, ...) OMX_CAT_LEVEL_LOG(OMX_DEBUG_GRAPH_MANAGER,OMX_LEVEL_LOG,fm,##__VA_ARGS__)
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/OpenMAXIL/ghdr/OMX_IVCommon.h b/OpenMAXIL/ghdr/OMX_IVCommon.h
new file mode 100755
index 0000000..9b2ce2b
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_IVCommon.h
@@ -0,0 +1,920 @@
+/**
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** 
+ * @file OMX_IVCommon.h - OpenMax IL version 1.1.2
+ *  The structures needed by Video and Image components to exchange
+ *  parameters and configuration data with the components.
+ */
+#ifndef OMX_IVCommon_h
+#define OMX_IVCommon_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * Each OMX header must include all required header files to allow the header
+ * to compile without errors.  The includes below are required for this header
+ * file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+/** @defgroup iv OpenMAX IL Imaging and Video Domain
+ * Common structures for OpenMAX IL Imaging and Video domains
+ * @{
+ */
+
+
+/** 
+ * Enumeration defining possible uncompressed image/video formats. 
+ *
+ * ENUMS:
+ *  Unused                 : Placeholder value when format is N/A
+ *  Monochrome             : black and white
+ *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
+ *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
+ *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
+ *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
+ *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
+ *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
+ *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
+ *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
+ *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
+ *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
+ *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
+ *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
+ *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
+ *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
+ *  YUV411PackedPlanar     : packed per payload in planar slices
+ *  YUV420Planar           : Three arrays Y,U,V.
+ *  YUV420PackedPlanar     : packed per payload in planar slices
+ *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YUV422Planar           : Three arrays Y,U,V.
+ *  YUV422PackedPlanar     : packed per payload in planar slices
+ *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
+ *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
+ *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
+ *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
+ *  YUV444Interleaved      : Each pixel contains equal parts YUV
+ *  RawBayer8bit           : SMIA camera output format
+ *  RawBayer10bit          : SMIA camera output format
+ *  RawBayer8bitcompressed : SMIA camera output format
+ */
+typedef enum OMX_COLOR_FORMATTYPE {
+    OMX_COLOR_FormatUnused,
+    OMX_COLOR_FormatMonochrome,
+    OMX_COLOR_Format8bitRGB332,
+    OMX_COLOR_Format12bitRGB444,
+    OMX_COLOR_Format16bitARGB4444,
+    OMX_COLOR_Format16bitARGB1555,
+    OMX_COLOR_Format16bitRGB565,
+    OMX_COLOR_Format16bitBGR565,
+    OMX_COLOR_Format18bitRGB666,
+    OMX_COLOR_Format18bitARGB1665,
+    OMX_COLOR_Format19bitARGB1666, 
+    OMX_COLOR_Format24bitRGB888,
+    OMX_COLOR_Format24bitBGR888,
+    OMX_COLOR_Format24bitARGB1887,
+    OMX_COLOR_Format25bitARGB1888,
+    OMX_COLOR_Format32bitBGRA8888,
+    OMX_COLOR_Format32bitARGB8888,
+    OMX_COLOR_FormatYUV411Planar,
+    OMX_COLOR_FormatYUV411PackedPlanar,
+    OMX_COLOR_FormatYUV420Planar,
+    OMX_COLOR_FormatYUV420PackedPlanar,
+    OMX_COLOR_FormatYUV420SemiPlanar,
+    OMX_COLOR_FormatYUV422Planar,
+    OMX_COLOR_FormatYUV422PackedPlanar,
+    OMX_COLOR_FormatYUV422SemiPlanar,
+    OMX_COLOR_FormatYCbYCr,
+    OMX_COLOR_FormatYCrYCb,
+    OMX_COLOR_FormatCbYCrY,
+    OMX_COLOR_FormatCrYCbY,
+    OMX_COLOR_FormatYUV444Interleaved,
+    OMX_COLOR_FormatRawBayer8bit,
+    OMX_COLOR_FormatRawBayer10bit,
+    OMX_COLOR_FormatRawBayer8bitcompressed,
+    OMX_COLOR_FormatL2, 
+    OMX_COLOR_FormatL4, 
+    OMX_COLOR_FormatL8, 
+    OMX_COLOR_FormatL16, 
+    OMX_COLOR_FormatL24, 
+    OMX_COLOR_FormatL32,
+    OMX_COLOR_FormatYUV420PackedSemiPlanar,
+    OMX_COLOR_FormatYUV422PackedSemiPlanar,
+    OMX_COLOR_Format18BitBGR666,
+    OMX_COLOR_Format24BitARGB6666,
+    OMX_COLOR_Format24BitABGR6666,
+    OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_COLOR_FormatMax = 0x7FFFFFFF
+} OMX_COLOR_FORMATTYPE;
+
+
+/** 
+ * Defines the matrix for conversion from RGB to YUV or vice versa.
+ * iColorMatrix should be initialized with the fixed point values 
+ * used in converting between formats.
+ */
+typedef struct OMX_CONFIG_COLORCONVERSIONTYPE {
+    OMX_U32 nSize;              /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */ 
+    OMX_U32 nPortIndex;         /**< Port that this struct applies to */
+    OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
+    OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
+}OMX_CONFIG_COLORCONVERSIONTYPE;
+
+
+/** 
+ * Structure defining percent to scale each frame dimension.  For example:  
+ * To make the width 50% larger, use fWidth = 1.5 and to make the width
+ * 1/2 the original size, use fWidth = 0.5
+ */
+typedef struct OMX_CONFIG_SCALEFACTORTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version info */ 
+    OMX_U32 nPortIndex;       /**< Port that this struct applies to */
+    OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
+    OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
+}OMX_CONFIG_SCALEFACTORTYPE;
+
+
+/** 
+ * Enumeration of possible image filter types 
+ */
+typedef enum OMX_IMAGEFILTERTYPE {
+    OMX_ImageFilterNone,
+    OMX_ImageFilterNoise,
+    OMX_ImageFilterEmboss,
+    OMX_ImageFilterNegative,
+    OMX_ImageFilterSketch,
+    OMX_ImageFilterOilPaint,
+    OMX_ImageFilterHatch,
+    OMX_ImageFilterGpen,
+    OMX_ImageFilterAntialias, 
+    OMX_ImageFilterDeRing,       
+    OMX_ImageFilterSolarize,
+    OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ImageFilterMax = 0x7FFFFFFF
+} OMX_IMAGEFILTERTYPE;
+
+
+/** 
+ * Image filter configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes       
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to 
+ *  eImageFilter : Image filter type enumeration      
+ */
+typedef struct OMX_CONFIG_IMAGEFILTERTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGEFILTERTYPE eImageFilter;
+} OMX_CONFIG_IMAGEFILTERTYPE;
+
+
+/** 
+ * Customized U and V for color enhancement 
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information 
+ *  nPortIndex        : Port that this structure applies to
+ *  bColorEnhancement : Enable/disable color enhancement
+ *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for 
+ *                      U component
+ *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for 
+ *                      V component
+ */
+typedef struct OMX_CONFIG_COLORENHANCEMENTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_BOOL bColorEnhancement;
+    OMX_U8 nCustomizedU;
+    OMX_U8 nCustomizedV;
+} OMX_CONFIG_COLORENHANCEMENTTYPE;
+
+
+/** 
+ * Define color key and color key mask 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
+ *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
+ */
+typedef struct OMX_CONFIG_COLORKEYTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nARGBColor;
+    OMX_U32 nARGBMask;
+} OMX_CONFIG_COLORKEYTYPE;
+
+
+/** 
+ * List of color blend types for pre/post processing 
+ *
+ * ENUMS:
+ *  None          : No color blending present
+ *  AlphaConstant : Function is (alpha_constant * src) + 
+ *                  (1 - alpha_constant) * dst)
+ *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
+ *  Alternate     : Function is alternating pixels from src and dst
+ *  And           : Function is (src & dst)
+ *  Or            : Function is (src | dst)
+ *  Invert        : Function is ~src
+ */
+typedef enum OMX_COLORBLENDTYPE {
+    OMX_ColorBlendNone,
+    OMX_ColorBlendAlphaConstant,
+    OMX_ColorBlendAlphaPerPixel,
+    OMX_ColorBlendAlternate,
+    OMX_ColorBlendAnd,
+    OMX_ColorBlendOr,
+    OMX_ColorBlendInvert,
+    OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ColorBlendMax = 0x7FFFFFFF
+} OMX_COLORBLENDTYPE;
+
+
+/** 
+ * Color blend configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes                        
+ *  nVersion          : OMX specification version information                
+ *  nPortIndex        : Port that this structure applies to                   
+ *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
+ *  eColorBlend       : Color blend type enumeration                         
+ */
+typedef struct OMX_CONFIG_COLORBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nRGBAlphaConstant;
+    OMX_COLORBLENDTYPE  eColorBlend;
+} OMX_CONFIG_COLORBLENDTYPE;
+
+
+/** 
+ * Hold frame dimension
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes      
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to     
+ *  nWidth     : Frame width in pixels                 
+ *  nHeight    : Frame height in pixels                
+ */
+typedef struct OMX_FRAMESIZETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_FRAMESIZETYPE;
+
+
+/**
+ * Rotation configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes             
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nRotation  : +/- integer rotation value               
+ */
+typedef struct OMX_CONFIG_ROTATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nRotation; 
+} OMX_CONFIG_ROTATIONTYPE;
+
+
+/** 
+ * Possible mirroring directions for pre/post processing 
+ *
+ * ENUMS:
+ *  None       : No mirroring                         
+ *  Vertical   : Vertical mirroring, flip on X axis   
+ *  Horizontal : Horizontal mirroring, flip on Y axis  
+ *  Both       : Both vertical and horizontal mirroring
+ */
+typedef enum OMX_MIRRORTYPE {
+    OMX_MirrorNone = 0,
+    OMX_MirrorVertical,
+    OMX_MirrorHorizontal,
+    OMX_MirrorBoth, 
+    OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_MirrorMax = 0x7FFFFFFF   
+} OMX_MIRRORTYPE;
+
+
+/** 
+ * Mirroring configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes      
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to  
+ *  eMirror    : Mirror type enumeration              
+ */
+typedef struct OMX_CONFIG_MIRRORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_MIRRORTYPE  eMirror;
+} OMX_CONFIG_MIRRORTYPE;
+
+
+/** 
+ * Position information only 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes               
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nX         : X coordinate for the point                     
+ *  nY         : Y coordinate for the point 
+ */                      
+typedef struct OMX_CONFIG_POINTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nX;
+    OMX_S32 nY;
+} OMX_CONFIG_POINTTYPE;
+
+
+/** 
+ * Frame size plus position 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes                    
+ *  nVersion   : OMX specification version information      
+ *  nPortIndex : Port that this structure applies to    
+ *  nLeft      : X Coordinate of the top left corner of the rectangle
+ *  nTop       : Y Coordinate of the top left corner of the rectangle
+ *  nWidth     : Width of the rectangle                              
+ *  nHeight    : Height of the rectangle                             
+ */
+typedef struct OMX_CONFIG_RECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;  
+    OMX_U32 nPortIndex; 
+    OMX_S32 nLeft; 
+    OMX_S32 nTop;
+    OMX_U32 nWidth;
+    OMX_U32 nHeight;
+} OMX_CONFIG_RECTTYPE;
+
+
+/** 
+ * Deblocking state; it is required to be set up before starting the codec 
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes      
+ *  nVersion    : OMX specification version information 
+ *  nPortIndex  : Port that this structure applies to
+ *  bDeblocking : Enable/disable deblocking mode    
+ */
+typedef struct OMX_PARAM_DEBLOCKINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bDeblocking;
+} OMX_PARAM_DEBLOCKINGTYPE;
+
+
+/** 
+ * Stabilization state 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes          
+ *  nVersion   : OMX specification version information    
+ *  nPortIndex : Port that this structure applies to   
+ *  bStab      : Enable/disable frame stabilization state
+ */
+typedef struct OMX_CONFIG_FRAMESTABTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bStab;
+} OMX_CONFIG_FRAMESTABTYPE;
+
+
+/** 
+ * White Balance control type 
+ *
+ * STRUCT MEMBERS:
+ *  SunLight : Referenced in JSR-234
+ *  Flash    : Optimal for device's integrated flash
+ */
+typedef enum OMX_WHITEBALCONTROLTYPE {
+    OMX_WhiteBalControlOff = 0,
+    OMX_WhiteBalControlAuto,
+    OMX_WhiteBalControlSunLight,
+    OMX_WhiteBalControlCloudy,
+    OMX_WhiteBalControlShade,
+    OMX_WhiteBalControlTungsten,
+    OMX_WhiteBalControlFluorescent,
+    OMX_WhiteBalControlIncandescent,
+    OMX_WhiteBalControlFlash,
+    OMX_WhiteBalControlHorizon,
+    OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_WhiteBalControlMax = 0x7FFFFFFF
+} OMX_WHITEBALCONTROLTYPE;
+
+
+/** 
+ * White Balance control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes       
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to                 
+ *  eWhiteBalControl : White balance enumeration            
+ */
+typedef struct OMX_CONFIG_WHITEBALCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
+} OMX_CONFIG_WHITEBALCONTROLTYPE;
+
+
+/** 
+ * Exposure control type 
+ */
+typedef enum OMX_EXPOSURECONTROLTYPE {
+    OMX_ExposureControlOff = 0,
+    OMX_ExposureControlAuto,
+    OMX_ExposureControlNight,
+    OMX_ExposureControlBackLight,
+    OMX_ExposureControlSpotLight,
+    OMX_ExposureControlSports,
+    OMX_ExposureControlSnow,
+    OMX_ExposureControlBeach,
+    OMX_ExposureControlLargeAperture,
+    OMX_ExposureControlSmallApperture,
+    OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_ExposureControlMax = 0x7FFFFFFF
+} OMX_EXPOSURECONTROLTYPE;
+
+
+/** 
+ * White Balance control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes      
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to                
+ *  eExposureControl : Exposure control enumeration         
+ */
+typedef struct OMX_CONFIG_EXPOSURECONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_EXPOSURECONTROLTYPE eExposureControl;
+} OMX_CONFIG_EXPOSURECONTROLTYPE;
+
+
+/** 
+ * Defines sensor supported mode. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes           
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to 
+ *  nFrameRate : Single shot mode is indicated by a 0     
+ *  bOneShot   : Enable for single shot, disable for streaming
+ *  sFrameSize : Framesize                                          
+ */
+typedef struct OMX_PARAM_SENSORMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nFrameRate;
+    OMX_BOOL bOneShot;
+    OMX_FRAMESIZETYPE sFrameSize;
+} OMX_PARAM_SENSORMODETYPE;
+
+
+/** 
+ * Defines contrast level 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes                              
+ *  nVersion   : OMX specification version information                
+ *  nPortIndex : Port that this structure applies to                 
+ *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_CONTRASTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nContrast;
+} OMX_CONFIG_CONTRASTTYPE;
+
+
+/** 
+ * Defines brightness level 
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes          
+ *  nVersion    : OMX specification version information 
+ *  nPortIndex  : Port that this structure applies to 
+ *  nBrightness : 0-100%        
+ */
+typedef struct OMX_CONFIG_BRIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBrightness;
+} OMX_CONFIG_BRIGHTNESSTYPE;
+
+
+/** 
+ * Defines backlight level configuration for a video sink, e.g. LCD panel 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nBacklight : Values allowed for backlight 0-100%
+ *  nTimeout   : Number of milliseconds before backlight automatically turns 
+ *               off.  A value of 0x0 disables backight timeout 
+ */
+typedef struct OMX_CONFIG_BACKLIGHTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nBacklight;
+    OMX_U32 nTimeout;
+} OMX_CONFIG_BACKLIGHTTYPE;
+
+
+/** 
+ * Defines setting for Gamma 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
+ */
+typedef struct OMX_CONFIG_GAMMATYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nGamma;
+} OMX_CONFIG_GAMMATYPE;
+
+
+/** 
+ * Define for setting saturation 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nSaturation : Values allowed for saturation -100 to 100, zero means 
+ *                no change
+ */
+typedef struct OMX_CONFIG_SATURATIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nSaturation;
+} OMX_CONFIG_SATURATIONTYPE;
+
+
+/** 
+ * Define for setting Lightness 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLightness : Values allowed for lightness -100 to 100, zero means no 
+ *               change
+ */
+typedef struct OMX_CONFIG_LIGHTNESSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_S32 nLightness;
+} OMX_CONFIG_LIGHTNESSTYPE;
+
+
+/** 
+ * Plane blend configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes 
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Index of input port associated with the plane.
+ *  nDepth     : Depth of the plane in relation to the screen. Higher 
+ *               numbered depths are "behind" lower number depths.  
+ *               This number defaults to the Port Index number.
+ *  nAlpha     : Transparency blending component for the entire plane.  
+ *               See blending modes for more detail.
+ */
+typedef struct OMX_CONFIG_PLANEBLENDTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nDepth;
+    OMX_U32 nAlpha;
+} OMX_CONFIG_PLANEBLENDTYPE;
+
+
+/** 
+ * Define interlace type
+ *
+ * STRUCT MEMBERS:
+ *  nSize                 : Size of the structure in bytes 
+ *  nVersion              : OMX specification version information 
+ *  nPortIndex            : Port that this structure applies to
+ *  bEnable               : Enable control variable for this functionality 
+ *                          (see below)
+ *  nInterleavePortIndex  : Index of input or output port associated with  
+ *                          the interleaved plane. 
+ *  pPlanarPortIndexes[4] : Index of input or output planar ports.
+ */
+typedef struct OMX_PARAM_INTERLEAVETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnable;
+    OMX_U32 nInterleavePortIndex;
+} OMX_PARAM_INTERLEAVETYPE;
+
+
+/** 
+ * Defines the picture effect used for an input picture 
+ */
+typedef enum OMX_TRANSITIONEFFECTTYPE {
+    OMX_EffectNone,
+    OMX_EffectFadeFromBlack,
+    OMX_EffectFadeToBlack,
+    OMX_EffectUnspecifiedThroughConstantColor,
+    OMX_EffectDissolve,
+    OMX_EffectWipe,
+    OMX_EffectUnspecifiedMixOfTwoScenes,
+    OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EffectMax = 0x7FFFFFFF
+} OMX_TRANSITIONEFFECTTYPE;
+
+
+/** 
+ * Structure used to configure current transition effect 
+ *
+ * STRUCT MEMBERS:
+ * nSize      : Size of the structure in bytes
+ * nVersion   : OMX specification version information 
+ * nPortIndex : Port that this structure applies to
+ * eEffect    : Effect to enable
+ */
+typedef struct OMX_CONFIG_TRANSITIONEFFECTTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TRANSITIONEFFECTTYPE eEffect;
+} OMX_CONFIG_TRANSITIONEFFECTTYPE;
+
+
+/** 
+ * Defines possible data unit types for encoded video data. The data unit 
+ * types are used both for encoded video input for playback as well as
+ * encoded video output from recording. 
+ */
+typedef enum OMX_DATAUNITTYPE {
+    OMX_DataUnitCodedPicture,
+    OMX_DataUnitVideoSegment,
+    OMX_DataUnitSeveralSegments,
+    OMX_DataUnitArbitraryStreamSection,
+    OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataUnitMax = 0x7FFFFFFF
+} OMX_DATAUNITTYPE;
+
+
+/** 
+ * Defines possible encapsulation types for coded video data unit. The 
+ * encapsulation information is used both for encoded video input for 
+ * playback as well as encoded video output from recording. 
+ */
+typedef enum OMX_DATAUNITENCAPSULATIONTYPE {
+    OMX_DataEncapsulationElementaryStream,
+    OMX_DataEncapsulationGenericPayload,
+    OMX_DataEncapsulationRtpPayload,
+    OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DataEncapsulationMax = 0x7FFFFFFF
+} OMX_DATAUNITENCAPSULATIONTYPE;
+
+
+/** 
+ * Structure used to configure the type of being decoded/encoded 
+ */
+typedef struct OMX_PARAM_DATAUNITTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DATAUNITTYPE eUnitType;
+    OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
+} OMX_PARAM_DATAUNITTYPE;
+
+
+/**
+ * Defines dither types 
+ */
+typedef enum OMX_DITHERTYPE {
+    OMX_DitherNone,
+    OMX_DitherOrdered,
+    OMX_DitherErrorDiffusion,
+    OMX_DitherOther,
+    OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_DitherMax = 0x7FFFFFFF
+} OMX_DITHERTYPE;
+
+
+/** 
+ * Structure used to configure current type of dithering 
+ */
+typedef struct OMX_CONFIG_DITHERTYPE {
+    OMX_U32 nSize;            /**< Size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */ 
+    OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
+} OMX_CONFIG_DITHERTYPE;
+
+typedef struct OMX_CONFIG_CAPTUREMODETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;     /**< Port that this structure applies to */
+    OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture 
+                             *   data as fast as possible (otherwise obey port's frame rate). */
+    OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the 
+                             *   specified number of frames (otherwise the port does not 
+                             *   terminate the capture until instructed to do so by the client). 
+                             *   Even if set, the client may manually terminate the capture prior 
+                             *   to reaching the limit. */
+    OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
+                               *   valid if bFrameLimited is set). */
+} OMX_CONFIG_CAPTUREMODETYPE;
+
+typedef enum OMX_METERINGTYPE {
+ 
+    OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
+    OMX_MeteringModeSpot,  	      /**< Spot (partial) metering. */
+    OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
+ 
+    OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_EVModeMax = 0x7fffffff
+} OMX_METERINGTYPE;
+ 
+typedef struct OMX_CONFIG_EXPOSUREVALUETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_METERINGTYPE eMetering;
+    OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
+    OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
+    OMX_BOOL bAutoAperture;		/**< Whether aperture number is defined automatically */
+    OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */ 
+    OMX_BOOL bAutoShutterSpeed;	/**< Whether shutter speed is defined automatically */ 
+    OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
+    OMX_BOOL bAutoSensitivity;	/**< Whether sensitivity is defined automatically */
+} OMX_CONFIG_EXPOSUREVALUETYPE;
+
+/** 
+ * Focus region configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  bCenter         : Use center region as focus region of interest
+ *  bLeft           : Use left region as focus region of interest
+ *  bRight          : Use right region as focus region of interest
+ *  bTop            : Use top region as focus region of interest
+ *  bBottom         : Use bottom region as focus region of interest
+ *  bTopLeft        : Use top left region as focus region of interest
+ *  bTopRight       : Use top right region as focus region of interest
+ *  bBottomLeft     : Use bottom left region as focus region of interest
+ *  bBottomRight    : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_CONFIG_FOCUSREGIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bCenter;
+    OMX_BOOL bLeft;
+    OMX_BOOL bRight;
+    OMX_BOOL bTop;
+    OMX_BOOL bBottom;
+    OMX_BOOL bTopLeft;
+    OMX_BOOL bTopRight;
+    OMX_BOOL bBottomLeft;
+    OMX_BOOL bBottomRight;
+} OMX_CONFIG_FOCUSREGIONTYPE;
+
+/** 
+ * Focus Status type 
+ */
+typedef enum OMX_FOCUSSTATUSTYPE {
+    OMX_FocusStatusOff = 0,
+    OMX_FocusStatusRequest,
+    OMX_FocusStatusReached,
+    OMX_FocusStatusUnableToReach,
+    OMX_FocusStatusLost,
+    OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_FocusStatusMax = 0x7FFFFFFF
+} OMX_FOCUSSTATUSTYPE;
+
+/** 
+ * Focus status configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  eFocusStatus        : Specifies the focus status
+ *  bCenterStatus       : Use center region as focus region of interest
+ *  bLeftStatus         : Use left region as focus region of interest
+ *  bRightStatus        : Use right region as focus region of interest
+ *  bTopStatus          : Use top region as focus region of interest
+ *  bBottomStatus       : Use bottom region as focus region of interest
+ *  bTopLeftStatus      : Use top left region as focus region of interest
+ *  bTopRightStatus     : Use top right region as focus region of interest
+ *  bBottomLeftStatus   : Use bottom left region as focus region of interest
+ *  bBottomRightStatus  : Use bottom right region as focus region of interest
+ */
+typedef struct OMX_PARAM_FOCUSSTATUSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_FOCUSSTATUSTYPE eFocusStatus;
+    OMX_BOOL bCenterStatus;
+    OMX_BOOL bLeftStatus;
+    OMX_BOOL bRightStatus;
+    OMX_BOOL bTopStatus;
+    OMX_BOOL bBottomStatus;
+    OMX_BOOL bTopLeftStatus;
+    OMX_BOOL bTopRightStatus;
+    OMX_BOOL bBottomLeftStatus;
+    OMX_BOOL bBottomRightStatus;
+} OMX_PARAM_FOCUSSTATUSTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_Image.h b/OpenMAXIL/ghdr/OMX_Image.h
new file mode 100755
index 0000000..840a068
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Image.h
@@ -0,0 +1,328 @@
+/**
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ */
+
+/** 
+ * @file OMX_Image.h - OpenMax IL version 1.1.2
+ * The structures needed by Image components to exchange parameters and 
+ * configuration data with the components.
+ */
+#ifndef OMX_Image_h
+#define OMX_Image_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the 
+ * header to compile without errors.  The includes below are required  
+ * for this header file to compile successfully 
+ */
+
+#include <OMX_IVCommon.h>
+
+/** @defgroup imaging OpenMAX IL Imaging Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Imaging domain
+ * @{
+ */
+
+/** 
+ * Enumeration used to define the possible image compression coding. 
+ */
+typedef enum OMX_IMAGE_CODINGTYPE {
+    OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
+    OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
+    OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
+    OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
+    OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
+    OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
+    OMX_IMAGE_CodingGIF,         /**< Graphics image format */
+    OMX_IMAGE_CodingPNG,         /**< PNG image format */
+    OMX_IMAGE_CodingLZW,         /**< LZW image format */
+    OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
+    OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_CodingMax = 0x7FFFFFFF
+} OMX_IMAGE_CODINGTYPE;
+
+
+/**
+ * Data structure used to define an image path. The number of image paths 
+ * for input and output will vary by type of the image component.  
+ * 
+ *  Input (aka Source) : Zero Inputs, one Output,
+ *  Splitter           : One Input, 2 or more Outputs,
+ *  Processing Element : One Input, one output,
+ *  Mixer              : 2 or more inputs, one output,
+ *  Output (aka Sink)  : One Input, zero outputs.
+ * 
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output  
+ * image path.  If additional vendor specific data is required, it should  
+ * be transmitted to the component using the CustomCommand function.   
+ * Compliant components will prepopulate this structure with optimal  
+ * values during the OMX_GetParameter() command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a 
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on port if 
+ *                          uncompressed format is used.  Use 0 for 
+ *                          unknown, don't care or variable
+ *  nFrameHeight          : Height of frame to be used on port if 
+ *                          uncompressed format is used. Use 0 for 
+ *                          unknown, don't care or variable
+ *  nStride               : Number of bytes per span of an image (i.e. 
+ *                          indicates the number of bytes to get from
+ *                          span N to span N+1, where negative stride 
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of  
+ *                          the component. When OMX_IMAGE_CodingUnused is 
+ *                          specified, eColorFormat is valid
+ *  eColorFormat          : Decompressed format used by this component
+ *  pNativeWindow         : Platform specific reference for a window object if a 
+ *                          display sink , otherwise this field is 0x0. 
+ */
+typedef struct OMX_IMAGE_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth; 
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;     
+    OMX_U32 nSliceHeight;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_IMAGE_PORTDEFINITIONTYPE;
+
+
+/**  
+ * Port format parameter.  This structure is used to enumerate the various 
+ * data input/output format supported by the port.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from 
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the 
+ *                       component. When OMX_IMAGE_CodingUnused is specified, 
+ *                       eColorFormat is valid
+ *  eColorFormat       : Decompressed format used by this component
+ */
+typedef struct OMX_IMAGE_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+} OMX_IMAGE_PARAM_PORTFORMATTYPE;
+
+
+/** 
+ * Flash control type 
+ *
+ * ENUMS
+ *  Torch : Flash forced constantly on
+ */
+typedef enum OMX_IMAGE_FLASHCONTROLTYPE {
+    OMX_IMAGE_FlashControlOn = 0,
+    OMX_IMAGE_FlashControlOff,
+    OMX_IMAGE_FlashControlAuto,
+    OMX_IMAGE_FlashControlRedEyeReduction,
+    OMX_IMAGE_FlashControlFillin,
+    OMX_IMAGE_FlashControlTorch,
+    OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FLASHCONTROLTYPE;
+
+
+/** 
+ * Flash control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize         : Size of the structure in bytes
+ *  nVersion      : OMX specification version information
+ *  nPortIndex    : Port that this structure applies to
+ *  eFlashControl : Flash control type
+ */
+typedef struct OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
+} OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
+
+
+/** 
+ * Focus control type 
+ */
+typedef enum OMX_IMAGE_FOCUSCONTROLTYPE {
+    OMX_IMAGE_FocusControlOn = 0,
+    OMX_IMAGE_FocusControlOff,
+    OMX_IMAGE_FocusControlAuto,
+    OMX_IMAGE_FocusControlAutoLock,
+    OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
+} OMX_IMAGE_FOCUSCONTROLTYPE;
+
+ 
+/** 
+ * Focus control configuration 
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  eFocusControl   : Focus control
+ *  nFocusSteps     : Focus can take on values from 0 mm to infinity. 
+ *                    Interest is only in number of steps over this range.
+ *  nFocusStepIndex : Current focus step index
+ */
+typedef struct OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
+    OMX_U32 nFocusSteps;
+    OMX_U32 nFocusStepIndex;
+} OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
+
+
+/** 
+ * Q Factor for JPEG compression, which controls the tradeoff between image
+ * quality and size.  Q Factor provides a more simple means of controlling
+ * JPEG compression quality, without directly programming Quantization
+ * tables for chroma and luma 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes         
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to 
+ *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1 
+ *               produces the smallest, worst quality images, and a factor 
+ *               of 100 produces the largest, best quality images.  A 
+ *               typical default is 75 for small good quality images               
+ */
+typedef struct OMX_IMAGE_PARAM_QFACTORTYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_U32 nQFactor;                                        
+} OMX_IMAGE_PARAM_QFACTORTYPE;
+
+/** 
+ * Quantization table type 
+ */
+
+typedef enum OMX_IMAGE_QUANTIZATIONTABLETYPE {
+    OMX_IMAGE_QuantizationTableLuma = 0,
+    OMX_IMAGE_QuantizationTableChroma,
+    OMX_IMAGE_QuantizationTableChromaCb,
+    OMX_IMAGE_QuantizationTableChromaCr,
+    OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
+} OMX_IMAGE_QUANTIZATIONTABLETYPE;
+
+/** 
+ * JPEG quantization tables are used to determine DCT compression for
+ * YUV data, as an alternative to specifying Q factor, providing exact 
+ * control of compression 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information 
+ *  nPortIndex              : Port that this structure applies to
+ *  eQuantizationTable      : Quantization table type
+ *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored 
+ *                            in increasing columns then by rows of data (i.e. 
+ *                            row 1, ... row 8). Quantization values are in 
+ *                            the range 0-255 and stored in linear order
+ *                            (i.e. the component will zig-zag the 
+ *                            quantization table data if required internally) 
+ */
+typedef struct OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
+    OMX_U8 nQuantizationMatrix[64];
+} OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
+
+
+/** 
+ * Huffman table type, the same Huffman table is applied for chroma and 
+ * luma component 
+ */
+typedef enum OMX_IMAGE_HUFFMANTABLETYPE {
+    OMX_IMAGE_HuffmanTableAC = 0,
+    OMX_IMAGE_HuffmanTableDC,
+    OMX_IMAGE_HuffmanTableACLuma,
+    OMX_IMAGE_HuffmanTableACChroma,
+    OMX_IMAGE_HuffmanTableDCLuma,
+    OMX_IMAGE_HuffmanTableDCChroma,
+    OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
+} OMX_IMAGE_HUFFMANTABLETYPE;
+
+/** 
+ * JPEG Huffman table 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                            : Size of the structure in bytes
+ *  nVersion                         : OMX specification version information
+ *  nPortIndex                       : Port that this structure applies to
+ *  eHuffmanTable                    : Huffman table type
+ *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each 
+ *                                     possible length
+ *  nHuffmanTable[256]               : 0-255, the size used for AC and DC 
+ *                                     HuffmanTable are 16 and 162 
+ */
+typedef struct OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
+    OMX_U8 nNumberOfHuffmanCodeOfLength[16];
+    OMX_U8 nHuffmanTable[256];
+}OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_ImageConvert.h b/OpenMAXIL/ghdr/OMX_ImageConvert.h
new file mode 100755
index 0000000..b30a38b
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_ImageConvert.h
@@ -0,0 +1,54 @@
+/*!
+ *  Copyright (c) 2009-2010,2012 Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ *  History :
+ *  Date             Author       Version    Description
+ *
+ *  07/01/2009-2010       Li Jian      0.1     Created
+ *
+ * OMX_ImageConvert.h
+ */
+
+#include "OMX_Core.h"
+#include "OMX_Component.h"
+#include "OMX_GraphManager.h"
+
+typedef enum {
+    NULL_RESIZE_MODE,
+    KEEP_ORG_RESOLUTION,
+    KEEP_DEST_RESOLUTION
+}Resize_mode;
+
+typedef enum {
+    PROPERTY_NONE,
+    PROPERTY_RESIZE_MODE,
+    PROPERTY_OUT_FILE,
+    PROPERTY_OUT_BUFFER
+}IC_PROPERTY;
+
+typedef struct _OMX_ImageConvert OMX_ImageConvert;
+struct _OMX_ImageConvert
+{
+	OMX_BOOL (*resize)(OMX_ImageConvert *h, 
+                           OMX_IMAGE_PORTDEFINITIONTYPE *in_format, OMX_CONFIG_RECTTYPE *pCropRect, OMX_U8 *in,
+                           OMX_IMAGE_PORTDEFINITIONTYPE *out_format, OMX_U8 *out);
+	OMX_BOOL (*jpeg_enc)(OMX_ImageConvert *h, OMX_IMAGE_PORTDEFINITIONTYPE *format, OMX_U8 *buf);
+	OMX_BOOL (*raw_data)(OMX_ImageConvert *h, OMX_IMAGE_PORTDEFINITIONTYPE *format, OMX_U8 *buf);
+        OMX_BOOL (*set_property)(OMX_ImageConvert *h, IC_PROPERTY property, OMX_PTR value);
+        OMX_BOOL (*delete_it)(OMX_ImageConvert *h);
+	void* pData;
+};
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+OMX_ImageConvert* OMX_ImageConvertCreate();
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
diff --git a/OpenMAXIL/ghdr/OMX_Implement.h b/OpenMAXIL/ghdr/OMX_Implement.h
new file mode 100755
index 0000000..e0c0021
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Implement.h
@@ -0,0 +1,489 @@
+/**
+ *  Copyright (c) 2009-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file OMX_Implement_h
+ *  @brief Contains the common definitions for implementing OpenMAX IL
+ *  @ingroup OMX_Implement
+ */
+
+
+#ifndef OMX_Implement_h
+#define OMX_Implement_h
+
+#include "fsl_osal.h"
+#include "OMX_Types.h"
+#include "OMX_Core.h"
+#include "OMX_Audio.h"
+#include "OMX_Video.h"
+
+
+/*copied from DivxDrmExtn.h*/
+#ifndef MFW_AVI_SUPPORT_DIVX_DRM
+#define MFW_AVI_SUPPORT_DIVX_DRM
+#endif
+
+/**< fsl defined buffer flags */
+#define OMX_BUFFERFLAG_STARTTRICK 0x10000000
+#define OMX_BUFFERFLAG_MAX_FILESIZE 0x20000000 
+#define OMX_BUFFERFLAG_MAX_DURATION 0x40000000 
+
+/**< fsl defined error type */
+#define FSL_ERRORTYPE(n) ((OMX_ERRORTYPE)(OMX_ErrorVendorStartUnused + n))
+#define OMX_ErrorNotComplete FSL_ERRORTYPE(1)
+#define OMX_ErrorNetworkFail FSL_ERRORTYPE(2)
+
+/**< fsl defined Event type */
+#define FSL_EVENTTYPE(n) ((OMX_EVENTTYPE)(OMX_EventVendorStartUnused + n))
+#define OMX_EventBufferingData FSL_EVENTTYPE(1)
+#define OMX_EventBufferingDone FSL_EVENTTYPE(2)
+#define OMX_EventBufferingUpdate FSL_EVENTTYPE(3)
+#define OMX_EventStreamSkipped FSL_EVENTTYPE(4)
+#define OMX_EventRenderingStart FSL_EVENTTYPE(5)
+#define OMX_EventNetworkFail FSL_EVENTTYPE(6)
+
+/**< fsl defined media type */
+#define   OMX_VIDEO_CodingDIVX    (OMX_VIDEO_CodingVendorStartUnused + 1)  /**< Divx */
+#define   OMX_VIDEO_CodingXVID    (OMX_VIDEO_CodingVendorStartUnused + 2)  /**< Xvid */
+#define   OMX_VIDEO_CodingDIV3    (OMX_VIDEO_CodingVendorStartUnused + 3)  /**< Divx3 */
+#define   OMX_VIDEO_CodingDIV4    (OMX_VIDEO_CodingVendorStartUnused + 4)  /**< Divx4 */
+#define   OMX_VIDEO_CodingVP8     (OMX_VIDEO_CodingVendorStartUnused + 5)  /**< VP8 */
+/**< Google externed the type to 9. */
+#define   OMX_VIDEO_CodingVPX     (9)  /**< Google VPX */
+#define   OMX_VIDEO_WMVFormat9a   (OMX_VIDEO_WMFFormatVendorStartUnused + 1) /**< WVC1 */
+#define   OMX_VIDEO_CodingWMV9    (OMX_VIDEO_WMFFormatVendorStartUnused + 21) /**< WVC1 */
+#define   OMX_VIDEO_WMVFormatWVC1 (OMX_VIDEO_WMFFormatVendorStartUnused + 22) /**< WVC1 */
+#define   OMX_VIDEO_SORENSON263   (OMX_VIDEO_WMFFormatVendorStartUnused + 23) /**< SORENSON */
+
+#define   OMX_AUDIO_CodingFLAC    (OMX_AUDIO_CodingVendorStartUnused + 1)
+#define   OMX_AUDIO_CodingAC3     (OMX_AUDIO_CodingVendorStartUnused + 2)
+#define   OMX_AUDIO_CodingIEC937  ((OMX_AUDIO_CODINGTYPE)(OMX_AUDIO_CodingVendorStartUnused + 3))
+#define   OMX_AUDIO_CodingEC3     (OMX_AUDIO_CodingVendorStartUnused + 4)
+
+/**<Reserved android opaque colorformat. Tells the encoder that
+ * the actual colorformat will be  relayed by the
+ * Gralloc Buffers.
+ * FIXME: In the process of reserving some enum values for
+ * Android-specific OMX IL colorformats. Change this enum to
+ * an acceptable range once that is done.
+ * */
+#define   OMX_COLOR_FormatAndroidOpaque (0x7F000789)
+#define   FSL_INDEXCOLOR(n) ((OMX_COLOR_FORMATTYPE)(OMX_COLOR_FormatVendorStartUnused + n))
+#define   OMX_COLOR_Format32bitRGBA8888 FSL_INDEXCOLOR(1)
+
+/**< fsl defined index */
+#define   FSL_INDEXTYPE(n) ((OMX_INDEXTYPE)(OMX_IndexVendorStartUnused + n))
+#define   OMX_IndexParamMediaSeekable FSL_INDEXTYPE(1)
+#define   OMX_IndexParamMediaDuration FSL_INDEXTYPE(2)
+#define   OMX_IndexParamTrackDuration FSL_INDEXTYPE(3)          /* OMX_TRACK_DURATION */
+#define   OMX_IndexConfigParserSendAudioFirst FSL_INDEXTYPE(4)  /* OMX_CONFIG_SENDAUDIOFIRST */
+	
+#define   OMX_IndexConfigCaptureFrame FSL_INDEXTYPE(5)          /* OMX_CONFIG_CAPTUREFRAME */
+#define   OMX_IndexOutputMode FSL_INDEXTYPE(6)                  /* OMX_CONFIG_OUTPUTMODE */
+#define   OMX_IndexSysSleep FSL_INDEXTYPE(7)                   /* OMX_CONFIG_SYSSLEEP */
+
+#define   INDEX_CONFIG_DIVX_DRM_CALLBACK FSL_INDEXTYPE(8)
+#define   INDEX_VC1_EXTRA_DATA 	FSL_INDEXTYPE(9)	
+#define   OMX_IndexParamAudioAc3 FSL_INDEXTYPE(10)
+#define   OMX_IndexConfigAudioPostProcess FSL_INDEXTYPE(11)
+#define   OMX_IndexParamAudioSink FSL_INDEXTYPE(12)
+#define   OMX_IndexConfigClock FSL_INDEXTYPE(13)                 /* OMX_CONFIG_CLOCK */
+#define   OMX_IndexConfigVideoOutBufPhyAddr FSL_INDEXTYPE(14)
+#define   OMX_IndexParamAudioFlac FSL_INDEXTYPE(15)
+#define   OMX_IndexParamMemOperator FSL_INDEXTYPE(16)
+#define   OMX_IndexConfigAbortBuffering FSL_INDEXTYPE(17)  //OMX_CONFIG_ABORTBUFFERING
+#define   OMX_IndexParamVideoCamera FSL_INDEXTYPE(18)
+#define   OMX_IndexParamVideoCameraId FSL_INDEXTYPE(19)
+#define   OMX_IndexParamVideoSurface FSL_INDEXTYPE(20)
+#define   OMX_IndexParamMaxFileDuration FSL_INDEXTYPE(21)
+#define   OMX_IndexParamMaxFileSize FSL_INDEXTYPE(22)
+#define   OMX_IndexParamInterleaveUs FSL_INDEXTYPE(23)
+#define   OMX_IndexParamIsGetMetadata FSL_INDEXTYPE(24)
+#define   OMX_IndexParamSurface FSL_INDEXTYPE(25)
+#define   OMX_IndexConfigEOS FSL_INDEXTYPE(26)
+#define   OMX_IndexParamAudioSource FSL_INDEXTYPE(27)
+#define   OMX_IndexConfigMaxAmplitude FSL_INDEXTYPE(28)
+#define   OMX_IndexParamDecoderPlayMode FSL_INDEXTYPE(29)
+#define   OMX_IndexParamTimeLapseUs FSL_INDEXTYPE(30)
+#define   OMX_IndexParamAudioWmaExt FSL_INDEXTYPE(31)
+#define   OMX_IndexParamVideoDecChromaAlign FSL_INDEXTYPE(32)
+#define   OMX_IndexParamVideoCameraProxy FSL_INDEXTYPE(33)
+#define   OMX_IndexParamLongitudex FSL_INDEXTYPE(34)
+#define   OMX_IndexParamLatitudex FSL_INDEXTYPE(35)
+#define   OMX_IndexParamBufferUsage FSL_INDEXTYPE(36)  //OMX_BUFFER_USAGE
+#define   OMX_IndexParamDecoderCachedThreshold FSL_INDEXTYPE(37)  //control the speed of input consumed by decoder
+#define   OMX_IndexParamVideoRegisterFrameExt FSL_INDEXTYPE(38)  //control the stride for frame width/height
+#define   OMX_IndexParamAudioRenderMode FSL_INDEXTYPE(40)
+#define   OMX_IndexConfigScalingMode FSL_INDEXTYPE(41)
+#define   OMX_IndexParamEnableAndroidNativeBuffers FSL_INDEXTYPE(41)
+#define   OMX_IndexParamNativeBufferUsage FSL_INDEXTYPE(43)
+#define   OMX_IndexParamStoreMetaDataInBuffers FSL_INDEXTYPE(44) 
+#define   OMX_IndexParamUseAndroidNativeBuffer FSL_INDEXTYPE(45)
+#define   OMX_IndexParamSubtitleSelect FSL_INDEXTYPE(46)
+#define   OMX_IndexParamSubtitleNumAvailableStreams FSL_INDEXTYPE(47)
+#define   OMX_IndexParamSubtitleNextSample FSL_INDEXTYPE(48)
+#define   OMX_IndexParamSubtitleConfigTimePosition FSL_INDEXTYPE(49)
+#define   OMX_IndexConfigInsertVideoCodecData FSL_INDEXTYPE(50)
+#define   OMX_IndexConfigGrallocBufferParameter FSL_INDEXTYPE(51)
+#define   OMX_IndexParamUseAndroidPrependSPSPPStoIDRFrames FSL_INDEXTYPE(52)
+#define   OMX_IndexParamFileOffset64Bits FSL_INDEXTYPE(53)
+#define   OMX_IndexParamClientName FSL_INDEXTYPE(54)
+#define   OMX_IndexParamClientUID FSL_INDEXTYPE(55)
+#define   OMX_IndexParamAudioEc3 FSL_INDEXTYPE(56)
+#define   OMX_IndexParamVideoDecReorderDisable FSL_INDEXTYPE(57)
+
+/**< fsl defined macro utils */
+#define MAX_NAME_LEN 128
+#define MAX_PORT_NUM 8
+#define MAX_PORT_BUFFER 32
+#define MAX_PORT_FORMAT_NUM 32
+
+#define CONTENTPIPE_NAME_LEN 128
+#define COMPONENT_NAME_LEN 128
+#define FUNCTION_NAME_LEN 128
+#define ROLE_NAME_LEN 128
+#define MAX_COMPONENTNUM_WITH_SAME_ROLE 8
+#define CORE_NAME_LEN 128
+#define MAX_VALUE_S64 (OMX_S64)((1ULL<<63)-1)
+#define MAX_VALUE_S32 (OMX_S32)((1ULL<<31)-1)
+
+#define MAX(a,b) ((a)>=(b)?(a):(b))
+#define MIN(a,b) ((a)<=(b)?(a):(b))
+#define ABS(a) (((a)>0)?(a):-(a))
+#ifndef Q16_SHIFT  
+#define Q16_SHIFT (0x10000)
+#endif
+#define INVALID_TS (-1)
+#define MAX_RATE (1.9)
+#define MIN_RATE (0.1)
+#define MAX_TRICK_MODE_RATE (16)
+#define MIN_TRICK_FORWARD_RATE 2
+#define MIN_TRICK_REWIND_RATE -2
+#define IS_TRICK_PLAY(scale) ((scale) <= MIN_TRICK_REWIND_RATE * Q16_SHIFT || (scale) >= MIN_TRICK_FORWARD_RATE * Q16_SHIFT)
+#define IS_TRICK_REWIND(scale) ((scale) <= MIN_TRICK_REWIND_RATE * Q16_SHIFT)
+#define IS_TRICK_FORWARD(scale) ((scale) >= MIN_TRICK_FORWARD_RATE * Q16_SHIFT)
+#define IS_NORMAL_PLAY(scale) ((scale) >= MIN_RATE * Q16_SHIFT && (scale) <= MAX_RATE * Q16_SHIFT)
+
+#define OMX_INIT_STRUCT(ptr, type) \
+    do { \
+        fsl_osal_memset((ptr), 0x0, sizeof(type)); \
+        (ptr)->nSize = sizeof(type); \
+        (ptr)->nVersion.s.nVersionMajor = 0x1; \
+        (ptr)->nVersion.s.nVersionMinor = 0x1; \
+        (ptr)->nVersion.s.nRevision = 0x2; \
+        (ptr)->nVersion.s.nStep = 0x0; \
+    } while(0);
+
+
+/**< fsl defined types */
+/* Display rotation type */
+typedef enum {
+    ROTATE_NONE = 0,
+    ROTATE_VERT_FLIP,
+    ROTATE_HORIZ_FLIP,
+    ROTATE_180,
+    ROTATE_90_RIGHT,
+    ROTATE_90_RIGHT_VFLIP,
+    ROTATE_90_RIGHT_HFLIP,
+    ROTATE_90_LEFT
+}ROTATION;
+
+typedef enum
+{
+    DIVX_DRM_ERROR_NONE = 0,     /*!< No drm error happens */
+    DIVX_DRM_OUTPUT_PROTECTION_COMMIT,
+    DIVX_DRM_ERR_NEED_RENTAL_CONFIRMATION, /*!< No drm error happens but this is a rental file.
+                                            Need user's confirmation to play it or not.
+                                            GUI shall display how many views left for this file, 
+                                            and let user decide whether to play the file. */
+    DIVX_DRM_ERROR_NOT_AUTH_USER,        /*!< Not an authorized user. 
+                                        The user shall activate the player if not, 
+                                        or this encrypted file is for another user.*/
+    DIVX_DRM_ERROR_RENTAL_EXPIRED,       /*!< This is a rental file and is expired. So the user can no longer play it. */
+    DIVX_DRM_ERROR_OTHERS,       /*!< Other error, reserved.*/
+} DIVX_DRM_ERR_CODE;
+
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_TICKS sTrackDuration;
+}OMX_TRACK_DURATION;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bSendAudioFrameFirst;
+}OMX_CONFIG_SENDAUDIOFIRST;
+
+/** FLAC params */
+typedef struct OMX_AUDIO_PARAM_FLACTYPE {
+    OMX_U32 nSize;                 
+    OMX_VERSIONTYPE nVersion;      
+    OMX_U32 nPortIndex;            
+    OMX_U32 nChannels;             
+    OMX_U32 nBitRate;              
+    OMX_U32 nSampleRate;           
+    OMX_U32 nBitPerSample;       
+    OMX_U32 nTotalSample;       
+    OMX_U32 nBlockSize;       
+} OMX_AUDIO_PARAM_FLACTYPE;
+
+/** AC3 params */
+typedef struct OMX_AUDIO_PARAM_AC3TYPE {
+    OMX_U32 nSize;                 
+    OMX_VERSIONTYPE nVersion;      
+    OMX_U32 nPortIndex;            
+    OMX_U32 nChannels;             
+    OMX_U32 nBitRate;              
+    OMX_U32 nSampleRate;           
+    OMX_U32 nAudioBandWidth;       
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   
+} OMX_AUDIO_PARAM_AC3TYPE;
+
+/** EC3 params */
+typedef struct OMX_AUDIO_PARAM_EC3TYPE {
+    OMX_U32 nSize;                 
+    OMX_VERSIONTYPE nVersion;      
+    OMX_U32 nPortIndex;            
+    OMX_U32 nChannels;             
+    OMX_U32 nBitRate;              
+    OMX_U32 nSampleRate;           
+    OMX_U32 nAudioBandWidth;       
+    OMX_AUDIO_CHANNELMODETYPE eChannelMode;   
+} OMX_AUDIO_PARAM_EC3TYPE;
+
+typedef struct OMX_AUDIO_CONFIG_POSTPROCESSTYPE {
+    OMX_U32 nSize;             /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    OMX_BOOL bEnable;          /**< Enable/disable for post process */
+    OMX_BU32 sDelay;           /**< average delay in milliseconds */
+} OMX_AUDIO_CONFIG_POSTPROCESSTYPE;
+
+typedef struct
+{
+    OMX_STRING  sInFilePath;
+    OMX_S32     nEncoder;
+    OMX_S32     nWidth;
+    OMX_S32     nHeight;
+    OMX_BOOL    bMPEG4FrameParsing;   //Needs to be enabled for frame decoding
+    OMX_BOOL    bH264FrameParsing;    //Needs to be enabled for frame decoding
+    OMX_BOOL    bWmvDecParsing;     //Enabled if source parses for frame size
+    OMX_S32     RealVideo;
+    OMX_BOOL    bAVCEnc;
+}VIDSRC_CONFIG;
+
+typedef struct {
+    OMX_U32 nPortIdx;
+    OMX_U32 size;
+    OMX_U8  data[128];
+}EXTRA_DATA;
+
+typedef enum {
+    CAP_NONE,
+    CAP_SNAPSHOT,
+    CAP_THUMBNAL
+}CAPTURETYPE;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    CAPTURETYPE eType;
+    OMX_BOOL bDone;
+    OMX_U8* pBuffer;
+    OMX_U32 nFilledLen;
+}OMX_CONFIG_CAPTUREFRAME;
+
+typedef enum {
+    MODE_NONE,
+    MODE_PAL,
+    MODE_NTSC,
+    MODE_720P
+}TV_MODE;
+
+typedef enum {
+    LAYER_NONE,
+    LAYER0,
+    LAYER1,
+    LAYER2,
+}FB_LAYER;
+
+typedef enum {
+    DEC_STREAM_MODE,
+    DEC_FILE_MODE,
+}OMX_DECODE_MODE;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bTv;
+    FB_LAYER eFbLayer;
+    TV_MODE eTvMode; 
+    OMX_CONFIG_RECTTYPE sRectIn;
+    OMX_CONFIG_RECTTYPE sRectOut;
+    ROTATION eRotation;
+    OMX_BOOL bSetupDone;
+}OMX_CONFIG_OUTPUTMODE;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bSleep;
+}OMX_CONFIG_SYSSLEEP;
+
+
+typedef struct _DivxDrmInfo
+{
+    int drm_code;   /* divx drm error code */
+    int  use_limit;     /* Maximum views of a rental file. 0 means this is NOT a rental file. */
+    int  use_count;     /* Views already played by the user for a rental file. Only valid for a rental file.
+                        No greater than the "use_limit".If its equal to the "use_limit", this rental file is expired. */
+    int rental_confirmed;   /* Only valid for a rental file,
+                            whether user confirms to play the rental file. */
+    OMX_U8 cgmsaSignal;
+    OMX_U8 acptbSignal;
+    OMX_U8 digitalProtectionSignal;  								
+	OMX_BOOL bDivxDrmPresent;
+}DivxDrmInfo;
+
+typedef void (*pf_cb_drm)(void* context, OMX_PTR drm_info);
+
+
+typedef struct OMX_CONFIG_CAPABILITY {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32  nPortIndex;      /**< Port index*/
+    OMX_BOOL bCapability;     /**< Flag to indicate if this media syncable */
+} OMX_PARAM_CAPABILITY;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_PTR hClock;
+} OMX_CONFIG_CLOCK;
+
+ /** 
+ * Video out port buffer physical address
+ *
+ * STRUCT MEMBERS:
+ *  nSize         : Size of the structure in bytes                    
+ *  nVersion      : OMX specification version information      
+ *  nBufferIndex  : Which buffer to query
+ *  nPhysicalAddr : Physical address to return
+ */
+typedef struct OMX_CONFIG_VIDEO_OUTBUFTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_BUFFERHEADERTYPE  * pBufferHdr;
+    OMX_PTR nPhysicalAddr;
+} OMX_CONFIG_VIDEO_OUTBUFTYPE;
+
+/* memory operator functions */
+typedef struct 
+{
+    int nSize;                        /*!requested memory size */
+    unsigned long nPhyAddr; /*!physical memory address allocated */
+    unsigned long nCpuAddr; /*!cpu addr for system free usage */
+    unsigned long nVirtAddr; /*!virtual user space address */	
+}OMX_MEM_DESC;
+typedef OMX_BOOL (*pf_mem_malloc)(OMX_MEM_DESC* pOutMemDesc);
+typedef OMX_BOOL (*pf_mem_free)(OMX_MEM_DESC* pOutMemDesc);
+typedef struct {
+    pf_mem_malloc pfMalloc;
+    pf_mem_free pfFree;
+} OMX_PARAM_MEM_OPERATOR;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bAbort;
+} OMX_CONFIG_ABORTBUFFERING;
+
+typedef struct {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bGetMetadata;
+} OMX_PARAM_IS_GET_METADATA;
+
+/** WMA params externtion */
+typedef struct OMX_AUDIO_PARAM_WMATYPE_EXT {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+	/**< Extensions for WMA codec config */
+    OMX_U32 nBitsPerSample;   
+} OMX_AUDIO_PARAM_WMATYPE_EXT;
+
+typedef enum {
+    BUFFER_SW_READ_NEVER  = 0x1,
+    BUFFER_SW_READ_OFTEN  = 0x2,
+    BUFFER_SW_WRITE_NEVER = 0x4,
+    BUFFER_SW_WRITE_OFTEN = 0x8,
+    BUFFER_PHY_CONTINIOUS = 0x10
+} OMX_BUFFER_USAGE;
+
+typedef struct {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_S32 nMaxDurationMsThreshold;
+    OMX_S32 nMaxBufCntThreshold;
+}OMX_DECODER_CACHED_THR;
+
+typedef struct {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_S32 nWidthStride;    /*-1: user don't care the stride, it is decoder's resposibility to decide the stride*/
+    OMX_S32 nHeightStride;   /*-1: user don't care the stride, it is decoder's resposibility to decide the stride*/
+    OMX_S32 nMaxBufferCnt;  /*-1: user don't care the count, it is decoder's responsibility to decide the count value*/
+}OMX_VIDEO_REG_FRM_EXT_INFO;
+
+// Used to transfer buffer between camera source and VPU encoder.
+typedef struct {
+    OMX_PTR pPhysicAddress;
+}METADATA_BUFFER;
+
+// Used to set parameters got from Gralloc buffer to VPU encoder.
+typedef struct {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    OMX_COLOR_FORMATTYPE eColorFormat;
+}GRALLOC_BUFFER_PARAMETER;
+
+/*subtitle sample structure*/
+typedef struct {
+    OMX_U8* pBuffer;
+    OMX_S32 nFilledLen;
+    OMX_TICKS nTimeStamp;
+    OMX_U32 nFlags;
+}OMX_SUBTITLE_SAMPLE;
+
+typedef struct {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_BOOL bEnableSPSToIDR; /*Add SPS/PPS into every IDR frame*/
+} OMX_PARAM_PREPEND_SPSPPS_TO_IDR;
+
+typedef struct { 
+    OMX_U32 nSize;                    /**< Size of this structure, in Bytes */ 
+    OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */ 
+    OMX_BOOL bDisable;                     /**< BOOL value */
+} OMX_DECODER_REORDER;
+
+#endif
+
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_Index.h b/OpenMAXIL/ghdr/OMX_Index.h
new file mode 100755
index 0000000..101595a
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Index.h
@@ -0,0 +1,258 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Index.h - OpenMax IL version 1.1.2
+ *  The OMX_Index header file contains the definitions for both applications
+ *  and components .
+ */
+
+
+#ifndef OMX_Index_h
+#define OMX_Index_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+#include <OMX_Types.h>
+
+
+/** The OMX_INDEXTYPE enumeration is used to select a structure when either
+ *  getting or setting parameters and/or configuration data.  Each entry in 
+ *  this enumeration maps to an OMX specified structure.  When the 
+ *  OMX_GetParameter, OMX_SetParameter, OMX_GetConfig or OMX_SetConfig methods
+ *  are used, the second parameter will always be an entry from this enumeration
+ *  and the third entry will be the structure shown in the comments for the entry.
+ *  For example, if the application is initializing a cropping function, the 
+ *  OMX_SetConfig command would have OMX_IndexConfigCommonInputCrop as the second parameter 
+ *  and would send a pointer to an initialized OMX_RECTTYPE structure as the 
+ *  third parameter.
+ *  
+ *  The enumeration entries named with the OMX_Config prefix are sent using
+ *  the OMX_SetConfig command and the enumeration entries named with the
+ *  OMX_PARAM_ prefix are sent using the OMX_SetParameter command.
+ */
+typedef enum OMX_INDEXTYPE {
+
+    OMX_IndexComponentStartUnused = 0x01000000,
+    OMX_IndexParamPriorityMgmt,             /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamAudioInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamImageInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamVideoInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamOtherInit,                /**< reference: OMX_PORT_PARAM_TYPE */
+    OMX_IndexParamNumAvailableStreams,      /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamActiveStream,             /**< reference: OMX_PARAM_U32TYPE */
+    OMX_IndexParamSuspensionPolicy,         /**< reference: OMX_PARAM_SUSPENSIONPOLICYTYPE */
+    OMX_IndexParamComponentSuspended,       /**< reference: OMX_PARAM_SUSPENSIONTYPE */
+    OMX_IndexConfigCapturing,               /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexConfigCaptureMode,             /**< reference: OMX_CONFIG_CAPTUREMODETYPE */ 
+    OMX_IndexAutoPauseAfterCapture,         /**< reference: OMX_CONFIG_BOOLEANTYPE */ 
+    OMX_IndexParamContentURI,               /**< reference: OMX_PARAM_CONTENTURITYPE */
+    OMX_IndexParamCustomContentPipe,        /**< reference: OMX_PARAM_CONTENTPIPETYPE */ 
+    OMX_IndexParamDisableResourceConcealment, /**< reference: OMX_RESOURCECONCEALMENTTYPE */
+    OMX_IndexConfigMetadataItemCount,       /**< reference: OMX_CONFIG_METADATAITEMCOUNTTYPE */
+    OMX_IndexConfigContainerNodeCount,      /**< reference: OMX_CONFIG_CONTAINERNODECOUNTTYPE */
+    OMX_IndexConfigMetadataItem,            /**< reference: OMX_CONFIG_METADATAITEMTYPE */
+    OMX_IndexConfigCounterNodeID,           /**< reference: OMX_CONFIG_CONTAINERNODEIDTYPE */
+    OMX_IndexParamMetadataFilterType,       /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexParamMetadataKeyFilter,        /**< reference: OMX_PARAM_METADATAFILTERTYPE */
+    OMX_IndexConfigPriorityMgmt,            /**< reference: OMX_PRIORITYMGMTTYPE */
+    OMX_IndexParamStandardComponentRole,    /**< reference: OMX_PARAM_COMPONENTROLETYPE */
+
+    OMX_IndexPortStartUnused = 0x02000000,
+    OMX_IndexParamPortDefinition,           /**< reference: OMX_PARAM_PORTDEFINITIONTYPE */
+    OMX_IndexParamCompBufferSupplier,       /**< reference: OMX_PARAM_BUFFERSUPPLIERTYPE */ 
+    OMX_IndexReservedStartUnused = 0x03000000,
+
+    /* Audio parameters and configurations */
+    OMX_IndexAudioStartUnused = 0x04000000,
+    OMX_IndexParamAudioPortFormat,          /**< reference: OMX_AUDIO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamAudioPcm,                 /**< reference: OMX_AUDIO_PARAM_PCMMODETYPE */
+    OMX_IndexParamAudioAac,                 /**< reference: OMX_AUDIO_PARAM_AACPROFILETYPE */
+    OMX_IndexParamAudioRa,                  /**< reference: OMX_AUDIO_PARAM_RATYPE */
+    OMX_IndexParamAudioMp3,                 /**< reference: OMX_AUDIO_PARAM_MP3TYPE */
+    OMX_IndexParamAudioAdpcm,               /**< reference: OMX_AUDIO_PARAM_ADPCMTYPE */
+    OMX_IndexParamAudioG723,                /**< reference: OMX_AUDIO_PARAM_G723TYPE */
+    OMX_IndexParamAudioG729,                /**< reference: OMX_AUDIO_PARAM_G729TYPE */
+    OMX_IndexParamAudioAmr,                 /**< reference: OMX_AUDIO_PARAM_AMRTYPE */
+    OMX_IndexParamAudioWma,                 /**< reference: OMX_AUDIO_PARAM_WMATYPE */
+    OMX_IndexParamAudioSbc,                 /**< reference: OMX_AUDIO_PARAM_SBCTYPE */
+    OMX_IndexParamAudioMidi,                /**< reference: OMX_AUDIO_PARAM_MIDITYPE */
+    OMX_IndexParamAudioGsm_FR,              /**< reference: OMX_AUDIO_PARAM_GSMFRTYPE */
+    OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
+    OMX_IndexParamAudioG726,                /**< reference: OMX_AUDIO_PARAM_G726TYPE */
+    OMX_IndexParamAudioGsm_EFR,             /**< reference: OMX_AUDIO_PARAM_GSMEFRTYPE */
+    OMX_IndexParamAudioGsm_HR,              /**< reference: OMX_AUDIO_PARAM_GSMHRTYPE */
+    OMX_IndexParamAudioPdc_FR,              /**< reference: OMX_AUDIO_PARAM_PDCFRTYPE */
+    OMX_IndexParamAudioPdc_EFR,             /**< reference: OMX_AUDIO_PARAM_PDCEFRTYPE */
+    OMX_IndexParamAudioPdc_HR,              /**< reference: OMX_AUDIO_PARAM_PDCHRTYPE */
+    OMX_IndexParamAudioTdma_FR,             /**< reference: OMX_AUDIO_PARAM_TDMAFRTYPE */
+    OMX_IndexParamAudioTdma_EFR,            /**< reference: OMX_AUDIO_PARAM_TDMAEFRTYPE */
+    OMX_IndexParamAudioQcelp8,              /**< reference: OMX_AUDIO_PARAM_QCELP8TYPE */
+    OMX_IndexParamAudioQcelp13,             /**< reference: OMX_AUDIO_PARAM_QCELP13TYPE */
+    OMX_IndexParamAudioEvrc,                /**< reference: OMX_AUDIO_PARAM_EVRCTYPE */
+    OMX_IndexParamAudioSmv,                 /**< reference: OMX_AUDIO_PARAM_SMVTYPE */
+    OMX_IndexParamAudioVorbis,              /**< reference: OMX_AUDIO_PARAM_VORBISTYPE */
+
+    OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
+    OMX_IndexConfigAudioMidiControl,        /**< reference: OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
+    OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
+    OMX_IndexConfigAudioMidiStatus,         /**< reference: OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
+    OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
+    OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
+    OMX_IndexConfigAudioVolume,             /**< reference: OMX_AUDIO_CONFIG_VOLUMETYPE */
+    OMX_IndexConfigAudioBalance,            /**< reference: OMX_AUDIO_CONFIG_BALANCETYPE */
+    OMX_IndexConfigAudioChannelMute,        /**< reference: OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
+    OMX_IndexConfigAudioMute,               /**< reference: OMX_AUDIO_CONFIG_MUTETYPE */
+    OMX_IndexConfigAudioLoudness,           /**< reference: OMX_AUDIO_CONFIG_LOUDNESSTYPE */
+    OMX_IndexConfigAudioEchoCancelation,    /**< reference: OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
+    OMX_IndexConfigAudioNoiseReduction,     /**< reference: OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
+    OMX_IndexConfigAudioBass,               /**< reference: OMX_AUDIO_CONFIG_BASSTYPE */
+    OMX_IndexConfigAudioTreble,             /**< reference: OMX_AUDIO_CONFIG_TREBLETYPE */
+    OMX_IndexConfigAudioStereoWidening,     /**< reference: OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
+    OMX_IndexConfigAudioChorus,             /**< reference: OMX_AUDIO_CONFIG_CHORUSTYPE */
+    OMX_IndexConfigAudioEqualizer,          /**< reference: OMX_AUDIO_CONFIG_EQUALIZERTYPE */
+    OMX_IndexConfigAudioReverberation,      /**< reference: OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
+    OMX_IndexConfigAudioChannelVolume,      /**< reference: OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
+
+    /* Image specific parameters and configurations */
+    OMX_IndexImageStartUnused = 0x05000000,
+    OMX_IndexParamImagePortFormat,          /**< reference: OMX_IMAGE_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamFlashControl,             /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+    OMX_IndexConfigFocusControl,            /**< reference: OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
+    OMX_IndexParamQFactor,                  /**< reference: OMX_IMAGE_PARAM_QFACTORTYPE */
+    OMX_IndexParamQuantizationTable,        /**< reference: OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
+    OMX_IndexParamHuffmanTable,             /**< reference: OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
+    OMX_IndexConfigFlashControl,            /**< reference: OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+
+    /* Video specific parameters and configurations */
+    OMX_IndexVideoStartUnused = 0x06000000,
+    OMX_IndexParamVideoPortFormat,          /**< reference: OMX_VIDEO_PARAM_PORTFORMATTYPE */
+    OMX_IndexParamVideoQuantization,        /**< reference: OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
+    OMX_IndexParamVideoFastUpdate,          /**< reference: OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
+    OMX_IndexParamVideoBitrate,             /**< reference: OMX_VIDEO_PARAM_BITRATETYPE */
+    OMX_IndexParamVideoMotionVector,        /**< reference: OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
+    OMX_IndexParamVideoIntraRefresh,        /**< reference: OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
+    OMX_IndexParamVideoErrorCorrection,     /**< reference: OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
+    OMX_IndexParamVideoVBSMC,               /**< reference: OMX_VIDEO_PARAM_VBSMCTYPE */
+    OMX_IndexParamVideoMpeg2,               /**< reference: OMX_VIDEO_PARAM_MPEG2TYPE */
+    OMX_IndexParamVideoMpeg4,               /**< reference: OMX_VIDEO_PARAM_MPEG4TYPE */
+    OMX_IndexParamVideoWmv,                 /**< reference: OMX_VIDEO_PARAM_WMVTYPE */
+    OMX_IndexParamVideoRv,                  /**< reference: OMX_VIDEO_PARAM_RVTYPE */
+    OMX_IndexParamVideoAvc,                 /**< reference: OMX_VIDEO_PARAM_AVCTYPE */
+    OMX_IndexParamVideoH263,                /**< reference: OMX_VIDEO_PARAM_H263TYPE */
+    OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexParamVideoProfileLevelCurrent, /**< reference: OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    OMX_IndexConfigVideoBitrate,            /**< reference: OMX_VIDEO_CONFIG_BITRATETYPE */
+    OMX_IndexConfigVideoFramerate,          /**< reference: OMX_CONFIG_FRAMERATETYPE */
+    OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: OMX_CONFIG_INTRAREFRESHVOPTYPE */
+    OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexConfigVideoMBErrorReporting,   /**< reference: OMX_CONFIG_MBERRORREPORTINGTYPE */
+    OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: OMX_PARAM_MACROBLOCKSTYPE */
+    OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    OMX_IndexParamVideoSliceFMO,            /**< reference: OMX_VIDEO_PARAM_AVCSLICEFMO */
+    OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
+    OMX_IndexConfigVideoNalSize,            /**< reference: OMX_VIDEO_CONFIG_NALSIZE */
+
+    /* Image & Video common Configurations */
+    OMX_IndexCommonStartUnused = 0x07000000,
+    OMX_IndexParamCommonDeblocking,         /**< reference: OMX_PARAM_DEBLOCKINGTYPE */
+    OMX_IndexParamCommonSensorMode,         /**< reference: OMX_PARAM_SENSORMODETYPE */
+    OMX_IndexParamCommonInterleave,         /**< reference: OMX_PARAM_INTERLEAVETYPE */
+    OMX_IndexConfigCommonColorFormatConversion, /**< reference: OMX_CONFIG_COLORCONVERSIONTYPE */
+    OMX_IndexConfigCommonScale,             /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonImageFilter,       /**< reference: OMX_CONFIG_IMAGEFILTERTYPE */
+    OMX_IndexConfigCommonColorEnhancement,  /**< reference: OMX_CONFIG_COLORENHANCEMENTTYPE */
+    OMX_IndexConfigCommonColorKey,          /**< reference: OMX_CONFIG_COLORKEYTYPE */
+    OMX_IndexConfigCommonColorBlend,        /**< reference: OMX_CONFIG_COLORBLENDTYPE */
+    OMX_IndexConfigCommonFrameStabilisation,/**< reference: OMX_CONFIG_FRAMESTABTYPE */
+    OMX_IndexConfigCommonRotate,            /**< reference: OMX_CONFIG_ROTATIONTYPE */
+    OMX_IndexConfigCommonMirror,            /**< reference: OMX_CONFIG_MIRRORTYPE */
+    OMX_IndexConfigCommonOutputPosition,    /**< reference: OMX_CONFIG_POINTTYPE */
+    OMX_IndexConfigCommonInputCrop,         /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonOutputCrop,        /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDigitalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE */
+    OMX_IndexConfigCommonOpticalZoom,       /**< reference: OMX_CONFIG_SCALEFACTORTYPE*/
+    OMX_IndexConfigCommonWhiteBalance,      /**< reference: OMX_CONFIG_WHITEBALCONTROLTYPE */
+    OMX_IndexConfigCommonExposure,          /**< reference: OMX_CONFIG_EXPOSURECONTROLTYPE */
+    OMX_IndexConfigCommonContrast,          /**< reference: OMX_CONFIG_CONTRASTTYPE */
+    OMX_IndexConfigCommonBrightness,        /**< reference: OMX_CONFIG_BRIGHTNESSTYPE */
+    OMX_IndexConfigCommonBacklight,         /**< reference: OMX_CONFIG_BACKLIGHTTYPE */
+    OMX_IndexConfigCommonGamma,             /**< reference: OMX_CONFIG_GAMMATYPE */
+    OMX_IndexConfigCommonSaturation,        /**< reference: OMX_CONFIG_SATURATIONTYPE */
+    OMX_IndexConfigCommonLightness,         /**< reference: OMX_CONFIG_LIGHTNESSTYPE */
+    OMX_IndexConfigCommonExclusionRect,     /**< reference: OMX_CONFIG_RECTTYPE */
+    OMX_IndexConfigCommonDithering,         /**< reference: OMX_CONFIG_DITHERTYPE */
+    OMX_IndexConfigCommonPlaneBlend,        /**< reference: OMX_CONFIG_PLANEBLENDTYPE */
+    OMX_IndexConfigCommonExposureValue,     /**< reference: OMX_CONFIG_EXPOSUREVALUETYPE */
+    OMX_IndexConfigCommonOutputSize,        /**< reference: OMX_FRAMESIZETYPE */
+    OMX_IndexParamCommonExtraQuantData,     /**< reference: OMX_OTHER_EXTRADATATYPE */
+    OMX_IndexConfigCommonFocusRegion,       /**< reference: OMX_CONFIG_FOCUSREGIONTYPE */
+    OMX_IndexConfigCommonFocusStatus,       /**< reference: OMX_PARAM_FOCUSSTATUSTYPE */
+    OMX_IndexConfigCommonTransitionEffect,  /**< reference: OMX_CONFIG_TRANSITIONEFFECTTYPE */
+
+    /* Reserved Configuration range */
+    OMX_IndexOtherStartUnused = 0x08000000,
+    OMX_IndexParamOtherPortFormat,          /**< reference: OMX_OTHER_PARAM_PORTFORMATTYPE */
+    OMX_IndexConfigOtherPower,              /**< reference: OMX_OTHER_CONFIG_POWERTYPE */
+    OMX_IndexConfigOtherStats,              /**< reference: OMX_OTHER_CONFIG_STATSTYPE */
+
+
+    /* Reserved Time range */
+    OMX_IndexTimeStartUnused = 0x09000000,
+    OMX_IndexConfigTimeScale,               /**< reference: OMX_TIME_CONFIG_SCALETYPE */
+    OMX_IndexConfigTimeClockState,          /**< reference: OMX_TIME_CONFIG_CLOCKSTATETYPE */
+    OMX_IndexConfigTimeActiveRefClock,      /**< reference: OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
+    OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentWallTime,     /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    OMX_IndexConfigTimeCurrentAudioReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeCurrentVideoReference, /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
+    OMX_IndexConfigTimeClientStartTime,     /**<reference:  OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    OMX_IndexConfigTimePosition,            /**< reference: OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    OMX_IndexConfigTimeSeekMode,            /**< reference: OMX_TIME_CONFIG_SEEKMODETYPE */
+
+
+    OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    /* Vendor specific area */
+    OMX_IndexVendorStartUnused = 0x7F000000,
+    /* Vendor specific structures should be in the range of 0x7F000000 
+       to 0x7FFFFFFE.  This range is not broken out by vendor, so
+       private indexes are not guaranteed unique and therefore should
+       only be sent to the appropriate component. */
+
+    OMX_IndexMax = 0x7FFFFFFF
+
+} OMX_INDEXTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_MetadataExtractor.h b/OpenMAXIL/ghdr/OMX_MetadataExtractor.h
new file mode 100755
index 0000000..711cbd1
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_MetadataExtractor.h
@@ -0,0 +1,75 @@
+/**
+ *  Copyright (c) 2010-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef _omx_metadataextractor_h_
+#define _omx_metadataextractor_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "OMX_Core.h"
+#include "OMX_Component.h"
+#include "fsl_osal.h"
+#include "OMX_Common.h"
+
+/*struct OMX_KeyMap {
+	const char *tag;
+	int key;
+};
+const OMX_KeyMap sOMX_KeyMap[] = {
+	{ "title", OMX_METADATA_TITLE },
+	{ "language", OMX_METADATA_LANGUAGE },
+	{ "genre", OMX_METADATA_GENRE },
+	{ "artist", OMX_METADATA_ARTIST },
+	{ "copyritht", OMX_METADATA_COPYRIGHT },
+	{ "comments", OMX_METADATA_COMMENTS },
+	{ "year", OMX_METADATA_CREATION_DATE },
+	{ "rating", OMX_METADATA_RATING },
+	{ "album", OMX_METADATA_ALBUM },
+	{ "vcodec", OMX_METADATA_VCODECNAME },
+	{ "acodec", OMX_METADATA_ACODECNAME },
+	{ "duration", OMX_METADATA_DURATION },
+	{ "tracknum", OMX_METADATA_TRACKNUM },
+	{ "albumart", OMX_METADATA_ALBUMART },
+};*/
+
+typedef struct OMX_METADATA {
+	OMX_METADATACHARSETTYPE eKeyCharset;
+	OMX_U8 nKeySizeUsed;
+	OMX_U8 nKey[128];
+	OMX_METADATACHARSETTYPE eValueCharset;
+	OMX_U32 nValueMaxSize;
+	OMX_U32 nValueSizeUsed;
+	OMX_U8 nValue[1];
+} OMX_METADATA;
+
+struct OMX_MetadataExtractor
+{
+	OMX_BOOL (*load)(OMX_MetadataExtractor *h, const char *filename, int length);
+	OMX_BOOL (*unLoad)(OMX_MetadataExtractor *h);
+	
+	OMX_U32 (*getMetadataNum)(OMX_MetadataExtractor* h);
+	OMX_U32 (*getMetadataSize)(OMX_MetadataExtractor* h, OMX_U32 index);
+	OMX_BOOL (*getMetadata)(OMX_MetadataExtractor* h, OMX_U32 index, OMX_METADATA *pMetadata);
+	OMX_BOOL (*getThumbnail)(OMX_MetadataExtractor* h, OMX_IMAGE_PORTDEFINITIONTYPE *pfmt, OMX_TICKS position, OMX_U8 **ppBuf);
+	OMX_BOOL (*deleteIt)(OMX_MetadataExtractor* h);
+        OMX_BOOL (*setVideoRenderType)(OMX_MetadataExtractor* h, OMX_VIDEO_RENDER_TYPE videoRender);
+        OMX_BOOL (*setSurface)(OMX_MetadataExtractor* h, OMX_PTR surface);
+
+	void* pData;
+};
+
+OMX_MetadataExtractor* OMX_MetadataExtractorCreate();
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/OpenMAXIL/ghdr/OMX_Other.h b/OpenMAXIL/ghdr/OMX_Other.h
new file mode 100755
index 0000000..d5cd976
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Other.h
@@ -0,0 +1,337 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** @file OMX_Other.h - OpenMax IL version 1.1.2
+ *  The structures needed by Other components to exchange
+ *  parameters and configuration data with the components.
+ */
+
+#ifndef OMX_Other_h
+#define OMX_Other_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully 
+ */
+
+#include <OMX_Core.h>
+
+
+/** 
+ * Enumeration of possible data types which match to multiple domains or no
+ * domain at all.  For types which are vendor specific, a value above
+ * OMX_OTHER_VENDORTSTART should be used.
+ */
+typedef enum OMX_OTHER_FORMATTYPE {
+    OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time, 
+                                   time deltas, etc */
+    OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power 
+                                   management, setting clocks? */
+    OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames 
+                                   dropped, etc */
+    OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+    OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific 
+                                                formats */
+
+    OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_OTHER_FormatMax = 0x7FFFFFFF
+} OMX_OTHER_FORMATTYPE;
+
+/** 
+ * Enumeration of seek modes.
+ */
+typedef enum OMX_TIME_SEEKMODETYPE {
+    OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
+                                * of the requested seek position over   
+                                * the actual seek position if it
+                                * results in a faster seek. */
+    OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek 
+                                * position over an approximation
+                                * of the requested seek position even
+                                * if it results in a slower seek. */
+    OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_TIME_SeekModeMax = 0x7FFFFFFF
+} OMX_TIME_SEEKMODETYPE;
+
+/* Structure representing the seekmode of the component */
+typedef struct OMX_TIME_CONFIG_SEEKMODETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
+} OMX_TIME_CONFIG_SEEKMODETYPE;
+
+/** Structure representing a time stamp used with the following configs 
+ * on the Clock Component (CC):
+ * 
+ * OMX_IndexConfigTimeCurrentWallTime: query of the CCs current wall  
+ *     time
+ * OMX_IndexConfigTimeCurrentMediaTime: query of the CCs current media
+ *     time
+ * OMX_IndexConfigTimeCurrentAudioReference and  
+ * OMX_IndexConfigTimeCurrentVideoReference: audio/video reference 
+ *     clock sending SC its reference time
+ * OMX_IndexConfigTimeClientStartTime: a Clock Component client sends 
+ *     this structure to the Clock Component via a SetConfig on its 
+ *     client port when it receives a buffer with
+ *     OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
+ *     specified by that buffer for nStartTimestamp. 
+ *
+ * Its also used with the following config on components in general:
+ *
+ * OMX_IndexConfigTimePosition: IL client querying component position 
+ * (GetConfig) or commanding a component to seek to the given location
+ * (SetConfig)
+ */	
+typedef struct OMX_TIME_CONFIG_TIMESTAMPTYPE {
+    OMX_U32 nSize;               /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;    /**< OMX specification version
+                                  *   information */
+    OMX_U32 nPortIndex;     /**< port that this structure applies to */
+    OMX_TICKS nTimestamp;  	     /**< timestamp .*/ 
+} OMX_TIME_CONFIG_TIMESTAMPTYPE;  
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_UPDATETYPE {
+      OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
+      OMX_TIME_UpdateScaleChanged,	        /**< Update was generated because the scale chagned. */
+      OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+      OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_UpdateMax = 0x7FFFFFFF
+} OMX_TIME_UPDATETYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum OMX_TIME_REFCLOCKTYPE {
+      OMX_TIME_RefClockNone,    /**< Use no references. */
+      OMX_TIME_RefClockAudio,	/**< Use references sent through OMX_IndexConfigTimeCurrentAudioReference */
+      OMX_TIME_RefClockVideo,   /**< Use references sent through OMX_IndexConfigTimeCurrentVideoReference */
+      OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_RefClockMax = 0x7FFFFFFF
+} OMX_TIME_REFCLOCKTYPE;
+
+/** Enumeration of clock states. */
+typedef enum OMX_TIME_CLOCKSTATE {
+      OMX_TIME_ClockStateRunning,             /**< Clock running. */
+      OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the 
+                                               *   prescribed clients emit their
+                                               *   start time. */
+      OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+      OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+      OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      OMX_TIME_ClockStateMax = 0x7FFFFFFF
+} OMX_TIME_CLOCKSTATE;
+
+/** Structure representing a media time request to the clock component.
+ *
+ *  A client component sends this structure to the Clock Component via a SetConfig
+ *  on its client port to specify a media timestamp the Clock Component
+ *  should emit.  The Clock Component should fulfill the request by sending a
+ *  OMX_TIME_MEDIATIMETYPE when its media clock matches the requested 
+ *  timestamp.
+ *
+ *  The client may require a media time request be fulfilled slightly
+ *  earlier than the media time specified. In this case the client specifies 
+ *  an offset which is equal to the difference between wall time corresponding 
+ *  to the requested media time and the wall time when it will be 
+ *  fulfilled. 
+ *
+ *  A client component may uses these requests and the OMX_TIME_MEDIATIMETYPE to
+ *  time events according to timestamps. If a client must perform an operation O at
+ *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a 
+ *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
+ *  is a little early). When the clock component passes the resulting OMX_TIME_MEDIATIMETYPE
+ *  structure back to the client component, the client may perform operation O (perhaps having
+ *  to wait a slight amount more time itself as specified by the return values).
+ */
+
+typedef struct OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time 
+                                 *   from others (e.g. the number of the frame to deliver). 
+                                 *   Duplicated in the media time structure that fulfills 
+                                 *   this request. A value of zero is reserved for time scale 
+                                 *   updates. */
+    OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/ 
+    OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
+                                 *   request should be fulfilled early */
+} OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
+
+/**< Structure sent from the clock component client either when fulfilling 
+ *   a media time request or when the time scale has changed. 
+ *
+ *   In the former case the Clock Component fills this structure and times its emission 
+ *   to a client component (via the client port) according to the corresponding media 
+ *   time request sent by the client. The Clock Component should time the emission to occur
+ *   when the requested timestamp matches the Clock Component's media time but also the 
+ *   prescribed offset early. 
+ *
+ *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
+ *   media time and sets the nScale to the new scale via the client port. It emits a 
+ *   OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to 
+ *   alter processing to accomodate scaling. For instance a video component might skip inter-frames 
+ *   in the case of extreme fastforward. Likewise an audio component might add or remove samples 
+ *   from an audio frame to scale audio data. 
+ *
+ *   It is expected that some clock components may not be able to fulfill requests
+ *   at exactly the prescribed time. This is acceptable so long as the request is 
+ *   fulfilled at least as early as described and not later. This structure provides 
+ *   fields the client may use to wait for the remaining time.
+ *
+ *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the 
+ *   wall time until the nMediaTimestamp actually occurs. In the latter case the
+ *   client can get a more accurate value for offset by getting the current wall
+ *   from the cloc component and subtracting it from nWallTimeAtMedia. 
+ */
+
+typedef struct OMX_TIME_MEDIATIMETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time 
+                                     *   from others. Copied from the media time request. 
+                                     *   A value of zero is reserved for time scale updates. */
+    OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
+    OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was 
+                                     *   requested then this is the current media time. */ 
+    OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
+                                     *   request was actually fulfilled early */
+
+    OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
+                                     *   A client may compare this value to current
+                                     *   media time obtained from the Clock Component to determine
+                                     *   the wall time until the media timestamp is really
+                                     *   current. */
+    OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
+    OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
+                                    /**< State of the media time. */
+} OMX_TIME_MEDIATIMETYPE;  
+
+/** Structure representing the current media time scale factor. Applicable only to clock 
+ *  component, other components see scale changes via OMX_TIME_MEDIATIMETYPE buffers sent via
+ *  the clock component client ports. Upon recieving this config the clock component changes 
+ *  the rate by which the media time increases or decreases effectively implementing trick modes. 
+ */ 
+typedef struct OMX_TIME_CONFIG_SCALETYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
+                                     * scaling the media time */
+} OMX_TIME_CONFIG_SCALETYPE;
+ 
+/** Bits used to identify a clock port. Used in OMX_TIME_CONFIG_CLOCKSTATETYPEs nWaitMask field */
+#define OMX_CLOCKPORT0 0x00000001
+#define OMX_CLOCKPORT1 0x00000002
+#define OMX_CLOCKPORT2 0x00000004
+#define OMX_CLOCKPORT3 0x00000008
+#define OMX_CLOCKPORT4 0x00000010
+#define OMX_CLOCKPORT5 0x00000020
+#define OMX_CLOCKPORT6 0x00000040
+#define OMX_CLOCKPORT7 0x00000080
+
+/** Structure representing the current mode of the media clock. 
+ *  IL Client uses this config to change or query the mode of the 
+ *  media clock of the clock component. Applicable only to clock
+ *  component. 
+ *  
+ *  On a SetConfig if eState is OMX_TIME_ClockStateRunning media time
+ *  starts immediately at the prescribed start time. If
+ *  OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
+ *  the given nStartTime and waits for all clients specified in the 
+ *  nWaitMask to send starttimes (via 
+ *  OMX_IndexConfigTimeClientStartTime). The Clock Component then starts 
+ *  the media clock using the earliest start time supplied. */    
+typedef struct OMX_TIME_CONFIG_CLOCKSTATETYPE {
+    OMX_U32 nSize;              /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;   /**< OMX specification version 
+                                 *   information */
+    OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
+    OMX_TICKS nStartTime;       /**< Start time of the media time. */
+    OMX_TICKS nOffset;          /**< Time to offset the media time by 
+                                 * (e.g. preroll). Media time will be
+                                 * reported to be nOffset ticks earlier.     
+                                 */
+    OMX_U32 nWaitMask;          /**< Mask of OMX_CLOCKPORT values. */
+} OMX_TIME_CONFIG_CLOCKSTATETYPE;
+
+/** Structure representing the reference clock currently being used to
+ *  compute media time. IL client uses this config to change or query the 
+ *  clock component's active reference clock */
+typedef struct OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
+    OMX_U32 nSize;                  /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */                        
+} OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
+
+/** Descriptor for setting specifics of power type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_POWERTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
+} OMX_OTHER_CONFIG_POWERTYPE;
+
+
+/** Descriptor for setting specifics of stats type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct OMX_OTHER_CONFIG_STATSTYPE {
+    OMX_U32 nSize;            /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    /* what goes here */
+} OMX_OTHER_CONFIG_STATSTYPE;
+
+
+/**
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output other 
+ * path.
+ */
+typedef struct OMX_OTHER_PORTDEFINITIONTYPE {
+    OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
+} OMX_OTHER_PORTDEFINITIONTYPE;
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct OMX_OTHER_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize; /**< size of the structure in bytes */
+    OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    OMX_U32 nPortIndex; /**< Indicates which port to set */
+    OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
+} OMX_OTHER_PARAM_PORTFORMATTYPE; 
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_Recorder.h b/OpenMAXIL/ghdr/OMX_Recorder.h
new file mode 100755
index 0000000..959c6fe
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Recorder.h
@@ -0,0 +1,149 @@
+/**
+ *  Copyright (c) 2011-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef _omx_recorder_h_
+#define _omx_recorder_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "OMX_Core.h"
+#include "OMX_Component.h"
+#include "fsl_osal.h"
+
+enum video_source_gm {
+    VIDEO_SOURCE_DEFAULT = 0,
+    VIDEO_SOURCE_CAMERA = 1,
+
+    VIDEO_SOURCE_LIST_END  // must be last - used to validate audio source type
+};
+
+//Please update media/java/android/media/MediaRecorder.java if the following is updated.
+enum output_format_gm {
+    OUTPUT_FORMAT_DEFAULT = 0,
+    OUTPUT_FORMAT_THREE_GPP = 1,
+    OUTPUT_FORMAT_MPEG_4 = 2,
+
+
+    OUTPUT_FORMAT_AUDIO_ONLY_START = 3, // Used in validating the output format.  Should be the
+                                        //  at the start of the audio only output formats.
+
+    /* These are audio only file formats */
+    OUTPUT_FORMAT_RAW_AMR = 3, //to be backward compatible
+    OUTPUT_FORMAT_AMR_NB = 3,
+    OUTPUT_FORMAT_AMR_WB = 4,
+    OUTPUT_FORMAT_AAC_ADIF = 5,
+    OUTPUT_FORMAT_AAC_ADTS = 6,
+
+    /* Stream over a socket, limited to a single stream */
+    OUTPUT_FORMAT_RTP_AVP = 7,
+
+    /* H.264/AAC data encapsulated in MPEG2/TS */
+    OUTPUT_FORMAT_MPEG2TS = 8,
+
+    OUTPUT_FORMAT_MP3 = 9,
+    OUTPUT_FORMAT_PCM16 = 10,
+    OUTPUT_FORMAT_LIST_END // must be last - used to validate format type
+};
+
+enum audio_encoder_gm {
+    AUDIO_ENCODER_DEFAULT = 0,
+    AUDIO_ENCODER_AMR_NB = 1,
+    AUDIO_ENCODER_AMR_WB = 2,
+    AUDIO_ENCODER_AAC = 3,
+    AUDIO_ENCODER_AAC_PLUS = 4,
+    AUDIO_ENCODER_EAAC_PLUS = 5,
+    AUDIO_ENCODER_MP3 = 6,
+    AUDIO_ENCODER_PCM16 = 7,
+    AUDIO_ENCODER_LIST_END // must be the last - used to validate the audio encoder type
+};
+
+enum video_encoder_gm {
+    VIDEO_ENCODER_DEFAULT = 0,
+    VIDEO_ENCODER_H263 = 1,
+    VIDEO_ENCODER_H264 = 2,
+    VIDEO_ENCODER_MPEG_4_SP = 3,
+
+    VIDEO_ENCODER_LIST_END // must be the last - used to validate the video encoder type
+};
+
+typedef enum
+{
+	RECORDER_EVENT_NONE,
+	RECORDER_EVENT_ERROR_UNKNOWN,
+    RECORDER_EVENT_UNKNOWN,
+    RECORDER_EVENT_MAX_DURATION_REACHED,
+    RECORDER_EVENT_MAX_FILESIZE_REACHED,
+    RECORDER_EVENT_COMPLETION_STATUS,
+    RECORDER_EVENT_PROGRESS_FRAME_STATUS,
+    RECORDER_EVENT_PROGRESS_TIME_STATUS,
+    RECORDER_EVENT_EOS,
+    RECORDER_EVENT_END
+}RECORDER_EVENT;
+
+typedef int (*RECORDER_EVENTHANDLER)(void* context, RECORDER_EVENT eventID, void* Eventpayload);
+
+struct OMX_Recorder
+{
+	OMX_BOOL (*init)(OMX_Recorder *h);
+	OMX_BOOL (*setAudioSource)(OMX_Recorder *h, OMX_S32 as);
+	OMX_BOOL (*setVideoSource)(OMX_Recorder *h, video_source_gm vs);
+	OMX_BOOL (*setOutputFormat)(OMX_Recorder *h, output_format_gm of);
+	OMX_BOOL (*setAudioEncoder)(OMX_Recorder *h, audio_encoder_gm ae);
+	OMX_BOOL (*setVideoEncoder)(OMX_Recorder *h, video_encoder_gm ve);
+	OMX_BOOL (*setVideoSize)(OMX_Recorder *h, OMX_S32 width, OMX_S32 height);
+	OMX_BOOL (*setVideoFrameRate)(OMX_Recorder *h, OMX_S32 frames_per_second);
+	OMX_BOOL (*setCamera)(OMX_Recorder *h, OMX_PTR camera, OMX_PTR cameraProxy);
+	OMX_BOOL (*setPreviewSurface)(OMX_Recorder *h, OMX_PTR surface);
+	OMX_BOOL (*setOutputFile)(OMX_Recorder *h, const OMX_STRING path);
+	OMX_BOOL (*setOutputFileFD)(OMX_Recorder *h, OMX_S32 fd, OMX_S64 offset, OMX_S64 length);
+	OMX_BOOL (*setParamMaxFileDurationUs)(OMX_Recorder *h, OMX_TICKS timeUs);
+	OMX_BOOL (*setParamMaxFileSizeBytes)(OMX_Recorder *h, OMX_S64 bytes);
+	OMX_BOOL (*setParamInterleaveDuration)(OMX_Recorder *h, OMX_S32 durationUs);
+	OMX_BOOL (*setParamMovieTimeScale)(OMX_Recorder *h, OMX_S32 timeScale);
+	OMX_BOOL (*setParam64BitFileOffset)(OMX_Recorder *h, OMX_BOOL use64Bit);
+	OMX_BOOL (*setParamGeotagLongitude)(OMX_Recorder *h, OMX_S64 longitudex10000);
+	OMX_BOOL (*setParamGeotagLatitude)(OMX_Recorder *h, OMX_S64 latitudex10000);
+	OMX_BOOL (*setParamTrackTimeStatus)(OMX_Recorder *h, OMX_S64 timeDurationUs);
+	OMX_BOOL (*setParamAudioSamplingRate)(OMX_Recorder *h, OMX_S32 sampleRate);
+	OMX_BOOL (*setParamAudioNumberOfChannels)(OMX_Recorder *h, OMX_S32 channels);
+	OMX_BOOL (*setParamAudioEncodingBitRate)(OMX_Recorder *h, OMX_S32 bitRate);
+	OMX_BOOL (*setParamAudioTimeScale)(OMX_Recorder *h, OMX_S32 timeScale);
+	OMX_BOOL (*setParamVideoEncodingBitRate)(OMX_Recorder *h, OMX_S32 bitRate);
+	OMX_BOOL (*setParamVideoRotation)(OMX_Recorder *h, OMX_S32 degrees);
+	OMX_BOOL (*setParamVideoIFramesInterval)(OMX_Recorder *h, OMX_S32 seconds);
+	OMX_BOOL (*setParamVideoEncoderProfile)(OMX_Recorder *h, OMX_S32 profile);
+	OMX_BOOL (*setParamVideoEncoderLevel)(OMX_Recorder *h, OMX_S32 level);
+	OMX_BOOL (*setParamVideoCameraId)(OMX_Recorder *h, OMX_S32 cameraId);
+	OMX_BOOL (*setParamVideoTimeScale)(OMX_Recorder *h, OMX_S32 timeScale);
+	OMX_BOOL (*setParamTimeLapseEnable)(OMX_Recorder *h, OMX_S32 timeLapseEnable);
+	OMX_BOOL (*setParamTimeBetweenTimeLapseFrameCapture)(OMX_Recorder *h, OMX_S64 timeUs);
+	OMX_BOOL (*registerEventHandler)(OMX_Recorder *h, OMX_PTR context, RECORDER_EVENTHANDLER handler);
+	OMX_BOOL (*prepare)(OMX_Recorder *h);
+	OMX_BOOL (*start)(OMX_Recorder *h);
+	OMX_BOOL (*pause)(OMX_Recorder *h);
+	OMX_BOOL (*stop)(OMX_Recorder *h);
+	OMX_BOOL (*close)(OMX_Recorder *h);
+	OMX_BOOL (*reset)(OMX_Recorder *h);
+	OMX_BOOL (*getMaxAmplitude)(OMX_Recorder *h, OMX_S32 *max);
+	OMX_BOOL (*getMediaTime)(OMX_Recorder *h, OMX_TICKS *pMediaTime);
+	OMX_BOOL (*deleteIt)(OMX_Recorder *h);
+	OMX_BOOL (*setClient)(OMX_Recorder *h, const OMX_U16* clientName, OMX_S32 clientUID);
+	
+	void* pData;
+};
+
+OMX_Recorder* OMX_RecorderCreate();
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/OpenMAXIL/ghdr/OMX_Types.h b/OpenMAXIL/ghdr/OMX_Types.h
new file mode 100755
index 0000000..96bd703
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Types.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** OMX_Types.h - OpenMax IL version 1.1.2
+ *  The OMX_Types header file contains the primitive type definitions used by 
+ *  the core, the application and the component.  This file may need to be
+ *  modified to be used on systems that do not have "char" set to 8 bits, 
+ *  "short" set to 16 bits and "long" set to 32 bits.
+ */
+
+#ifndef OMX_Types_h
+#define OMX_Types_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/** The OMX_API and OMX_APIENTRY are platform specific definitions used
+ *  to declare OMX function prototypes.  They are modified to meet the
+ *  requirements for a particular platform */
+#ifdef __SYMBIAN32__   
+#   ifdef __OMX_EXPORTS
+#       define OMX_API __declspec(dllexport)
+#   else
+#       ifdef _WIN32
+#           define OMX_API __declspec(dllexport) 
+#       else
+#           define OMX_API __declspec(dllimport)
+#       endif
+#   endif
+#else
+#   ifdef _WIN32
+#      ifdef __OMX_EXPORTS
+#          define OMX_API __declspec(dllexport)
+#      else
+#          define OMX_API __declspec(dllimport)
+#      endif
+#   else
+#      ifdef __OMX_EXPORTS
+#          define OMX_API
+#      else
+#          define OMX_API extern
+#      endif
+#   endif
+#endif
+
+#ifndef OMX_APIENTRY
+#define OMX_APIENTRY 
+#endif 
+
+/** OMX_IN is used to identify inputs to an OMX function.  This designation 
+    will also be used in the case of a pointer that points to a parameter 
+    that is used as an output. */
+#ifndef OMX_IN
+#define OMX_IN
+#endif
+
+/** OMX_OUT is used to identify outputs from an OMX function.  This 
+    designation will also be used in the case of a pointer that points 
+    to a parameter that is used as an input. */
+#ifndef OMX_OUT
+#define OMX_OUT
+#endif
+
+
+/** OMX_INOUT is used to identify parameters that may be either inputs or
+    outputs from an OMX function at the same time.  This designation will 
+    also be used in the case of a pointer that  points to a parameter that 
+    is used both as an input and an output. */
+#ifndef OMX_INOUT
+#define OMX_INOUT
+#endif
+
+/** OMX_ALL is used to as a wildcard to select all entities of the same type
+ *  when specifying the index, or referring to a object by an index.  (i.e.
+ *  use OMX_ALL to indicate all N channels). When used as a port index
+ *  for a config or parameter this OMX_ALL denotes that the config or
+ *  parameter applies to the entire component not just one port. */
+#define OMX_ALL 0xFFFFFFFF
+
+/** In the following we define groups that help building doxygen documentation */
+
+/** @defgroup core OpenMAX IL core
+ * Functions and structure related to the OMX IL core
+ */
+ 
+ /** @defgroup comp OpenMAX IL component
+ * Functions and structure related to the OMX IL component
+ */
+ 
+/** @defgroup rpm Resource and Policy Management 
+ * Structures for resource and policy management of components
+ */
+
+/** @defgroup buf Buffer Management
+ * Buffer handling functions and structures
+ */
+  
+/** @defgroup tun Tunneling
+ * @ingroup core comp
+ * Structures and functions to manage tunnels among component ports
+ */
+ 
+/** @defgroup cp Content Pipes
+ *  @ingroup core
+ */
+ 
+ /** @defgroup metadata Metadata handling
+  * 
+  */ 
+
+/** OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
+typedef unsigned char OMX_U8;
+
+/** OMX_S8 is an 8 bit signed quantity that is byte aligned */
+typedef signed char OMX_S8;
+
+/** OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
+typedef unsigned short OMX_U16;
+
+/** OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
+typedef signed short OMX_S16;
+
+/** OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
+typedef unsigned long OMX_U32;
+
+/** OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
+typedef signed long OMX_S32;
+
+
+/* Users with compilers that cannot accept the "long long" designation should
+   define the OMX_SKIP64BIT macro.  It should be noted that this may cause 
+   some components to fail to compile if the component was written to require
+   64 bit integral types.  However, these components would NOT compile anyway
+   since the compiler does not support the way the component was written.
+*/
+#ifndef OMX_SKIP64BIT
+#ifdef __SYMBIAN32__
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#elif defined(WIN32)
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */   
+typedef unsigned __int64  OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed   __int64  OMX_S64;
+
+#else /* WIN32 */
+
+/** OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long OMX_U64;
+
+/** OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long OMX_S64;
+
+#endif /* WIN32 */
+#endif
+
+
+/** The OMX_BOOL type is intended to be used to represent a true or a false 
+    value when passing parameters to and from the OMX core and components.  The
+    OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
+ */
+typedef enum OMX_BOOL {
+    OMX_FALSE = 0,
+    OMX_TRUE = !OMX_FALSE,
+    OMX_BOOL_MAX = 0x7FFFFFFF
+} OMX_BOOL; 
+ 
+/** The OMX_PTR type is intended to be used to pass pointers between the OMX
+    applications and the OMX Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* OMX_PTR;
+
+/** The OMX_STRING type is intended to be used to pass "C" type strings between
+    the application and the core and component.  The OMX_STRING type is a 32 
+    bit pointer to a zero terminated string.  The  pointer is word aligned and 
+    the string is byte aligned.  
+ */
+typedef char* OMX_STRING;
+
+/** The OMX_BYTE type is intended to be used to pass arrays of bytes such as
+    buffers between the application and the component and core.  The OMX_BYTE 
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+typedef unsigned char* OMX_BYTE;
+
+/** OMX_UUIDTYPE is a very long unique identifier to uniquely identify
+    at runtime.  This identifier should be generated by a component in a way
+    that guarantees that every instance of the identifier running on the system
+    is unique. */
+typedef unsigned char OMX_UUIDTYPE[128];
+
+/** The OMX_DIRTYPE enumeration is used to indicate if a port is an input or
+    an output port.  This enumeration is common across all component types.    
+ */
+typedef enum OMX_DIRTYPE
+{
+    OMX_DirInput,              /**< Port is an input port */
+    OMX_DirOutput,             /**< Port is an output port */
+    OMX_DirMax = 0x7FFFFFFF
+} OMX_DIRTYPE;
+
+/** The OMX_ENDIANTYPE enumeration is used to indicate the bit ordering 
+    for numerical data (i.e. big endian, or little endian).    
+ */
+typedef enum OMX_ENDIANTYPE
+{
+    OMX_EndianBig, /**< big endian */
+    OMX_EndianLittle, /**< little endian */
+    OMX_EndianMax = 0x7FFFFFFF
+} OMX_ENDIANTYPE;
+
+
+/** The OMX_NUMERICALDATATYPE enumeration is used to indicate if data 
+    is signed or unsigned
+ */
+typedef enum OMX_NUMERICALDATATYPE
+{
+    OMX_NumericalDataSigned, /**< signed data */
+    OMX_NumericalDataUnsigned, /**< unsigned data */
+    OMX_NumercialDataMax = 0x7FFFFFFF
+} OMX_NUMERICALDATATYPE;
+
+
+/** Unsigned bounded value type */
+typedef struct OMX_BU32 {
+    OMX_U32 nValue; /**< actual value */
+    OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BU32;
+
+
+/** Signed bounded value type */
+typedef struct OMX_BS32 {
+    OMX_S32 nValue; /**< actual value */
+    OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} OMX_BS32;
+
+
+/** Structure representing some time or duration in microseconds. This structure
+  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate 
+  *  negative deltas and preroll scenarios. The quantity is represented in microseconds 
+  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
+  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g. 
+  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to 
+  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
+  *  or minus 35 minutes).
+  *
+  *  Implementations with limited precision may convert the signed 64 bit value to 
+  *  a signed 32 bit value internally but risk loss of precision.  
+  */
+#ifndef OMX_SKIP64BIT
+typedef OMX_S64 OMX_TICKS;
+#else
+typedef struct OMX_TICKS
+{
+    OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
+    OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
+} OMX_TICKS;
+#endif
+#define OMX_TICKS_PER_SECOND 1000000
+
+/** Define the public interface for the OMX Handle.  The core will not use
+    this value internally, but the application should only use this value.
+ */
+typedef void* OMX_HANDLETYPE;
+
+typedef struct OMX_MARKTYPE
+{
+    OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will 
+                                                generate a mark event upon 
+                                                processing the mark. */
+    OMX_PTR pMarkData;   /**< Application specific data associated with 
+                              the mark sent on a mark event to disambiguate 
+                              this mark from others. */
+} OMX_MARKTYPE;
+
+
+/** OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the display 
+ *  or can be used by a audio port for native audio rendering */
+typedef void* OMX_NATIVE_DEVICETYPE;
+
+/** OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the window */
+typedef void* OMX_NATIVE_WINDOWTYPE;
+
+/** The OMX_VERSIONTYPE union is used to specify the version for
+    a structure or component.  For a component, the version is entirely
+    specified by the component vendor.  Components doing the same function
+    from different vendors may or may not have the same version.  For 
+    structures, the version shall be set by the entity that allocates the
+    structure.  For structures specified in the OMX 1.1 specification, the
+    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
+    OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
+    by accessing one of the structure elements to, for example, check only
+    the Major revision.
+ */
+typedef union OMX_VERSIONTYPE
+{
+    struct
+    {
+        OMX_U8 nVersionMajor;   /**< Major version accessor element */
+        OMX_U8 nVersionMinor;   /**< Minor version accessor element */
+        OMX_U8 nRevision;       /**< Revision version accessor element */
+        OMX_U8 nStep;           /**< Step version accessor element */
+    } s;
+    OMX_U32 nVersion;           /**< 32 bit value to make accessing the
+                                    version easily done in a single word
+                                    size copy/compare operation */
+} OMX_VERSIONTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/ghdr/OMX_Video.h b/OpenMAXIL/ghdr/OMX_Video.h
new file mode 100755
index 0000000..049f936
--- /dev/null
+++ b/OpenMAXIL/ghdr/OMX_Video.h
@@ -0,0 +1,1060 @@
+/**
+ * Copyright (c) 2008 The Khronos Group Inc. 
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions: 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software. 
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ *
+ */
+
+/** 
+ *  @file OMX_Video.h - OpenMax IL version 1.1.2
+ *  The structures is needed by Video components to exchange parameters 
+ *  and configuration data with OMX components.
+ */
+#ifndef OMX_Video_h
+#define OMX_Video_h
+
+/** @defgroup video OpenMAX IL Video Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Video domain
+ * @{
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully 
+ */
+
+#include <OMX_IVCommon.h>
+
+
+/**
+ * Enumeration used to define the possible video compression codings.  
+ * NOTE:  This essentially refers to file extensions. If the coding is 
+ *        being used to specify the ENCODE type, then additional work 
+ *        must be done to configure the exact flavor of the compression 
+ *        to be used.  For decode cases where the user application can 
+ *        not differentiate between MPEG-4 and H.264 bit streams, it is 
+ *        up to the codec to handle this.
+ */
+typedef enum OMX_VIDEO_CODINGTYPE {
+    OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
+    OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
+    OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
+    OMX_VIDEO_CodingH263,       /**< H.263 */
+    OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
+    OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
+    OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
+    OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
+    OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
+    OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_CodingMax = 0x7FFFFFFF
+} OMX_VIDEO_CODINGTYPE;
+
+
+/**
+ * Data structure used to define a video path.  The number of Video paths for 
+ * input and output will vary by type of the Video component.  
+ * 
+ *    Input (aka Source) : zero Inputs, one Output,
+ *    Splitter           : one Input, 2 or more Outputs,
+ *    Processing Element : one Input, one output,
+ *    Mixer              : 2 or more inputs, one output,
+ *    Output (aka Sink)  : one Input, zero outputs.
+ * 
+ * The PortDefinition structure is used to define all of the parameters 
+ * necessary for the compliant component to setup an input or an output video 
+ * path.  If additional vendor specific data is required, it should be 
+ * transmitted to the component using the CustomCommand function.  Compliant 
+ * components will prepopulate this structure with optimal values during the 
+ * GetDefaultInitParams command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a 
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on channel if 
+ *                          uncompressed format is used.  Use 0 for unknown,
+ *                          don't care or variable
+ *  nFrameHeight          : Height of frame to be used on channel if 
+ *                          uncompressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  nStride               : Number of bytes per span of an image 
+ *                          (i.e. indicates the number of bytes to get
+ *                          from span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  nBitrate              : Bit rate of frame to be used on channel if 
+ *                          compressed format is used. Use 0 for unknown, 
+ *                          don't care or variable
+ *  xFramerate            : Frame rate to be used on channel if uncompressed 
+ *                          format is used. Use 0 for unknown, don't care or 
+ *                          variable.  Units are Q16 frames per second.
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by 
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of the 
+ *                          component. When OMX_VIDEO_CodingUnused is 
+ *                          specified, eColorFormat is used
+ *  eColorFormat : Decompressed format used by this component
+ *  pNativeWindow : Platform specific reference for a window object if a 
+ *                          display sink , otherwise this field is 0x0. 
+ */
+typedef struct OMX_VIDEO_PORTDEFINITIONTYPE {
+    OMX_STRING cMIMEType;
+    OMX_NATIVE_DEVICETYPE pNativeRender;
+    OMX_U32 nFrameWidth;
+    OMX_U32 nFrameHeight;
+    OMX_S32 nStride;
+    OMX_U32 nSliceHeight;
+    OMX_U32 nBitrate;
+    OMX_U32 xFramerate;
+    OMX_BOOL bFlagErrorConcealment;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} OMX_VIDEO_PORTDEFINITIONTYPE;
+
+/**  
+ * Port format parameter.  This structure is used to enumerate the various 
+ * data input/output format supported by the port.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from 
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the 
+ *                       component. When OMX_VIDEO_CodingUnused is specified, 
+ *                       eColorFormat is used 
+ *  eColorFormat       : Decompressed format used by this component
+ *  xFrameRate         : Indicates the video frame rate in Q16 format
+ */
+typedef struct OMX_VIDEO_PARAM_PORTFORMATTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIndex;
+    OMX_VIDEO_CODINGTYPE eCompressionFormat; 
+    OMX_COLOR_FORMATTYPE eColorFormat;
+    OMX_U32 xFramerate;
+} OMX_VIDEO_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * This is a structure for configuring video compression quantization 
+ * parameter values.  Codecs may support different QP values for different
+ * frame types.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  nQpI       : QP value to use for index frames
+ *  nQpP       : QP value to use for P frames
+ *  nQpB       : QP values to use for bidirectional frames 
+ */
+typedef struct OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nQpI;
+    OMX_U32 nQpP;
+    OMX_U32 nQpB;
+} OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
+
+
+/** 
+ * Structure for configuration of video fast update parameters. 
+ *  
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info 
+ *  nPortIndex : Port that this structure applies to
+ *  bEnableVFU : Enable/Disable video fast update
+ *  nFirstGOB  : Specifies the number of the first macroblock row
+ *  nFirstMB   : specifies the first MB relative to the specified first GOB
+ *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB 
+ *               and nFirstMB
+ */
+typedef struct OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
+    OMX_U32 nSize;            
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_BOOL bEnableVFU;      
+    OMX_U32 nFirstGOB;                            
+    OMX_U32 nFirstMB;                            
+    OMX_U32 nNumMBs;                                  
+} OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
+
+
+/** 
+ * Enumeration of possible bitrate control types 
+ */
+typedef enum OMX_VIDEO_CONTROLRATETYPE {
+    OMX_Video_ControlRateDisable,
+    OMX_Video_ControlRateVariable,
+    OMX_Video_ControlRateConstant,
+    OMX_Video_ControlRateVariableSkipFrames,
+    OMX_Video_ControlRateConstantSkipFrames,
+    OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_ControlRateMax = 0x7FFFFFFF
+} OMX_VIDEO_CONTROLRATETYPE;
+
+
+/** 
+ * Structure for configuring bitrate mode of a codec. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  eControlRate   : Control rate type enum
+ *  nTargetBitrate : Target bitrate to encode with
+ */
+typedef struct OMX_VIDEO_PARAM_BITRATETYPE {
+    OMX_U32 nSize;                          
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;                     
+    OMX_VIDEO_CONTROLRATETYPE eControlRate; 
+    OMX_U32 nTargetBitrate;                 
+} OMX_VIDEO_PARAM_BITRATETYPE;
+
+
+/** 
+ * Enumeration of possible motion vector (MV) types 
+ */
+typedef enum OMX_VIDEO_MOTIONVECTORTYPE {
+    OMX_Video_MotionVectorPixel,
+    OMX_Video_MotionVectorHalfPel,
+    OMX_Video_MotionVectorQuarterPel,
+    OMX_Video_MotionVectorEighthPel,
+    OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_Video_MotionVectorMax = 0x7FFFFFFF
+} OMX_VIDEO_MOTIONVECTORTYPE;
+
+
+/**
+ * Structure for configuring the number of motion vectors used as well
+ * as their accuracy.
+ * 
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the struct in bytes
+ *  nVersion         : OMX spec version info
+ *  nPortIndex       : port that this structure applies to
+ *  eAccuracy        : Enumerated MV accuracy
+ *  bUnrestrictedMVs : Allow unrestricted MVs
+ *  bFourMV          : Allow use of 4 MVs
+ *  sXSearchRange    : Search range in horizontal direction for MVs
+ *  sYSearchRange    : Search range in vertical direction for MVs
+ */
+typedef struct OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
+    OMX_BOOL bUnrestrictedMVs;
+    OMX_BOOL bFourMV;
+    OMX_S32 sXSearchRange;
+    OMX_S32 sYSearchRange;
+} OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
+
+
+/** 
+ * Enumeration of possible methods to use for Intra Refresh 
+ */
+typedef enum OMX_VIDEO_INTRAREFRESHTYPE {
+    OMX_VIDEO_IntraRefreshCyclic,
+    OMX_VIDEO_IntraRefreshAdaptive,
+    OMX_VIDEO_IntraRefreshBoth,
+    OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
+} OMX_VIDEO_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for configuring intra refresh mode 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eRefreshMode : Cyclic, Adaptive, or Both
+ *  nAirMBs      : Number of intra macroblocks to refresh in a frame when 
+ *                 AIR is enabled
+ *  nAirRef      : Number of times a motion marked macroblock has to be  
+ *                 intra coded
+ *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"  
+ *                 when CIR is enabled
+ */
+typedef struct OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
+    OMX_U32 nAirMBs;
+    OMX_U32 nAirRef;
+    OMX_U32 nCirMBs;
+} OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for enabling various error correction methods for video 
+ * compression.
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information 
+ *  nPortIndex              : Port that this structure applies to 
+ *  bEnableHEC              : Enable/disable header extension codes (HEC)
+ *  bEnableResync           : Enable/disable resynchronization markers
+ *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be 
+ *                            applied in the stream 
+ *  bEnableDataPartitioning : Enable/disable data partitioning 
+ *  bEnableRVLC             : Enable/disable reversible variable length 
+ *                            coding
+ */
+typedef struct OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnableHEC;
+    OMX_BOOL bEnableResync;
+    OMX_U32  nResynchMarkerSpacing;
+    OMX_BOOL bEnableDataPartitioning;
+    OMX_BOOL bEnableRVLC;
+} OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
+
+
+/** 
+ * Configuration of variable block-size motion compensation (VBSMC) 
+ * 
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information 
+ *  nPortIndex : Port that this structure applies to
+ *  b16x16     : Enable inter block search 16x16
+ *  b16x8      : Enable inter block search 16x8
+ *  b8x16      : Enable inter block search 8x16
+ *  b8x8       : Enable inter block search 8x8
+ *  b8x4       : Enable inter block search 8x4
+ *  b4x8       : Enable inter block search 4x8
+ *  b4x4       : Enable inter block search 4x4
+ */
+typedef struct OMX_VIDEO_PARAM_VBSMCTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;       
+    OMX_BOOL b16x16; 
+    OMX_BOOL b16x8; 
+    OMX_BOOL b8x16;
+    OMX_BOOL b8x8;
+    OMX_BOOL b8x4;
+    OMX_BOOL b4x8;
+    OMX_BOOL b4x4;
+} OMX_VIDEO_PARAM_VBSMCTYPE;
+
+
+/** 
+ * H.263 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  Baseline           : Baseline Profile: H.263 (V1), no optional modes                                                    
+ *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility 
+ *                       Profile: H.263+ (V2), includes annexes I, J, L.4
+ *                       and T
+ *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1), 
+ *                       includes annex F                                    
+ *  ISWV2              : Interactive Streaming Wireless Profile: H.263+ 
+ *                       (V2), includes annexes I, J, K and T                 
+ *  ISWV3              : Interactive Streaming Wireless Profile: H.263++  
+ *                       (V3), includes profile 3 and annexes V and W.6.3.8   
+ *  HighCompression    : Conversational High Compression Profile: H.263++  
+ *                       (V3), includes profiles 1 & 2 and annexes D and U   
+ *  Internet           : Conversational Internet Profile: H.263++ (V3),  
+ *                       includes profile 5 and annex K                       
+ *  Interlace          : Conversational Interlace Profile: H.263++ (V3),  
+ *                       includes profile 5 and annex W.6.3.11               
+ *  HighLatency        : High Latency Profile: H.263++ (V3), includes  
+ *                       profile 6 and annexes O.1 and P.5                       
+ */
+typedef enum OMX_VIDEO_H263PROFILETYPE {
+    OMX_VIDEO_H263ProfileBaseline            = 0x01,        
+    OMX_VIDEO_H263ProfileH320Coding          = 0x02,          
+    OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,  
+    OMX_VIDEO_H263ProfileISWV2               = 0x08,               
+    OMX_VIDEO_H263ProfileISWV3               = 0x10,               
+    OMX_VIDEO_H263ProfileHighCompression     = 0x20,     
+    OMX_VIDEO_H263ProfileInternet            = 0x40,            
+    OMX_VIDEO_H263ProfileInterlace           = 0x80,           
+    OMX_VIDEO_H263ProfileHighLatency         = 0x100,         
+    OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF  
+} OMX_VIDEO_H263PROFILETYPE;
+
+
+/** 
+ * H.263 level types, each level indicates support for various frame sizes, 
+ * bit rates, decoder frame rates.
+ */
+typedef enum OMX_VIDEO_H263LEVELTYPE {
+    OMX_VIDEO_H263Level10  = 0x01,  
+    OMX_VIDEO_H263Level20  = 0x02,      
+    OMX_VIDEO_H263Level30  = 0x04,      
+    OMX_VIDEO_H263Level40  = 0x08,      
+    OMX_VIDEO_H263Level45  = 0x10,      
+    OMX_VIDEO_H263Level50  = 0x20,      
+    OMX_VIDEO_H263Level60  = 0x40,      
+    OMX_VIDEO_H263Level70  = 0x80, 
+    OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_H263LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_H263LEVELTYPE;
+
+
+/** 
+ * Specifies the picture type. These values should be OR'd to signal all 
+ * pictures types which are allowed.
+ *
+ * ENUMS:
+ *  Generic Picture Types:          I, P and B
+ *  H.263 Specific Picture Types:   SI and SP
+ *  H.264 Specific Picture Types:   EI and EP
+ *  MPEG-4 Specific Picture Types:  S
+ */
+typedef enum OMX_VIDEO_PICTURETYPE {
+    OMX_VIDEO_PictureTypeI   = 0x01,
+    OMX_VIDEO_PictureTypeP   = 0x02,
+    OMX_VIDEO_PictureTypeB   = 0x04,
+    OMX_VIDEO_PictureTypeSI  = 0x08,
+    OMX_VIDEO_PictureTypeSP  = 0x10,
+    OMX_VIDEO_PictureTypeEI  = 0x11,
+    OMX_VIDEO_PictureTypeEP  = 0x12,
+    OMX_VIDEO_PictureTypeS   = 0x14,
+    OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
+} OMX_VIDEO_PICTURETYPE;
+
+
+/** 
+ * H.263 Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                    : Size of the structure in bytes
+ *  nVersion                 : OMX specification version information 
+ *  nPortIndex               : Port that this structure applies to
+ *  nPFrames                 : Number of P frames between each I frame
+ *  nBFrames                 : Number of B frames between each I frame
+ *  eProfile                 : H.263 profile(s) to use
+ *  eLevel                   : H.263 level(s) to use
+ *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE 
+ *                             (specified in the 1998 version of H.263) to 
+ *                             indicate custom picture sizes or clock 
+ *                             frequencies 
+ *  nAllowedPictureTypes     : Specifies the picture types allowed in the 
+ *                             bitstream
+ *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is 
+ *                             not constrained. It is recommended to change 
+ *                             the value of the RTYPE bit for each reference 
+ *                             picture in error-free communication
+ *  nPictureHeaderRepetition : Specifies the frequency of picture header 
+ *                             repetition
+ *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB  
+ *                             headers in units of GOBs
+ */
+typedef struct OMX_VIDEO_PARAM_H263TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_VIDEO_H263PROFILETYPE eProfile;
+	OMX_VIDEO_H263LEVELTYPE eLevel;
+    OMX_BOOL bPLUSPTYPEAllowed;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_BOOL bForceRoundingTypeToZero;
+    OMX_U32 nPictureHeaderRepetition;
+    OMX_U32 nGOBHeaderInterval;
+} OMX_VIDEO_PARAM_H263TYPE;
+
+
+/** 
+ * MPEG-2 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_MPEG2PROFILETYPE {
+    OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
+    OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
+    OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
+    OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
+    OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
+    OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
+    OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG2PROFILETYPE;
+
+
+/** 
+ * MPEG-2 level types, each level indicates support for various frame 
+ * sizes, bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_MPEG2LEVELTYPE {
+    OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */ 
+    OMX_VIDEO_MPEG2LevelML,      /**< Main Level */ 
+    OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */ 
+    OMX_VIDEO_MPEG2LevelHL,      /**< High Level */   
+    OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG2LEVELTYPE;
+
+
+/** 
+ * MPEG-2 params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nPFrames   : Number of P frames between each I frame
+ *  nBFrames   : Number of B frames between each I frame
+ *  eProfile   : MPEG-2 profile(s) to use
+ *  eLevel     : MPEG-2 levels(s) to use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG2TYPE {
+    OMX_U32 nSize;           
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;      
+    OMX_U32 nPFrames;        
+    OMX_U32 nBFrames;        
+    OMX_VIDEO_MPEG2PROFILETYPE eProfile;
+	OMX_VIDEO_MPEG2LEVELTYPE eLevel;   
+} OMX_VIDEO_PARAM_MPEG2TYPE;
+
+
+/** 
+ * MPEG-4 profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ * 
+ * ENUMS:
+ *  - Simple Profile, Levels 1-3
+ *  - Simple Scalable Profile, Levels 1-2
+ *  - Core Profile, Levels 1-2
+ *  - Main Profile, Levels 2-4
+ *  - N-bit Profile, Level 2
+ *  - Scalable Texture Profile, Level 1
+ *  - Simple Face Animation Profile, Levels 1-2
+ *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
+ *  - Basic Animated Texture Profile, Levels 1-2
+ *  - Hybrid Profile, Levels 1-2
+ *  - Advanced Real Time Simple Profiles, Levels 1-4
+ *  - Core Scalable Profile, Levels 1-3
+ *  - Advanced Coding Efficiency Profile, Levels 1-4
+ *  - Advanced Core Profile, Levels 1-2
+ *  - Advanced Scalable Texture, Levels 2-3
+ */
+typedef enum OMX_VIDEO_MPEG4PROFILETYPE {
+    OMX_VIDEO_MPEG4ProfileSimple           = 0x01,        
+    OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,    
+    OMX_VIDEO_MPEG4ProfileCore             = 0x04,              
+    OMX_VIDEO_MPEG4ProfileMain             = 0x08,             
+    OMX_VIDEO_MPEG4ProfileNbit             = 0x10,              
+    OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,   
+    OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,        
+    OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,         
+    OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,     
+    OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,            
+    OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,  
+    OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,      
+    OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,    
+    OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,      
+    OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
+    OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
+    OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG4PROFILETYPE;
+
+
+/** 
+ * MPEG-4 level types, each level indicates support for various frame 
+ * sizes, bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_MPEG4LEVELTYPE {
+    OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */   
+    OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */   
+    OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */ 
+    OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */ 
+    OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */ 
+    OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */  
+    OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */  
+    OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */  
+    OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_MPEG4LEVELTYPE;
+
+
+/** 
+ * MPEG-4 configuration.  This structure handles configuration options
+ * which are specific to MPEG4 algorithms
+ *
+ * STRUCT MEMBERS:
+ *  nSize                : Size of the structure in bytes
+ *  nVersion             : OMX specification version information
+ *  nPortIndex           : Port that this structure applies to
+ *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+ 
+ *                         Annex K). Put zero if not used
+ *  bSVH                 : Enable Short Video Header mode
+ *  bGov                 : Flag to enable GOV
+ *  nPFrames             : Number of P frames between each I frame (also called 
+ *                         GOV period)
+ *  nBFrames             : Number of B frames between each I frame
+ *  nIDCVLCThreshold     : Value of intra DC VLC threshold
+ *  bACPred              : Flag to use ac prediction
+ *  nMaxPacketSize       : Maximum size of packet in bytes.
+ *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4. 
+ *                         Interpreted as described in MPEG4 standard.
+ *  eProfile             : MPEG-4 profile(s) to use.
+ *  eLevel               : MPEG-4 level(s) to use.
+ *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
+ *  nHeaderExtension     : Specifies the number of consecutive video packet
+ *                         headers within a VOP
+ *  bReversibleVLC       : Specifies whether reversible variable length coding 
+ *                         is in use
+ */
+typedef struct OMX_VIDEO_PARAM_MPEG4TYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nSliceHeaderSpacing;
+    OMX_BOOL bSVH;
+    OMX_BOOL bGov;
+    OMX_U32 nPFrames;
+    OMX_U32 nBFrames;
+    OMX_U32 nIDCVLCThreshold;
+    OMX_BOOL bACPred;
+    OMX_U32 nMaxPacketSize;
+    OMX_U32 nTimeIncRes;
+    OMX_VIDEO_MPEG4PROFILETYPE eProfile;
+    OMX_VIDEO_MPEG4LEVELTYPE eLevel;
+    OMX_U32 nAllowedPictureTypes;
+    OMX_U32 nHeaderExtension;
+    OMX_BOOL bReversibleVLC;
+} OMX_VIDEO_PARAM_MPEG4TYPE;
+
+
+/** 
+ * WMV Versions 
+ */
+typedef enum OMX_VIDEO_WMVFORMATTYPE {
+    OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
+    OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
+    OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
+    OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
+    OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
+} OMX_VIDEO_WMVFORMATTYPE;
+
+
+/** 
+ * WMV Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eFormat    : Version of WMV stream / data
+ */
+typedef struct OMX_VIDEO_PARAM_WMVTYPE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_WMVFORMATTYPE eFormat;
+} OMX_VIDEO_PARAM_WMVTYPE;
+
+
+/** 
+ * Real Video Version 
+ */
+typedef enum OMX_VIDEO_RVFORMATTYPE {
+    OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
+    OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
+    OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
+    OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
+    OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
+} OMX_VIDEO_RVFORMATTYPE;
+
+
+/** 
+ * Real Video Params 
+ *
+ * STUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information 
+ *  nPortIndex         : Port that this structure applies to
+ *  eFormat            : Version of RV stream / data
+ *  nBitsPerPixel      : Bits per pixel coded in the frame
+ *  nPaddedWidth       : Padded width in pixel of a video frame
+ *  nPaddedHeight      : Padded Height in pixels of a video frame
+ *  nFrameRate         : Rate of video in frames per second
+ *  nBitstreamFlags    : Flags which internal information about the bitstream
+ *  nBitstreamVersion  : Bitstream version
+ *  nMaxEncodeFrameSize: Max encoded frame size
+ *  bEnablePostFilter  : Turn on/off post filter
+ *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
+ *  bEnableLatencyMode : When enabled, the decoder does not display a decoded 
+ *                       frame until it has detected that no enhancement layer 
+ *  					 frames or dependent B frames will be coming. This 
+ *  					 detection usually occurs when a subsequent non-B 
+ *  					 frame is encountered 
+ */
+typedef struct OMX_VIDEO_PARAM_RVTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_VIDEO_RVFORMATTYPE eFormat;
+    OMX_U16 nBitsPerPixel;
+    OMX_U16 nPaddedWidth;
+    OMX_U16 nPaddedHeight;
+    OMX_U32 nFrameRate;
+    OMX_U32 nBitstreamFlags;
+    OMX_U32 nBitstreamVersion;
+    OMX_U32 nMaxEncodeFrameSize;
+    OMX_BOOL bEnablePostFilter;
+    OMX_BOOL bEnableTemporalInterpolation;
+    OMX_BOOL bEnableLatencyMode;
+} OMX_VIDEO_PARAM_RVTYPE;
+
+
+/** 
+ * AVC profile types, each profile indicates support for various 
+ * performance bounds and different annexes.
+ */
+typedef enum OMX_VIDEO_AVCPROFILETYPE {
+    OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
+    OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
+    OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
+    OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
+    OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
+    OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
+    OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
+    OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF  
+} OMX_VIDEO_AVCPROFILETYPE;
+
+
+/** 
+ * AVC level types, each level indicates support for various frame sizes, 
+ * bit rates, decoder frame rates.  No need 
+ */
+typedef enum OMX_VIDEO_AVCLEVELTYPE {
+    OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
+    OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
+    OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
+    OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
+    OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
+    OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
+    OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
+    OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
+    OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
+    OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
+    OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
+    OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
+    OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
+    OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
+    OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
+    OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
+    OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF  
+} OMX_VIDEO_AVCLEVELTYPE;
+
+
+/** 
+ * AVC loop filter modes 
+ *
+ * OMX_VIDEO_AVCLoopFilterEnable               : Enable
+ * OMX_VIDEO_AVCLoopFilterDisable              : Disable
+ * OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
+ */
+typedef enum OMX_VIDEO_AVCLOOPFILTERTYPE {
+    OMX_VIDEO_AVCLoopFilterEnable = 0,
+    OMX_VIDEO_AVCLoopFilterDisable,
+    OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
+    OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCLOOPFILTERTYPE;
+
+
+/** 
+ * AVC params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put  
+ *                              zero if not used
+ *  nPFrames                  : Number of P frames between each I frame
+ *  nBFrames                  : Number of B frames between each I frame
+ *  bUseHadamard              : Enable/disable Hadamard transform
+ *  nRefFrames                : Max number of reference frames to use for inter
+ *                              motion search (1-16)
+ *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
+ *                              frame buffer of trailing frames list), B frame
+ *                              support
+ *  nRefIdxForward            : Pic param set ref frame index (index into ref
+ *                              frame buffer of forward frames list), B frame
+ *                              support
+ *  bEnableUEP                : Enable/disable unequal error protection. This 
+ *                              is only valid of data partitioning is enabled.
+ *  bEnableFMO                : Enable/disable flexible macroblock ordering
+ *  bEnableASO                : Enable/disable arbitrary slice ordering
+ *  bEnableRS                 : Enable/disable sending of redundant slices
+ *  eProfile                  : AVC profile(s) to use
+ *  eLevel                    : AVC level(s) to use
+ *  nAllowedPictureTypes      : Specifies the picture types allowed in the 
+ *                              bitstream
+ *  bFrameMBsOnly             : specifies that every coded picture of the 
+ *                              coded video sequence is a coded frame 
+ *                              containing only frame macroblocks
+ *  bMBAFF                    : Enable/disable switching between frame and 
+ *                              field macroblocks within a picture
+ *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the 
+ *                              syntax elements for which two descriptors appear 
+ *                              in the syntax tables
+ *  bWeightedPPrediction      : Enable/disable weighted prediction shall not 
+ *                              be applied to P and SP slices
+ *  nWeightedBipredicitonMode : Default weighted prediction is applied to B 
+ *                              slices 
+ *  bconstIpred               : Enable/disable intra prediction
+ *  bDirect8x8Inference       : Specifies the method used in the derivation 
+ *                              process for luma motion vectors for B_Skip, 
+ *                              B_Direct_16x16 and B_Direct_8x8 as specified 
+ *                              in subclause 8.4.1.2 of the AVC spec 
+ *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
+ *                              mode used in B slice coding (related to 
+ *                              bDirect8x8Inference) . Spatial direct mode is 
+ *                              more common and should be the default.
+ *  nCabacInitIdx             : Index used to init CABAC contexts
+ *  eLoopFilterMode           : Enable/disable loop filter
+ */
+typedef struct OMX_VIDEO_PARAM_AVCTYPE {
+    OMX_U32 nSize;                 
+    OMX_VERSIONTYPE nVersion;      
+    OMX_U32 nPortIndex;            
+    OMX_U32 nSliceHeaderSpacing;  
+    OMX_U32 nPFrames;     
+    OMX_U32 nBFrames;     
+    OMX_BOOL bUseHadamard;
+    OMX_U32 nRefFrames;  
+	OMX_U32 nRefIdx10ActiveMinus1;
+	OMX_U32 nRefIdx11ActiveMinus1;
+    OMX_BOOL bEnableUEP;  
+    OMX_BOOL bEnableFMO;  
+    OMX_BOOL bEnableASO;  
+    OMX_BOOL bEnableRS;   
+    OMX_VIDEO_AVCPROFILETYPE eProfile;
+	OMX_VIDEO_AVCLEVELTYPE eLevel; 
+    OMX_U32 nAllowedPictureTypes;  
+	OMX_BOOL bFrameMBsOnly;        									
+    OMX_BOOL bMBAFF;               
+    OMX_BOOL bEntropyCodingCABAC;  
+    OMX_BOOL bWeightedPPrediction; 
+    OMX_U32 nWeightedBipredicitonMode; 
+    OMX_BOOL bconstIpred ;
+    OMX_BOOL bDirect8x8Inference;  
+	OMX_BOOL bDirectSpatialTemporal;
+	OMX_U32 nCabacInitIdc;
+	OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+} OMX_VIDEO_PARAM_AVCTYPE;
+
+typedef struct OMX_VIDEO_PARAM_PROFILELEVELTYPE {
+   OMX_U32 nSize;                 
+   OMX_VERSIONTYPE nVersion;      
+   OMX_U32 nPortIndex;            
+   OMX_U32 eProfile;      /**< type is OMX_VIDEO_AVCPROFILETYPE, OMX_VIDEO_H263PROFILETYPE, 
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 eLevel;        /**< type is OMX_VIDEO_AVCLEVELTYPE, OMX_VIDEO_H263LEVELTYPE, 
+                                 or OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
+                               This parameter is valid only for 
+                               OMX_IndexParamVideoProfileLevelQuerySupported index,
+                               For all other indices this parameter is to be ignored. */
+} OMX_VIDEO_PARAM_PROFILELEVELTYPE;
+
+/** 
+ * Structure for dynamically configuring bitrate mode of a codec. 
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  nEncodeBitrate : Target average bitrate to be generated in bps
+ */
+typedef struct OMX_VIDEO_CONFIG_BITRATETYPE {
+    OMX_U32 nSize;                          
+    OMX_VERSIONTYPE nVersion;               
+    OMX_U32 nPortIndex;                     
+    OMX_U32 nEncodeBitrate;                 
+} OMX_VIDEO_CONFIG_BITRATETYPE;
+
+/** 
+ * Defines Encoder Frame Rate setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information 
+ *  nPortIndex       : Port that this structure applies to
+ *  xEncodeFramerate : Encoding framerate represented in Q16 format
+ */
+typedef struct OMX_CONFIG_FRAMERATETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 xEncodeFramerate; /* Q16 format */
+} OMX_CONFIG_FRAMERATETYPE;
+
+typedef struct OMX_CONFIG_INTRAREFRESHVOPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL IntraRefreshVOP;
+} OMX_CONFIG_INTRAREFRESHVOPTYPE;
+
+typedef struct OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
+    OMX_U8  ErrMap[1];             /* Error map hint */
+} OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
+
+typedef struct OMX_CONFIG_MBERRORREPORTINGTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bEnabled;
+} OMX_CONFIG_MBERRORREPORTINGTYPE;
+
+typedef struct OMX_PARAM_MACROBLOCKSTYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nMacroblocks;
+} OMX_PARAM_MACROBLOCKSTYPE;
+
+/** 
+ * AVC Slice Mode modes 
+ *
+ * OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
+ * OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
+ * OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
+ */
+typedef enum OMX_VIDEO_AVCSLICEMODETYPE {
+    OMX_VIDEO_SLICEMODE_AVCDefault = 0,
+    OMX_VIDEO_SLICEMODE_AVCMBSlice,
+    OMX_VIDEO_SLICEMODE_AVCByteSlice,
+    OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
+    OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
+} OMX_VIDEO_AVCSLICEMODETYPE;
+
+/** 
+ * AVC FMO Slice Mode Params 
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNumSliceGroups : Specifies the number of slice groups
+ *  nSliceGroupMapType : Specifies the type of slice groups
+ *  eSliceMode : Specifies the type of slice
+ */
+typedef struct OMX_VIDEO_PARAM_AVCSLICEFMO {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U8 nNumSliceGroups;
+    OMX_U8 nSliceGroupMapType;
+    OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
+} OMX_VIDEO_PARAM_AVCSLICEFMO;
+
+/** 
+ * AVC IDR Period Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nIDRPeriod : Specifies periodicity of IDR frames
+ *  nPFrames : Specifies internal of coding Intra frames
+ */
+typedef struct OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nIDRPeriod;
+    OMX_U32 nPFrames;
+} OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
+
+/** 
+ * AVC NAL Size Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNaluBytes : Specifies the NAL unit size
+ */
+typedef struct OMX_VIDEO_CONFIG_NALSIZE {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_U32 nNaluBytes;
+} OMX_VIDEO_CONFIG_NALSIZE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
diff --git a/OpenMAXIL/ghdr/PlatformResourceMgrItf.h b/OpenMAXIL/ghdr/PlatformResourceMgrItf.h
new file mode 100755
index 0000000..3b7540b
--- /dev/null
+++ b/OpenMAXIL/ghdr/PlatformResourceMgrItf.h
@@ -0,0 +1,33 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file PlatformResourceMgrItf.h
+ *  @brief Interface definition of PlatformResourceMgr
+ *  @ingroup State
+ */
+
+#ifndef PlatformResourceMgrItf_h
+#define PlatformResourceMgrItf_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+OMX_ERRORTYPE CreatePlatformResMgr();
+OMX_ERRORTYPE DestroyPlatformResMgr();
+OMX_ERRORTYPE AddHwBuffer(OMX_PTR pPhyiscAddr, OMX_PTR pVirtualAddr);
+OMX_ERRORTYPE RemoveHwBuffer(OMX_PTR pVirtualAddr);
+OMX_ERRORTYPE GetHwBuffer(OMX_PTR pVirtualAddr, OMX_PTR *ppPhyiscAddr);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/OpenMAXIL/release/registry/Android.mk b/OpenMAXIL/release/registry/Android.mk
new file mode 100755
index 0000000..498e610
--- /dev/null
+++ b/OpenMAXIL/release/registry/Android.mk
@@ -0,0 +1,27 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := core_register
+LOCAL_MODULE_CLASS := ETC
+LOCAL_SRC_FILES := core_register
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_PREBUILT)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := component_register
+LOCAL_MODULE_CLASS := ETC
+LOCAL_SRC_FILES := component_register
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_PREBUILT)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := contentpipe_register
+LOCAL_MODULE_CLASS := ETC
+LOCAL_SRC_FILES := contentpipe_register
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_PREBUILT)
+
+endif
diff --git a/OpenMAXIL/release/registry/component_register b/OpenMAXIL/release/registry/component_register
new file mode 100755
index 0000000..48604fc
--- /dev/null
+++ b/OpenMAXIL/release/registry/component_register
@@ -0,0 +1,566 @@
+# Register component to core. The component role priority is [1, 5]. 1 is the lowest
+# priority, 5 is the highest priority. 3 is the default priority if the component role 
+# priority hasn't set. The component role priority should be set immediately after the 
+# component role.
+#
+# Usage:
+# @ means the begin of one component.
+# # means comments.
+# $ means the end of one component.
+# ; means finish of one tag value.
+# envirenment value should be set: COMPONENT_REGISTER_FILE=../registry/component_register 
+
+@
+component_name=OMX.Freescale.std.template.sw-based;
+library_path=lib_omx_template_arm11_elinux.so;
+component_entry_function=TemplateInit;
+component_role=component.template;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.component.file_write.sw-based;
+library_path=lib_omx_file_write_arm11_elinux.so;
+component_entry_function=FileWriteInit;
+component_role=component.file_write;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.mp3.sw-based;
+library_path=lib_omx_mp3_dec_v2_arm11_elinux.so;
+component_entry_function=Mp3DecInit;
+component_role=audio_decoder.mp3;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.vorbis.sw-based;
+library_path=lib_omx_vorbis_dec_v2_arm11_elinux.so;
+component_entry_function=VorbisDecInit;
+component_role=audio_decoder.vorbis;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_encoder.amr.sw-based;
+library_path=lib_omx_amr_enc_v2_arm11_elinux.so;
+component_entry_function=AmrEncInit;
+component_role=audio_encoder.amr;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.amr.sw-based;
+library_path=lib_omx_amr_dec_v2_arm11_elinux.so;
+component_entry_function=AmrDecInit;
+component_role=audio_decoder.amr;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.mp3;
+
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.ac3.sw-based;
+library_path=lib_omx_ac3_parser_v2_arm11_elinux.so;
+component_entry_function=Ac3ParserInit;
+component_role=parser.ac3;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.wav;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_processor.volume.sw-based;
+library_path=lib_omx_audio_processor_v2_arm11_elinux.so;
+component_entry_function=AudioProcessorInit;
+component_role=audio_processor.volume;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video.processor.hw-based;
+library_path=lib_omx_video_processor_arm11_elinux.so;
+component_entry_function=VideoProcessor_ComponentInit;
+component_role=video.processor;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_render.fb.sw-based;
+library_path=lib_omx_render_fb_arm11_elinux.so;
+component_entry_function=FBRenderInit;
+component_role=video_render.fb;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_source.android.sw-based;
+library_path=lib_omx_android_audio_source_arm11_elinux.so;
+component_entry_function=AndroidAudioSourceInit;
+component_role=audio_source.android;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_source.alsa.sw-based;
+library_path=lib_omx_alsa_source_arm11_elinux.so;
+component_entry_function=AlsaSourceInit;
+component_role=audio_source.alsa;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_render.alsa.sw-based;
+library_path=lib_omx_alsa_render_arm11_elinux.so;
+component_entry_function=AlsaRenderInit;
+component_role=audio_render.alsa;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_source.camera.sw-based;
+library_path=lib_omx_camera_source_arm11_elinux.so;
+component_entry_function=CameraSourceInit;
+component_role=video_source.camera;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_source.v4l.sw-based;
+library_path=lib_omx_v4l_source_arm11_elinux.so;
+component_entry_function=V4lSourceInit;
+component_role=video_source.v4l;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_render.fake.sw-based;
+library_path=lib_omx_audio_fake_render_arm11_elinux.so;
+component_entry_function=AudioFakeRenderInit;
+component_role=audio_render.fake;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.clocksrc.sw-based;
+library_path=lib_omx_clock_v2_arm11_elinux.so;
+component_entry_function=ClockInit;
+component_role=clocksrc;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_encoder.aac.sw-based;
+library_path=lib_omx_aac_enc_v2_arm11_elinux.so;
+component_entry_function=AacEncInit;
+component_role=audio_encoder.aac;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_encoder.mp3.sw-based;
+library_path=lib_omx_mp3_enc_v2_arm11_elinux.so;
+component_entry_function=Mp3EncInit;
+component_role=audio_encoder.mp3;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_encoder.pcm.sw-based;
+library_path=lib_omx_pcm_enc_v2_arm11_elinux.so;
+component_entry_function=PcmEncInit;
+component_role=audio_encoder.pcm;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.pcm.sw-based;
+library_path=lib_omx_pcm_dec_v2_arm11_elinux.so;
+component_entry_function=PcmDecInit;
+component_role=audio_decoder.pcm;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.aac.sw-based;
+library_path=lib_omx_aac_dec_v2_arm11_elinux.so;
+component_entry_function=AacDecInit;
+component_role=audio_decoder.aac;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.wma.sw-based;
+library_path=lib_omx_wma_dec_v2_arm11_elinux.so;
+component_entry_function=WmaDecInit;
+component_role=audio_decoder.wma;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.ac3.sw-based;
+library_path=lib_omx_ac3_dec_v2_arm11_elinux.so;
+component_entry_function=Ac3DecInit;
+component_role=audio_decoder.ac3;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_render.v4l.sw-based;
+library_path=lib_omx_v4l_render_arm11_elinux.so;
+component_entry_function=V4lRenderInit;
+component_role=video_render.v4l;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_render.surface.sw-based;
+library_path=lib_omx_surface_render_arm11_elinux.so;
+component_entry_function=SurfaceRenderInit;
+component_role=video_render.surface;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_render.ipulib.sw-based;
+library_path=lib_omx_ipulib_render_arm11_elinux.so;
+component_entry_function=IpulibRenderInit;
+component_role=video_render.ipulib;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_render.overlay.sw-based;
+library_path=lib_omx_overlay_render_arm11_elinux.so;
+component_entry_function=OverlayRenderInit;
+component_role=video_render.overlay;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.avc.v3.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.avc;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_encoder.h263.hw-based;
+library_path=lib_omx_vpu_enc_v2_arm11_elinux.so;
+component_entry_function=VpuEncoderInit;
+component_role=video_encoder.h263;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_encoder.mpeg4.hw-based;
+library_path=lib_omx_vpu_enc_v2_arm11_elinux.so;
+component_entry_function=VpuEncoderInit;
+component_role=video_encoder.mpeg4;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_encoder.avc.hw-based;
+library_path=lib_omx_vpu_enc_v2_arm11_elinux.so;
+component_entry_function=VpuEncoderInit;
+component_role=video_encoder.avc;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.mpeg2.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.mpeg2;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.mpeg4.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.mpeg4;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.div3.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.div3;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.divx.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.divx;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.div4.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.div4;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.xvid.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.xvid;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.h263.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.h263;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.rv.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.rv;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.mjpeg.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.mjpeg;
+role_priority=3;
+$
+
+# Add the component and role for StageFright.
+@
+component_name=OMX.Freescale.std.video_decoder.vpx.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.vpx;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.vp8.hw-based;
+library_path=lib_omx_vpu_dec_v2_arm11_elinux.so;
+component_entry_function=VpuDecoderInit;
+component_role=video_decoder.vp8;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.wmv.sw-based;
+library_path=lib_omx_wmv_dec_v2_arm11_elinux.so;
+component_entry_function=WmvDecoderInit;
+component_role=video_decoder.wmv;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_decoder.sorenson.sw-based;
+library_path=lib_omx_sorenson_dec_v2_arm11_elinux.so;
+component_entry_function=SorensonDecoderInit;
+component_role=video_decoder.sorenson;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio.file_read.sw-based;
+library_path=lib_omx_audio_fileread_v2_arm11_elinux.so;
+component_entry_function=AudioFileRead_ComponentInit;
+component_role=audio.file_read;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video.file_read.sw-based;
+library_path=lib_omx_video_fileread_v2_arm11_elinux.so;
+component_entry_function=VidSrc_ComponentInit;
+component_role=video.file_read;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.ra.sw-based;
+library_path=lib_omx_ra_dec_v2_arm11_elinux.so;
+component_entry_function=RaDecInit;
+component_role=audio_decoder.ra;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.mp4;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.amr;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.rmvb;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.flv;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.mkv;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.mpg2;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.avi;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.ogg;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.asf;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.flac.sw-based;
+library_path=lib_omx_flac_dec_v2_arm11_elinux.so;
+component_entry_function=FlacDecInit;
+component_role=audio_decoder.flac;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.flac;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.video_render.fake.sw-based;
+library_path=lib_omx_fake_video_render_arm11_elinux.so;
+component_entry_function=FakeVideoRenderInit;
+component_role=video_render.fake;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_render.android.sw-based;
+library_path=lib_omx_android_audio_render_arm11_elinux.so;
+component_entry_function=AndroidAudioRenderInit;
+component_role=audio_render.android;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.muxer.fsl.sw-based;
+library_path=lib_omx_fsl_muxer_v2_arm11_elinux.so;
+component_entry_function=FslMuxerInit;
+component_role=muxer.mp4;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.streaming.sw-based;
+library_path=lib_omx_streaming_parser_arm11_elinux.so;
+component_entry_function=StreamingParserInit;
+component_role=parser.rtsp;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.streaming.sw-based;
+library_path=lib_omx_streaming_parser_arm11_elinux.so;
+component_entry_function=StreamingParserInit;
+component_role=parser.httplive;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.audio_processor.ac3toiec937.sw-based;
+library_path=lib_omx_ac3toiec937_arm11_elinux.so;
+component_entry_function=AC3ToIEC937Init;
+component_role=audio_processor.ac3toiec937;
+role_priority=3;
+$
+
+@
+component_name=OMX.Freescale.std.parser.fsl.sw-based;
+library_path=lib_omx_fsl_parser_v2_arm11_elinux.so;
+component_entry_function=FslParserInit;
+component_role=parser.aac;
+role_priority=4;
+$
+
+@
+component_name=OMX.Freescale.std.audio_decoder.ec3.sw-based;
+library_path=lib_omx_ec3_dec_v2_arm11_elinux.so;
+component_entry_function=Ec3DecInit;
+component_role=audio_decoder.ec3;
+role_priority=3;
+$
+
diff --git a/OpenMAXIL/release/registry/contentpipe_register b/OpenMAXIL/release/registry/contentpipe_register
new file mode 100755
index 0000000..d5e82b6
--- /dev/null
+++ b/OpenMAXIL/release/registry/contentpipe_register
@@ -0,0 +1,44 @@
+# Register content pipe to core. 
+#
+# Usage:
+# @ means the begin of one content pipe.
+# # means comments.
+# $ means the end of one content pipe.
+# ; means finish of one tag value.
+# envirenment value should be set: CONTENTPIPE_REGISTER_FILE=../registry/contentpipe_register 
+
+@
+content_pipe_name=LOCAL_FILE_PIPE_NEW;
+content_pipe_library_path=lib_omx_local_file_pipe_v2_arm11_elinux.so;
+content_pipe_entry_function=LocalFilePipe_Init;
+$
+
+@
+content_pipe_name=SHAREDFD_PIPE;
+content_pipe_library_path=lib_omx_shared_fd_pipe_arm11_elinux.so;
+content_pipe_entry_function=SharedFdPipe_Init;
+$
+
+@
+content_pipe_name=HTTPS_PIPE;
+content_pipe_library_path=lib_omx_https_pipe_v3_arm11_elinux.so;
+content_pipe_entry_function=HttpsPipe_Init;
+$
+
+@
+content_pipe_name=MMS_PIPE;
+content_pipe_library_path=lib_omx_https_pipe_v3_arm11_elinux.so;
+content_pipe_entry_function=HttpsPipe_Init;
+$
+
+@
+content_pipe_name=RTPS_PIPE;
+content_pipe_library_path=lib_omx_rtps_pipe_arm11_elinux.so;
+content_pipe_entry_function=RtpsPipe_Init;
+$
+
+@
+content_pipe_name=UDPS_PIPE;
+content_pipe_library_path=lib_omx_udps_pipe_arm11_elinux.so;
+content_pipe_entry_function=UdpsPipe_Init;
+$
diff --git a/OpenMAXIL/release/registry/core_register b/OpenMAXIL/release/registry/core_register
new file mode 100755
index 0000000..08e5710
--- /dev/null
+++ b/OpenMAXIL/release/registry/core_register
@@ -0,0 +1,23 @@
+# Register core to core manager. The core priority is [1, 5]. 1 is the lowest
+# priority, 5 is the highest priority. 3 is the default priority if the core 
+# priority hasn't set.  
+#
+# Usage:
+# @ means the begin of one core.
+# # means comments.
+# $ means the end of one core.
+# ; means finish of one tag value.
+# envirenment value should be set: CORE_REGISTER_FILE=../registry/core_register 
+
+@
+core_name=FSL_CORE;
+core_library_path=lib_omx_core_v2_arm11_elinux.so;
+core_priority=3;
+$
+
+#@
+#core_name=FSL_CORE_OLD;
+#core_library_path=lib_omx_core_arm11_elinux.so;
+#core_priority=3;
+#$
+
diff --git a/OpenMAXIL/src/component/common/Android.mk b/OpenMAXIL/src/component/common/Android.mk
new file mode 100755
index 0000000..3bce1cd
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Android.mk
@@ -0,0 +1,47 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	ComponentBase.cpp \
+        ExecutingState.cpp \
+        IdleState.cpp \
+        InvalidState.cpp \
+        LoadedState.cpp \
+        PauseState.cpp \
+        Port.cpp \
+        State.cpp \
+        WaitForResourcesState.cpp \
+        AudioParserBase.cpp \
+        AudioFilter.cpp \
+        AudioRender.cpp \
+	Parser.cpp \
+	VideoFilter.cpp \
+	VideoSource.cpp \
+	AudioSource.cpp \
+	Muxer.cpp \
+	VideoRender.cpp \
+	UniaDecoder.cpp
+
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+ 
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) 
+
+LOCAL_SHARED_LIBRARIES := lib_omx_osal_v2_arm11_elinux \
+    			  lib_omx_utils_v2_arm11_elinux \
+				  lib_omx_res_mgr_v2_arm11_elinux \
+				  lib_omx_core_v2_arm11_elinux \
+				  lib_id3_parser_arm11_elinux \
+				  libutils 
+
+LOCAL_PRELINK_MODULE := false
+	
+LOCAL_MODULE:= lib_omx_common_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/OpenMAXIL/src/component/common/AudioCoreParser.h b/OpenMAXIL/src/component/common/AudioCoreParser.h
new file mode 100755
index 0000000..eefebf5
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioCoreParser.h
@@ -0,0 +1,115 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor, Inc.
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductors Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file AudioCoreParser.h
+ *  @brief Audio core parser.
+ *  @ingroup AudioCoreParser
+ */
+
+
+#ifndef AudioCoreParser_h
+#define AudioCoreParser_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "fsl_types.h"
+
+/** Audio parser return value */
+typedef enum AUDIO_PARSERRETURNTYPE {
+    AUDIO_PARSERRETURNSUCESS = 0,
+    AUDIO_PARSERRETURNFAIL
+} AUDIO_PARSERRETURNTYPE;
+ 
+typedef enum PCM_MODE {
+    PCM_MODE_LINEAR = 0,
+    PCM_MODE_ALAW,
+	PCM_MODE_MULAW,
+	PCM_MODE_UNKNOW
+} PCM_MODE;
+
+/** Audio file information */
+typedef struct AUDIO_FILE_INFO {
+	bool bIsCBR;
+	bool bSeekable;
+	bool bGotDuration;
+	uint32 nFrameHeaderSize;    /*< For overlay search */
+	int64 nDuration;
+	uint64 nBeginPointOffset;
+	uint64 nBitStreamLen;
+	uint64 nTotalSample;
+	uint32 nChannels;
+	uint32 nSamplingRate;
+	uint32 nBitRate;
+	uint32 nBitPerSample;
+	uint32 nBlockSize;
+	uint32 nMinBlockSize;
+	PCM_MODE ePCMMode;
+} AUDIO_FILE_INFO;
+
+typedef struct FRAME_INFO
+{
+	uint32 frm_size;
+	uint32 index;
+	uint32 b_rate;
+	uint32 flags;
+	uint32 total_frame_num;
+	uint32 total_bytes;
+	uint32 sampling_rate;
+	uint32 sample_per_fr;
+	uint32 samples;
+	uint32 layer;
+	uint32 version;
+	uint32 xing_exist;
+	uint32 vbri_exist;
+    uint32 channels;
+	uint8  TOC[100];
+#ifdef PARSER_MP3_LAME_ENC_TAG
+    uint32 lame_exist;
+    uint32 enc_delay;
+    uint32 enc_padding;
+#endif
+}FRAME_INFO;
+
+/** Audio frame information */
+typedef struct AUDIO_FRAME_INFO {
+	bool bGotOneFrame;
+	bool bIsCBR;
+	uint32 nFrameCount;
+	uint32 nFrameHeaderConsumed;
+	uint32 nFrameSize;
+	uint32 nBitRate;
+	uint32 nSamplesPerFrame;
+	uint32 nSamplingRate;
+	FRAME_INFO FrameInfo;
+#ifdef PARSER_MP3_LAME_ENC_TAG
+    uint32 lame_exist;
+    uint32 enc_delay;
+    uint32 enc_padding;
+#endif
+} AUDIO_FRAME_INFO;
+
+
+/** Audio core parser need implement below two function */
+/*
+ * AUDIO_PARSERRETURNTYPE ParserFileHeader(AUDIO_FILE_INFO *pFileInfo, fsl_osal_u8 *pBuffer, \
+ *										uint32 nBufferLen);
+ * AUDIO_PARSERRETURNTYPE ParserFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, \
+ *										uint32 nBufferLen);
+ *
+ */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioFilter.cpp b/OpenMAXIL/src/component/common/AudioFilter.cpp
new file mode 100755
index 0000000..62cc0a4
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioFilter.cpp
@@ -0,0 +1,426 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "AudioFilter.h"
+ 
+OMX_ERRORTYPE AudioFilter::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+		case OMX_IndexParamAudioPcm:
+            {
+				OMX_BOOL bOutputPort = OMX_FALSE;
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmMode;
+                pPcmMode = (OMX_AUDIO_PARAM_PCMMODETYPE*)pComponentParameterStructure;
+                OMX_CHECK_STRUCT(pPcmMode, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+				if (pPcmMode->nPortIndex == AUDIO_FILTER_OUTPUT_PORT)
+				{
+					bOutputPort = OMX_TRUE;
+				}
+
+				fsl_osal_memcpy(pPcmMode, &PcmMode,	sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
+			}
+			LOG_DEBUG("PcmMode.nSamplingRate = %d\n", PcmMode.nSamplingRate);
+			break;
+		default:
+			ret = AudioFilterGetParameter(nParamIndex, pComponentParameterStructure);
+			break;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioFilter::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+        case OMX_IndexParamAudioPortFormat:
+            {
+                OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat;
+                pPortFormat = (OMX_AUDIO_PARAM_PORTFORMATTYPE*)pComponentParameterStructure;
+                OMX_CHECK_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+				if (pPortFormat->nPortIndex > AUDIO_FILTER_PORT_NUMBER - 1)
+				{
+					ret = OMX_ErrorBadPortIndex;
+					break;
+				}
+				fsl_osal_memcpy(&PortFormat[pPortFormat->nPortIndex], pPortFormat, \
+						sizeof(OMX_AUDIO_PARAM_PORTFORMATTYPE));
+            }
+			break;
+        case OMX_IndexParamAudioPcm:
+            {
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmMode;
+                pPcmMode = (OMX_AUDIO_PARAM_PCMMODETYPE*)pComponentParameterStructure;
+                OMX_CHECK_STRUCT(pPcmMode, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+				fsl_osal_memcpy(&PcmMode, pPcmMode, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
+			}
+			AudioFilterSetParameterPCM();
+			break;
+		default:
+			ret = AudioFilterSetParameter(nParamIndex, pComponentParameterStructure);
+			break;
+	}
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioFilter::AudioFilterSetParameterPCM()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    return ret;
+}
+ 
+OMX_ERRORTYPE AudioFilter::InstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	ret = AudioFilterInstanceInit();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Audio decoder instance init fail.\n");
+		return ret;
+	}
+
+	RINGBUFFER_ERRORTYPE BufferRet = RINGBUFFER_SUCCESS;
+	BufferRet = AudioRingBuffer.BufferCreate(nPushModeInputLen, nRingBufferScale);
+	if (BufferRet != RINGBUFFER_SUCCESS)
+	{
+		LOG_ERROR("Create ring buffer fail.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+	LOG_DEBUG("Ring buffer push mode input len: %d\n", nPushModeInputLen);
+
+	AUDIO_TS_MANAGER_ERRORTYPE Ret = AUDIO_TS_MANAGER_SUCCESS;
+	Ret = TS_Manager.Create();
+	if (Ret != AUDIO_TS_MANAGER_SUCCESS)
+	{
+		LOG_ERROR("Create audio ts manager fail.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	pInBufferHdr = pOutBufferHdr = NULL; 
+	bReceivedEOS = OMX_FALSE;
+	bFirstFrame = OMX_FALSE;
+	bCodecInit = OMX_FALSE;
+	bInstanceReset = OMX_FALSE;
+	bDecoderEOS = OMX_FALSE;
+	bDecoderInitFail = OMX_FALSE;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioFilter::InstanceDeInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	ret = AudioFilterInstanceDeInit();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Audio decoder instance de-init fail.\n");
+		return ret;
+	}
+
+	LOG_DEBUG("Audio decoder instance de-init.\n");
+	AudioRingBuffer.BufferFree();
+	TS_Manager.Free();
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioFilter::AudioFilterCheckCodecConfig()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	pInBufferHdr->nFilledLen = 0;
+	return ret;
+}
+ 
+OMX_ERRORTYPE AudioFilter::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    LOG_LOG("Audio filter In: %d, Out: %d\n", ports[AUDIO_FILTER_INPUT_PORT]->BufferNum(), ports[AUDIO_FILTER_OUTPUT_PORT]->BufferNum());
+
+    if(((ports[AUDIO_FILTER_INPUT_PORT]->BufferNum() == 0 && pInBufferHdr == NULL )
+				|| pInBufferHdr != NULL) /**< Ring buffer full */
+            && (ports[AUDIO_FILTER_OUTPUT_PORT]->BufferNum() == 0  && pOutBufferHdr == NULL))
+        return OMX_ErrorNoMore;
+	if(pOutBufferHdr == NULL && ports[AUDIO_FILTER_OUTPUT_PORT]->BufferNum() > 0) {
+		ports[AUDIO_FILTER_OUTPUT_PORT]->GetBuffer(&pOutBufferHdr);
+		pOutBufferHdr->nFlags = 0;
+	}
+
+    if(pInBufferHdr == NULL && ports[AUDIO_FILTER_INPUT_PORT]->BufferNum() > 0) {
+		ports[AUDIO_FILTER_INPUT_PORT]->GetBuffer(&pInBufferHdr);
+		if(pInBufferHdr != NULL) {
+			ret = ProcessInputBufferFlag();
+			if (ret != OMX_ErrorNone)
+			{
+				LOG_ERROR("Process input buffer flag fail.\n");
+				return ret;
+			}
+		}
+	}
+
+	if(pInBufferHdr != NULL) {
+		ret = ProcessInputDataBuffer();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Process input data buffer fail.\n");
+			return ret;
+		}
+	}
+
+	if (bInstanceReset == OMX_TRUE)
+	{
+		bInstanceReset = OMX_FALSE;
+		ret = AudioFilterInstanceReset();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Audio filter instance reset fail.\n");
+			bDecoderEOS = OMX_TRUE;
+			SendEvent(OMX_EventError, ret, 0, NULL);
+			return ret;
+		}
+	} 
+
+	if (bFirstFrame == OMX_TRUE)
+	{
+		ret = AudioFilterCheckFrameHeader();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("AudioFilterCheckFrameHeader fail.\n");
+		}
+            
+	}
+
+    	LOG_LOG("Audio Filter Ringbuffer data len: %d\n", AudioRingBuffer.AudioDataLen());
+	if ((AudioRingBuffer.AudioDataLen() < nPushModeInputLen && bReceivedEOS == OMX_FALSE)
+			|| bDecoderEOS == OMX_TRUE)
+    {
+        LOG_DEBUG("Input buffer is not enough for filter.\n");
+        if(ports[AUDIO_FILTER_INPUT_PORT]->BufferNum() > 0)
+			return OMX_ErrorNone;
+		else
+			return OMX_ErrorNoMore;
+	}
+
+	if (bCodecInit == OMX_FALSE)
+	{
+		bCodecInit = OMX_TRUE;
+		ret = AudioFilterCodecInit();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Audio decoder codec init fail.\n");
+			bDecoderInitFail = OMX_TRUE;
+		}
+	}  
+
+	if(pOutBufferHdr != NULL) 
+	{
+		ret = ProcessOutputDataBuffer();
+		if (ret != OMX_ErrorNone)
+			LOG_ERROR("Process Output data buffer fail.\n");
+	}
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioFilter::AudioFilterInstanceReset()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioFilter::ProcessInputBufferFlag()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_CODECCONFIG)
+        {
+            LOG_DEBUG("received audio codec config data.\n");
+            AudioFilterCheckCodecConfig();
+            return OMX_ErrorNone;
+        }
+
+	if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME)
+	{
+		AudioRingBuffer.BufferReset();
+		TS_Manager.Reset();
+		AudioFilterReset();
+		bReceivedEOS = OMX_FALSE;
+		bDecoderEOS = OMX_FALSE;
+        bFirstFrame = OMX_TRUE; 
+        LOG_DEBUG("Audio Filter received STARTTIME.\n");
+	}
+
+	if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_EOS)
+	{
+		bReceivedEOS = OMX_TRUE;
+		LOG_DEBUG("Audio Filter %s received EOS.\n", role[0]);
+	}
+ 
+	LOG_DEBUG_INS("FilledLen = %d, TimeStamp = %lld\n", \
+			pInBufferHdr->nFilledLen, pInBufferHdr->nTimeStamp);
+    TS_Manager.TS_Add(pInBufferHdr->nTimeStamp, pInBufferHdr->nFilledLen - \
+            pInBufferHdr->nOffset);
+
+	return ret;
+}
+
+
+OMX_ERRORTYPE AudioFilter::ProcessInputDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 nActuralLen;
+
+	/** Process audio data */
+	AudioRingBuffer.BufferAdd(pInBufferHdr->pBuffer + pInBufferHdr->nOffset, 
+                pInBufferHdr->nFilledLen,
+				&nActuralLen);
+
+	if (nActuralLen < pInBufferHdr->nFilledLen)
+	{
+        pInBufferHdr->nOffset += nActuralLen;
+        pInBufferHdr->nFilledLen -= nActuralLen;
+	}
+	else
+	{
+        pInBufferHdr->nOffset = 0;
+        pInBufferHdr->nFilledLen = 0;
+        ports[AUDIO_FILTER_INPUT_PORT]->SendBuffer(pInBufferHdr);
+        pInBufferHdr = NULL;
+	}
+	
+    return ret;
+}
+
+OMX_ERRORTYPE AudioFilter::AudioFilterCheckFrameHeader()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	
+    return ret;
+}
+
+
+OMX_ERRORTYPE AudioFilter::ProcessOutputDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if (bFirstFrame == OMX_TRUE) {
+        TS_Manager.Consumered(0);
+		TS_Manager.TS_SetIncrease(0); 
+    }
+	TS_Manager.TS_Get(&pOutBufferHdr->nTimeStamp);
+
+	AUDIO_FILTERRETURNTYPE DecodeRet;
+
+	if (bDecoderInitFail == OMX_TRUE)
+	{
+		AudioRingBuffer.BufferReset();
+		TS_Manager.Reset();
+		bReceivedEOS = OMX_TRUE;
+		DecodeRet = AUDIO_FILTER_EOS;
+	}
+	else
+	{
+		DecodeRet = AudioFilterFrame();
+		if (DecodeRet == AUDIO_FILTER_FAILURE)
+		{
+			LOG_WARNING("Decode frame fail.\n");
+                     fsl_osal_sleep(4000);
+                     return OMX_ErrorNone;
+		}else if(DecodeRet == AUDIO_FILTER_FATAL_ERROR){
+            AudioRingBuffer.BufferReset();
+            TS_Manager.Reset();
+            bReceivedEOS = OMX_TRUE;
+            DecodeRet = AUDIO_FILTER_EOS;
+        }
+	}
+
+
+	if (DecodeRet == AUDIO_FILTER_EOS && bReceivedEOS == OMX_TRUE && AudioRingBuffer.AudioDataLen() == 0)
+	{
+		LOG_DEBUG("Audio Filter %s send EOS, len %d\n", role[0], pOutBufferHdr->nFilledLen);
+		pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_EOS;
+		bDecoderEOS = OMX_TRUE;
+		SendEvent(OMX_EventBufferFlag, AUDIO_FILTER_OUTPUT_PORT, OMX_BUFFERFLAG_EOS, NULL);
+	}
+
+	if (bFirstFrame == OMX_TRUE)
+	{
+		bFirstFrame = OMX_FALSE;
+		pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+	}
+	pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+	pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
+
+    if(DecodeRet == AUDIO_FILTER_NEEDMORE){
+        return OMX_ErrorNone;
+    }
+    
+    ports[AUDIO_FILTER_OUTPUT_PORT]->SendBuffer(pOutBufferHdr);
+    pOutBufferHdr = NULL;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioFilter::ComponentReturnBuffer(
+        OMX_U32 nPortIndex)
+{
+	bDecoderEOS = OMX_FALSE;
+	if(nPortIndex == AUDIO_FILTER_INPUT_PORT && pInBufferHdr != NULL) {
+        ports[AUDIO_FILTER_INPUT_PORT]->SendBuffer(pInBufferHdr);
+        pInBufferHdr = NULL;
+    }
+
+    if(nPortIndex == AUDIO_FILTER_OUTPUT_PORT && pOutBufferHdr != NULL) {
+        ports[AUDIO_FILTER_OUTPUT_PORT]->SendBuffer(pOutBufferHdr);
+        pOutBufferHdr = NULL;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioFilter::FlushComponent(
+        OMX_U32 nPortIndex)
+{
+    if(nPortIndex == AUDIO_FILTER_INPUT_PORT && pInBufferHdr != NULL) {
+        ports[AUDIO_FILTER_INPUT_PORT]->SendBuffer(pInBufferHdr);
+        pInBufferHdr = NULL;
+    }
+
+    if(nPortIndex == AUDIO_FILTER_OUTPUT_PORT && pOutBufferHdr != NULL) {
+        ports[AUDIO_FILTER_OUTPUT_PORT]->SendBuffer(pOutBufferHdr);
+        pOutBufferHdr = NULL;
+    }
+
+	bReceivedEOS = OMX_FALSE;
+	AudioRingBuffer.BufferReset();
+	TS_Manager.Reset();
+	LOG_DEBUG("Clear ring buffer.\n");
+
+    return OMX_ErrorNone;
+}
+
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioFilter.h b/OpenMAXIL/src/component/common/AudioFilter.h
new file mode 100755
index 0000000..d3006b0
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioFilter.h
@@ -0,0 +1,82 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file AudioFilter.h
+ *  @brief Class definition of AudioFilter Component
+ *  @ingroup AudioFilter
+ */
+
+#ifndef AudioFilter_h
+#define AudioFilter_h
+
+#include "ComponentBase.h"
+#include "RingBuffer.h"
+#include "AudioTSManager.h"
+
+#define AUDIO_FILTER_INPUT_PORT 0
+#define AUDIO_FILTER_OUTPUT_PORT 1
+#define AUDIO_FILTER_PORT_NUMBER 2
+#define CHECKFRAMEHEADERREADLEN 1024
+#define AUDIO_MAXIMUM_ERROR_COUNT 100
+
+typedef enum {
+    AUDIO_FILTER_SUCCESS,
+    AUDIO_FILTER_EOS,
+    AUDIO_FILTER_FAILURE,
+    AUDIO_FILTER_NEEDMORE,
+    AUDIO_FILTER_FATAL_ERROR,
+}AUDIO_FILTERRETURNTYPE;
+
+class AudioFilter : public ComponentBase {
+    public:
+		RingBuffer AudioRingBuffer;
+		AudioTSManager TS_Manager;
+		OMX_BOOL bReceivedEOS;
+	protected:
+        OMX_ERRORTYPE ProcessDataBuffer();
+		OMX_S32 nInputPortBufferSize;
+		OMX_S32 nOutputPortBufferSize;
+		OMX_BOOL bDecoderEOS;
+		OMX_U32 nPushModeInputLen;
+		OMX_U32 nRingBufferScale;
+		OMX_TICKS TS_PerFrame;
+		OMX_BOOL bInstanceReset;
+        OMX_BUFFERHEADERTYPE *pOutBufferHdr;
+        OMX_BUFFERHEADERTYPE *pInBufferHdr;
+        OMX_AUDIO_PARAM_PCMMODETYPE PcmMode; /**< For output port */
+    private:
+        OMX_ERRORTYPE InstanceInit();
+        OMX_ERRORTYPE InstanceDeInit();
+        virtual OMX_ERRORTYPE AudioFilterInstanceInit() = 0;
+        virtual OMX_ERRORTYPE AudioFilterCodecInit() = 0;
+        virtual OMX_ERRORTYPE AudioFilterInstanceDeInit() = 0;
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE AudioFilterGetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) = 0;
+        virtual OMX_ERRORTYPE AudioFilterSetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) = 0;
+        virtual OMX_ERRORTYPE AudioFilterSetParameterPCM();
+		virtual OMX_ERRORTYPE AudioFilterInstanceReset();
+		virtual OMX_ERRORTYPE AudioFilterCheckCodecConfig();
+		virtual OMX_ERRORTYPE AudioFilterCheckFrameHeader();
+        virtual AUDIO_FILTERRETURNTYPE AudioFilterFrame() = 0;
+		virtual OMX_ERRORTYPE AudioFilterReset() = 0;
+		OMX_ERRORTYPE ProcessInputBufferFlag();
+		OMX_ERRORTYPE ProcessInputDataBuffer();
+		OMX_ERRORTYPE ProcessOutputDataBuffer();
+        virtual OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+		OMX_AUDIO_PARAM_PORTFORMATTYPE PortFormat[AUDIO_FILTER_PORT_NUMBER];
+		OMX_BOOL bFirstFrame;
+		OMX_BOOL bCodecInit;
+		OMX_BOOL bDecoderInitFail;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioParserBase.cpp b/OpenMAXIL/src/component/common/AudioParserBase.cpp
new file mode 100755
index 0000000..21492be
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioParserBase.cpp
@@ -0,0 +1,1251 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifdef ANDROID_BUILD
+#include <utils/String8.h>
+#include "id3_parser/ID3.h"
+using namespace android;
+#endif
+#include "AudioParserBase.h"
+#include "ShareLibarayMgr.h"
+
+OMX_ERRORTYPE AudioParserBase::InstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    bHasAudioTrack = OMX_TRUE;
+
+	nBeginPoint = 0;
+	nReadPoint = 0;
+	nBeginPointOffset = 0;
+	bBeginPointFounded = OMX_FALSE;
+	pThreadId = NULL;
+	nSource2CurPos = 0;
+	bStopVBRDurationThread = OMX_FALSE;
+	bSegmentStart = OMX_TRUE;
+	bSeekable = OMX_TRUE;
+	bTOCSeek = OMX_FALSE;
+	nOneSecondSample = 0;
+	nSampleRate = 44100;
+	bCBR = OMX_FALSE; 
+	bVBRDurationReady = OMX_FALSE;
+	fsl_osal_memset(SeekTable, 0, sizeof(OMX_U64 **) * MAXAUDIODURATIONHOUR);
+#ifndef ANDROID_BUILD
+	fsl_osal_memset(&info, 0, sizeof(meta_data_v1));
+	fsl_osal_memset(&info_v2, 0, sizeof(meta_data_v2));
+#endif
+	sourceFileHandle = fileOps.Open((const uint8*)pMediaName,(const uint8*) "rb", this);
+	if (sourceFileHandle == 0 )
+	{
+		LOG_ERROR("Can't open input file.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	nFileSize = fileOps.Size(sourceFileHandle, this);
+	nEndPoint = nFileSize;
+        if(nEndPoint == 0 && isStreamingSource == OMX_TRUE)
+            nEndPoint = -1L;
+
+	ret = GetCoreParser();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Get core parser fail.\n");
+		return ret;
+	}
+
+	struct timeval tv, tv1;
+	gettimeofday (&tv, NULL);
+
+	ret = AudioParserInstanceInit();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Audio parser instance init fail.\n");
+		return ret;
+	}
+
+	SetMetadata((OMX_STRING)"mime", GetMimeFromComponentRole(sCompRole.cRole), 32);
+	// The duration value is a string representing the duration in ms. 
+	char tmp[32];
+	sprintf(tmp, "%lld", (usDuration + 500) / 1000); 
+	SetMetadata((OMX_STRING)"duration", tmp, 32);
+	gettimeofday (&tv1, NULL);
+	LOG_DEBUG("Audio Parser Time: %d\n", (tv1.tv_sec-tv.tv_sec)*1000+(tv1.tv_usec-tv.tv_usec)/1000);
+
+    return ret;
+}
+
+void *ParserCalculateVBRDurationFunc(void *arg);
+
+OMX_ERRORTYPE AudioParserBase::AudioParserInstanceInit()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 nAvrageBitRate;
+
+	LOG_DEBUG("Audio file size: %lld\n", nFileSize);
+	if (nFileSize == 0)
+	{
+		SetupPortMediaFormat();
+		return ret;
+	}
+
+	/** Parser ID3 tag */
+	ParserID3Tag();
+
+	/** Parser file header */
+	ret = AudioParserFileHeader();
+	if (ret != OMX_ErrorNone)
+	{
+		if (ret == OMX_ErrorNoMore)
+			return OMX_ErrorNone;
+		else
+			return ret;
+	}
+
+	/** Parser three segment to check if the file format is supported and get rough duration*/
+	LOG_DEBUG("Begin Point: %lld\n", nBeginPoint);
+	if (bGetMetadata == OMX_TRUE)
+		ParserOneSegmentAudio();
+	else
+		ParserThreeSegmentAudio();
+	LOG_DEBUG("bCBR after three segment = %d\n", bCBR);
+
+	if (bBeginPointFounded == OMX_TRUE)
+	{
+		nBeginPoint += nBeginPointOffset;
+	}
+	LOG_DEBUG("Begin Point: %lld\n", nBeginPoint);
+	nAvrageBitRate = GetAvrageBitRate();
+	if (nAvrageBitRate == 0)
+	{
+		LOG_ERROR("Audio duration is 0.\n");
+		return OMX_ErrorFormatNotDetected;
+	}
+	nAudioDuration = (OMX_U64)((nEndPoint - nBeginPoint) << 3) * OMX_TICKS_PER_SECOND / nAvrageBitRate;
+	usDuration = nAudioDuration;
+	LOG_DEBUG("Audio Duration: %lld\n", usDuration);
+
+	if (bBeginPointFounded == OMX_FALSE && bGetMetadata != OMX_TRUE)
+	{
+		ParserFindBeginPoint();
+	}
+
+	LOG_DEBUG("Have Xing: %d total frame: %d sample rate: %d sample_per_fr: %d total bytes: %d TOC(1): %d\n", FrameInfo.FrameInfo.xing_exist, FrameInfo.FrameInfo.total_frame_num, FrameInfo.FrameInfo.sampling_rate, FrameInfo.FrameInfo.sample_per_fr, FrameInfo.FrameInfo.total_bytes, FrameInfo.FrameInfo.TOC[1]);
+	if (FrameInfo.FrameInfo.sampling_rate && FrameInfo.FrameInfo.sample_per_fr && FrameInfo.FrameInfo.total_frame_num)
+		nAudioDuration = (OMX_U64)FrameInfo.FrameInfo.total_frame_num * FrameInfo.FrameInfo.sample_per_fr * OMX_TICKS_PER_SECOND / FrameInfo.FrameInfo.sampling_rate;
+	usDuration = nAudioDuration;
+	LOG_DEBUG("Audio Duration: %lld\n", usDuration);
+
+	if (bCBR == OMX_FALSE && FrameInfo.FrameInfo.total_bytes && FrameInfo.FrameInfo.TOC[1]) {
+		bTOCSeek = OMX_TRUE;
+		bVBRDurationReady = OMX_TRUE;
+	} else if (bCBR == OMX_FALSE && isStreamingSource != OMX_TRUE && isLiveSource != OMX_TRUE && bGetMetadata != OMX_TRUE)
+	{
+		/** Calculate accurate duration and seek table in background thread */
+		if(E_FSL_OSAL_SUCCESS != fsl_osal_thread_create(&pThreadId, NULL, \
+					ParserCalculateVBRDurationFunc, this))
+		{
+			LOG_ERROR("Create audio parser calculate duration thread failed.\n");
+			return OMX_ErrorInsufficientResources;
+		}
+	}
+
+	fileOps.Seek(sourceFileHandle, nBeginPoint, SEEK_SET, this);
+	nReadPoint = nBeginPoint;
+
+	SetupPortMediaFormat();
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::AudioParserFileHeader()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	/** Parser file header */
+	LOG_DEBUG("Begin Point: %lld\n", nBeginPoint);
+	fileOps.Seek(sourceFileHandle, nBeginPoint, SEEK_SET, this);
+	OMX_U8 *pTmpBuffer = (OMX_U8 *)FSL_MALLOC(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	OMX_U32 nReadLen = AUDIO_PARSER_READ_SIZE;
+	OMX_U32 nActuralRead;
+
+	if (nReadLen > nFileSize - nBeginPoint)
+	{
+		nReadLen = nFileSize - nBeginPoint;
+	}
+
+	nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+	if (ParserFileHeader(&FileInfo, pTmpBuffer, nActuralRead) == AUDIO_PARSERRETURNFAIL)
+		return OMX_ErrorUndefined;
+
+	FSL_FREE(pTmpBuffer);
+
+	if (FileInfo.bSeekable == E_FSL_OSAL_FALSE)
+	{
+		/** ADIF file will into this part code. */
+		bSeekable = OMX_FALSE;
+		LOG_DEBUG("BitRate: %d\n", FileInfo.nBitRate);
+		if (FileInfo.nBitRate != 0)
+		{
+			nAudioDuration = (nFileSize<<3)/FileInfo.nBitRate*OMX_TICKS_PER_SECOND;
+			usDuration = nAudioDuration;
+		}
+		goto Done;
+	}
+
+	if (FileInfo.bGotDuration == E_FSL_OSAL_TRUE && FileInfo.bIsCBR == E_FSL_OSAL_TRUE)
+	{
+		/** WAVE and FLAC file will into this part code. */
+		bCBR = OMX_TRUE;
+		nAudioDuration = FileInfo.nDuration;
+		usDuration = nAudioDuration;
+		nBeginPoint += FileInfo.nBeginPointOffset;
+		if (FileInfo.ePCMMode != PCM_MODE_UNKNOW)
+			nEndPoint = nBeginPoint + FileInfo.nBitStreamLen;
+		goto Done;
+	}
+
+	if (FileInfo.bGotDuration == E_FSL_OSAL_TRUE && FileInfo.bIsCBR == E_FSL_OSAL_FALSE)
+	{
+		/** FLAC and MP3 with Xing header file will into this part code. */
+		bCBR = OMX_FALSE;
+		nAudioDuration = FileInfo.nDuration;
+		usDuration = nAudioDuration;
+		nBeginPoint += FileInfo.nBeginPointOffset;
+		goto DoneDuration;
+	}
+
+	return ret;
+
+DoneDuration:
+	if (bCBR == OMX_FALSE)
+	{
+		fileOps.Seek(sourceFileHandle, nBeginPoint, SEEK_SET, this);
+		/** Calculate accurate duration and seek table in background thread */
+		if(E_FSL_OSAL_SUCCESS != fsl_osal_thread_create(&pThreadId, NULL, \
+					ParserCalculateVBRDurationFunc, this))
+		{
+			LOG_ERROR("Create audio parser calculate duration thread failed.\n");
+			return OMX_ErrorInsufficientResources;
+		}
+	}
+
+Done:
+	fileOps.Seek(sourceFileHandle, nBeginPoint, SEEK_SET, this);
+	nReadPoint = nBeginPoint;
+
+	SetupPortMediaFormat();
+
+	return OMX_ErrorNoMore;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserID3Tag()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+#ifdef ANDROID_BUILD
+	OMX_U8 *pTmpBuffer = (OMX_U8 *)FSL_MALLOC(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+	fsl_osal_memset(pTmpBuffer, 0, AUDIO_PARSER_READ_SIZE);
+
+	OMX_U32 nReadLen = 10;
+	OMX_U32 nActuralRead;
+
+	if (nReadLen > nFileSize)
+	{
+		nReadLen = nFileSize;
+	}
+
+	nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+	ID3 id3;
+	bool isValid;
+	if (!fsl_osal_memcmp((void *)("ID3"), pTmpBuffer, 3)) {
+		// Skip the ID3v2 header.
+		OMX_U32 len =
+			((pTmpBuffer[6] & 0x7f) << 21)
+			| ((pTmpBuffer[7] & 0x7f) << 14)
+			| ((pTmpBuffer[8] & 0x7f) << 7)
+			| (pTmpBuffer[9] & 0x7f);
+
+		if (len > 3 * 1024 * 1024)
+			len = 3 * 1024 * 1024;
+
+		len += 10;
+
+		nBeginPoint = len;
+
+		LOG_DEBUG("Begin point: %lld\n", nBeginPoint);
+
+		if (nBeginPoint > AUDIO_PARSER_READ_SIZE) 
+		{
+			FSL_FREE(pTmpBuffer);
+
+			pTmpBuffer = (OMX_U8 *)FSL_MALLOC(nBeginPoint);
+			if (pTmpBuffer == NULL)
+			{
+				LOG_ERROR("Can't get memory.\n");
+				return OMX_ErrorInsufficientResources;
+			}
+			fsl_osal_memset(pTmpBuffer, 0, nBeginPoint);
+		}
+
+		fileOps.Seek(sourceFileHandle, 0, SEEK_SET, this); 
+		nReadLen = nBeginPoint;
+
+		if (nReadLen > nFileSize)
+		{
+			nReadLen = nFileSize;
+		}
+
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+		OMX_BOOL bGetV2 = OMX_FALSE;
+
+		isValid = id3.parseV2((const char *)pTmpBuffer); 
+
+	} else {
+		isValid = false;
+	}
+
+	if (!isValid) {
+		nReadLen = 128;
+		fsl_osal_memset(pTmpBuffer, 0, AUDIO_PARSER_READ_SIZE);
+		fileOps.Seek(sourceFileHandle, -128, SEEK_END, this); /*< ID3v1 */
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+		LOG_DEBUG("Parser ID3 TAG V1.\n");
+		isValid = id3.parseV1((const char *)pTmpBuffer); 
+
+		if (!isValid) {
+			LOG_DEBUG("No any metadata.\n");
+			FSL_FREE(pTmpBuffer);
+			return ret;
+		}
+	}
+
+    struct Map {
+        const char *key;
+        const char *tag1;
+        const char *tag2;
+    };
+    static const Map kMap[] = {
+        { "album", "TALB", "TAL" },
+        { "artist", "TPE1", "TP1" },
+        { "albumartist", "TPE2", "TP2" },
+        { "composer", "TCOM", "TCM" },
+        { "genre", "TCON", "TCO" },
+        { "title", "TIT2", "TT2" },
+        { "year", "TYE", "TYER" },
+        { "tracknumber", "TRK", "TRCK" },
+        { "discnumber", "TPA", "TPOS" },
+    };
+	
+    static const OMX_U32 kNumMapEntries = sizeof(kMap) / sizeof(kMap[0]);
+
+    for (OMX_U32 i = 0; i < kNumMapEntries; ++i) {
+        ID3::Iterator *it = FSL_NEW(ID3::Iterator, (id3, kMap[i].tag1));
+        if (it->done()) {
+			FSL_DELETE(it);
+			it = FSL_NEW(ID3::Iterator, (id3, kMap[i].tag2));
+        }
+
+        if (it->done()) {
+			FSL_DELETE(it);
+			continue;
+        }
+
+        String8 s;
+        it->getString(&s);
+        FSL_DELETE(it);
+
+		SetMetadata((char *)kMap[i].key, (char *)s.string(), s.length());
+		LOG_DEBUG("Key: %s  metadate: %s\n", (char *)kMap[i].key, (char *)s.string());
+    }
+
+    size_t dataSize;
+    String8 mime;
+    const void *data = id3.getAlbumArt(&dataSize, &mime);
+
+    if (data) {
+		SetMetadata((OMX_STRING)"albumart", (char *)data, dataSize);
+		LOG_DEBUG("albumart format: %s\n", mime.string());
+    }
+
+	FSL_FREE(pTmpBuffer);
+#else
+    ShareLibarayMgr *libMgr = NULL;
+    OMX_PTR hLibId3 = NULL;
+	int (*parse_id3_v2_size)(char *);
+	id3_err (*parse_id3_v2)(meta_data_v2 *, unsigned char *);
+	id3_err (*parse_id3_albumart)(meta_data_v2 *, unsigned char *);
+	id3_err (*parse_id3_v1_metadata)(meta_data_v1 *,char *);
+
+    libMgr = FSL_NEW(ShareLibarayMgr, ());
+    if(libMgr == NULL)
+        return OMX_ErrorInsufficientResources;
+
+    hLibId3 = libMgr->load("lib_id3_parser_arm11_elinux.so");
+    if(hLibId3 == NULL) {
+        FSL_DELETE(libMgr);
+        return OMX_ErrorUndefined;
+    }
+
+    parse_id3_v2_size = (int (*)(char *))libMgr->getSymbol(hLibId3, "id3_parser_get_id3_v2_size");
+    parse_id3_v2 = (id3_err (*)(meta_data_v2 *, unsigned char *))libMgr->getSymbol(hLibId3, "id3_parser_parse_v2");
+    parse_id3_albumart = (id3_err (*)(meta_data_v2 *, unsigned char *))libMgr->getSymbol(hLibId3, "id3_parser_parse_albumart_v2");
+    parse_id3_v1_metadata = (id3_err (*)(meta_data_v1 *,char *))libMgr->getSymbol(hLibId3, "get_metadata_v1");
+    if(parse_id3_v2_size == NULL
+			|| parse_id3_v2 == NULL
+			|| parse_id3_albumart == NULL
+			|| parse_id3_v1_metadata == NULL) {
+        libMgr->unload(hLibId3);
+        FSL_DELETE(libMgr);
+        return OMX_ErrorUndefined;
+    }
+
+
+	OMX_U8 *pTmpBuffer = (OMX_U8 *)FSL_MALLOC(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+        libMgr->unload(hLibId3);
+        FSL_DELETE(libMgr);
+		return OMX_ErrorInsufficientResources;
+	}
+	fsl_osal_memset(pTmpBuffer, 0, AUDIO_PARSER_READ_SIZE);
+
+	OMX_U32 nReadLen = AUDIO_PARSER_READ_SIZE;
+	OMX_U32 nActuralRead;
+
+	if (nReadLen > nFileSize)
+	{
+		nReadLen = nFileSize;
+	}
+
+	nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+	nBeginPoint = parse_id3_v2_size((char *)pTmpBuffer);
+
+	LOG_DEBUG("Begin point: %lld\n", nBeginPoint);
+	id3_err retID3 = ID3_OK;
+
+	if (nBeginPoint > AUDIO_PARSER_READ_SIZE) 
+	{
+		FSL_FREE(pTmpBuffer);
+
+		pTmpBuffer = (OMX_U8 *)FSL_MALLOC(nBeginPoint);
+		if (pTmpBuffer == NULL)
+		{
+			LOG_ERROR("Can't get memory.\n");
+			libMgr->unload(hLibId3);
+			FSL_DELETE(libMgr);
+			return OMX_ErrorInsufficientResources;
+		}
+		fsl_osal_memset(pTmpBuffer, 0, nBeginPoint);
+	}
+
+	fileOps.Seek(sourceFileHandle, 0, SEEK_SET, this); 
+	nReadLen = nBeginPoint;
+
+	if (nReadLen > nFileSize)
+	{
+		nReadLen = nFileSize;
+	}
+
+	nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+	OMX_BOOL bGetV2 = OMX_FALSE;
+	retID3 = parse_id3_v2(&info_v2, pTmpBuffer);
+	if (retID3 == ID3_OK)
+	{
+		if (fsl_osal_strlen(info_v2.song_title))
+			SetMetadata("title", info_v2.song_title, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.artist))
+			SetMetadata("artist", info_v2.artist, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.album))
+			SetMetadata("album", info_v2.album, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.year))
+			SetMetadata("year", info_v2.year, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.comment))
+			SetMetadata("comment", info_v2.comment, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.genre))
+			SetMetadata("genre", info_v2.genre, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.composer))
+			SetMetadata("composer", info_v2.composer, MAX_V2_STRING);
+		if (fsl_osal_strlen(info_v2.copyright))
+			SetMetadata("copyright", info_v2.copyright, MAX_V2_STRING);
+		bGetV2 = OMX_TRUE;
+	}
+
+	retID3 = parse_id3_albumart(&info_v2, pTmpBuffer);
+	if (retID3 == ID3_OK && info_v2.albumartsize != 0)
+	{
+		SetMetadata("albumart", info_v2.albumart, info_v2.albumartsize);
+		free(info_v2.albumart);
+	}
+
+	OMX_U32 nDataSize = nEndPoint - nBeginPoint;
+	fsl_osal_memset(pTmpBuffer, 0, AUDIO_PARSER_READ_SIZE);
+	if (nDataSize >= 128 && nDataSize <= 128 + 227)
+	{
+		nReadLen = 128;
+		fileOps.Seek(sourceFileHandle, -128, SEEK_END, this); /*< ID3v1 */
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+		retID3 = parse_id3_v1_metadata(&info, (char *)pTmpBuffer);
+		if (retID3 == ID3_OK && bGetV2 == OMX_FALSE)
+		{
+			nEndPoint -= 128;
+			if (fsl_osal_strlen(info.song_title))
+				SetMetadata("title", info.song_title, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.artist))
+				SetMetadata("artist", info.artist, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.album))
+				SetMetadata("album", info.album, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.year))
+				SetMetadata("year", info.year, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.comment))
+				SetMetadata("comment", info.comment, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.genre_string))
+				SetMetadata("genre", info.genre_string, MAX_V1_STRING);
+		}
+	}
+	else if (nDataSize >= 128 + 227)
+	{
+		nReadLen = 128 + 227;
+		fileOps.Seek(sourceFileHandle, -128-227, SEEK_END, this); /*< ID3v1 and ID3v1.1 */
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+		retID3 = parse_id3_v1_metadata(&info, (char *)(pTmpBuffer + 227));
+		if (retID3 == ID3_OK && bGetV2 == OMX_FALSE)
+		{
+			nEndPoint -= 128;
+			if (fsl_osal_strlen(info.song_title))
+				SetMetadata("title", info.song_title, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.artist))
+				SetMetadata("artist", info.artist, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.album))
+				SetMetadata("album", info.album, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.year))
+				SetMetadata("year", info.year, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.comment))
+				SetMetadata("comment", info.comment, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.genre_string))
+				SetMetadata("genre", info.genre_string, MAX_V1_STRING);
+		}
+		retID3 = parse_id3_v1_metadata(&info, (char *)pTmpBuffer);
+		if (retID3 == ID3_OK && bGetV2 == OMX_FALSE)
+		{
+			nEndPoint -= 227;
+			if (fsl_osal_strlen(info.song_title))
+				SetMetadata("title", info.song_title, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.artist))
+				SetMetadata("artist", info.artist, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.album))
+				SetMetadata("album", info.album, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.year))
+				SetMetadata("year", info.year, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.comment))
+				SetMetadata("comment", info.comment, MAX_V1_STRING);
+			if (fsl_osal_strlen(info.genre_string))
+				SetMetadata("genre", info.genre_string, MAX_V1_STRING);
+		}
+	}
+
+	FSL_FREE(pTmpBuffer);
+	libMgr->unload(hLibId3);
+	FSL_DELETE(libMgr);
+
+#endif
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserOneSegmentAudio()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	fileOps.Seek(sourceFileHandle, nBeginPoint, SEEK_SET, this);
+	bCBR = OMX_TRUE;
+	FrameInfo.bIsCBR = E_FSL_OSAL_TRUE;
+
+	OMX_U8 *pTmpBuffer = AudioParserGetBuffer(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	OMX_U32 nActuralRead, nSegmentCnt = 1;
+	OMX_U32 nReadPointTmp = 0, nReadPointTmp2 = 0;
+	OMX_U32 nReadLen = AUDIO_PARSER_READ_SIZE;
+	OMX_U32 nDataSize = nEndPoint - nBeginPoint;
+
+	OMX_S64 nSkip = (nDataSize - 3 * AUDIO_PARSER_SEGMENT_SIZE) / 2;
+	if (nSkip < 0)
+	{
+		nSkip = 0;
+	}
+
+	if(-1 == fileOps.Seek(sourceFileHandle, nSkip, SEEK_CUR, this))
+	{
+		LOG_DEBUG("Audio file seek fail.\n");
+	}
+
+	for (OMX_U32 i = 0; ; i ++)
+	{
+		if (nReadPointTmp + nReadLen > nDataSize)
+		{
+			nReadLen = nDataSize - nReadPointTmp;
+		}
+
+		LOG_DEBUG("Audio parser read point: %lld\n", nBeginPoint + nReadPointTmp + nSkip);
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+		nReadPointTmp += nActuralRead;
+		nReadPointTmp2 += nActuralRead;
+
+		LOG_LOG("nReadPointTmp = %d\n", nReadPointTmp);
+		ParserAudioFrame(pTmpBuffer, nActuralRead, nSegmentCnt);
+
+		if (nActuralRead < AUDIO_PARSER_READ_SIZE)
+		{
+			LOG_DEBUG("Audio file parser reach end.\n");
+			break;
+		}
+
+		if (nReadPointTmp2 >= AUDIO_PARSER_SEGMENT_SIZE)
+		{
+			break;
+			nReadPointTmp2 = 0;
+			nSegmentCnt ++;
+			nReadPointTmp += nSkip;
+		}
+	}
+
+	if (FrameInfo.bIsCBR == E_FSL_OSAL_FALSE)
+	{
+		bCBR = OMX_FALSE;
+	}
+
+	AudioParserFreeBuffer(pTmpBuffer);
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserThreeSegmentAudio()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	fileOps.Seek(sourceFileHandle, nBeginPoint, SEEK_SET, this);
+	bCBR = OMX_TRUE;
+	FrameInfo.bIsCBR = E_FSL_OSAL_TRUE;
+
+	OMX_U8 *pTmpBuffer = AudioParserGetBuffer(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	OMX_U32 nActuralRead, nSegmentCnt = 0;
+	OMX_U32 nReadPointTmp = 0, nReadPointTmp2 = 0;
+	OMX_U32 nReadLen = AUDIO_PARSER_READ_SIZE;
+	OMX_U32 nDataSize = nEndPoint - nBeginPoint;
+
+	for (OMX_U32 i = 0; ; i ++)
+	{
+		if (nReadPointTmp + nReadLen > nDataSize)
+		{
+			nReadLen = nDataSize - nReadPointTmp;
+		}
+
+		LOG_LOG("Audio parser read point: %lld\n", nBeginPoint + nReadPointTmp);
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+		nReadPointTmp += nActuralRead;
+		nReadPointTmp2 += nActuralRead;
+
+		LOG_LOG("nReadPointTmp = %d\n", nReadPointTmp);
+		ParserAudioFrame(pTmpBuffer, nActuralRead, nSegmentCnt);
+
+		if (nActuralRead < AUDIO_PARSER_READ_SIZE)
+		{
+			LOG_DEBUG("Audio file parser reach end.\n");
+			break;
+		}
+
+		if (nReadPointTmp2 >= AUDIO_PARSER_SEGMENT_SIZE)
+		{
+			nReadPointTmp2 = 0;
+			nSegmentCnt ++;
+			OMX_S64 nSkip = (nDataSize - 3 * AUDIO_PARSER_SEGMENT_SIZE) / 2;
+			if (nSkip < 0)
+			{
+				nSkip = 0;
+			}
+
+			if(-1 == fileOps.Seek(sourceFileHandle, nSkip, SEEK_CUR, this))
+			{
+				LOG_DEBUG("Audio file seek fail.\n");
+				break;
+			}
+			nReadPointTmp += nSkip;
+		}
+	}
+
+	if (FrameInfo.bIsCBR == E_FSL_OSAL_FALSE)
+	{
+		bCBR = OMX_FALSE;
+	}
+
+	AudioParserFreeBuffer(pTmpBuffer);
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserFindBeginPoint()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	fileOps.Seek(sourceFileHandle, nBeginPoint + AUDIO_PARSER_SEGMENT_SIZE, SEEK_SET, this);
+	OMX_U8 *pTmpBuffer = AudioParserGetBuffer(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	OMX_U32 nReadLen = AUDIO_PARSER_READ_SIZE;
+	OMX_U32 nActuralRead, nSegmentCnt = PARSERAUDIO_BEGINPOINT;
+	OMX_U32 nReadPointTmp = 0;
+	OMX_U32 nDataSize = nEndPoint - nBeginPoint;
+
+	for (OMX_U32 i = 0; ; i ++)
+	{
+		if (nReadPointTmp + nReadLen > nDataSize)
+		{
+			nReadLen = nDataSize - nReadPointTmp;
+		}
+
+		nActuralRead = fileOps.Read(sourceFileHandle, pTmpBuffer, nReadLen, this);
+
+		nReadPointTmp += nActuralRead;
+
+		ParserAudioFrame(pTmpBuffer, nActuralRead, nSegmentCnt);
+
+		if (nActuralRead < AUDIO_PARSER_READ_SIZE)
+		{
+			LOG_DEBUG("Audio file parser reach end.\n");
+			break;
+		}
+
+		if (bBeginPointFounded == OMX_TRUE)
+		{
+			LOG_DEBUG("Audio file begin point found.\n");
+			break;
+		}
+	}
+
+	AudioParserFreeBuffer(pTmpBuffer);
+
+	nBeginPoint += AUDIO_PARSER_SEGMENT_SIZE;
+	nBeginPoint += nBeginPointOffset;
+	LOG_DEBUG("Begin Point: %lld\n", nBeginPoint);
+
+	return ret;
+}
+
+void *ParserCalculateVBRDurationFunc(void *arg) 
+{
+	AudioParserBase *AudioParserBasePtr = (AudioParserBase *)arg;
+
+	AudioParserBasePtr->ParserCalculateVBRDuration();
+
+	return NULL;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserCalculateVBRDuration() 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	FslFileStream fileOps2;
+	FslFileHandle sourceFileHandle2;
+
+	OMX_U8 *pTmpBuffer = AudioParserGetBuffer(AUDIO_PARSER_READ_SIZE);
+	if (pTmpBuffer == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	fsl_osal_memcpy(&fileOps2, &fileOps, sizeof(FslFileStream));
+
+	sourceFileHandle2 = fileOps2.Open((const uint8*)pMediaName,(const uint8*) "rb", this);
+	if (sourceFileHandle2 == 0 )
+	{
+		LOG_ERROR("Can't open input file.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	LOG_DEBUG("Begin point: %d\n", nBeginPoint);
+	fileOps2.Seek(sourceFileHandle2, nBeginPoint, SEEK_SET, this);
+
+	SeekTable[0] = (OMX_U64 **)FSL_MALLOC(60 * sizeof(OMX_U64 *));
+	if(SeekTable[0] == NULL)
+	{
+		LOG_ERROR("Failed in allocate memory for seek_index\n");
+		return OMX_ErrorInsufficientResources;
+	}
+	fsl_osal_memset(SeekTable[0], 0, 60 * sizeof(OMX_U64 *));
+
+	SeekTable[0][0] = (OMX_U64 *)FSL_MALLOC(60 * sizeof(OMX_U64));
+	if(SeekTable[0][0] == NULL)
+	{
+		LOG_ERROR("Failed in allocate memory for seek_index\n");
+		return OMX_ErrorInsufficientResources;
+	}
+	fsl_osal_memset(SeekTable[0][0], 0, 60 * sizeof(OMX_U64));
+
+	SeekTable[0][0][0] = nBeginPoint;
+	secctr = 1;
+	minctr = 0;
+	hourctr =0;
+
+	OMX_U32 nReadLen = AUDIO_PARSER_READ_SIZE;
+	OMX_U32 nActuralRead, nSegmentCnt = PARSERAUDIO_VBRDURATION;
+	OMX_U32 nDataSize = nEndPoint - nBeginPoint;
+	OMX_U32 nReadPointTmp = 0;
+	for (OMX_U32 i = 0; ; i ++)
+	{
+		if (nReadPointTmp + nReadLen > nDataSize)
+		{
+			nReadLen = nDataSize - nReadPointTmp;
+		}
+
+		LOG_LOG("Read: %lld\n", nBeginPoint + nReadPointTmp);
+		nSource2CurPos = fileOps.Tell(sourceFileHandle2, this);
+		nActuralRead = fileOps2.Read(sourceFileHandle2, pTmpBuffer, nReadLen, this);
+
+		nReadPointTmp += nActuralRead;
+
+		ParserAudioFrame(pTmpBuffer, nActuralRead, nSegmentCnt);
+
+		if (nActuralRead < AUDIO_PARSER_READ_SIZE || bStopVBRDurationThread == OMX_TRUE)
+		{
+			LOG_DEBUG("Audio file parser reach end.\n");
+			break;
+		}
+	}
+
+	if (fileOps2.Close(sourceFileHandle2, this) != 0)
+	{
+		LOG_ERROR("Can't close input file.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	AudioParserFreeBuffer(pTmpBuffer);
+
+	nAudioDuration = ((hourctr * 60 + minctr) * 60 + (secctr-1)) * (OMX_U64) OMX_TICKS_PER_SECOND + \
+					 (OMX_U64)nOneSecondSample * OMX_TICKS_PER_SECOND / nSampleRate;
+	usDuration = nAudioDuration;
+	LOG_DEBUG("Audio Duration: %lld\n", usDuration);
+
+	bVBRDurationReady = OMX_TRUE;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserAudioFrame(OMX_U8 *pBuffer, OMX_U32 nActuralRead, OMX_U32 nSegmentCnt)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U8 *pBuffer2 = pBuffer;
+	OMX_U32 nActuralRead2;
+
+	pBuffer2 -= nOverlap;
+	nActuralRead2 = nActuralRead + nOverlap;
+
+	ParserAudioFrameOverlap(pBuffer2, nActuralRead2, nSegmentCnt);
+
+	if (nOverlap < FileInfo.nFrameHeaderSize)
+	{
+		nOverlap = FileInfo.nFrameHeaderSize;
+	}
+	else if (nOverlap > AUDIO_PARSER_READ_SIZE>>1)
+	{
+		LOG_DEBUG("Over lap audio data wrong.\n");
+		nOverlap = AUDIO_PARSER_READ_SIZE>>1;
+	}
+
+	LOG_LOG("Audio parser overlap data length: %d\n", nOverlap);
+	fsl_osal_memcpy(pBuffer - nOverlap, pBuffer+nActuralRead-nOverlap, nOverlap);
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::ParserAudioFrameOverlap(OMX_U8 *pBuffer, OMX_U32 nActuralRead, OMX_U32 nSegmentCnt)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 offset = 0;
+
+	while (offset < nActuralRead)
+	{
+		ParserFrame(&FrameInfo, pBuffer+offset, nActuralRead-offset);
+		if (FrameInfo.bGotOneFrame == E_FSL_OSAL_FALSE)
+		{
+			nOverlap = nActuralRead - offset;
+			LOG_DEBUG("nOverlap: %d\n", nOverlap);
+			break;
+		}
+
+		OMX_U32 nFrameLen = FrameInfo.nFrameHeaderConsumed + FrameInfo.nFrameSize;
+		LOG_LOG("nFrameLen: %d\n", nFrameLen);
+
+		if (FrameInfo.nFrameCount == 1)
+		{
+			if (nSegmentCnt == PARSERAUDIO_HEAD || nSegmentCnt == PARSERAUDIO_BEGINPOINT)
+			{
+				nBeginPointOffset = offset + FrameInfo.nFrameHeaderConsumed - FileInfo.nFrameHeaderSize;
+				bBeginPointFounded = OMX_TRUE;
+			}
+			if (nSegmentCnt == PARSERAUDIO_BEGINPOINT)
+			{
+				break;
+			}
+		}
+
+		if (nSegmentCnt == PARSERAUDIO_VBRDURATION )
+		{
+			AudioParserBuildSeekTable(offset - nOverlap + FrameInfo.nFrameHeaderConsumed - \
+					FileInfo.nFrameHeaderSize, FrameInfo.nSamplesPerFrame, FrameInfo.nSamplingRate);
+		}
+		offset += nFrameLen;
+
+		nTotalBitRate += FrameInfo.nBitRate * 1000;
+	}
+
+	return ret;
+}
+
+OMX_U8 *AudioParserBase::AudioParserGetBuffer(OMX_U32 nBufferSize)
+{
+	LOG_DEBUG("Audio parser malloc tmp buffer size: %d\n", nBufferSize*2);
+	pTmpBufferPtr = (OMX_U8 *)FSL_MALLOC(nBufferSize*2);
+	if (pTmpBufferPtr == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return NULL;
+	}
+
+	nTotalBitRate = 0;
+	FrameInfo.nFrameCount = 0;
+	nOverlap = 0;
+
+	return pTmpBufferPtr+nBufferSize;
+}
+
+OMX_ERRORTYPE AudioParserBase::AudioParserFreeBuffer(OMX_U8 *pBuffer)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	FSL_FREE(pTmpBufferPtr);
+
+	return ret;
+}
+
+OMX_U32 AudioParserBase::GetAvrageBitRate()
+{
+	if (FrameInfo.nFrameCount != 0)
+	{
+		nAvrageBitRate = nTotalBitRate / FrameInfo.nFrameCount;
+		LOG_DEBUG("nAvrageBitRate: %d\n", nAvrageBitRate);
+	}
+	else 
+	{
+		nAvrageBitRate = 0;
+	}
+
+	return nAvrageBitRate;
+}
+
+OMX_ERRORTYPE AudioParserBase::AudioParserBuildSeekTable(OMX_S32 nOffset, OMX_U32 nSamples, OMX_U32 nSamplingRate)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	//static int iCnt = 0;
+	//iCnt ++;
+	//printf("iCnt = %d\n", iCnt);
+	//printf("nSamplingRate = %d\n", nSamplingRate);
+
+	nOneSecondSample += nSamples;
+	if (nSamplingRate)
+		nSampleRate = nSamplingRate;
+	LOG_LOG("nOneSecondSample: %d\t nSamples: %d\n", nOneSecondSample, nSamples);
+	LOG_LOG("Frame bound: %lld\n", nSource2CurPos + nOffset);
+
+	if (nOneSecondSample >= nSamplingRate)
+	{
+		SeekTable[hourctr][minctr][secctr] = nSource2CurPos + nOffset;
+		LOG_LOG("Seek Tabel: %lld\n", nSource2CurPos + nOffset);
+		nOneSecondSample -= nSamplingRate;
+
+		secctr ++;
+		if(secctr == 60)
+		{
+			minctr ++;
+			secctr = 0;
+			if(minctr == 60)
+			{
+				hourctr ++;
+				minctr = 0;
+				if(hourctr >= MAXAUDIODURATIONHOUR)
+				{
+					LOG_ERROR("Audio duration is biger than 1024 hour, can't build seek table.\n");
+					return ret;
+				}
+
+				SeekTable[hourctr] = (OMX_U64 **)FSL_MALLOC(60 * sizeof(OMX_U64 *));
+				if(SeekTable[hourctr] == NULL)
+				{
+					LOG_ERROR("Failed in allocate memory for seek table\n");
+					return OMX_ErrorInsufficientResources;
+				}
+				fsl_osal_memset(SeekTable[hourctr], 0, 60 * sizeof(OMX_U64 *));
+			}
+
+			SeekTable[hourctr][minctr] = (OMX_U64 *)FSL_MALLOC(60 * sizeof(OMX_U64));
+			if(SeekTable[hourctr][minctr] == NULL)
+			{
+				LOG_ERROR("Failed in allocate memory for seek table\n");
+				return OMX_ErrorInsufficientResources;
+			}
+			fsl_osal_memset(SeekTable[hourctr][minctr], 0, 60 * sizeof(OMX_U64));
+		}
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::SetupPortMediaFormat()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+	if (ports[AUDIO_OUTPUT_PORT] == NULL)
+		return ret;
+
+	OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+	sPortDef.nPortIndex = AUDIO_OUTPUT_PORT;
+	ports[AUDIO_OUTPUT_PORT]->GetPortDefinition(&sPortDef);
+
+    OMX_AUDIO_CODINGTYPE CodingType = OMX_AUDIO_CodingUnused;
+
+	CodingType = GetAudioCodingType();
+
+	sPortDef.format.audio.eEncoding = CodingType;
+	ports[AUDIO_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+        nNumAvailAudioStream = 1;
+	SendEvent(OMX_EventPortFormatDetected, AUDIO_OUTPUT_PORT, 0, NULL);
+	SendEvent(OMX_EventPortSettingsChanged, AUDIO_OUTPUT_PORT, 0, NULL);
+
+	sPortDef.nPortIndex = VIDEO_OUTPUT_PORT;
+	ports[VIDEO_OUTPUT_PORT]->GetPortDefinition(&sPortDef);
+        sPortDef.format.video.eCompressionFormat = OMX_VIDEO_CodingMax;
+	ports[VIDEO_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+        nNumAvailVideoStream = 0;
+	SendEvent(OMX_EventPortFormatDetected, VIDEO_OUTPUT_PORT, 0, NULL);
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::InstanceDeInit()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if(pThreadId != NULL) {
+		bStopVBRDurationThread = OMX_TRUE;
+		fsl_osal_thread_destroy(pThreadId);
+	}
+
+	ret = AudioParserInstanceDeInit();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Audio parser instance de-init fail.\n");
+		return ret;
+	}
+
+	if (fileOps.Close(sourceFileHandle, this) != 0)
+	{
+		LOG_ERROR("Can't close input file.\n");
+		return OMX_ErrorUndefined;
+	}
+	sourceFileHandle = NULL;
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::AudioParserInstanceDeInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	// Free seek table.
+	OMX_U32 nSec, nMin, nHour;
+
+	for (nHour=0; nHour<MAXAUDIODURATIONHOUR; nHour++)
+	{
+		if(SeekTable[nHour] != NULL)
+		{
+			for(nMin=0; nMin<60; nMin++)
+				if(SeekTable[nHour][nMin] != NULL)
+					FSL_FREE(SeekTable[nHour][nMin]);
+			FSL_FREE(SeekTable[nHour]);
+		}
+		else
+			break;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioParserBase::AudioParserSetCodecConfig(OMX_BUFFERHEADERTYPE *pOutBuffer)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    return ret;
+}
+ 
+OMX_ERRORTYPE AudioParserBase::GetNextSample(Port *pPort, OMX_BUFFERHEADERTYPE *pOutBuffer)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 nReadLen = pOutBuffer->nAllocLen;
+	OMX_U32 nActuralRead;
+
+	if (bNeedSendCodecConfig == OMX_TRUE)
+	{
+		bNeedSendCodecConfig = OMX_FALSE;
+		AudioParserSetCodecConfig(pOutBuffer);
+	}
+	else
+	{
+		if (nReadPoint + nReadLen > nEndPoint)
+		{
+			nReadLen = nEndPoint - nReadPoint;
+			pOutBuffer->nFlags |= OMX_BUFFERFLAG_EOS;
+			LOG_DEBUG("Audio parser send EOS.\n");
+		}
+
+		nActuralRead = fileOps.Read(sourceFileHandle, pOutBuffer->pBuffer, nReadLen, this);
+
+		if (nActuralRead == 0)
+			pOutBuffer->nFlags |= OMX_BUFFERFLAG_EOS;
+
+		pOutBuffer->nFilledLen = nActuralRead;
+		LOG_DEBUG("Audio parser send length = %d\n", nActuralRead);
+		pOutBuffer->nOffset = 0;
+		if (bSegmentStart == OMX_TRUE)
+		{
+			pOutBuffer->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+			bSegmentStart = OMX_FALSE;
+			LOG_DEBUG("Audio parser ts = %lld\n", sAudioSeekPos);
+			LOG_DEBUG("Audio begin data = %p\n", *((OMX_U32 *)pOutBuffer->pBuffer));
+		}
+		nReadPoint += nActuralRead;
+	}
+
+	pOutBuffer->nTimeStamp = INVALID_TS;
+    if (pOutBuffer->nFlags & OMX_BUFFERFLAG_STARTTIME)
+        pOutBuffer->nTimeStamp = sAudioSeekPos;
+
+	return ret;
+}
+
+OMX_S64 AudioParserBase::nGetTimeStamp(OMX_S64 *pSeekPoint)
+{
+	return sAudioSeekPos;
+}
+
+OMX_U64 AudioParserBase::FrameBound(OMX_U64 nSkip)
+{
+	return nSkip;
+}
+
+OMX_ERRORTYPE AudioParserBase::DoSeek(OMX_U32 nPortIndex, OMX_U32 nSeekFlag)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if (nPortIndex != AUDIO_OUTPUT_PORT)
+	{
+		sActualVideoSeekPos = sAudioSeekPos;
+		return ret;
+	}
+
+	LOG_DEBUG("Seek Position: %lld\t Audio Duration: %lld\n", sAudioSeekPos, nAudioDuration);
+	if (sAudioSeekPos > nAudioDuration)
+	{
+		LOG_WARNING("Seek time is bigger than audio duration.\n");
+		return ret;
+	}
+
+	LOG_DEBUG("bCBR = %d\t bVBRDurationReady = %d\n", bCBR, bVBRDurationReady);
+	OMX_S64 nSeekPoint;
+	if (bCBR == OMX_TRUE || bVBRDurationReady == OMX_FALSE)
+	{
+		OMX_U64 nSkip = (nEndPoint - nBeginPoint) * sAudioSeekPos / nAudioDuration;
+		nSeekPoint = nBeginPoint + FrameBound(nSkip);
+		LOG_DEBUG("Stream Len = %lld\n", (nEndPoint - nBeginPoint));
+		nGetTimeStamp(&nSeekPoint);
+		LOG_DEBUG("After adjust Seek Position: %lld\t Audio Duration: %lld\n", sAudioSeekPos, nAudioDuration);
+	} else if (bTOCSeek == OMX_TRUE) {
+		float percent = (float)sAudioSeekPos * 100 / nAudioDuration;
+		float fx;
+		if( percent <= 0.0f ) {
+			fx = 0.0f;
+		} else if( percent >= 100.0f ) {
+			fx = 256.0f;
+		} else {
+			OMX_S32 a = (OMX_S32)percent;
+			float fa, fb;
+			if ( a == 0 ) {
+				fa = 0.0f;
+			} else {
+				fa = (float)FrameInfo.FrameInfo.TOC[a];
+			}
+			if ( a < 99 ) {
+				fb = (float)FrameInfo.FrameInfo.TOC[a+1];
+			} else {
+				fb = 256.0f;
+			}
+			fx = fa + (fb-fa)*(percent-a);
+		}
+		nSeekPoint = nBeginPoint + (OMX_S32)((1.0f/256.0f)*fx*FrameInfo.FrameInfo.total_bytes);
+		LOG_DEBUG("Seek Point = %lld\n", nSeekPoint);
+	} else {
+		OMX_U32 nSec = (sAudioSeekPos / OMX_TICKS_PER_SECOND) % 60;
+		OMX_U32 nMin = (sAudioSeekPos / (OMX_TICKS_PER_SECOND * 60)) % 60;
+		OMX_U32 nHour = sAudioSeekPos / (OMX_TICKS_PER_SECOND * 60) / 60;
+
+		nSeekPoint = SeekTable[nHour][nMin][nSec];
+		LOG_DEBUG("Seek Point = %lld\n", nSeekPoint);
+	}
+
+	fileOps.Seek(sourceFileHandle, nSeekPoint, SEEK_SET, this);
+	nReadPoint = nSeekPoint;
+	bSegmentStart = OMX_TRUE;
+	sActualAudioSeekPos = sAudioSeekPos;
+	sVideoSeekPos = sAudioSeekPos;
+	sActualVideoSeekPos = sAudioSeekPos;
+
+	return OMX_ErrorNone;
+}
+
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioParserBase.h b/OpenMAXIL/src/component/common/AudioParserBase.h
new file mode 100755
index 0000000..11ce29f
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioParserBase.h
@@ -0,0 +1,106 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file AudioParserBase.h
+ *  @brief Class definition of AudioParserBase Component
+ *  @ingroup AudioParserBase
+ */
+
+#ifndef AudioParserBase_h
+#define AudioParserBase_h
+
+#include "ComponentBase.h"
+#include "Parser.h"
+#include "AudioCoreParser.h"
+#ifndef ANDROID_BUILD
+#include "id3_parser/id3_parse.h"
+#endif
+#define MAXAUDIODURATIONHOUR (1024)
+#define AUDIO_PARSER_READ_SIZE (16*1024)
+#define AUDIO_PARSER_SEGMENT_SIZE (32*1024)
+
+#define PARSERAUDIO_HEAD 0
+#define PARSERAUDIO_MIDDLE 1
+#define PARSERAUDIO_TAIL 2
+#define PARSERAUDIO_BEGINPOINT 3
+#define PARSERAUDIO_VBRDURATION 4
+
+class AudioParserBase : public Parser {
+	public:
+		OMX_ERRORTYPE ParserCalculateVBRDuration(); 
+        OMX_ERRORTYPE InstanceInit();
+        OMX_ERRORTYPE InstanceDeInit();
+	protected:
+		OMX_BOOL bNeedSendCodecConfig;
+		AUDIO_FILE_INFO FileInfo;
+		OMX_U64 nEndPoint;
+		OMX_U64 nFileSize;
+		AUDIO_PARSERRETURNTYPE (*ParserFileHeader)(AUDIO_FILE_INFO *pFileInfo, \
+				uint8 *pBuffer, uint32 nBufferLen);
+		AUDIO_PARSERRETURNTYPE (*ParserFrame)(AUDIO_FRAME_INFO *pFrameInfo, \
+				uint8 *pBuffer, uint32 nBufferLen);
+        FslFileHandle sourceFileHandle;
+	private:
+        virtual OMX_ERRORTYPE GetCoreParser() = 0;
+		OMX_ERRORTYPE AudioParserInstanceInit();
+		OMX_ERRORTYPE ParserID3Tag();
+		OMX_ERRORTYPE AudioParserFileHeader();
+		OMX_ERRORTYPE ParserOneSegmentAudio();
+		OMX_ERRORTYPE ParserThreeSegmentAudio();
+		OMX_ERRORTYPE ParserFindBeginPoint();
+		OMX_ERRORTYPE AudioParserInstanceDeInit();
+		virtual OMX_AUDIO_CODINGTYPE GetAudioCodingType() = 0;
+		OMX_ERRORTYPE SetupPortMediaFormat();
+		virtual OMX_ERRORTYPE AudioParserSetCodecConfig(OMX_BUFFERHEADERTYPE *pOutBuffer);
+        OMX_ERRORTYPE GetNextSample(Port *pPort,OMX_BUFFERHEADERTYPE *pOutBuffer);
+		virtual OMX_U64 FrameBound(OMX_U64 nSkip);
+		virtual OMX_S64 nGetTimeStamp(OMX_S64 *pSeekPoint);
+		OMX_ERRORTYPE DoSeek(OMX_U32 nPortIndex, OMX_U32 nSeekFlag);
+ 		OMX_ERRORTYPE ParserAudioFrame(OMX_U8 *pBuffer, OMX_U32 nActuralRead, \
+				OMX_U32 nSegmentCnt);
+ 		OMX_ERRORTYPE ParserAudioFrameOverlap(OMX_U8 *pBuffer, OMX_U32 nActuralRead, \
+				OMX_U32 nSegmentCnt);
+		OMX_U32 GetAvrageBitRate();
+		OMX_U8 *AudioParserGetBuffer(OMX_U32 nBufferSize);
+		OMX_ERRORTYPE AudioParserFreeBuffer(OMX_U8 *pBuffer);
+		OMX_ERRORTYPE AudioParserBuildSeekTable(OMX_S32 nOffset, OMX_U32 nSamples, \
+				OMX_U32 nSamplingRate);
+
+		OMX_U64 nBeginPoint;
+		OMX_U64 nBeginPointOffset;
+		OMX_U64 nReadPoint;
+		OMX_BOOL bCBR;
+		OMX_BOOL bVBRDurationReady;
+		OMX_BOOL bBeginPointFounded;
+		OMX_U32 nAvrageBitRate;
+		OMX_U8 *pTmpBufferPtr;
+		OMX_U32 nOverlap;
+		OMX_U64 nTotalBitRate;
+		OMX_U32 nFrameCount;
+		OMX_U64 **SeekTable[MAXAUDIODURATIONHOUR];
+		OMX_S64 nSource2CurPos;
+		OMX_U32 secctr;
+		OMX_U32 minctr;
+		OMX_U32 hourctr;
+		OMX_U32 nOneSecondSample;
+        OMX_U32 nSampleRate;
+		AUDIO_FRAME_INFO FrameInfo;
+		fsl_osal_ptr pThreadId;
+		OMX_BOOL bStopVBRDurationThread;
+		OMX_BOOL bSegmentStart;
+		OMX_BOOL bTOCSeek;
+#ifndef ANDROID_BUILD
+		meta_data_v1 info;
+		meta_data_v2 info_v2; 
+#endif
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioRender.cpp b/OpenMAXIL/src/component/common/AudioRender.cpp
new file mode 100755
index 0000000..ea33668
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioRender.cpp
@@ -0,0 +1,1030 @@
+/**
+ *  Copyright (c) 2009-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+ 
+#include "AudioRender.h"
+ 
+#define AUDIO_INTERVAL_THRESHOLD 1000000
+
+#define CHECK_STRUCT(ps,t,r) \
+    do { \
+        OMX_CHECK_STRUCT(ps, t, r); \
+        if(r != OMX_ErrorNone) \
+        break; \
+        if(ps->nPortIndex != IN_PORT) { \
+            r = OMX_ErrorBadPortIndex; \
+            break; \
+        } \
+    } while(0);
+
+OMX_ERRORTYPE AudioRender::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = IN_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainAudio;
+    sPortDef.format.audio.eEncoding = OMX_AUDIO_CodingPCM;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 3;
+    sPortDef.nBufferSize = 1024;
+    ret = ports[IN_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for in port failed.\n");
+        return ret;
+    }
+
+    sPortDef.nPortIndex = CLK_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainOther;
+    sPortDef.format.other.eFormat = OMX_OTHER_FormatTime;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_FALSE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 1;
+    sPortDef.nBufferSize = sizeof(OMX_TIME_MEDIATIMETYPE);
+    ret = ports[CLK_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for clk port failed.\n");
+        return ret;
+    }
+
+	OMX_INIT_STRUCT(&PcmMode, OMX_AUDIO_PARAM_PCMMODETYPE);
+
+	PcmMode.nPortIndex = IN_PORT;
+	PcmMode.nChannels = 2;
+	PcmMode.nSamplingRate = 44100;
+	PcmMode.nBitPerSample = 16;
+	PcmMode.bInterleaved = OMX_TRUE;
+	PcmMode.eNumData = OMX_NumericalDataSigned;
+	PcmMode.ePCMMode = OMX_AUDIO_PCMModeLinear;
+	PcmMode.eEndian = OMX_EndianLittle;
+	PcmMode.eChannelMapping[0] = OMX_AUDIO_ChannelNone;
+
+	OMX_INIT_STRUCT(&Volume, OMX_AUDIO_CONFIG_VOLUMETYPE);
+
+	Volume.bLinear = OMX_TRUE;
+	Volume.sVolume.nValue = 100;
+	Volume.sVolume.nMin = 0;
+	Volume.sVolume.nMax = 100;
+
+	OMX_INIT_STRUCT(&Mute, OMX_AUDIO_CONFIG_MUTETYPE);
+
+	Mute.bMute = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&StartTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+	StartTime.nTimestamp = 0;
+	OMX_INIT_STRUCT(&ReferTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+	ReferTime.nTimestamp = 0;
+ 
+	nWriteOutLen = 0;
+	nPeriodSize = 0;
+	nSampleSize = 0;
+	nAudioDataWriteThreshold = 0;
+	nFadeInFadeOutProcessLen = 0;
+	bClockRuningFlag = OMX_FALSE;
+	bHeardwareError = OMX_FALSE;
+	bReceivedEOS = OMX_FALSE;
+	bSendEOS = OMX_FALSE;
+    bLiveMode = OMX_FALSE;
+	CurrentTS = 0;
+	nDiscardData = 0;
+	nAddZeros = 0;
+	nTotalConsumeredLen = 0;
+	nTotalReceivedLen = 0;
+	nClockScale = Q16_SHIFT;
+	nDNSeScale = Q16_SHIFT;
+
+	pInBufferHdr = NULL;
+	pInBufferHdrBak = NULL;
+       audioIntervalThreshold = AUDIO_INTERVAL_THRESHOLD;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioRender::DeInitComponent()
+{
+	if (pInBufferHdrBak)
+	{
+		FSL_FREE(pInBufferHdrBak->pBuffer);
+		FSL_FREE(pInBufferHdrBak);
+	}
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::InstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::InstanceDeInit()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	DoExec2Idle();
+
+ 	CloseDevice();
+
+	AudioRenderRingBuffer.BufferFree();
+	TS_Manager.Free();
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+		case OMX_IndexParamAudioPcm:
+            {
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmMode;
+                pPcmMode = (OMX_AUDIO_PARAM_PCMMODETYPE*)pStructure;
+                CHECK_STRUCT(pPcmMode, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+				fsl_osal_memcpy(pPcmMode, &PcmMode,	sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
+			}
+			break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch ((int)nParamIndex) {
+        case OMX_IndexParamAudioPcm:
+            {
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmMode;
+                pPcmMode = (OMX_AUDIO_PARAM_PCMMODETYPE*)pStructure;
+                CHECK_STRUCT(pPcmMode, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+				fsl_osal_memcpy(&PcmMode, pPcmMode, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
+				LOG_INFO("Audio render samplerate: %d, channels: %d, bitspersample: %d\n", PcmMode.nSamplingRate, PcmMode.nChannels, PcmMode.nBitPerSample);
+
+				TS_Manager.SetOneByteTime(OMX_TICKS_PER_SECOND/PcmMode.nChannels/(PcmMode.nBitPerSample>>3)/PcmMode.nSamplingRate); 
+				LOG_DEBUG("Audio render samplerate: %d\n", PcmMode.nSamplingRate);
+				LOG_DEBUG("Audio render channels: %d\n", PcmMode.nChannels);
+				LOG_DEBUG("Audio render bitspersample: %d\n", PcmMode.nBitPerSample);
+			}
+            break;
+        case OMX_IndexParamAudioSink:
+            SelectDevice(pStructure);
+            break;
+		case OMX_IndexParamAudioRenderMode:
+			 {
+				 OMX_CONFIG_BOOLEANTYPE *pRenderMode;
+				 pRenderMode = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+				 OMX_CHECK_STRUCT(pRenderMode, OMX_CONFIG_BOOLEANTYPE, ret);
+                 bLiveMode = pRenderMode->bEnabled;
+			 }
+			 break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::GetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigAudioVolume:
+            {
+                OMX_AUDIO_CONFIG_VOLUMETYPE *pVolume;
+                pVolume = (OMX_AUDIO_CONFIG_VOLUMETYPE*)pStructure;
+                CHECK_STRUCT(pVolume, OMX_AUDIO_CONFIG_VOLUMETYPE, ret);
+				fsl_osal_memcpy(pVolume, &Volume, sizeof(OMX_AUDIO_CONFIG_VOLUMETYPE));
+            }
+            break;
+        case OMX_IndexConfigAudioMute:
+             {
+                OMX_AUDIO_CONFIG_MUTETYPE *pMute;
+                pMute = (OMX_AUDIO_CONFIG_MUTETYPE*)pStructure;
+                CHECK_STRUCT(pMute, OMX_AUDIO_CONFIG_MUTETYPE, ret);
+				fsl_osal_memcpy(pMute, &Mute, sizeof(OMX_AUDIO_CONFIG_MUTETYPE));
+            }
+            break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::SetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigAudioVolume:
+            {
+                OMX_AUDIO_CONFIG_VOLUMETYPE *pVolume;
+                pVolume = (OMX_AUDIO_CONFIG_VOLUMETYPE*)pStructure;
+                CHECK_STRUCT(pVolume, OMX_AUDIO_CONFIG_VOLUMETYPE, ret);
+				fsl_osal_memcpy(&Volume, pVolume, sizeof(OMX_AUDIO_CONFIG_VOLUMETYPE));
+            }
+            break;
+        case OMX_IndexConfigAudioMute:
+             {
+                OMX_AUDIO_CONFIG_MUTETYPE *pMute;
+                pMute = (OMX_AUDIO_CONFIG_MUTETYPE*)pStructure;
+                CHECK_STRUCT(pMute, OMX_AUDIO_CONFIG_MUTETYPE, ret);
+				fsl_osal_memcpy(&Mute, pMute, sizeof(OMX_AUDIO_CONFIG_MUTETYPE));
+            }
+            break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+ 
+OMX_ERRORTYPE AudioRender::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(bHeardwareError == OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+	LOG_LOG("Input port buffer number = %d\t pInBufferHdr = %p\n", ports[IN_PORT]->BufferNum(), pInBufferHdr);
+    if(pInBufferHdr == NULL && ports[IN_PORT]->BufferNum() > 0) {
+		ports[IN_PORT]->GetBuffer(&pInBufferHdr);
+		if(pInBufferHdr != NULL) {
+			ret = ProcessInputBufferFlag();
+			if (ret != OMX_ErrorNone)
+			{
+				LOG_ERROR("Process input buffer flag fail.\n");
+				return ret;
+			}
+		}
+	}
+
+	if(pInBufferHdr != NULL) 
+	{
+		ret = ProcessInputDataBuffer();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Process input data buffer fail.\n");
+			return ret;
+		}
+	}
+
+	LOG_LOG("Audio Ring buffer len: %d\n", AudioRenderRingBuffer.AudioDataLen());
+    if((AudioRenderRingBuffer.AudioDataLen() < nAudioDataWriteThreshold 
+			&& bReceivedEOS == OMX_FALSE)
+			&& (pInBufferHdr == NULL && ports[IN_PORT]->BufferNum() == 0))
+        return OMX_ErrorNoMore;
+
+    if((bReceivedEOS == OMX_TRUE && AudioRenderRingBuffer.AudioDataLen() == 0))
+    {
+        if(ports[IN_PORT]->BufferNum() > 0)
+            return OMX_ErrorNone;
+        else
+		{
+			if (bSendEOS == OMX_FALSE)
+			{
+				LOG_DEBUG("Audio render send EOS\n");
+				SendEvent(OMX_EventBufferFlag, IN_PORT, OMX_BUFFERFLAG_EOS, NULL);
+				bSendEOS = OMX_TRUE;
+			}
+			return OMX_ErrorNoMore;
+		}
+    }
+
+	if((bClockRuningFlag == OMX_TRUE && ports[CLK_PORT]->IsEnabled() == OMX_TRUE)
+			|| ports[CLK_PORT]->IsEnabled() == OMX_FALSE) {
+		ret = RenderData();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Render audio data fail.\n");
+			return ret;
+		}
+	}
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::ProcessInputBufferFlag()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	audioIntervalThreshold = AUDIO_INTERVAL_THRESHOLD;
+
+	if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME)
+	{
+		LOG_DEBUG("Audio render received STARTTIME flag.\n");
+		OMX_TIME_CONFIG_CLOCKSTATETYPE ClockState;
+		OMX_INIT_STRUCT(&ClockState, OMX_TIME_CONFIG_CLOCKSTATETYPE);
+		ClockGetConfig(OMX_IndexConfigTimeClockState, &ClockState);
+		AudioRenderFadeInFadeOut.SetMode(FADEIN);
+		nWriteOutLen = nPeriodSize * nSampleSize;
+		if (ClockState.eState == OMX_TIME_ClockStateRunning)
+		{
+			OMX_TIME_CONFIG_TIMESTAMPTYPE sCur;
+			OMX_INIT_STRUCT(&sCur, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+			ClockGetConfig(OMX_IndexConfigTimeCurrentMediaTime, &sCur);
+
+			CurrentTS = sCur.nTimestamp;
+			StartTime.nTimestamp = CurrentTS;
+			LOG_DEBUG("CurrentTS = %lld\n", CurrentTS);
+			audioIntervalThreshold = 0; // fix for a/v sync lost after track select: discard all overdue data in SyncTS() when switching track, prevent data before seek point from coming into ringbuffer
+
+			bClockRuningFlag = OMX_TRUE;
+		}
+		else
+		{
+			StartTime.nTimestamp = pInBufferHdr->nTimeStamp;
+			CurrentTS = pInBufferHdr->nTimeStamp;
+			bClockRuningFlag = OMX_FALSE;
+			ClockSetConfig(OMX_IndexConfigTimeClientStartTime, &StartTime);
+			LOG_DEBUG("Audio render set start time: %lld\n", StartTime.nTimestamp);
+		}
+		nAddZeros = 0;
+		nDiscardData = 0;
+		bReceivedEOS = OMX_FALSE;
+		bSendEOS = OMX_FALSE;
+		nTotalConsumeredLen = 0;
+        nTotalReceivedLen = 0;
+        ResetDevice();
+	}
+
+	if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_EOS)
+	{
+		bReceivedEOS = OMX_TRUE;
+		LOG_DEBUG("Audio render received EOS.\n");
+	}
+
+	if (bLiveMode == OMX_TRUE) {
+        TS_Manager.TS_Add(pInBufferHdr->nTimeStamp, pInBufferHdr->nFilledLen - \
+                pInBufferHdr->nOffset);
+        if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME) {
+            TS_Manager.Consumered(0);
+            TS_Manager.TS_SetIncrease(0); 
+        }
+	} else {
+			SyncTS(pInBufferHdr->nTimeStamp);
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioRender::ClockGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+        return OMX_ErrorNoMore;
+
+	switch (nParamIndex) {
+		case OMX_IndexConfigTimeClockState:
+			{
+				OMX_TIME_CONFIG_CLOCKSTATETYPE *pClockState = (OMX_TIME_CONFIG_CLOCKSTATETYPE *)pStructure;
+				ret = OMX_GetConfig(hClockComp, OMX_IndexConfigTimeClockState, pClockState);
+			}
+			break;
+		case OMX_IndexConfigTimeCurrentMediaTime:
+			{
+				OMX_TIME_CONFIG_TIMESTAMPTYPE *pCur = (OMX_TIME_CONFIG_TIMESTAMPTYPE *)pStructure;
+				pCur->nPortIndex = TunnelInfo.nTunneledPort;
+				ret = OMX_GetConfig(hClockComp, OMX_IndexConfigTimeCurrentMediaTime, pCur);
+			}
+			break;
+		default :
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioRender::ClockSetConfig(OMX_INDEXTYPE nParamIndex, OMX_TIME_CONFIG_TIMESTAMPTYPE *pTimeStamp)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+        return OMX_ErrorNoMore;
+
+	pTimeStamp->nPortIndex = TunnelInfo.nTunneledPort;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigTimeClientStartTime:
+			ret = OMX_SetConfig(hClockComp, OMX_IndexConfigTimeClientStartTime,pTimeStamp);
+            break;
+        case OMX_IndexConfigTimeCurrentAudioReference:
+			ret = OMX_SetConfig(hClockComp, OMX_IndexConfigTimeCurrentAudioReference,pTimeStamp);
+            break;
+        default :
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioRender::SyncTS(OMX_TICKS nTimeStamp)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    LOG_DEBUG("CurrentTS = %lld\t nTimeStamp = %lld nFilledLen: %d\n", \
+            CurrentTS, nTimeStamp, pInBufferHdr->nFilledLen);
+
+    if (nTimeStamp < 0) {
+        nTotalReceivedLen += pInBufferHdr->nFilledLen;
+        CurrentTS = StartTime.nTimestamp + nTotalReceivedLen * \
+                    OMX_TICKS_PER_SECOND / PcmMode.nChannels / \
+                    PcmMode.nBitPerSample * 8 / PcmMode.nSamplingRate;
+        return ret;
+    }
+
+	LOG_DEBUG("Input buffer data len: %d\n", pInBufferHdr->nFilledLen);
+    if (CurrentTS > nTimeStamp) {
+		LOG_DEBUG("Audio TS jetter: %lld\n", CurrentTS - nTimeStamp);
+		if (CurrentTS - nTimeStamp > audioIntervalThreshold) {
+            LOG_DEBUG("CurrentTS = %lld\t nTimeStamp = %lld\n", CurrentTS, \
+                    nTimeStamp);
+            nDiscardData = (CurrentTS - nTimeStamp) * PcmMode.nSamplingRate / \
+                    OMX_TICKS_PER_SECOND * nSampleSize;
+            nTotalReceivedLen -= nDiscardData;
+            LOG_ERROR("Need discard audio data.\n");
+        }
+	}
+	else if (CurrentTS < nTimeStamp) {
+		LOG_DEBUG("Audio TS jetter: %lld\n", nTimeStamp - CurrentTS);
+		if (nTimeStamp - CurrentTS > audioIntervalThreshold) {
+            nAddZeros = (nTimeStamp - CurrentTS) * PcmMode.nSamplingRate / \
+                        OMX_TICKS_PER_SECOND * nSampleSize;
+            LOG_DEBUG("CurrentTS = %lld\t nTimeStamp = %lld\n", CurrentTS, \
+                    nTimeStamp);
+            nTotalReceivedLen += nAddZeros;
+            LOG_ERROR("Need add zeros in audio render.\n");
+        }
+	}
+
+    nTotalReceivedLen += pInBufferHdr->nFilledLen;
+    LOG_DEBUG("StartTime: %lld nTotalReceivedLen: %lld\n", StartTime.nTimestamp, \
+            nTotalReceivedLen);
+    CurrentTS = StartTime.nTimestamp + nTotalReceivedLen * \
+                OMX_TICKS_PER_SECOND / PcmMode.nChannels / \
+                PcmMode.nBitPerSample * 8 / PcmMode.nSamplingRate;
+	return ret;
+}
+
+OMX_ERRORTYPE AudioRender::ProcessInputDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 nActuralLen;
+
+	if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME)
+	{
+		// need return for mark buffer event.
+		if (pInBufferHdrBak == NULL)
+		{
+			OMX_PTR ptr = NULL;
+			OMX_U32 nSize;
+
+			nSize = sizeof(OMX_BUFFERHEADERTYPE);
+			ptr = FSL_MALLOC(nSize);
+			if(ptr == NULL) {
+				LOG_ERROR("Allocate memory failed, size: %d\n", nSize);
+				return OMX_ErrorInsufficientResources;
+			}
+
+			fsl_osal_memset(ptr, 0, nSize);
+			pInBufferHdrBak = (OMX_BUFFERHEADERTYPE *)ptr;
+
+			nSize = pInBufferHdr->nAllocLen;
+			ptr = FSL_MALLOC(nSize);
+			if(ptr == NULL) {
+				LOG_ERROR("Allocate memory failed, size: %d\n", nSize);
+				return OMX_ErrorInsufficientResources;
+			}
+
+			fsl_osal_memset(ptr, 0, nSize);
+			pInBufferHdrBak->pBuffer = (OMX_U8 *)ptr;
+		}
+
+		fsl_osal_memcpy(pInBufferHdrBak->pBuffer, pInBufferHdr->pBuffer, pInBufferHdr->nFilledLen);
+
+		pInBufferHdrBak->nFilledLen = pInBufferHdr->nFilledLen;
+		pInBufferHdrBak->nOffset = pInBufferHdr->nOffset;
+
+		pInBufferHdr->nFilledLen = 0;
+		ports[IN_PORT]->SendBuffer(pInBufferHdr);
+		pInBufferHdr = NULL;
+		LOG_DEBUG("pInBufferHdrBak: %p Len: %d\n", pInBufferHdrBak, pInBufferHdrBak->nFilledLen);
+	}
+
+	if (nAddZeros != 0 && pInBufferHdr)
+	{
+		LOG_DEBUG("Add zeros to ring buffer.\n");
+		AudioRenderRingBuffer.BufferAddZeros(nAddZeros, &nActuralLen);
+		nAddZeros -= nActuralLen;
+		if (nAddZeros != 0)
+		{
+			return ret;
+		}
+	}
+
+	if (nDiscardData != 0 && pInBufferHdr)
+	{ 
+		if (nDiscardData > pInBufferHdr->nFilledLen)
+		{
+			nDiscardData -= pInBufferHdr->nFilledLen;
+			LOG_DEBUG("Discard audio data: %d\n", pInBufferHdr->nFilledLen);
+			pInBufferHdr->nFilledLen = 0;
+		}
+		else
+		{
+			pInBufferHdr->nFilledLen -= nDiscardData;
+			LOG_DEBUG("Discard audio data: %d\n", nDiscardData);
+			nDiscardData = 0;
+		}
+	}
+
+	if ((bClockRuningFlag == OMX_TRUE && ports[CLK_PORT]->IsEnabled() == OMX_TRUE)
+			|| ports[CLK_PORT]->IsEnabled() == OMX_FALSE)
+	{
+		/** Process audio data */
+		if (pInBufferHdrBak && pInBufferHdrBak->nFilledLen)
+		{
+			LOG_DEBUG("Process pInBufferHdrBak: %p Len: %d\n", pInBufferHdrBak, pInBufferHdrBak->nFilledLen);
+			AudioRenderRingBuffer.BufferAdd(pInBufferHdrBak->pBuffer + pInBufferHdrBak->nOffset, 
+					pInBufferHdrBak->nFilledLen,
+					&nActuralLen);
+
+			if (nActuralLen < pInBufferHdrBak->nFilledLen)
+			{
+				pInBufferHdrBak->nOffset += nActuralLen;
+				pInBufferHdrBak->nFilledLen -= nActuralLen;
+			}
+			else
+			{
+				pInBufferHdrBak->nFilledLen = 0;
+			}
+
+		}
+
+		if (pInBufferHdr)
+		{
+			AudioRenderRingBuffer.BufferAdd(pInBufferHdr->pBuffer + pInBufferHdr->nOffset, 
+					pInBufferHdr->nFilledLen,
+					&nActuralLen);
+
+			if (nActuralLen < pInBufferHdr->nFilledLen)
+			{
+				pInBufferHdr->nOffset += nActuralLen;
+				pInBufferHdr->nFilledLen -= nActuralLen;
+			}
+			else
+			{
+				pInBufferHdr->nFilledLen = 0;
+				ports[IN_PORT]->SendBuffer(pInBufferHdr);
+				pInBufferHdr = NULL;
+			}
+		}
+	}
+	
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::RenderData()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if (AudioRenderRingBuffer.AudioDataLen() < nAudioDataWriteThreshold && bReceivedEOS == OMX_FALSE)
+	{
+		LOG_DEBUG("Not engough audio data for render.\n");
+		return OMX_ErrorNone;
+	}
+
+	ret = RenderPeriod();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Render period fail.\n");
+		return ret;
+	}
+
+	if (bReceivedEOS == OMX_TRUE && AudioRenderRingBuffer.AudioDataLen() == 0)
+	{
+		LOG_DEBUG("Audio render send EOS\n");
+		if (bSendEOS == OMX_FALSE)
+		{
+			SendEvent(OMX_EventBufferFlag, IN_PORT, OMX_BUFFERFLAG_EOS, NULL);
+			bSendEOS = OMX_TRUE;
+		}
+	}
+
+    return OMX_ErrorNone;
+} 
+
+OMX_ERRORTYPE AudioRender::RenderPeriod()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U8 *pBuffer;
+	OMX_U32 nActuralLen;
+	OMX_U32 nDelayLen;
+	OMX_S64 PlayingTime;
+
+	AudioRenderRingBuffer.BufferGet(&pBuffer, nWriteOutLen, &nActuralLen);
+  
+	LOG_LOG("nWriteOutLen = %d\t nActuralLen = %d\n", nWriteOutLen, nActuralLen);
+	AudioRenderFadeInFadeOut.Process(pBuffer, nActuralLen);
+  
+	ret = WriteDevice(pBuffer, nActuralLen);
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Can't write audio data to device.\n");
+		return ret;
+	}
+
+	AudioRenderRingBuffer.BufferConsumered(nActuralLen);
+	if (bLiveMode == OMX_TRUE) {
+        TS_Manager.Consumered(nActuralLen);
+    }
+
+	DeviceDelay(&nDelayLen);
+	if (bLiveMode == OMX_TRUE) {
+		OMX_TICKS TS_PerFrame;
+		TS_PerFrame = (OMX_U64)nActuralLen/nSampleSize*OMX_TICKS_PER_SECOND/PcmMode.nSamplingRate;
+		TS_Manager.TS_SetIncrease(TS_PerFrame); 
+
+        if (bLiveMode == OMX_TRUE) {
+            TS_Manager.TS_Get(&PlayingTime);
+        }
+
+		PlayingTime = (PlayingTime - (nDelayLen/nSampleSize * OMX_TICKS_PER_SECOND) / PcmMode.nSamplingRate) * ((float)nDNSeScale / Q16_SHIFT);
+	} else {
+		nTotalConsumeredLen += nActuralLen;
+		PlayingTime = StartTime.nTimestamp + ((nTotalConsumeredLen - nDelayLen)/nSampleSize * OMX_TICKS_PER_SECOND) / PcmMode.nSamplingRate * ((float)nDNSeScale / Q16_SHIFT);
+	}
+
+	ReferTime.nTimestamp = PlayingTime;
+	LOG_LOG("Audio render total render data: %lld\n", nTotalConsumeredLen);
+	LOG_LOG("Set reference time to clock: %lld\n", PlayingTime);
+	ClockSetConfig(OMX_IndexConfigTimeCurrentAudioReference, &ReferTime);
+	LOG_LOG("RenderPeriod finished.\n");
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::SelectDevice(OMX_PTR device)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::ProcessClkBuffer()
+{
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+        return OMX_ErrorNoMore;
+
+    if(ports[CLK_PORT]->BufferNum() == 0)
+		return OMX_ErrorNoMore;
+
+	OMX_BUFFERHEADERTYPE *pClockBufferHdr;
+	ports[CLK_PORT]->GetBuffer(&pClockBufferHdr);
+	OMX_TIME_MEDIATIMETYPE *pTimeBuffer = (OMX_TIME_MEDIATIMETYPE*) pClockBufferHdr->pBuffer;
+
+	if ((pTimeBuffer->eUpdateType == OMX_TIME_UpdateClockStateChanged)
+		&& (pTimeBuffer->eState == OMX_TIME_ClockStateRunning))
+	{
+		OMX_ERRORTYPE ret = OMX_ErrorNone;
+		bClockRuningFlag = OMX_TRUE;
+		LOG_DEBUG("Audio start time: %lld Clock return start time: %lld\n", StartTime.nTimestamp, pTimeBuffer->nMediaTimestamp);
+		if (StartTime.nTimestamp > pTimeBuffer->nMediaTimestamp)
+		{
+			/** Add zeros at ring buffer header */
+			nAddZeros = (StartTime.nTimestamp - pTimeBuffer->nMediaTimestamp) * PcmMode.nSamplingRate / OMX_TICKS_PER_SECOND * nSampleSize;
+            nTotalReceivedLen += nAddZeros;
+			StartTime.nTimestamp = pTimeBuffer->nMediaTimestamp;
+		}
+		else if (StartTime.nTimestamp < pTimeBuffer->nMediaTimestamp)
+		{
+			/** Discard audio data at ring buffer header */
+
+		}
+ 
+		ret = RenderData();
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Render audio data fail.\n");
+			return ret;
+		}
+
+	}
+	else if (pTimeBuffer->eUpdateType == OMX_TIME_UpdateScaleChanged)
+	{
+		OMX_U32 nClockScalePre = nClockScale;
+		nClockScale = pTimeBuffer->xScale;
+		LOG_DEBUG("nClockScale = %d\n", nClockScale);
+		if (nClockScale <= (OMX_S32)(MAX_RATE * Q16_SHIFT)
+				&& nClockScale >= (OMX_S32)(MIN_RATE * Q16_SHIFT))
+		{
+			OMX_ERRORTYPE ret = OMX_ErrorNone;
+			if (nClockScalePre <= (OMX_S32)(MAX_RATE * Q16_SHIFT)
+					&& nClockScalePre >= (OMX_S32)(MIN_RATE * Q16_SHIFT))
+			{
+				ret = DrainDevice();
+				if (ret != OMX_ErrorNone)
+				{
+					LOG_ERROR("Drain fail.\n");
+					return ret;
+				}
+			}
+
+			ret = SetDevice();
+			if(ret != OMX_ErrorNone) {
+				LOG_WARNING("Set device fail.\n");
+				ports[CLK_PORT]->SendBuffer(pClockBufferHdr);
+				bHeardwareError = OMX_TRUE;
+				SendEvent(OMX_EventError, ret, 0, NULL);
+				return ret;
+			}
+
+			nWriteOutLen = nPeriodSize * nSampleSize;
+			nAudioDataWriteThreshold = nFadeInFadeOutProcessLen + nWriteOutLen;
+			AudioRenderFadeInFadeOut.Create(PcmMode.nChannels, PcmMode.nSamplingRate, \
+					PcmMode.nBitPerSample, nFadeInFadeOutProcessLen, 2);
+		}
+	}
+	else
+	{
+		LOG_WARNING("Unknow clock buffer.\n");
+	}
+
+	ports[CLK_PORT]->SendBuffer(pClockBufferHdr);
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::DoLoaded2Idle()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = OpenDevice();
+    if(ret != OMX_ErrorNone) {
+        CloseDevice();
+		bHeardwareError = OMX_TRUE;
+        SendEvent(OMX_EventError, ret, 0, NULL);
+        return ret;
+    }
+
+    ret = SetDevice();
+    if(ret != OMX_ErrorNone) {
+        LOG_WARNING("Set device fail.\n");
+		bHeardwareError = OMX_TRUE;
+		SendEvent(OMX_EventError, ret, 0, NULL);
+        return ret;
+    }
+
+	nWriteOutLen = nPeriodSize * nSampleSize;
+	nAudioDataWriteThreshold = nFadeInFadeOutProcessLen + nWriteOutLen;
+	RINGBUFFER_ERRORTYPE BufferRet = RINGBUFFER_SUCCESS;
+	/** As speed change, ring buffer should use the largest writen threshold */
+	OMX_U32 nRingBufferSize = (OMX_U32)(nAudioDataWriteThreshold * MAX_RATE);
+	LOG_DEBUG("Aurio render nRingBufferSize = %d\n", nRingBufferSize);
+	BufferRet = AudioRenderRingBuffer.BufferCreate(nRingBufferSize);
+	if (BufferRet != RINGBUFFER_SUCCESS)
+	{
+		LOG_ERROR("Create ring buffer fail.\n");
+		return OMX_ErrorInsufficientResources;
+	} 
+
+    AUDIO_TS_MANAGER_ERRORTYPE Ret = AUDIO_TS_MANAGER_SUCCESS;
+    Ret = TS_Manager.Create();
+    if (Ret != AUDIO_TS_MANAGER_SUCCESS)
+    {
+        LOG_ERROR("Create audio ts manager fail.\n");
+        return OMX_ErrorInsufficientResources;
+    }
+
+	FADEINFADEOUT_ERRORTYPE FadeRet = FADEINFADEOUT_SUCCESS;
+	FadeRet = AudioRenderFadeInFadeOut.Create(PcmMode.nChannels, PcmMode.nSamplingRate, \
+			PcmMode.nBitPerSample, nFadeInFadeOutProcessLen, 1);
+	if (FadeRet != FADEINFADEOUT_SUCCESS)
+	{
+		LOG_ERROR("Create fade in fade out process fail.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::DoIdle2Loaded()
+{
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::DoExec2Pause()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    LOG_DEBUG("AudioRender::DoExec2Pause");
+	if (AudioRenderRingBuffer.AudioDataLen() == 0 || bHeardwareError == OMX_TRUE)
+	{
+		LOG_DEBUG("No audio data for Fade out process.\n");
+		return OMX_ErrorNone;
+	}
+
+	AudioRenderFadeInFadeOut.SetMode(FADEOUT);
+	nWriteOutLen = nFadeInFadeOutProcessLen;
+
+	ret = RenderPeriod();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Render period fail(E2P).\n");
+		return ret;
+	}
+
+	ret = DrainDevice();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Drain fail.\n");
+		return ret;
+	}
+
+	LOG_DEBUG("Fade out over.\n");
+
+	OMX_S64 PlayingTime;
+	if (bLiveMode == OMX_TRUE) {
+        TS_Manager.TS_Get(&PlayingTime);
+    } else {
+        PlayingTime = StartTime.nTimestamp + ((nTotalConsumeredLen)/nSampleSize * OMX_TICKS_PER_SECOND) / PcmMode.nSamplingRate * ((float)nDNSeScale / Q16_SHIFT);
+    }
+
+	ReferTime.nTimestamp = PlayingTime;
+	LOG_DEBUG("Set reference time to clock: %lld\n", PlayingTime);
+	ClockSetConfig(OMX_IndexConfigTimeCurrentAudioReference, &ReferTime);
+
+    ret = AudioRenderDoExec2Pause();
+    return ret;
+}
+
+OMX_ERRORTYPE AudioRender::DoPause2Exec()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	LOG_DEBUG("AudioRender::DoPause2Exec Fade in begin.\n");
+	AudioRenderFadeInFadeOut.SetMode(FADEIN);
+	nWriteOutLen = nPeriodSize * nSampleSize;
+
+    ret = AudioRenderDoPause2Exec();
+    return ret;
+}
+OMX_ERRORTYPE AudioRender::AudioRenderDoExec2Pause()
+{
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE AudioRender::AudioRenderDoPause2Exec()
+{
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE AudioRender::DoExec2Idle()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if (AudioRenderRingBuffer.AudioDataLen() == 0 ||bHeardwareError == OMX_TRUE)
+	{
+		LOG_DEBUG("No audio data for Fade out process.\n");
+		return OMX_ErrorNone;
+	}
+
+	LOG_DEBUG("Audio render Exec2Idle.\n");
+
+	AudioRenderFadeInFadeOut.SetMode(FADEOUT);
+	nWriteOutLen = nFadeInFadeOutProcessLen;
+
+	ret = RenderPeriod();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Render period fail.\n");
+		return ret;
+	}
+
+	ret = DrainDevice();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Drain fail.\n");
+		return ret;
+	}
+
+	AudioRenderRingBuffer.BufferReset();
+    TS_Manager.Reset();
+
+    return ret;
+}
+
+
+OMX_ERRORTYPE AudioRender::ComponentReturnBuffer(
+        OMX_U32 nPortIndex)
+{
+	OMX_STATETYPE eState = OMX_StateInvalid;
+	GetState(&eState);
+
+	/* Consume all audio data in input port buffer when disable input port */
+	if(nPortIndex == IN_PORT \
+			&& ports[IN_PORT]->IsEnabled() != OMX_TRUE \
+			&& eState == OMX_StateExecuting) {
+		while (ports[IN_PORT]->BufferNum() != 0 || pInBufferHdr != NULL)
+		{
+			LOG_DEBUG("Audio render process input data.\n");
+			ProcessDataBuffer();
+			usleep(5000);
+		}
+	}
+
+    if(nPortIndex == IN_PORT && pInBufferHdr != NULL) {
+        ports[IN_PORT]->SendBuffer(pInBufferHdr);
+        pInBufferHdr = NULL;
+    }
+
+	LOG_DEBUG("Alsa Return Buffer.\n");
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioRender::FlushComponent(
+        OMX_U32 nPortIndex)
+{
+    if(nPortIndex == IN_PORT && pInBufferHdr != NULL) {
+        ports[IN_PORT]->SendBuffer(pInBufferHdr);
+        pInBufferHdr = NULL;
+    }
+
+	if (AudioRenderRingBuffer.AudioDataLen() == 0 || bHeardwareError == OMX_TRUE)
+	{
+		LOG_DEBUG("No audio data for Fade out process.\n");
+		return OMX_ErrorNone;
+	}
+
+	AudioRenderFadeInFadeOut.SetMode(FADEOUT);
+	nWriteOutLen = nFadeInFadeOutProcessLen;
+
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	ret = RenderPeriod();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Render period fail.\n");
+		return ret;
+	}
+
+	ret = DrainDevice();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Drain fail.\n");
+		return ret;
+	}
+
+	AudioRenderRingBuffer.BufferReset();
+    TS_Manager.Reset();
+
+	return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioRender.h b/OpenMAXIL/src/component/common/AudioRender.h
new file mode 100755
index 0000000..79984d3
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioRender.h
@@ -0,0 +1,105 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file AudioRender.h
+ *  @brief Class definition of AudioRender Component
+ *  @ingroup AudioRender
+ */
+
+#ifndef AudioRender_h
+#define AudioRender_h
+
+#include "ComponentBase.h"
+#include "RingBuffer.h"
+#include "AudioTSManager.h"
+#include "FadeInFadeOut.h"
+
+#define NUM_PORTS 2
+#define IN_PORT 0
+#define CLK_PORT 1
+
+#define FADEPROCESSTIME 100  /**< 100 ms for fade process */
+
+
+class AudioRender : public ComponentBase {
+    protected:
+        OMX_AUDIO_PARAM_PCMMODETYPE PcmMode; 
+		OMX_U32 nPeriodSize;
+		OMX_U32 nSampleSize;
+        OMX_U32 nFadeInFadeOutProcessLen;
+        OMX_U32 nClockScale;
+		OMX_BOOL bSendEOS;
+    private:
+        OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE InstanceInit();
+        OMX_ERRORTYPE InstanceDeInit();
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+		OMX_ERRORTYPE DoLoaded2Idle();
+		OMX_ERRORTYPE DoIdle2Loaded();
+		OMX_ERRORTYPE DoExec2Pause();
+		OMX_ERRORTYPE DoPause2Exec();
+		OMX_ERRORTYPE DoExec2Idle();
+		OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+		OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+		OMX_ERRORTYPE ProcessDataBuffer();
+		OMX_ERRORTYPE ProcessInputBufferFlag();
+		OMX_ERRORTYPE ClockGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+		OMX_ERRORTYPE ClockSetConfig(OMX_INDEXTYPE nParamIndex, \
+				OMX_TIME_CONFIG_TIMESTAMPTYPE *pTimeStamp);
+		OMX_ERRORTYPE ProcessInputDataBuffer();
+		OMX_ERRORTYPE ProcessOutputDataBuffer();
+        OMX_ERRORTYPE ProcessClkBuffer();
+        OMX_ERRORTYPE SyncTS(OMX_TICKS nTimeStamp);
+        OMX_ERRORTYPE RenderData();
+        OMX_ERRORTYPE RenderPeriod();
+
+		/** Audio render device related */
+        virtual OMX_ERRORTYPE SelectDevice(OMX_PTR device);
+        virtual OMX_ERRORTYPE OpenDevice() = 0;
+        virtual OMX_ERRORTYPE CloseDevice() = 0;
+        virtual OMX_ERRORTYPE SetDevice() = 0;
+        virtual OMX_ERRORTYPE ResetDevice() = 0;
+        virtual OMX_ERRORTYPE DrainDevice() = 0;
+		virtual OMX_ERRORTYPE DeviceDelay(OMX_U32 *nDelayLen) = 0;
+        virtual OMX_ERRORTYPE WriteDevice(OMX_U8 *pBuffer, OMX_U32 nActuralLen) = 0;
+
+		virtual OMX_ERRORTYPE AudioRenderDoExec2Pause();
+		virtual OMX_ERRORTYPE AudioRenderDoPause2Exec();
+
+		RingBuffer AudioRenderRingBuffer;
+		AudioTSManager TS_Manager;
+		FadeInFadeOut AudioRenderFadeInFadeOut;
+		OMX_AUDIO_CONFIG_VOLUMETYPE Volume;
+		OMX_AUDIO_CONFIG_MUTETYPE Mute;
+        OMX_BUFFERHEADERTYPE *pInBufferHdr;
+        OMX_BUFFERHEADERTYPE *pInBufferHdrBak;
+		OMX_TIME_CONFIG_TIMESTAMPTYPE StartTime;
+		OMX_TIME_CONFIG_TIMESTAMPTYPE ReferTime;
+		OMX_U32 nWriteOutLen;
+        OMX_U32 nAudioDataWriteThreshold;
+		OMX_BOOL bClockRuningFlag;
+		OMX_BOOL bHeardwareError;
+		OMX_BOOL bReceivedEOS;
+		OMX_BOOL bLiveMode;
+		OMX_TICKS CurrentTS;
+        OMX_U32 nDiscardData;
+        OMX_U32 nAddZeros;
+		OMX_U32 nDNSeScale;
+		OMX_S64 nTotalConsumeredLen;
+		OMX_S64 nTotalReceivedLen;
+		OMX_TICKS audioIntervalThreshold;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioSource.cpp b/OpenMAXIL/src/component/common/AudioSource.cpp
new file mode 100755
index 0000000..ce8a14f
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioSource.cpp
@@ -0,0 +1,618 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+ 
+#include "AudioSource.h"
+ 
+#define CHECK_STRUCT(ps,t,r) \
+    do { \
+        OMX_CHECK_STRUCT(ps, t, r); \
+        if(r != OMX_ErrorNone) \
+        break; \
+        if(ps->nPortIndex != OUTPUT_PORT) { \
+            r = OMX_ErrorBadPortIndex; \
+            break; \
+        } \
+    } while(0);
+
+AudioSource::AudioSource()
+{
+    bInContext = OMX_FALSE;
+    nPorts = NUM_PORTS;
+}
+
+OMX_ERRORTYPE AudioSource::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = OUTPUT_PORT;
+    sPortDef.eDir = OMX_DirOutput;
+    sPortDef.eDomain = OMX_PortDomainAudio;
+    sPortDef.format.audio.eEncoding = OMX_AUDIO_CodingPCM;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 3;
+	sPortDef.nBufferSize = 1024;
+	ret = ports[OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+	if(ret != OMX_ErrorNone) {
+		LOG_ERROR("Set port definition for in port failed.\n");
+        return ret;
+    }
+
+    sPortDef.nPortIndex = CLK_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainOther;
+    sPortDef.format.other.eFormat = OMX_OTHER_FormatTime;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_FALSE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 1;
+    sPortDef.nBufferSize = sizeof(OMX_TIME_MEDIATIMETYPE);
+    ret = ports[CLK_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for clk port failed.\n");
+        return ret;
+    }
+
+	OMX_INIT_STRUCT(&PcmMode, OMX_AUDIO_PARAM_PCMMODETYPE);
+
+	PcmMode.nPortIndex = OUTPUT_PORT;
+	PcmMode.nChannels = 2;
+	PcmMode.nSamplingRate = 44100;
+	PcmMode.nBitPerSample = 16;
+	PcmMode.bInterleaved = OMX_TRUE;
+	PcmMode.eNumData = OMX_NumericalDataSigned;
+	PcmMode.ePCMMode = OMX_AUDIO_PCMModeLinear;
+	PcmMode.eEndian = OMX_EndianLittle;
+	PcmMode.eChannelMapping[0] = OMX_AUDIO_ChannelNone;
+
+	OMX_INIT_STRUCT(&Volume, OMX_AUDIO_CONFIG_VOLUMETYPE);
+
+	Volume.bLinear = OMX_TRUE;
+	Volume.sVolume.nValue = 100;
+	Volume.sVolume.nMin = 0;
+	Volume.sVolume.nMax = 100;
+
+	OMX_INIT_STRUCT(&EOS, OMX_CONFIG_BOOLEANTYPE);
+
+	EOS.bEnabled = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&Mute, OMX_AUDIO_CONFIG_MUTETYPE);
+
+	Mute.bMute = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&StartTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+	StartTime.nTimestamp = 0;
+
+	bFirstFrame = OMX_TRUE;
+	pOutBufferHdr = NULL;
+	TotalRecordedLen = 0;
+	nDeviceReadLen = 0;
+	nDeviceReadOffset = 0;
+	bAddZeros = OMX_FALSE;
+	pDeviceReadBuffer = NULL;
+	nMaxDuration = MAX_VALUE_S64;
+	nAudioSource = 0;
+	bSendEOS = OMX_FALSE;
+
+    ret = InitSourceComponent();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::DeInitComponent()
+{
+	AudioRenderFadeInFadeOut.SetMode(FADEOUT);
+
+    DeInitSourceComponent();
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioSource::InstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::InstanceDeInit()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	StopDevice();
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioSource::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+		case OMX_IndexParamAudioPcm:
+            {
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmMode;
+                pPcmMode = (OMX_AUDIO_PARAM_PCMMODETYPE*)pStructure;
+                CHECK_STRUCT(pPcmMode, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+				fsl_osal_memcpy(pPcmMode, &PcmMode,	sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
+			}
+			break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioSource::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch ((int)nParamIndex) {
+        case OMX_IndexParamAudioPcm:
+            {
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmMode;
+                pPcmMode = (OMX_AUDIO_PARAM_PCMMODETYPE*)pStructure;
+                CHECK_STRUCT(pPcmMode, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+				fsl_osal_memcpy(&PcmMode, pPcmMode, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE));
+				LOG_DEBUG("Audio source samplerate: %d\n", PcmMode.nSamplingRate);
+				LOG_DEBUG("Audio source channels: %d\n", PcmMode.nChannels);
+				LOG_DEBUG("Audio source bitspersample: %d\n", PcmMode.nBitPerSample);
+			}
+            break;
+		case OMX_IndexParamMaxFileDuration:
+			 {
+				 nMaxDuration = *((OMX_TICKS*)pStructure);
+			 }
+			 break;
+		case OMX_IndexParamAudioSource:
+			{
+				 nAudioSource = *((OMX_S32*)pStructure);
+			}
+			break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioSource::GetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch ((int)nParamIndex) {
+        case OMX_IndexConfigAudioVolume:
+            {
+                OMX_AUDIO_CONFIG_VOLUMETYPE *pVolume;
+                pVolume = (OMX_AUDIO_CONFIG_VOLUMETYPE*)pStructure;
+                CHECK_STRUCT(pVolume, OMX_AUDIO_CONFIG_VOLUMETYPE, ret);
+				fsl_osal_memcpy(pVolume, &Volume, sizeof(OMX_AUDIO_CONFIG_VOLUMETYPE));
+            }
+            break;
+        case OMX_IndexConfigAudioMute:
+             {
+                OMX_AUDIO_CONFIG_MUTETYPE *pMute;
+                pMute = (OMX_AUDIO_CONFIG_MUTETYPE*)pStructure;
+                CHECK_STRUCT(pMute, OMX_AUDIO_CONFIG_MUTETYPE, ret);
+				fsl_osal_memcpy(pMute, &Mute, sizeof(OMX_AUDIO_CONFIG_MUTETYPE));
+            }
+            break;
+        case OMX_IndexConfigMaxAmplitude:
+            {
+				 *((OMX_S32*)pStructure) = getMaxAmplitude();
+            }
+            break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioSource::SetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch ((int)nParamIndex) {
+        case OMX_IndexConfigAudioVolume:
+            {
+                OMX_AUDIO_CONFIG_VOLUMETYPE *pVolume;
+                pVolume = (OMX_AUDIO_CONFIG_VOLUMETYPE*)pStructure;
+                CHECK_STRUCT(pVolume, OMX_AUDIO_CONFIG_VOLUMETYPE, ret);
+				fsl_osal_memcpy(&Volume, pVolume, sizeof(OMX_AUDIO_CONFIG_VOLUMETYPE));
+            }
+            break;
+        case OMX_IndexConfigAudioMute:
+             {
+                OMX_AUDIO_CONFIG_MUTETYPE *pMute;
+                pMute = (OMX_AUDIO_CONFIG_MUTETYPE*)pStructure;
+                CHECK_STRUCT(pMute, OMX_AUDIO_CONFIG_MUTETYPE, ret);
+				fsl_osal_memcpy(&Mute, pMute, sizeof(OMX_AUDIO_CONFIG_MUTETYPE));
+            }
+            break;
+		case OMX_IndexConfigEOS:
+			 {
+				 OMX_CONFIG_BOOLEANTYPE *pEOS;
+				 pEOS = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+				 OMX_CHECK_STRUCT(pEOS, OMX_CONFIG_BOOLEANTYPE, ret);
+				 fsl_osal_memcpy(&EOS, pEOS, sizeof(OMX_CONFIG_BOOLEANTYPE));
+			 }
+			 break;
+		default:
+			 ret = OMX_ErrorUnsupportedIndex;
+			 break;
+    }
+
+    return ret;
+}
+ 
+OMX_ERRORTYPE AudioSource::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 nActuralLen;
+	
+	if (bSendEOS == OMX_TRUE)
+		return OMX_ErrorNoMore;
+
+	if (AudioRenderRingBuffer.AudioDataLen() <= nFadeInFadeOutProcessLen) {
+		if (nDeviceReadLen == 0) {
+			LOG_DEBUG("Ringbuffer data len: %d\n", AudioRenderRingBuffer.AudioDataLen());
+			ret = GetOneFrameFromDevice();
+			if (ret == OMX_ErrorUndefined) {
+				OMX_U8 *pBuffer;
+
+				AudioRenderRingBuffer.BufferGet(&pBuffer, nFadeInFadeOutProcessLen, &nActuralLen);
+				AudioRenderFadeInFadeOut.SetMode(FADEOUT);
+				AudioRenderFadeInFadeOut.Process(pBuffer, nActuralLen);
+				AudioRenderRingBuffer.BufferConsumered(nActuralLen);
+				AudioRenderRingBuffer.BufferAdd(pBuffer, nFadeInFadeOutProcessLen, &nActuralLen);
+
+				nDeviceReadOffset = 0;
+				AudioRenderRingBuffer.BufferAddZeros(nDeviceReadLen, &nActuralLen);
+				LOG_LOG("Ringbuffer add len: %d\n", nActuralLen);
+				nDeviceReadLen -= nActuralLen;
+				nDeviceReadOffset += nActuralLen;
+				bAddZeros = OMX_TRUE;
+				if (nDeviceReadLen == 0)
+					AudioRenderFadeInFadeOut.SetMode(FADEIN);
+
+			} else {
+				if (ret != OMX_ErrorNone)
+					return ret;
+
+				bAddZeros = OMX_FALSE;
+				nDeviceReadOffset = 0;
+				AudioRenderFadeInFadeOut.Process(pDeviceReadBuffer, nDeviceReadLen);
+				AudioRenderRingBuffer.BufferAdd(pDeviceReadBuffer, nDeviceReadLen, &nActuralLen);
+				LOG_LOG("Ringbuffer add len: %d\n", nActuralLen);
+				nDeviceReadLen -= nActuralLen;
+				nDeviceReadOffset += nActuralLen;
+			}
+		} else {
+			if (bAddZeros == OMX_TRUE) {
+				AudioRenderRingBuffer.BufferAddZeros(nDeviceReadLen, &nActuralLen);
+				nDeviceReadLen -= nActuralLen;
+				nDeviceReadOffset += nActuralLen;
+				if (nDeviceReadLen == 0)
+					AudioRenderFadeInFadeOut.SetMode(FADEIN);
+			} else {
+				AudioRenderFadeInFadeOut.Process(pDeviceReadBuffer + nDeviceReadOffset, nDeviceReadLen);
+				AudioRenderRingBuffer.BufferAdd(pDeviceReadBuffer + nDeviceReadOffset, nDeviceReadLen, &nActuralLen);
+				nDeviceReadLen -= nActuralLen;
+				nDeviceReadOffset += nActuralLen;
+			}
+		}
+	}
+
+	LOG_LOG("Ringbuffer data len: %d\n", AudioRenderRingBuffer.AudioDataLen());
+	while(AudioRenderRingBuffer.AudioDataLen() > nFadeInFadeOutProcessLen) {
+		if (ports[OUTPUT_PORT]->BufferNum() == 0 && pOutBufferHdr == NULL ) {
+			fsl_osal_sleep(5000);
+			continue;
+		}
+
+		if (ports[OUTPUT_PORT]->BufferNum() > 0 && pOutBufferHdr == NULL) {
+			ports[OUTPUT_PORT]->GetBuffer(&pOutBufferHdr);
+		}
+
+		ret = ProcessOutputBufferData();
+		if (ret != OMX_ErrorNone)
+			return ret;
+		ret = ProcessOutputBufferFlag();
+		if (ret != OMX_ErrorNone)
+			return ret;
+		ret = SendOutputBuffer();
+		if (ret != OMX_ErrorNone)
+			return ret;
+	}
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioSource::ProcessOutputBufferData()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U8 *pBuffer;
+	OMX_U32 nActuralLen;
+	OMX_U32 nSendDataLen = pOutBufferHdr->nAllocLen;
+	if (nSendDataLen > AudioRenderRingBuffer.AudioDataLen() - nFadeInFadeOutProcessLen)
+		nSendDataLen = AudioRenderRingBuffer.AudioDataLen() - nFadeInFadeOutProcessLen;
+
+	AudioRenderRingBuffer.BufferGet(&pBuffer, nSendDataLen, &nActuralLen);
+ 
+	fsl_osal_memcpy(pOutBufferHdr->pBuffer, pBuffer, nActuralLen);
+	pOutBufferHdr->nFilledLen = nActuralLen;
+
+	LOG_LOG("pOutBufferHdr->nAllocLen = %d\t pOutBufferHdr->nFilledLen = %d\n", pOutBufferHdr->nAllocLen, pOutBufferHdr->nFilledLen);
+	AudioRenderRingBuffer.BufferConsumered(nActuralLen);
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::ProcessOutputBufferFlag()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if (bFirstFrame == OMX_TRUE) {
+		pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+		bFirstFrame = OMX_FALSE;
+	}
+	pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::SendOutputBuffer()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_TIME_CONFIG_TIMESTAMPTYPE ReferTime;
+	OMX_U32 nDelayLen;
+	OMX_S64 MediaTime;
+
+	OMX_INIT_STRUCT(&ReferTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+
+	GetDeviceDelay(&nDelayLen);
+
+	TotalRecordedLen += pOutBufferHdr->nFilledLen;
+	MediaTime = StartTime.nTimestamp + ((TotalRecordedLen + nDelayLen)/nSampleSize * OMX_TICKS_PER_SECOND) / PcmMode.nSamplingRate;
+	pOutBufferHdr->nTimeStamp = StartTime.nTimestamp + ((TotalRecordedLen)/nSampleSize * OMX_TICKS_PER_SECOND) / PcmMode.nSamplingRate;
+
+	ReferTime.nTimestamp = MediaTime;
+	LOG_DEBUG("Audio source total recorded data: %lld\n", TotalRecordedLen);
+	LOG_DEBUG("Set reference time to clock: %lld\n", MediaTime);
+	//ClockSetConfig(OMX_IndexConfigTimeCurrentAudioReference, &ReferTime);
+   
+	if (EOS.bEnabled == OMX_TRUE || pOutBufferHdr->nTimeStamp > nMaxDuration) {
+		pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_EOS;
+		pOutBufferHdr->nFilledLen = 0;
+		bSendEOS = OMX_TRUE;
+		SendEvent(OMX_EventBufferFlag, 0, OMX_BUFFERFLAG_MAX_DURATION, NULL);
+	}
+
+	LOG_DEBUG("Audio source send buffer len: %d, flags: %p offset: %d time stamp: %lld\n", \
+			pOutBufferHdr->nFilledLen, pOutBufferHdr->nFlags, pOutBufferHdr->nOffset, \
+			pOutBufferHdr->nTimeStamp);
+	ports[OUTPUT_PORT]->SendBuffer(pOutBufferHdr);
+	pOutBufferHdr = NULL;
+	
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::ClockGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+	{
+		return ret;
+	}
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+	{
+				return ret;
+	}
+
+	switch (nParamIndex) {
+		case OMX_IndexConfigTimeClockState:
+			{
+				OMX_TIME_CONFIG_CLOCKSTATETYPE *pClockState = (OMX_TIME_CONFIG_CLOCKSTATETYPE *)pStructure;
+				ret = OMX_GetConfig(hClockComp, OMX_IndexConfigTimeClockState, pClockState);
+			}
+			break;
+		case OMX_IndexConfigTimeCurrentMediaTime:
+			{
+				OMX_TIME_CONFIG_TIMESTAMPTYPE *pCur = (OMX_TIME_CONFIG_TIMESTAMPTYPE *)pStructure;
+				pCur->nPortIndex = TunnelInfo.nTunneledPort;
+				ret = OMX_GetConfig(hClockComp, OMX_IndexConfigTimeCurrentMediaTime, pCur);
+			}
+			break;
+		default :
+			ret = OMX_ErrorUnsupportedIndex;
+			break;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::ClockSetConfig(OMX_INDEXTYPE nParamIndex, OMX_TIME_CONFIG_TIMESTAMPTYPE *pTimeStamp)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+		return ret;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+		return ret;
+
+	pTimeStamp->nPortIndex = TunnelInfo.nTunneledPort;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigTimeClientStartTime:
+			ret = OMX_SetConfig(hClockComp, OMX_IndexConfigTimeClientStartTime,pTimeStamp);
+            break;
+        case OMX_IndexConfigTimeCurrentAudioReference:
+			ret = OMX_SetConfig(hClockComp, OMX_IndexConfigTimeCurrentAudioReference,pTimeStamp);
+            break;
+        default :
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+	return ret;
+}
+
+OMX_ERRORTYPE AudioSource::ProcessClkBuffer()
+{
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+        return OMX_ErrorNoMore;
+
+    if(ports[CLK_PORT]->BufferNum() == 0)
+		return OMX_ErrorNoMore;
+
+	OMX_BUFFERHEADERTYPE *pClockBufferHdr;
+	ports[CLK_PORT]->GetBuffer(&pClockBufferHdr);
+	OMX_TIME_MEDIATIMETYPE *pTimeBuffer = (OMX_TIME_MEDIATIMETYPE*) pClockBufferHdr->pBuffer;
+
+	if ((pTimeBuffer->eUpdateType == OMX_TIME_UpdateClockStateChanged)
+		&& (pTimeBuffer->eState == OMX_TIME_ClockStateRunning))
+	{
+	}
+	else if (pTimeBuffer->eUpdateType == OMX_TIME_UpdateScaleChanged)
+	{
+	}
+	else
+	{
+		LOG_WARNING("Unknow clock buffer.\n");
+	}
+
+	ports[CLK_PORT]->SendBuffer(pClockBufferHdr);
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioSource::DoLoaded2Idle()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = OpenDevice();
+    if(ret != OMX_ErrorNone) {
+        CloseDevice();
+        SendEvent(OMX_EventError, ret, 0, NULL);
+        return ret;
+	}
+
+	nDeviceReadLen = nPeriodSize * nSampleSize;
+	OMX_U32 BufferSize;
+	OMX_U8 *pBuffer;
+
+	BufferSize = nDeviceReadLen;
+	pBuffer = (OMX_U8 *)FSL_MALLOC(BufferSize);
+	if (pBuffer == NULL) {
+		LOG_ERROR("Can't get memory.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+	fsl_osal_memset(pBuffer, 0, BufferSize);
+	pDeviceReadBuffer = pBuffer;
+
+	OMX_U32 nRingBufferSize = nFadeInFadeOutProcessLen + nDeviceReadLen;
+	RINGBUFFER_ERRORTYPE BufferRet = RINGBUFFER_SUCCESS;
+	LOG_DEBUG("Audio source nRingBufferSize = %d\n", nRingBufferSize);
+	BufferRet = AudioRenderRingBuffer.BufferCreate(nRingBufferSize);
+	if (BufferRet != RINGBUFFER_SUCCESS) {
+		LOG_ERROR("Create ring buffer fail.\n");
+		return OMX_ErrorInsufficientResources;
+	} 
+
+	FADEINFADEOUT_ERRORTYPE FadeRet = FADEINFADEOUT_SUCCESS;
+	FadeRet = AudioRenderFadeInFadeOut.Create(PcmMode.nChannels, PcmMode.nSamplingRate, \
+			PcmMode.nBitPerSample, nFadeInFadeOutProcessLen, 0);
+	if (FadeRet != FADEINFADEOUT_SUCCESS) {
+		LOG_ERROR("Create fade in fade out process fail.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioSource::DoIdle2Loaded()
+{
+ 	CloseDevice();
+
+	LOG_DEBUG("Audio source ring buffer free.\n");
+	AudioRenderRingBuffer.BufferFree();
+
+	FSL_FREE(pDeviceReadBuffer);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioSource::DoPause2Exec()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	AudioRenderFadeInFadeOut.SetMode(FADEIN);
+
+	printf("Set AudioSource start time.\n");
+	ClockSetConfig(OMX_IndexConfigTimeClientStartTime, &StartTime);
+
+	StartDevice();
+
+    return ret;
+}
+
+OMX_ERRORTYPE AudioSource::ComponentReturnBuffer(
+        OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	StopDevice();
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AudioSource::FlushComponent(
+        OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	StopDevice();
+
+	return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/AudioSource.h b/OpenMAXIL/src/component/common/AudioSource.h
new file mode 100755
index 0000000..0fe8af7
--- /dev/null
+++ b/OpenMAXIL/src/component/common/AudioSource.h
@@ -0,0 +1,90 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file AudioSource.h
+ *  @brief Class definition of AudioSource Component
+ *  @ingroup AudioSource
+ */
+
+#ifndef AudioSource_h
+#define AudioSource_h
+
+#include "ComponentBase.h"
+#include "RingBuffer.h"
+#include "FadeInFadeOut.h"
+
+#define NUM_PORTS 2
+#define OUTPUT_PORT 0
+#define CLK_PORT 1
+
+#define FADEPROCESSTIME 100  /**< 100 ms for fade process */
+
+class AudioSource : public ComponentBase {
+    public:
+		AudioSource();
+    protected:
+        OMX_U32 nFadeInFadeOutProcessLen;
+        OMX_AUDIO_PARAM_PCMMODETYPE PcmMode;
+		OMX_BUFFERHEADERTYPE *pOutBufferHdr;
+		OMX_AUDIO_CONFIG_VOLUMETYPE Volume;
+		OMX_AUDIO_CONFIG_MUTETYPE Mute;
+		OMX_U32 nPeriodSize;
+		OMX_U32 nSampleSize;
+		OMX_U8 *pDeviceReadBuffer;
+		OMX_U32 nDeviceReadLen;
+		OMX_S32 nAudioSource;
+	private:
+		OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE InstanceInit();
+        OMX_ERRORTYPE InstanceDeInit();
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+		OMX_ERRORTYPE DoLoaded2Idle();
+		OMX_ERRORTYPE DoIdle2Loaded();
+		OMX_ERRORTYPE DoPause2Exec();
+		OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+		OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+		OMX_ERRORTYPE ProcessDataBuffer();
+		OMX_ERRORTYPE ProcessOutputBufferData();
+		OMX_ERRORTYPE ProcessOutputBufferFlag();
+		OMX_ERRORTYPE SendOutputBuffer();
+		OMX_ERRORTYPE ClockGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+		OMX_ERRORTYPE ClockSetConfig(OMX_INDEXTYPE nParamIndex, \
+				OMX_TIME_CONFIG_TIMESTAMPTYPE *pTimeStamp);
+        OMX_ERRORTYPE ProcessClkBuffer();
+
+		/** Audio source device related */
+        virtual OMX_ERRORTYPE InitSourceComponent() = 0;
+        virtual OMX_ERRORTYPE DeInitSourceComponent() = 0;
+        virtual OMX_ERRORTYPE OpenDevice() = 0;
+		virtual OMX_ERRORTYPE CloseDevice() = 0;
+		virtual OMX_ERRORTYPE StartDevice() = 0;
+		virtual OMX_ERRORTYPE StopDevice() = 0;
+        virtual OMX_ERRORTYPE GetOneFrameFromDevice() = 0;
+		virtual OMX_ERRORTYPE GetDeviceDelay(OMX_U32 *nDelayLen) = 0;
+		virtual OMX_S16 getMaxAmplitude() = 0;
+
+		OMX_TIME_CONFIG_TIMESTAMPTYPE StartTime;
+		RingBuffer AudioRenderRingBuffer;
+		FadeInFadeOut AudioRenderFadeInFadeOut;
+		OMX_S64 TotalRecordedLen;
+		OMX_U32 nDeviceReadOffset;
+		OMX_BOOL bFirstFrame;
+		OMX_BOOL bAddZeros;
+		OMX_BOOL bSendEOS;
+		OMX_CONFIG_BOOLEANTYPE EOS;
+		OMX_TICKS nMaxDuration;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/ComponentBase.cpp b/OpenMAXIL/src/component/common/ComponentBase.cpp
new file mode 100755
index 0000000..504e0ed
--- /dev/null
+++ b/OpenMAXIL/src/component/common/ComponentBase.cpp
@@ -0,0 +1,1241 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor, Inc. 
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "ComponentBase.h"
+#include "InvalidState.h"
+#include "LoadedState.h"
+#include "IdleState.h"
+#include "ExecutingState.h"
+#include "PauseState.h"
+#include "WaitForResourcesState.h"
+#include <string.h>
+/**< internally used functions */
+
+#define OMX_COMP_DBG
+#ifdef OMX_COMP_DBG
+#define OMX_COMP_DBG_LEVEL	LOG_LEVEL_APIINFO
+//#define OMX_COMP_API_LOG(...)   LOG(-1/*always logout*/, __VA_ARGS__) 
+#define OMX_COMP_API_LOG(name,...)   {if((nLogLevel >=OMX_COMP_DBG_LEVEL)){printf("OMXCOMP(%s): ",name); printf(__VA_ARGS__);}}
+#define OMX_COMP_CALLBACK_LOG(name,...)	 {if((nLogLevel >=OMX_COMP_DBG_LEVEL)){printf("OMXCALLBACK(%s): ",name); printf(__VA_ARGS__);}}
+#else
+#define OMX_COMP_API_LOG(...)
+#define OMX_COMP_CALLBACK_LOG(...)
+#endif
+
+#ifdef OMX_COMP_DBG
+
+typedef struct {
+	OMX_U32 value;
+	OMX_U8 str[32];
+}OMX_MAP_NODE;
+
+#define OMX_MAP_INVALID_VALUE	0xFFFFFFFF
+
+OMX_MAP_NODE omx_map_cmd_str[]={
+	{OMX_CommandStateSet,"StateSet"},
+	{OMX_CommandFlush,"Flush"},
+	{OMX_CommandPortDisable,"PortDisable"},
+	{OMX_CommandPortEnable,"PortEnable"},
+	{OMX_CommandMarkBuffer,"MarkBuffer"},
+	{OMX_CommandKhronosExtensions,"KhronosExtensions"},
+	{OMX_CommandVendorStartUnused,"VendorStartUnused"},
+	{OMX_CommandMax,"CommandMax"},
+	{OMX_MAP_INVALID_VALUE,"CommandUnspecified"},
+};
+
+OMX_MAP_NODE omx_map_state_str[]={
+	{OMX_StateInvalid,"StateInvalid"},
+	{OMX_StateLoaded,"StateLoaded"},
+	{OMX_StateIdle,"StateIdle"},
+	{OMX_StateExecuting,"StateExecuting"},
+	{OMX_StatePause,"StatePause"},
+	{OMX_StateWaitForResources,"StateWaitForResources"},
+	{OMX_StateKhronosExtensions,"StateKhronosExtensions"},
+	{OMX_StateVendorStartUnused,"StateVendorStartUnused"},
+	{OMX_StateMax,"StateVendorStartUnused"},
+	{OMX_MAP_INVALID_VALUE,"StateUnspecified"},
+};
+
+ OMX_MAP_NODE omx_map_event_str[]={
+	{OMX_EventCmdComplete,"CmdComplete"},
+	{OMX_EventError,"Error"},
+	{OMX_EventMark,"Mark"},
+	{OMX_EventPortSettingsChanged,"PortSettingsChanged"},
+	{OMX_EventBufferFlag,"BufferFlag"},
+	{OMX_EventResourcesAcquired,"ResourcesAcquired"},
+	{OMX_EventComponentResumed,"ComponentResumed"},
+	{OMX_EventDynamicResourcesAvailable,"DynamicResourcesAvailable"},
+	{OMX_EventPortFormatDetected,"PortFormatDetected"},
+	{OMX_EventKhronosExtensions,"KhronosExtensions"},
+	{OMX_EventVendorStartUnused,"VendorStartUnused"},
+	{OMX_EventMax,"Max"},
+	{OMX_MAP_INVALID_VALUE,"EventUnspecified"},
+};
+
+
+
+OMX_MAP_NODE omx_map_index_str[]={	/*only one sub-set of index*/
+	{OMX_IndexParamAudioInit,"AudioInit"},
+	{OMX_IndexParamImageInit,"ImageInit"},
+	{OMX_IndexParamVideoInit,"VideoInit"},
+	{OMX_IndexParamOtherInit,"OtherInit"},
+	{OMX_IndexParamNumAvailableStreams,"NumAvailableStreams"},
+	{OMX_IndexParamActiveStream,"ActiveStream"},
+	{OMX_IndexParamContentURI,"ContentURI"},
+	{OMX_IndexParamCustomContentPipe,"CustomContentPipe"},
+	{OMX_IndexConfigMetadataItemCount,"MetadataItemCount"},
+	{OMX_IndexConfigMetadataItem,"MetadataItem"},
+	{OMX_IndexParamStandardComponentRole,"StandardComponentRole"},
+	{OMX_IndexParamPortDefinition,"PortDefinition"},
+	{OMX_IndexParamCompBufferSupplier,"CompBufferSupplier"},
+	{OMX_IndexParamAudioPortFormat,"AudioPortFormat"},
+	{OMX_IndexParamAudioPcm,"AudioPcm"},
+	{OMX_IndexParamAudioAac,"AudioAac"},
+	{OMX_IndexParamAudioRa,"AudioRa"},
+	{OMX_IndexParamAudioMp3,"AudioMp3"},
+	{OMX_IndexParamAudioAdpcm,"AudioAdpcm"},
+	{OMX_IndexParamAudioG723,"AudioG723"},
+	{OMX_IndexParamAudioG729,"AudioG729"},
+	{OMX_IndexParamAudioAmr,"AudioAmr"},
+	{OMX_IndexParamAudioWma,"AudioWma"},
+	{OMX_IndexParamAudioVorbis,"AudioVorbis"},
+	{OMX_IndexConfigAudioVolume,"AudioVolume"},
+	{OMX_IndexConfigAudioEqualizer,"AudioEqualizer"},
+	{OMX_IndexParamVideoPortFormat,"VideoPortFormat"},
+	{OMX_IndexParamVideoQuantization,"VideoQuantization"},
+	{OMX_IndexParamVideoFastUpdate,"VideoFastUpdate"},
+	{OMX_IndexParamVideoBitrate,"VideoBitrate"},
+	{OMX_IndexParamVideoMotionVector,"VideoMotionVector"},
+	{OMX_IndexParamVideoIntraRefresh,"VideoIntraRefresh"},
+	{OMX_IndexParamVideoMpeg2,"VideoMpeg2"},
+	{OMX_IndexParamVideoMpeg4,"VideoMpeg4"},
+	{OMX_IndexParamVideoWmv,"VideoWmv"},
+	{OMX_IndexParamVideoRv,"VideoRv"},
+	{OMX_IndexParamVideoAvc,"VideoAvc"},
+	{OMX_IndexParamVideoH263,"VideoH263"},
+	{OMX_IndexParamVideoProfileLevelQuerySupported,"VideoProfileLevelQuerySupported"},
+	{OMX_IndexParamVideoProfileLevelCurrent,"VideoProfileLevelCurrent"},
+	{OMX_IndexConfigVideoBitrate,"VideoBitrate"},
+	{OMX_IndexConfigVideoFramerate,"VideoFramerate"},
+	{OMX_IndexConfigVideoIntraVOPRefresh,"VideoIntraVOPRefresh"},
+	{OMX_IndexConfigVideoAVCIntraPeriod,"VideoAVCIntraPeriod"},
+	{OMX_IndexParamCommonDeblocking,"CommonDeblocking"},
+	{OMX_IndexParamCommonSensorMode,"CommonSensorMode"},
+	{OMX_IndexParamCommonInterleave,"CommonInterleave"},
+	{OMX_IndexConfigCommonColorFormatConversion,"CommonColorFormatConversion"},
+	{OMX_IndexConfigCommonScale,"CommonScale"},
+	{OMX_IndexConfigCommonRotate,"CommonRotate"},
+	{OMX_IndexConfigCommonMirror,"CommonMirror"},
+	{OMX_IndexConfigCommonOutputPosition,"CommonOutputPosition"},
+	{OMX_IndexConfigCommonInputCrop,"CommonInputCrop"},
+	{OMX_IndexConfigCommonOutputCrop,"CommonOutputCrop"},
+	{OMX_IndexConfigCommonDigitalZoom,"CommonDigitalZoom"},
+	{OMX_IndexConfigCommonOpticalZoom,"CommonOpticalZoom"},
+	{OMX_IndexConfigCommonWhiteBalance,"CommonWhiteBalance"},
+	{OMX_IndexConfigCommonExposureValue,"CommonExposureValue"},
+	{OMX_IndexParamOtherPortFormat,"OtherPortFormat"},
+	{OMX_IndexConfigOtherPower,"OtherPower"},
+	{OMX_IndexConfigTimeScale,"TimeScale"},
+	{OMX_IndexConfigTimeClockState,"TimeClockState"},
+	{OMX_IndexConfigTimeActiveRefClock,"TimeActiveRefClock"},
+	{OMX_IndexConfigTimeCurrentMediaTime,"TimeCurrentMediaTime"},
+	{OMX_IndexConfigTimeCurrentWallTime,"TimeCurrentWallTime"},
+	{OMX_IndexConfigTimeCurrentAudioReference,"TimeCurrentAudioReference"},
+	{OMX_IndexConfigTimeCurrentVideoReference,"TimeCurrentVideoReference"},
+	{OMX_IndexConfigTimeMediaTimeRequest,"TimeMediaTimeRequest"},
+	{OMX_IndexConfigTimeClientStartTime,"TimeClientStartTime"},
+	{OMX_IndexConfigTimePosition,"TimePosition"},
+	{OMX_IndexConfigTimeSeekMode,"TimeSeekMode"},
+	{OMX_IndexKhronosExtensions,"KhronosExtensions"},
+	{OMX_IndexVendorStartUnused,"VendorStartUnused"},
+	{OMX_IndexParamMediaSeekable,"FSL_MediaSeekable"},
+	{OMX_IndexParamMediaDuration,"FSL_MediaDuration"},
+	{OMX_IndexParamTrackDuration,"FSL_TrackDuration"},
+	{OMX_IndexConfigParserSendAudioFirst,"FSL_SendAudioFirst"},
+	{OMX_IndexConfigCaptureFrame,"FSL_CaptureFrame"},
+	{OMX_IndexOutputMode,"FSL_OutputMode"},
+	{OMX_IndexSysSleep,"FSL_SysSleep"},
+	{OMX_IndexParamAudioAc3,"FSL_AudioAc3"},
+	{OMX_IndexConfigAudioPostProcess,"FSL_AudioPostProcess"},
+	{OMX_IndexParamAudioSink,"FSL_AudioSink"},
+	{OMX_IndexConfigClock,"FSL_Clock"},
+	{OMX_IndexConfigVideoOutBufPhyAddr,"FSL_VideoOutBufPhyAddr"},
+	{OMX_IndexParamAudioFlac,"FSL_AudioFlac"},
+	{OMX_IndexParamMemOperator,"FSL_MemOperator"},
+	{OMX_IndexConfigAbortBuffering,"FSL_AbortBuffering"},
+	{OMX_IndexParamVideoCamera,"FSL_VideoCamera"},
+	{OMX_IndexParamVideoCameraId,"FSL_VideoCameraId"},
+	{OMX_IndexParamVideoSurface,"FSL_VideoSurface"},
+	{OMX_IndexParamMaxFileDuration,"FSL_MaxFileDuration"},
+	{OMX_IndexParamMaxFileSize,"FSL_MaxFileSize"},
+	{OMX_IndexParamInterleaveUs,"FSL_InterleaveUs"},
+	{OMX_IndexParamIsGetMetadata,"FSL_IsGetMetadata"},
+	{OMX_IndexParamSurface,"FSL_Surface"},
+	{OMX_IndexConfigEOS,"FSL_EOS"},
+	{OMX_IndexParamAudioSource,"FSL_AudioSource"},
+	{OMX_IndexConfigMaxAmplitude,"FSL_MaxAmplitude"},
+	{OMX_IndexParamDecoderPlayMode,"FSL_DecoderPlayMode"},
+	{OMX_IndexParamTimeLapseUs,"FSL_TimeLapseUs"},
+	{OMX_IndexParamAudioWmaExt,"FSL_AudioWmaExt"},
+	{OMX_IndexParamVideoDecChromaAlign,"FSL_VideoDecChromaAlign"},
+	{OMX_IndexParamVideoCameraProxy,"FSL_VideoCameraProxy"},
+	{OMX_IndexMax,"Max"},
+	{OMX_MAP_INVALID_VALUE,"Index***"},
+};
+
+static OMX_STRING DBG_MAP_STR(OMX_U32 nValue,OMX_MAP_NODE* pNodeBase)
+{
+	OMX_MAP_NODE* pNode=pNodeBase;
+	do{
+		if(pNode->value==OMX_MAP_INVALID_VALUE)
+			break;
+		if(nValue==pNode->value)
+			break;
+		pNode++;
+	}while(1);
+	return (OMX_STRING)pNode->str;
+}
+#endif
+
+static OMX_ERRORTYPE BaseGetComponentVersion(
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_STRING pComponentName,
+        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
+        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
+        OMX_OUT OMX_UUIDTYPE* pComponentUUID)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"GetComponentVersion: ComponentName: %s \r\n",pComponentName);
+    return base->CurState->GetVersion(pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+}
+
+
+static OMX_ERRORTYPE BaseSendCommand(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_COMMANDTYPE Cmd,
+            OMX_IN  OMX_U32 nParam1,
+            OMX_IN  OMX_PTR pCmdData)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"SendCommand: Cmd: 0x%X(%s), Param: 0x%X, CmdData: 0x%X \r\n",Cmd,DBG_MAP_STR((OMX_U32)Cmd,&omx_map_cmd_str[0]),nParam1,pCmdData);
+    return base->CurState->SendCommand(Cmd, nParam1, pCmdData);
+}
+
+
+static OMX_ERRORTYPE BaseGetParameter(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nParamIndex,  
+            OMX_INOUT OMX_PTR pComponentParameterStructure)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    if(nParamIndex==OMX_IndexParamPortDefinition)
+    {
+        OMX_COMP_API_LOG(base->name,"GetParameter: ParamIndex: 0x%X(%s), PortIndex: %d \r\n",nParamIndex,DBG_MAP_STR((OMX_U32)nParamIndex,&omx_map_index_str[0]),((OMX_PARAM_PORTDEFINITIONTYPE*)pComponentParameterStructure)->nPortIndex);
+    }
+    else
+    {
+        OMX_COMP_API_LOG(base->name,"GetParameter: ParamIndex: 0x%X(%s) \r\n",nParamIndex,DBG_MAP_STR((OMX_U32)nParamIndex,&omx_map_index_str[0]));
+    }
+    return base->CurState->GetParameter(nParamIndex, pComponentParameterStructure);
+}
+
+
+static OMX_ERRORTYPE BaseSetParameter(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nIndex,
+            OMX_IN  OMX_PTR pComponentParameterStructure)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    if(nIndex==OMX_IndexParamPortDefinition)
+    {
+        OMX_COMP_API_LOG(base->name,"SetParameter: Index: 0x%X(%s), PortIndex: %d \r\n",nIndex,DBG_MAP_STR((OMX_U32)nIndex,&omx_map_index_str[0]),((OMX_PARAM_PORTDEFINITIONTYPE*)pComponentParameterStructure)->nPortIndex);
+    }
+    else
+    {
+        OMX_COMP_API_LOG(base->name,"SetParameter: Index: 0x%X(%s) \r\n",nIndex,DBG_MAP_STR((OMX_U32)nIndex,&omx_map_index_str[0]));
+    }
+    return base->CurState->SetParameter(nIndex, pComponentParameterStructure);
+}
+
+
+static OMX_ERRORTYPE BaseGetConfig(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_INOUT OMX_PTR pComponentConfigStructure)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"GetConfig: Index: 0x%X(%s) \r\n",nIndex,DBG_MAP_STR((OMX_U32)nIndex,&omx_map_index_str[0]));
+    return base->CurState->GetConfig(nIndex, pComponentConfigStructure);
+}
+
+
+static OMX_ERRORTYPE BaseSetConfig(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_IN  OMX_PTR pComponentConfigStructure)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"SetConfig: Index: 0x%X(%s) \r\n",nIndex,DBG_MAP_STR((OMX_U32)nIndex,&omx_map_index_str[0]));	
+    return base->CurState->SetConfig(nIndex, pComponentConfigStructure);
+}
+
+
+static OMX_ERRORTYPE BaseGetExtensionIndex(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_STRING cParameterName,
+            OMX_OUT OMX_INDEXTYPE* pIndexType)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"GetExtensionIndex: ParamName: %s \r\n",cParameterName);
+    return base->CurState->GetExtensionIndex(cParameterName, pIndexType);
+}
+
+
+static OMX_ERRORTYPE BaseGetState(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STATETYPE* pState)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"GetState: \r\n");
+    return base->GetState(pState);
+}
+
+static OMX_ERRORTYPE BaseComponentTunnelRequest(
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_U32 nPort,
+        OMX_IN  OMX_HANDLETYPE hTunneledComp,
+        OMX_IN  OMX_U32 nTunneledPort,
+        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    if(hTunneledComp==NULL){
+        OMX_COMP_API_LOG(base->name,"ComponentTunnelRequest: TunneledComponent: NULL, Port: 0x%X, TunnelFlag: 0x%X, TunnelSupplier: 0x%X \r\n",
+            nTunneledPort,pTunnelSetup->nTunnelFlags,pTunnelSetup->eSupplier);
+    }
+    else{
+        OMX_COMP_API_LOG(base->name,"ComponentTunnelRequest: Port: 0x%X, TunneledComponent: %s, TunneledPort: 0x%X, TunnelFlag: 0x%X, TunnelSupplier: 0x%X \r\n",nPort,
+            ((ComponentBase*)(((OMX_COMPONENTTYPE*)hTunneledComp)->pComponentPrivate))->name,nTunneledPort,pTunnelSetup->nTunnelFlags,pTunnelSetup->eSupplier);
+    }
+    return base->CurState->TunnelRequest(nPort, hTunneledComp, nTunneledPort, pTunnelSetup);
+}
+
+
+static OMX_ERRORTYPE BaseUseBuffer(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes,
+            OMX_IN OMX_U8* pBuffer)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"UseBuffer: Port: 0x%X, Buffer: 0x%X, Size: 0x%X \r\n",nPortIndex,pBuffer,nSizeBytes);
+    return base->CurState->UseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+}
+
+
+static OMX_ERRORTYPE BaseAllocateBuffer(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"AllocateBuffer: Port: 0x%X, Size: 0x%X \r\n",nPortIndex,nSizeBytes);
+    return base->CurState->AllocateBuffer(ppBuffer, nPortIndex, pAppPrivate, nSizeBytes);
+}
+
+
+static OMX_ERRORTYPE BaseFreeBuffer(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_U32 nPortIndex,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"FreeBuffer: Port: 0x%X, Buffer: 0x%X, Size: 0x%X \r\n",nPortIndex,pBuffer->pBuffer,pBuffer->nAllocLen);
+    return base->CurState->FreeBuffer(nPortIndex, pBuffer);
+}
+
+
+static OMX_ERRORTYPE BaseEmptyThisBuffer(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"EmptyThisBuffer: Buffer: 0x%X, Offset: 0x%X, FilledLen: 0x%X(%d), Flag: 0x%X \r\n",pBuffer->pBuffer,pBuffer->nOffset,pBuffer->nFilledLen,pBuffer->nFilledLen,pBuffer->nFlags);
+    return base->CurState->EmptyThisBuffer(pBuffer);
+}
+
+
+static OMX_ERRORTYPE BaseFillThisBuffer(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"FillThisBuffer: Buffer: 0x%X, AllocLen: 0x%X \r\n",pBuffer->pBuffer,pBuffer->nAllocLen);
+    return base->CurState->FillThisBuffer(pBuffer);
+}
+
+
+static OMX_ERRORTYPE BaseSetCallbacks(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_CALLBACKTYPE* pCbs, 
+            OMX_IN  OMX_PTR pAppData)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"SetCallbacks: \r\n");
+    return base->SetCallbacks(pCbs, pAppData);
+}
+
+
+static OMX_ERRORTYPE BaseComponentDeInit(
+            OMX_IN  OMX_HANDLETYPE hComponent)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"ComponentDeInit: \r\n");
+    return base->DestructComponent();
+}
+
+
+static OMX_ERRORTYPE BaseUseEGLImage(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN void* eglImage)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"UseEGLImage: Port: 0x%X, EGLImage: 0x%X \r\n",nPortIndex,eglImage);
+    return base->UseEGLImage(ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+}
+
+
+static OMX_ERRORTYPE BaseComponentRoleEnum(
+        OMX_IN OMX_HANDLETYPE hComponent,
+		OMX_OUT OMX_U8 *cRole,
+		OMX_IN OMX_U32 nIndex)
+{
+    ComponentBase *base = NULL;
+    OMX_COMPONENTTYPE *hComp = NULL;
+
+    if(hComponent == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    hComp = (OMX_COMPONENTTYPE*)hComponent;
+    base = (ComponentBase*)(hComp->pComponentPrivate);
+    OMX_COMP_API_LOG(base->name,"ComponentRoleEnum: Index: 0x%X \r\n",nIndex);
+    return base->ComponentRoleEnum(cRole, nIndex);
+}
+
+
+void *DoThread(void *arg) 
+{
+    ComponentBase *base = (ComponentBase*)arg;
+    OMX_ERRORTYPE ret1, ret2;
+
+    while(1) {
+        base->Down();
+        if(base->bStopThread == OMX_TRUE)
+            break;
+        ret1 = ret2 = OMX_ErrorNone;
+        LOG_DEBUG("Thread processing.\n");
+        while(ret1 == OMX_ErrorNone || ret2 == OMX_ErrorNone) {
+            ret1 = base->CurState->ProcessCmd();
+            ret2 = base->CurState->ProcessBuffer();
+        }
+        LOG_DEBUG("Thread processing done.\n");
+    }
+
+    LOG_DEBUG("Thread is stoped.\n");
+
+    return NULL;
+}
+
+/**< done internally used functions */
+
+ComponentBase::ComponentBase()
+{
+    OMX_U32 i;
+
+    pCmdQueue = NULL;
+    for(i=0; i<MAX_PORT_NUM; i++)
+        ports[i] = NULL;
+    states[InvalidStateIdx] = NULL;
+    states[LoadedStateIdx] = NULL;
+    states[IdleStateIdx] = NULL;
+    states[ExecutingStateIdx] = NULL;
+    states[PauseStateIdx] = NULL;
+    states[WaitForResourcesStateIdx] = NULL;
+    inContextMutex = NULL;
+    pThreadId = NULL;
+    outContextSem = NULL;
+    SemLock = NULL;
+}
+
+OMX_ERRORTYPE ComponentBase::ConstructComponent(
+        OMX_HANDLETYPE pHandle)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_U32 i;
+
+    if(pHandle == NULL)
+        return OMX_ErrorBadParameter;
+
+    SpecVersion.s.nVersionMajor = 0x1;
+    SpecVersion.s.nVersionMinor = 0x1;
+    SpecVersion.s.nRevision = 0x2;
+    SpecVersion.s.nStep = 0x0;
+
+    hComponent = (OMX_COMPONENTTYPE*)pHandle;
+    OMX_CHECK_STRUCT(hComponent, OMX_COMPONENTTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    hComponent->pComponentPrivate = this;
+    hComponent->GetComponentVersion = BaseGetComponentVersion;
+    hComponent->SendCommand = BaseSendCommand;
+    hComponent->GetParameter = BaseGetParameter;
+    hComponent->SetParameter = BaseSetParameter;
+    hComponent->GetConfig = BaseGetConfig;
+    hComponent->SetConfig = BaseSetConfig;
+    hComponent->GetExtensionIndex = BaseGetExtensionIndex;
+    hComponent->GetState = BaseGetState;
+    hComponent->ComponentTunnelRequest = BaseComponentTunnelRequest;
+    hComponent->UseBuffer = BaseUseBuffer;
+    hComponent->AllocateBuffer = BaseAllocateBuffer;
+    hComponent->FreeBuffer = BaseFreeBuffer;
+    hComponent->EmptyThisBuffer = BaseEmptyThisBuffer;
+    hComponent->FillThisBuffer = BaseFillThisBuffer;
+    hComponent->SetCallbacks = BaseSetCallbacks;
+    hComponent->ComponentDeInit = BaseComponentDeInit;
+    hComponent->UseEGLImage = BaseUseEGLImage;
+    hComponent->ComponentRoleEnum = BaseComponentRoleEnum;
+
+    pendingCmd.cmd = OMX_CommandMax;
+
+    /**< setup cmd queue */
+    pCmdQueue = FSL_NEW(Queue, ());
+    if(pCmdQueue == NULL) {
+        LOG_ERROR("New cmd queue failed.\n");
+        ret = OMX_ErrorInsufficientResources;
+        goto err;
+    }
+
+    if(pCmdQueue->Create(32, sizeof(CMD_MSG), E_FSL_OSAL_TRUE) != QUEUE_SUCCESS) {
+        LOG_ERROR("Init cmd queue failed.\n");
+        ret = OMX_ErrorUndefined;
+        goto err;
+    }
+
+    /**< setup ports */
+    if(nPorts > MAX_PORT_NUM) {
+        LOG_ERROR("Requried port number: %d more than defined: %d\n", nPorts, MAX_PORT_NUM);
+        ret = OMX_ErrorBadParameter;
+        goto err;
+    }
+
+    for(i=0; i<nPorts; i++) {
+        ports[i] = FSL_NEW(Port, (this, i));
+        if(ports[i] == NULL) {
+            LOG_ERROR("Create ports[%d] failed.\n", i);
+            ret = OMX_ErrorInsufficientResources;
+            goto err;
+        }
+
+        ret = ports[i]->Init();
+        if(ret != OMX_ErrorNone) {
+            LOG_ERROR("Init port [%d] failed\n", i);
+            goto err;
+        }
+    }
+
+    /**< setup states */
+    states[InvalidStateIdx] = FSL_NEW(InvalidState, (this));
+    states[LoadedStateIdx] = FSL_NEW(LoadedState, (this));
+    states[IdleStateIdx] = FSL_NEW(IdleState, (this));
+    states[ExecutingStateIdx] = FSL_NEW(ExecutingState, (this));
+    states[PauseStateIdx] = FSL_NEW(PauseState, (this));
+    states[WaitForResourcesStateIdx] = FSL_NEW(WaitForResourcesState, (this));
+    if(states[InvalidStateIdx] == NULL 
+            || states[LoadedStateIdx] == NULL
+            || states[IdleStateIdx] == NULL 
+            || states[ExecutingStateIdx] == NULL
+            || states[PauseStateIdx] == NULL
+            || states[WaitForResourcesStateIdx] == NULL) {
+        LOG_ERROR("Create states failed.\n");
+        ret = OMX_ErrorInsufficientResources;
+        goto err;
+    }
+
+    /**< setup mutex and thread for message processing */
+    if(bInContext == OMX_TRUE) {
+        if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&inContextMutex, fsl_osal_mutex_normal)) {
+            LOG_ERROR("Create inContext Mutex failed.\n");
+            ret = OMX_ErrorInsufficientResources;
+            goto err;
+        }
+    }
+    else {
+        SemCnt = 0;
+        bStopThread = OMX_FALSE;
+
+        if(E_FSL_OSAL_SUCCESS != fsl_osal_sem_init(&outContextSem, 0, 0)) {
+            LOG_ERROR("Create outContext Semphore failed.\n");
+            ret = OMX_ErrorInsufficientResources;
+            goto err;
+        }
+
+        if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&SemLock, fsl_osal_mutex_normal)) {
+            LOG_ERROR("Create Semphore Mutex failed.\n");
+            ret = OMX_ErrorInsufficientResources;
+            goto err;
+        }
+
+        if(E_FSL_OSAL_SUCCESS != fsl_osal_thread_create(&pThreadId, NULL, DoThread, this)) {
+            LOG_ERROR("Create outContext Thread failed.\n");
+            ret = OMX_ErrorInsufficientResources;
+            goto err;
+        }
+    }
+
+    ret = InitComponent();
+    if(ret != OMX_ErrorNone)
+        goto err;
+
+    for(i=0; i<TOTAL_PORT_PARM; i++) {
+        OMX_INIT_STRUCT(&PortParam[i], OMX_PORT_PARAM_TYPE);
+        PortParam[i].nStartPortNumber = OMX_ALL;
+    }
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    for(i=0; i<nPorts; i++) {
+        sPortDef.nPortIndex = i;
+        ports[i]->GetPortDefinition(&sPortDef);
+        switch(sPortDef.eDomain) {
+            case OMX_PortDomainAudio:
+                PortParam[AudioPortParamIdx].nPorts ++;
+                if(PortParam[AudioPortParamIdx].nStartPortNumber == OMX_ALL)
+                    PortParam[AudioPortParamIdx].nStartPortNumber = i;
+                break;
+            case OMX_PortDomainVideo:
+                PortParam[VideoPortParamIdx].nPorts ++;
+                if(PortParam[VideoPortParamIdx].nStartPortNumber == OMX_ALL)
+                    PortParam[VideoPortParamIdx].nStartPortNumber = i;
+                break;
+            case OMX_PortDomainImage: 
+                PortParam[ImagePortParamIdx].nPorts ++;
+                if(PortParam[ImagePortParamIdx].nStartPortNumber == OMX_ALL)
+                    PortParam[ImagePortParamIdx].nStartPortNumber = i;
+                break;
+            case OMX_PortDomainOther:
+                PortParam[OtherPortParamIdx].nPorts ++;
+                if(PortParam[OtherPortParamIdx].nStartPortNumber == OMX_ALL)
+                    PortParam[OtherPortParamIdx].nStartPortNumber = i;
+                break;
+            default:
+                break;
+        }
+    }
+
+    /**< set state to loaded */
+    eCurState = OMX_StateLoaded;
+    CurState = states[LoadedStateIdx];
+    LOG_DEBUG("Component %s is loaded.\n", name);
+
+    return ret;
+err:
+    DestructComponent();
+    return ret;
+}
+
+OMX_ERRORTYPE ComponentBase::DestructComponent()
+{
+    OMX_U32 i;
+
+    /**< free resources allocated by components */
+    DeInitComponent();
+
+    /**< free mutex and thread for message processing*/
+    if(bInContext == OMX_TRUE) {
+        if(inContextMutex != NULL)
+            fsl_osal_mutex_destroy(inContextMutex);
+    }
+    else {
+        if(pThreadId != NULL) {
+            bStopThread = OMX_TRUE;
+            Up();
+            fsl_osal_thread_destroy(pThreadId);
+        }
+        if(outContextSem != NULL)
+            fsl_osal_sem_destroy(outContextSem);
+        if(SemLock != NULL)
+            fsl_osal_mutex_destroy(SemLock);
+    }
+
+    /**< free cmd queue */
+    if(pCmdQueue != NULL) {
+        pCmdQueue->Free();
+        FSL_DELETE(pCmdQueue);
+    }
+
+    /**< free ports */
+    for(i=0; i<nPorts; i++) {
+        if(ports[i] != NULL) {
+            ports[i]->DeInit();
+            FSL_DELETE(ports[i]);
+        }
+    }
+
+    /**< free states */
+    if(states[InvalidStateIdx] != NULL)
+        FSL_DELETE(states[InvalidStateIdx]);
+    if(states[LoadedStateIdx] != NULL)
+        FSL_DELETE(states[LoadedStateIdx]);
+    if(states[IdleStateIdx] != NULL)
+        FSL_DELETE(states[IdleStateIdx]);
+    if(states[ExecutingStateIdx] != NULL)
+        FSL_DELETE(states[ExecutingStateIdx]);
+    if(states[PauseStateIdx] != NULL)
+        FSL_DELETE(states[PauseStateIdx]);
+    if(states[WaitForResourcesStateIdx] != NULL)
+        FSL_DELETE(states[WaitForResourcesStateIdx]);
+
+    LOG_DEBUG("%s destroyed.\n", name);
+
+    ComponentBase *own = this;
+    FSL_DELETE(own);
+
+    return OMX_ErrorNone;
+}
+
+
+OMX_ERRORTYPE ComponentBase::SetCallbacks(
+        OMX_CALLBACKTYPE* pCbs, 
+        OMX_PTR pAppData)
+{
+    pCallbacks = pCbs;
+    hComponent->pApplicationPrivate = pAppData;
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::ComponentRoleEnum(
+        OMX_U8 *cRole, OMX_U32 nIndex)
+{
+    if(nIndex >= role_cnt)
+        return OMX_ErrorBadParameter;
+
+    fsl_osal_memcpy(cRole, role[nIndex], MAX_ROLE_NAME_LEN);
+
+    return OMX_ErrorNone;
+}
+
+OMX_HANDLETYPE ComponentBase::GetComponentHandle()
+{
+    return (OMX_HANDLETYPE) hComponent;
+}
+
+OMX_ERRORTYPE ComponentBase::GetState(
+        OMX_STATETYPE *pState)
+{
+    if(pState == NULL) {
+        LOG_ERROR("pState is null in funtion GetState.\n");
+        return OMX_ErrorBadParameter;
+    }
+
+    *pState = eCurState;
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::SetState(
+        OMX_STATETYPE eState)
+{
+    eCurState = eState;
+    CurState = states[eState - OMX_StateInvalid];
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::PortNotify(OMX_U32 nPortIndex, PORT_NOTIFY_TYPE ePortNotify)
+{
+    OMX_BOOL bCmdComplete = OMX_FALSE;
+
+    /**< if Port is populated*/
+    if(ePortNotify == PORT_ON) {
+        if(pendingCmd.cmd == OMX_CommandStateSet && pendingCmd.nParam == OMX_StateIdle) {
+            if(OMX_TRUE == CheckAllPortsState(PORT_ON))
+                bCmdComplete = OMX_TRUE;
+        }
+
+        if(pendingCmd.cmd == OMX_CommandPortEnable) {
+            if(pendingCmd.nParam == OMX_ALL) {
+                if(OMX_TRUE == CheckAllPortsState(PORT_ON))
+                    bCmdComplete = OMX_TRUE;
+            }
+            else if(pendingCmd.nParam == nPortIndex) {
+                bCmdComplete = OMX_TRUE;
+            }
+        }
+    }
+    /**< if Port is un-populated*/
+    else if(ePortNotify == PORT_OFF) {
+        if(pendingCmd.cmd == OMX_CommandStateSet && pendingCmd.nParam == OMX_StateLoaded) {
+            if(OMX_TRUE == CheckAllPortsState(PORT_OFF)) {
+                bCmdComplete = OMX_TRUE;
+                DoIdle2Loaded();
+            }
+        }
+
+        /* Failed to switch Loaded to Idle */
+        if(pendingCmd.cmd == OMX_CommandStateSet && pendingCmd.nParam == OMX_StateIdle && eCurState == OMX_StateLoaded) {
+            if(OMX_TRUE == CheckAllPortsState(PORT_OFF)) {
+                DoIdle2Loaded();
+                pendingCmd.cmd = OMX_CommandMax;
+            }
+        }
+
+        if(pendingCmd.cmd == OMX_CommandPortDisable) {
+            if(pendingCmd.nParam == OMX_ALL) {
+                if(OMX_TRUE == CheckAllPortsState(PORT_ON))
+                    bCmdComplete = OMX_TRUE;
+            }
+            else if(pendingCmd.nParam == nPortIndex) {
+                bCmdComplete = OMX_TRUE;
+            }
+        }
+    }
+    else if(ePortNotify == BUFFER_RETURNED)
+        bCmdComplete = OMX_TRUE;
+
+    if(bCmdComplete == OMX_TRUE) {
+        SendEvent(OMX_EventCmdComplete, pendingCmd.cmd, pendingCmd.nParam, pendingCmd.pCmdData);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::MarkOtherPortsBuffer(
+        OMX_MARKTYPE *pMarkData)
+{
+    OMX_U32 i;
+
+    for(i=0; i<nPorts; i++) {
+        if(OMX_DirOutput == ports[i]->GetPortDir())
+            ports[i]->MarkBuffer(pMarkData);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_BOOL ComponentBase::bHasCmdToProcess()
+{
+    if(pCmdQueue == NULL)
+        return OMX_FALSE;
+
+    if(pCmdQueue->Size() > 0)
+        return OMX_TRUE;
+    else
+        return OMX_FALSE;
+}
+
+OMX_BOOL ComponentBase::CheckAllPortsState(
+        PORT_NOTIFY_TYPE ePortNotify)
+{
+    OMX_BOOL ret = OMX_TRUE;
+    OMX_U32 i;
+
+    for(i=0; i<nPorts; i++) {
+        if(ports[i]->IsEnabled() != OMX_TRUE)
+            continue;
+
+        if(ePortNotify == PORT_ON) {
+            if(ports[i]->IsPopulated() == OMX_FALSE) {
+                ret = OMX_FALSE;
+                break;
+            }
+        }
+        else if(ePortNotify == PORT_OFF) {
+            if(ports[i]->IsPopulated() == OMX_TRUE) {
+                ret = OMX_FALSE;
+                break;
+            }
+        }
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE ComponentBase::FlushComponent(
+        OMX_U32 nPortIndex) 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::ComponentReturnBuffer(
+        OMX_U32 nPortIndex)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex, 
+        OMX_PTR pAppPrivate, 
+        void* eglImage)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE ComponentBase::SendEvent(
+        OMX_EVENTTYPE eEvent, 
+        OMX_U32 nData1, 
+        OMX_U32 nData2, 
+        OMX_PTR pEventData)
+{
+    if(eEvent == OMX_EventCmdComplete) {
+        pendingCmd.cmd = OMX_CommandMax;
+        if(nData1 == OMX_CommandStateSet)
+            SetState((OMX_STATETYPE)nData2);
+    }
+
+    if(eEvent == OMX_EventError) {
+        /* Failed to switch Loaded to Idle */
+        if(pendingCmd.cmd == OMX_CommandStateSet && pendingCmd.nParam == OMX_StateIdle && eCurState == OMX_StateLoaded) {
+            if(OMX_TRUE == CheckAllPortsState(PORT_OFF)) {
+                DoIdle2Loaded();
+                pendingCmd.cmd = OMX_CommandMax;
+            }
+        }
+    }
+
+    pCallbacks->EventHandler(hComponent, hComponent->pApplicationPrivate, 
+            eEvent, nData1, nData2, pEventData);
+
+    LOG_DEBUG("SendEvent to client, [eEvent: %d, nData1: %d, nData2: %d]\n", eEvent, nData1, nData2);
+    OMX_COMP_CALLBACK_LOG(((ComponentBase*)(hComponent->pComponentPrivate))->name,"SendEvent to client, [eEvent: %d(%s), nData1: %d, nData2: %d] \r\n", eEvent,DBG_MAP_STR((OMX_U32)eEvent,&omx_map_event_str[0]), nData1, nData2);
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::EmptyDone(
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    pCallbacks->EmptyBufferDone(hComponent, hComponent->pApplicationPrivate, pBufferHdr);
+
+    LOG_DEBUG("EmptyDone to client, buffer[%p]\n", pBufferHdr);
+    OMX_COMP_CALLBACK_LOG(((ComponentBase*)(hComponent->pComponentPrivate))->name,"EmptyDone to buffer: 0x%X \r\n", pBufferHdr->pBuffer);
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::FillDone(
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    pCallbacks->FillBufferDone(hComponent, hComponent->pApplicationPrivate, pBufferHdr);
+
+    LOG_DEBUG("FillDone to client, buffer[%p]\n", pBufferHdr);
+    OMX_COMP_CALLBACK_LOG(((ComponentBase*)(hComponent->pComponentPrivate))->name,"FillDone to buffer: 0x%X \r\n", pBufferHdr->pBuffer);
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    return OMX_ErrorUnsupportedIndex;
+}
+
+OMX_ERRORTYPE ComponentBase::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    return OMX_ErrorUnsupportedIndex;
+}
+
+OMX_ERRORTYPE ComponentBase::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    return OMX_ErrorUnsupportedIndex;
+}
+
+OMX_ERRORTYPE ComponentBase::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    return OMX_ErrorUnsupportedIndex;
+}
+
+OMX_ERRORTYPE ComponentBase::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE ComponentBase::PortFormatChanged(
+        OMX_U32 nPortIndex)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::DoAllocateBuffer(
+        OMX_PTR *buffer,
+        OMX_U32 nSize,
+        OMX_U32 nPortIndex)
+{
+    OMX_PTR ptr = NULL;
+
+    if(buffer == NULL) {
+        LOG_ERROR("buffer pointer is null in function DoAllocateBuffer.\n");
+        return OMX_ErrorBadParameter;
+    }
+
+    ptr = FSL_MALLOC(nSize);
+    if(ptr == NULL) {
+        LOG_ERROR("Allocate memory failed, size: %d\n", nSize);
+        return OMX_ErrorInsufficientResources;
+    }
+
+    fsl_osal_memset(ptr, 0, nSize);
+    *buffer = ptr;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::DoFreeBuffer(
+        OMX_PTR buffer,
+        OMX_U32 nPortIndex) 
+{
+    FSL_FREE(buffer);
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::DoLoaded2Idle() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::DoIdle2Loaded() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::InstanceInit() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::InstanceDeInit() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::DoExec2Pause() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::DoPause2Exec() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::ProcessInContext(
+        MSG_TYPE msg)
+{
+    OMX_ERRORTYPE ret1, ret2;
+
+    if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_trylock(inContextMutex)) {
+        fsl_osal_u32 id = 0;
+        fsl_osal_thread_self(&id);
+        if(id == InContextThreadId) {
+            DelayedInContextMsgList.Add(&msg);
+            return OMX_ErrorNone;
+        }
+        else
+            fsl_osal_mutex_lock(inContextMutex);
+    }
+
+    fsl_osal_thread_self(&InContextThreadId);
+
+    while(1) {
+        if(msg == COMMAND)
+            CurState->ProcessCmd();
+        else if(msg == BUFFER)
+            CurState->ProcessBuffer();
+
+        if(DelayedInContextMsgList.GetNodeCnt() == 0)
+            break;
+
+        MSG_TYPE *pMsg = NULL;
+        pMsg = DelayedInContextMsgList.GetNode(0);
+        msg = *pMsg;
+        DelayedInContextMsgList.Remove(pMsg);
+    };
+
+    fsl_osal_mutex_unlock(inContextMutex);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::ProcessOutContext(
+        MSG_TYPE msg) 
+{
+    Up();
+        
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::Up() 
+{
+    fsl_osal_mutex_lock(SemLock);
+    if(SemCnt == 0) {
+        SemCnt = 1;
+        fsl_osal_sem_post(outContextSem);
+    }
+    fsl_osal_mutex_unlock(SemLock);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::Down() 
+{
+    fsl_osal_sem_wait(outContextSem);
+    fsl_osal_mutex_lock(SemLock);
+    SemCnt --;
+    fsl_osal_mutex_unlock(SemLock);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ComponentBase::ProcessClkBuffer() 
+{
+    return OMX_ErrorNoMore;
+}
+
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/ComponentBase.h b/OpenMAXIL/src/component/common/ComponentBase.h
new file mode 100755
index 0000000..9a0169f
--- /dev/null
+++ b/OpenMAXIL/src/component/common/ComponentBase.h
@@ -0,0 +1,104 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file ComponentBase.h
+ *  @brief Base class definition of component
+ *  @ingroup ComponentBase
+ */
+
+#ifndef ComponentBase_h
+#define ComponentBase_h
+
+#include "ComponentCommon.h"
+#include "Port.h"
+#include "Queue.h"
+#include "State.h"
+#include "List.h"
+
+class ComponentBase {
+    public:
+        friend class State;
+        friend class LoadedState;
+        friend class IdleState;
+        friend class ExecutingState;
+        friend class PauseState;
+        friend void *DoThread(void *arg);
+        State *CurState; /**< stores the instance of current state */
+        ComponentBase();
+        virtual ~ComponentBase() {};
+        OMX_ERRORTYPE ConstructComponent(OMX_HANDLETYPE pHandle);
+        OMX_ERRORTYPE DestructComponent();
+        OMX_ERRORTYPE SetCallbacks(OMX_CALLBACKTYPE* pCbs, OMX_PTR pAppData);
+        OMX_ERRORTYPE ComponentRoleEnum(OMX_U8 *cRole, OMX_U32 nIndex);
+        OMX_HANDLETYPE GetComponentHandle();
+        OMX_ERRORTYPE GetState(OMX_STATETYPE* pState);
+        OMX_ERRORTYPE SetState(OMX_STATETYPE eState);
+        OMX_ERRORTYPE SendEvent(OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
+        OMX_ERRORTYPE EmptyDone(OMX_BUFFERHEADERTYPE* pBufferHdr);
+        OMX_ERRORTYPE FillDone(OMX_BUFFERHEADERTYPE* pBufferHdr);
+        OMX_ERRORTYPE PortNotify(OMX_U32 nPortIndex, PORT_NOTIFY_TYPE ePortNotify);
+        OMX_ERRORTYPE MarkOtherPortsBuffer(OMX_MARKTYPE *pMarkData);
+        OMX_BOOL bHasCmdToProcess();
+        virtual OMX_ERRORTYPE DoAllocateBuffer(OMX_PTR *buffer, OMX_U32 nSize,OMX_U32 nPortIndex);
+        virtual OMX_ERRORTYPE DoFreeBuffer(OMX_PTR buffer,OMX_U32 nPortIndex);
+        virtual OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+        virtual OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage);
+        OMX_U8 name[MAX_NAME_LEN];
+    protected:
+
+        OMX_VERSIONTYPE ComponentVersion;
+        OMX_U32 role_cnt; /**< how many roles this component supported */
+        OMX_STRING role[MAX_COMPONENT_ROLE]; /**< store all the roles this component supported */
+        OMX_BOOL bInContext;
+        OMX_U32 nPorts;
+        Port *ports[MAX_PORT_NUM]; /**< store all the port instance this component have */
+        OMX_PORT_PARAM_TYPE PortParam[TOTAL_PORT_PARM];
+    private:
+        OMX_VERSIONTYPE SpecVersion;
+        OMX_COMPONENTTYPE *hComponent;
+        OMX_CALLBACKTYPE *pCallbacks;
+        fsl_osal_ptr pThreadId;
+        fsl_osal_sem outContextSem;
+        fsl_osal_mutex SemLock;
+        OMX_S32 SemCnt;
+        OMX_BOOL bStopThread;
+        fsl_osal_mutex inContextMutex;
+        fsl_osal_u32 InContextThreadId;
+        List<MSG_TYPE> DelayedInContextMsgList;
+        OMX_STATETYPE eCurState;
+        State *states[TOTAL_STATE]; /**< stores all the instance of each state */
+        Queue *pCmdQueue;
+        PENDING_CMD pendingCmd; /**< stores the current processing command */
+        virtual OMX_ERRORTYPE InitComponent() = 0;
+        virtual OMX_ERRORTYPE DeInitComponent() = 0;
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        virtual OMX_ERRORTYPE PortFormatChanged(OMX_U32 nPortIndex);
+        virtual OMX_ERRORTYPE InstanceInit();
+        virtual OMX_ERRORTYPE InstanceDeInit();
+        virtual OMX_ERRORTYPE DoLoaded2Idle();
+        virtual OMX_ERRORTYPE DoIdle2Loaded();
+        virtual OMX_ERRORTYPE DoExec2Pause();
+        virtual OMX_ERRORTYPE DoPause2Exec();
+        OMX_ERRORTYPE ProcessInContext(MSG_TYPE msg);
+        OMX_ERRORTYPE ProcessOutContext(MSG_TYPE msg);
+        OMX_ERRORTYPE Up();
+        OMX_ERRORTYPE Down();
+        virtual OMX_ERRORTYPE ProcessClkBuffer();
+        virtual OMX_ERRORTYPE ProcessDataBuffer() = 0;
+        OMX_BOOL CheckAllPortsState(PORT_NOTIFY_TYPE ePortNotify);
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/ComponentCommon.h b/OpenMAXIL/src/component/common/ComponentCommon.h
new file mode 100755
index 0000000..3d5b491
--- /dev/null
+++ b/OpenMAXIL/src/component/common/ComponentCommon.h
@@ -0,0 +1,187 @@
+/**
+ *  Copyright (c) 2009-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file ComponentCommon.h
+ *  @brief Components common defines 
+ *  @ingroup ComponentCommon
+ */
+
+#ifndef ComponentCommon_h
+#define ComponentCommon_h
+
+#include "OMX_Implement.h"
+#include "PlatformResourceMgrItf.h"
+#include "fsl_osal.h"
+#include "Mem.h"
+#include "Log.h"
+
+#include "OMX_Core.h"
+#include "OMX_Component.h"    
+
+#define MAX_COMPONENT_ROLE 8
+#define MAX_ROLE_NAME_LEN 128
+
+#define TOTAL_STATE 6
+#define InvalidStateIdx          0
+#define LoadedStateIdx           1
+#define IdleStateIdx             2
+#define ExecutingStateIdx        3
+#define PauseStateIdx            4
+#define WaitForResourcesStateIdx 5
+
+#define TOTAL_PORT_PARM          4
+#define AudioPortParamIdx        0
+#define VideoPortParamIdx        1
+#define ImagePortParamIdx        2
+#define OtherPortParamIdx        3
+
+
+#define OMX_TIME_UpdateVideoLate ((OMX_TIME_UPDATETYPE)(OMX_TIME_UpdateVendorStartUnused + 1))
+#define OMX_IndexConfigTimeVideoLate FSL_INDEXTYPE(256)  /* OMX_TIME_CONFIG_TIMEVIDEOLATE */
+
+#define OMX_CHECK_STRUCT(ptr, type, err) \
+    do { \
+        if((ptr)->nSize != sizeof(type)) err = OMX_ErrorBadParameter; \
+        if(((ptr)->nVersion.s.nVersionMajor != 0x1)|| \
+                ((ptr)->nVersion.s.nVersionMinor != 0x1 &&\
+				(ptr)->nVersion.s.nVersionMinor != 0x0 )) \
+        err = OMX_ErrorVersionMismatch; \
+    } while(0);
+
+#define WAIT_CONDTION(cond, state, to) \
+    do { \
+        OMX_S32 cnt = to/10000 ; \
+        while (cond != state) { \
+            fsl_osal_sleep(10000); \
+            cnt --; \
+            if(cnt <= 0) { \
+                LOG_ERROR("wait condition timeout.\n"); \
+                return OMX_ErrorTimeout; \
+            } \
+        } \
+    } while(0);
+
+typedef enum{
+    COMMAND = 1,
+    BUFFER
+}MSG_TYPE;
+
+typedef enum {
+    PORT_ON = 1,
+    PORT_OFF,
+    BUFFER_RETURNED
+}PORT_NOTIFY_TYPE;
+
+typedef struct {
+    OMX_COMMANDTYPE Cmd;
+    OMX_U32 nParam;
+    OMX_PTR pCmdData;
+}CMD_MSG;
+
+typedef struct {
+    OMX_COMMANDTYPE cmd;
+    OMX_U32 nParam;
+    OMX_PTR pCmdData;
+    OMX_BOOL bProcessed;
+}PENDING_CMD;
+
+typedef struct {
+    OMX_HANDLETYPE hTunneledComp;
+    OMX_U32 nTunneledPort;
+}TUNNEL_INFO;
+
+typedef struct {
+    OMX_U32 nSize; 
+    OMX_VERSIONTYPE nVersion; 
+    OMX_U32 nPortIndex;
+    OMX_BOOL bLate;
+}OMX_TIME_CONFIG_TIMEVIDEOLATE;
+
+class ComponentBase;
+class Port;
+class State;
+
+static OMX_U32 pxlfmt2bpp(OMX_COLOR_FORMATTYPE omx_pxlfmt)
+{
+	OMX_U32 bpp; // bit per pixel
+
+	switch((int)omx_pxlfmt) {
+	case OMX_COLOR_FormatMonochrome:
+	  bpp = 1;
+	  break;
+	case OMX_COLOR_FormatL2:
+	  bpp = 2;
+	  break;
+	case OMX_COLOR_FormatL4:
+	  bpp = 4;
+	  break;
+	case OMX_COLOR_FormatL8:
+	case OMX_COLOR_Format8bitRGB332:
+	case OMX_COLOR_FormatRawBayer8bit:
+	case OMX_COLOR_FormatRawBayer8bitcompressed:
+	  bpp = 8;
+	  break;
+	case OMX_COLOR_FormatRawBayer10bit:
+	  bpp = 10;
+	  break;
+	case OMX_COLOR_FormatYUV411Planar:
+	case OMX_COLOR_FormatYUV411PackedPlanar:
+	case OMX_COLOR_Format12bitRGB444:
+	case OMX_COLOR_FormatYUV420Planar:
+	case OMX_COLOR_FormatYUV420PackedPlanar:
+	case OMX_COLOR_FormatYUV420SemiPlanar:
+	case OMX_COLOR_FormatYUV444Interleaved:
+	  bpp = 12;
+	  break;
+	case OMX_COLOR_FormatL16:
+	case OMX_COLOR_Format16bitARGB4444:
+	case OMX_COLOR_Format16bitARGB1555:
+	case OMX_COLOR_Format16bitRGB565:
+	case OMX_COLOR_Format16bitBGR565:
+	case OMX_COLOR_FormatYUV422Planar:
+	case OMX_COLOR_FormatYUV422PackedPlanar:
+	case OMX_COLOR_FormatYUV422SemiPlanar:
+	case OMX_COLOR_FormatYCbYCr:
+	case OMX_COLOR_FormatYCrYCb:
+	case OMX_COLOR_FormatCbYCrY:
+	case OMX_COLOR_FormatCrYCbY:
+	  bpp = 16;
+	  break;
+	case OMX_COLOR_Format18bitRGB666:
+	case OMX_COLOR_Format18bitARGB1665:
+	  bpp = 18;
+	  break;
+	case OMX_COLOR_Format19bitARGB1666:
+	  bpp = 19;
+	  break;
+	case OMX_COLOR_FormatL24:
+	case OMX_COLOR_Format24bitRGB888:
+	case OMX_COLOR_Format24bitBGR888:
+	case OMX_COLOR_Format24bitARGB1887:
+	  bpp = 24;
+	  break;
+	case OMX_COLOR_Format25bitARGB1888:
+	  bpp = 25;
+	  break;
+	case OMX_COLOR_FormatL32:
+	case OMX_COLOR_Format32bitBGRA8888:
+	case OMX_COLOR_Format32bitARGB8888:
+	case OMX_COLOR_Format32bitRGBA8888:
+	  bpp = 32;
+	  break;
+	default:
+	  bpp = 0;
+	  break;
+	}
+	return bpp;
+}
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/ExecutingState.cpp b/OpenMAXIL/src/component/common/ExecutingState.cpp
new file mode 100755
index 0000000..1ecdbb7
--- /dev/null
+++ b/OpenMAXIL/src/component/common/ExecutingState.cpp
@@ -0,0 +1,226 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "ExecutingState.h"
+
+OMX_ERRORTYPE ExecutingState::GetVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    return State::DoGetComponentVersion(
+            pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+}
+
+OMX_ERRORTYPE ExecutingState::SendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam, 
+        OMX_PTR pCmdData)
+{
+    return State::DoSendCommand(Cmd, nParam, pCmdData);
+}
+
+OMX_ERRORTYPE ExecutingState::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    return State::DoEmptyThisBuffer(pBufferHdr);
+}
+
+OMX_ERRORTYPE ExecutingState::FillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    return State::DoFillThisBuffer(pBufferHdr);
+}
+
+OMX_ERRORTYPE ExecutingState::ProcessBuffer() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = base->ProcessClkBuffer();
+    if(ret == OMX_ErrorNoMore) {
+        ret = base->ProcessDataBuffer();
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE ExecutingState::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetParameter(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE ExecutingState::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    OMX_U32 i;
+    OMX_BOOL bHasPortDisabled = OMX_FALSE;
+
+    for(i=0; i<base->nPorts; i++) {
+        if(base->ports[i]->IsEnabled() == OMX_FALSE) {
+            bHasPortDisabled = OMX_TRUE;
+            break;
+        }
+    }
+
+    if(bHasPortDisabled == OMX_TRUE)
+        return State::DoSetParameter(nParamIndex, pComponentParameterStructure);
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE ExecutingState::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE ExecutingState::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoSetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE ExecutingState::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return State::DoGetExtensionIndex(cParameterName, pIndexType);
+}
+
+OMX_ERRORTYPE ExecutingState::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_ENABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoUseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE ExecutingState::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void *eglImage) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_ENABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoUseEGLImage(ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE ExecutingState::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_ENABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoAllocateBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE ExecutingState::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_DISABLING(nPortIndex) == OMX_TRUE) {
+		/* Change longer for drain component internal data when port disable */
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 5000000);
+        return State::DoFreeBuffer(nPortIndex, pBufferHdr);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE ExecutingState::TunnelRequest(
+        OMX_U32 nPort, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    if(nPort >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(base->ports[nPort]->IsEnabled() != OMX_TRUE)
+        return State::DoTunnelRequest(nPort, hTunneledComp, nTunneledPort, pTunnelSetup);
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE ExecutingState::ToInvalid() 
+{
+    //TODO
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE ExecutingState::ToLoaded() 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE ExecutingState::ToWaitForResources() 
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE ExecutingState::ToIdle() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 i;
+
+    base->InstanceDeInit();
+
+    for(i=0; i<base->nPorts; i++) {
+        if(OMX_ErrorNone != base->ports[i]->ReturnBuffers())
+            ret = OMX_ErrorNotComplete;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE ExecutingState::ToPause() 
+{
+    return base->DoExec2Pause();
+}
+
+OMX_ERRORTYPE ExecutingState::ToExecuting() 
+{
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/ExecutingState.h b/OpenMAXIL/src/component/common/ExecutingState.h
new file mode 100755
index 0000000..e2d954f
--- /dev/null
+++ b/OpenMAXIL/src/component/common/ExecutingState.h
@@ -0,0 +1,56 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file ExecutingState.h
+ *  @brief class definition of ExecutingState
+ *  @ingroup State
+ */
+
+#ifndef ExecutingState_h
+#define ExecutingState_h
+
+#include "State.h"
+
+class ExecutingState : public State {
+    public:
+        ExecutingState(ComponentBase *pBase) : State(pBase) {};
+        virtual OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                         OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID);
+        virtual OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData);
+        virtual OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE ProcessBuffer();
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        virtual OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, void *eglImage);
+        virtual OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                             OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        virtual OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE TunnelRequest(OMX_U32 nPort, OMX_HANDLETYPE hTunneledComp,
+                                            OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+    private:
+        OMX_ERRORTYPE ToInvalid();
+        OMX_ERRORTYPE ToLoaded();
+        OMX_ERRORTYPE ToWaitForResources();
+        OMX_ERRORTYPE ToIdle();
+        OMX_ERRORTYPE ToPause();
+        OMX_ERRORTYPE ToExecuting();
+        OMX_ERRORTYPE DoGetParameter();
+
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/IdleState.cpp b/OpenMAXIL/src/component/common/IdleState.cpp
new file mode 100755
index 0000000..eb820b4
--- /dev/null
+++ b/OpenMAXIL/src/component/common/IdleState.cpp
@@ -0,0 +1,241 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "IdleState.h"
+
+OMX_ERRORTYPE IdleState::GetVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    return State::DoGetComponentVersion(
+            pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+}
+
+OMX_ERRORTYPE IdleState::SendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam, 
+        OMX_PTR pCmdData)
+{
+    return State::DoSendCommand(Cmd, nParam, pCmdData);
+}
+
+OMX_ERRORTYPE IdleState::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    return State::DoEmptyThisBuffer(pBufferHdr);
+}
+
+OMX_ERRORTYPE IdleState::FillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    return State::DoFillThisBuffer(pBufferHdr);
+}
+
+OMX_ERRORTYPE IdleState::ProcessBuffer() 
+{
+    return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetParameter(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE IdleState::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    OMX_U32 i;
+    OMX_BOOL bHasPortDisabled = OMX_FALSE;
+
+    for(i=0; i<base->nPorts; i++) {
+        if(base->ports[i]->IsEnabled() == OMX_FALSE) {
+            bHasPortDisabled = OMX_TRUE;
+            break;
+        }
+    }
+
+    if(bHasPortDisabled == OMX_TRUE)
+        return State::DoSetParameter(nParamIndex, pComponentParameterStructure);
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE IdleState::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoSetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE IdleState::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return State::DoGetExtensionIndex(cParameterName, pIndexType);
+}
+
+OMX_ERRORTYPE IdleState::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(base->ports[nPortIndex]->IsEnabled() != OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoUseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void *eglImage) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(base->ports[nPortIndex]->IsEnabled() != OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoUseEGLImage(ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(base->ports[nPortIndex]->IsEnabled() != OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoAllocateBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    /* check if component in loaded->idle state trans
+     * or port is disabling */
+    if((base->pendingCmd.cmd == OMX_CommandStateSet && base->pendingCmd.nParam == OMX_StateLoaded)
+            || (IS_PORT_DISABLING(nPortIndex) == OMX_TRUE)) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoFreeBuffer(nPortIndex, pBufferHdr);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::TunnelRequest(
+        OMX_U32 nPort, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    if(nPort >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(base->ports[nPort]->IsEnabled() != OMX_TRUE)
+        return State::DoTunnelRequest(nPort, hTunneledComp, nTunneledPort, pTunnelSetup);
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE IdleState::ToInvalid() 
+{
+    //TODO
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE IdleState::ToLoaded() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 i;
+
+    for(i=0; i<base->nPorts; i++) {
+        if(base->ports[i]->IsEnabled() != OMX_TRUE)
+            continue;
+
+        if(base->ports[i]->IsTunneled() == OMX_TRUE
+                && base->ports[i]->IsSupplier() == OMX_TRUE) {
+            base->ports[i]->SupplierFreeBuffers();
+        }
+
+        ret = OMX_ErrorNotComplete;
+    }
+	
+    if (ret == OMX_ErrorNone)
+        base->DoIdle2Loaded();
+
+    return ret;
+}
+
+OMX_ERRORTYPE IdleState::ToWaitForResources() 
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE IdleState::ToIdle() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE IdleState::ToPause() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = base->InstanceInit();
+    if(ret != OMX_ErrorNone)
+        base->InstanceDeInit();
+
+    return ret;
+}
+
+OMX_ERRORTYPE IdleState::ToExecuting() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = base->InstanceInit();
+    if(ret != OMX_ErrorNone)
+        base->InstanceDeInit();
+
+    return ret;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/IdleState.h b/OpenMAXIL/src/component/common/IdleState.h
new file mode 100755
index 0000000..f0340b6
--- /dev/null
+++ b/OpenMAXIL/src/component/common/IdleState.h
@@ -0,0 +1,56 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file IdleState.h
+ *  @brief class definition of IdleState
+ *  @ingroup State
+ */
+
+#ifndef IdleState_h
+#define IdleState_h
+
+#include "State.h"
+
+class IdleState : public State {
+    public:
+        IdleState(ComponentBase *pBase) : State(pBase) {};
+        virtual OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                         OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID);
+        virtual OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData);
+        virtual OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE ProcessBuffer();
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        virtual OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, void *eglImage);
+        virtual OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                             OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        virtual OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE TunnelRequest(OMX_U32 nPort, OMX_HANDLETYPE hTunneledComp,
+                                            OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+    private:
+        OMX_ERRORTYPE ToInvalid();
+        OMX_ERRORTYPE ToLoaded();
+        OMX_ERRORTYPE ToWaitForResources();
+        OMX_ERRORTYPE ToIdle();
+        OMX_ERRORTYPE ToPause();
+        OMX_ERRORTYPE ToExecuting();
+        OMX_ERRORTYPE DoGetParameter();
+
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/InvalidState.cpp b/OpenMAXIL/src/component/common/InvalidState.cpp
new file mode 100755
index 0000000..acaea05
--- /dev/null
+++ b/OpenMAXIL/src/component/common/InvalidState.cpp
@@ -0,0 +1,155 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "InvalidState.h"
+
+OMX_ERRORTYPE InvalidState::GetVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::SendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam1, 
+        OMX_PTR pCmdData)
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::FillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::ProcessBuffer() 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void *eglImage) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBuffer, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::TunnelRequest(
+        OMX_U32 nPort, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE InvalidState::ToInvalid() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE InvalidState::ToLoaded() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+OMX_ERRORTYPE InvalidState::ToWaitForResources() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+OMX_ERRORTYPE InvalidState::ToIdle() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+OMX_ERRORTYPE InvalidState::ToPause() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+OMX_ERRORTYPE InvalidState::ToExecuting() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/InvalidState.h b/OpenMAXIL/src/component/common/InvalidState.h
new file mode 100755
index 0000000..e1eaa6a
--- /dev/null
+++ b/OpenMAXIL/src/component/common/InvalidState.h
@@ -0,0 +1,56 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file InvalidState.h
+ *  @brief class definition of InvalidState
+ *  @ingroup State
+ */
+
+#ifndef InvalidState_h
+#define InvalidState_h
+
+#include "State.h"
+
+class InvalidState : public State {
+    public:
+        InvalidState(ComponentBase *pBase) : State(pBase) {};
+        virtual OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                         OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID);
+        virtual OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData);
+        virtual OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE ProcessBuffer();
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        virtual OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, void *eglImage);
+        virtual OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                             OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        virtual OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE TunnelRequest(OMX_U32 nPort, OMX_HANDLETYPE hTunneledComp,
+                                            OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+    private:
+        OMX_ERRORTYPE ToInvalid();
+        OMX_ERRORTYPE ToLoaded();
+        OMX_ERRORTYPE ToWaitForResources();
+        OMX_ERRORTYPE ToIdle();
+        OMX_ERRORTYPE ToPause();
+        OMX_ERRORTYPE ToExecuting();
+        OMX_ERRORTYPE DoGetParameter();
+
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/LoadedState.cpp b/OpenMAXIL/src/component/common/LoadedState.cpp
new file mode 100755
index 0000000..79b174d
--- /dev/null
+++ b/OpenMAXIL/src/component/common/LoadedState.cpp
@@ -0,0 +1,219 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "LoadedState.h"
+
+OMX_ERRORTYPE LoadedState::GetVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    return State::DoGetComponentVersion(
+            pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+}
+
+OMX_ERRORTYPE LoadedState::SendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam, 
+        OMX_PTR pCmdData)
+{
+    return State::DoSendCommand(Cmd, nParam, pCmdData);
+}
+
+OMX_ERRORTYPE LoadedState::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE LoadedState::FillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE LoadedState::ProcessBuffer() 
+{
+    return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE LoadedState::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetParameter(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE LoadedState::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoSetParameter(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE LoadedState::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE LoadedState::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoSetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE LoadedState::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return State::DoGetExtensionIndex(cParameterName, pIndexType);
+}
+
+OMX_ERRORTYPE LoadedState::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    /* check if component in loaded->idle state trans*/
+    if(base->pendingCmd.cmd == OMX_CommandStateSet
+            && base->pendingCmd.nParam == OMX_StateIdle) {
+		/* FIXME: workround for ALSA open need long time */
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 1000000);
+        if(base->pendingCmd.cmd != OMX_CommandStateSet)
+            return OMX_ErrorIncorrectStateOperation;
+        return State::DoUseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+    }
+    else{
+       OMX_S32 nCount =1000;
+        do{
+            fsl_osal_sleep(1000);
+            nCount--;
+            if(nCount <=0){ 
+                LOG_WARNING("%s UseBuffer in wrong state\n",base->name);
+                return OMX_ErrorIncorrectStateOperation;
+            }
+        }while(base->pendingCmd.cmd !=OMX_CommandStateSet || base->pendingCmd.nParam != OMX_StateIdle);
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 1000000);
+        return State::DoUseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+    }
+}
+
+OMX_ERRORTYPE LoadedState::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void *eglImage) 
+{
+    /* check if component in loaded->idle state trans*/
+    if(base->pendingCmd.cmd == OMX_CommandStateSet
+            && base->pendingCmd.nParam == OMX_StateIdle) {
+		/* FIXME: workround for ALSA open need long time */
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 1000000);
+        if(base->pendingCmd.cmd != OMX_CommandStateSet)
+            return OMX_ErrorIncorrectStateOperation;
+        return State::DoUseEGLImage(ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE LoadedState::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    /* check if component in loaded->idle state trans*/
+    if(base->pendingCmd.cmd == OMX_CommandStateSet
+            && base->pendingCmd.nParam == OMX_StateIdle) {
+		/* FIXME: workround for ALSA and camera open need long time */
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 3000000);
+        if(base->pendingCmd.cmd != OMX_CommandStateSet)
+            return OMX_ErrorIncorrectStateOperation;
+        return State::DoAllocateBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE LoadedState::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    return State::DoFreeBuffer(nPortIndex, pBufferHdr);
+}
+
+OMX_ERRORTYPE LoadedState::TunnelRequest(
+        OMX_U32 nPort, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    return State::DoTunnelRequest(nPort, hTunneledComp, nTunneledPort, pTunnelSetup);
+}
+
+OMX_ERRORTYPE LoadedState::ToInvalid() 
+{
+    //TODO
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE LoadedState::ToLoaded() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE LoadedState::ToWaitForResources() 
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE LoadedState::ToIdle() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 i;
+
+    ret = base->DoLoaded2Idle();
+    if(ret != OMX_ErrorNone) {
+        base->DoIdle2Loaded();
+        return ret;
+    }
+
+    for(i=0; i<base->nPorts; i++) {
+        if(base->ports[i]->IsEnabled() != OMX_TRUE)
+            continue;
+
+        if(base->ports[i]->IsTunneled() == OMX_TRUE
+                && base->ports[i]->IsSupplier() == OMX_TRUE) {
+            base->ports[i]->SupplierAllocateBuffers();
+        }
+
+        ret = OMX_ErrorNotComplete;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE LoadedState::ToPause() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+OMX_ERRORTYPE LoadedState::ToExecuting() 
+{
+    return OMX_ErrorIncorrectStateTransition;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/LoadedState.h b/OpenMAXIL/src/component/common/LoadedState.h
new file mode 100755
index 0000000..de877b8
--- /dev/null
+++ b/OpenMAXIL/src/component/common/LoadedState.h
@@ -0,0 +1,56 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file LoadedState.h
+ *  @brief class definition of LoadedState
+ *  @ingroup State
+ */
+
+#ifndef LoadedState_h
+#define LoadedState_h
+
+#include "State.h"
+
+class LoadedState : public State {
+    public:
+        LoadedState(ComponentBase *pBase) : State(pBase) {};
+        virtual OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                         OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID);
+        virtual OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData);
+        virtual OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE ProcessBuffer();
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        virtual OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, void *eglImage);
+        virtual OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                             OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        virtual OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE TunnelRequest(OMX_U32 nPort, OMX_HANDLETYPE hTunneledComp,
+                                            OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+    private:
+        OMX_ERRORTYPE ToInvalid();
+        OMX_ERRORTYPE ToLoaded();
+        OMX_ERRORTYPE ToWaitForResources();
+        OMX_ERRORTYPE ToIdle();
+        OMX_ERRORTYPE ToPause();
+        OMX_ERRORTYPE ToExecuting();
+        OMX_ERRORTYPE DoGetParameter();
+
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/Makefile b/OpenMAXIL/src/component/common/Makefile
new file mode 100755
index 0000000..7a39d04
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Makefile
@@ -0,0 +1,52 @@
+#####################################################################################
+#
+#   Copyright (c) 2009-2011, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+#Set the root directory
+OMX_ROOT_DIR=../../../..
+
+#Set the component directory
+OMX_COMPONENT_DEFINE_DIR=..
+
+# Set the BUILD information 
+include $(OMX_COMPONENT_DEFINE_DIR)/Makefile_component.defines
+
+COMPONENT_SO_NAME=$(COMMON_SO_NAME)
+
+LFLAGS+= -l_omx_core_mgr_v2_$(PROCESSOR)_$(OSTYPE)
+
+SOURCE_FILES = $(SRC_DIR)/ComponentBase.cpp \
+               $(SRC_DIR)/ExecutingState.cpp \
+               $(SRC_DIR)/IdleState.cpp \
+               $(SRC_DIR)/InvalidState.cpp \
+               $(SRC_DIR)/LoadedState.cpp \
+               $(SRC_DIR)/PauseState.cpp \
+               $(SRC_DIR)/Port.cpp \
+               $(SRC_DIR)/State.cpp \
+               $(SRC_DIR)/WaitForResourcesState.cpp \
+               $(SRC_DIR)/AudioParserBase.cpp \
+               $(SRC_DIR)/AudioFilter.cpp \
+               $(SRC_DIR)/AudioRender.cpp \
+	       $(SRC_DIR)/Parser.cpp \
+	       $(SRC_DIR)/Muxer.cpp \
+	       $(SRC_DIR)/VideoFilter.cpp \
+	       $(SRC_DIR)/VideoSource.cpp \
+	       $(SRC_DIR)/AudioSource.cpp \
+	       $(SRC_DIR)/VideoRender.cpp
+              
+#Include rules Makefile
+include $(OMX_COMPONENT_DEFINE_DIR)/Makefile.rules	
+
+
+
diff --git a/OpenMAXIL/src/component/common/Muxer.cpp b/OpenMAXIL/src/component/common/Muxer.cpp
new file mode 100755
index 0000000..de98064
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Muxer.cpp
@@ -0,0 +1,1135 @@
+/**
+ *  Copyright (c) 2011-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Muxer.h"
+
+#define MAX_INTERLEAVE (5*OMX_TICKS_PER_SECOND)
+// Reserved space for MP4 Muxer meta data for every sample.
+#define MP4MUXER_METADATA_SIZE (50)
+
+FslFileHandle OpenContentCb(
+        const uint8 *fileName, 
+        const uint8 *mode, 
+        void *context)
+{
+    Muxer *hMuxer = (Muxer*)context;
+    if(hMuxer == NULL)
+        return NULL;
+
+    return hMuxer->OpenContent(CP_AccessWrite);
+}
+
+int32 CloseContentCb(
+        FslFileHandle handle, 
+        void *context) 
+{
+    Muxer *hMuxer = (Muxer*)context;
+    if(hMuxer == NULL)
+        return -1;
+
+    hMuxer->CloseContent(handle);
+
+    return 0;
+}
+
+uint32 WriteContentCb(
+        FslFileHandle handle, 
+        void *buffer, 
+        uint32 size, 
+        void *context)
+{
+    Muxer *hMuxer = (Muxer*)context;
+    if(hMuxer == NULL)
+        return 0;
+
+    return hMuxer->WriteContent(handle, buffer, size);
+}
+
+int32 SeekContentCb(
+        FslFileHandle handle, 
+        int64 offset, 
+        int32 whence, 
+        void *context)
+{
+    Muxer *hMuxer = (Muxer*)context;
+    if(hMuxer == NULL)
+        return -1;
+
+    CP_ORIGINTYPE eOrigin = CP_OriginBegin;
+    if(whence == FSL_SEEK_SET)
+        eOrigin = CP_OriginBegin;
+    else if(whence == FSL_SEEK_CUR)
+        eOrigin = CP_OriginCur;
+    else if(whence == FSL_SEEK_END)
+        eOrigin = CP_OriginEnd;
+
+    if(OMX_ErrorNone != hMuxer->SeekContent(handle, offset, eOrigin))
+        return -1;
+
+    return 0;
+}
+
+int64 TellContentCb(
+        FslFileHandle handle, 
+        void * context)
+{
+    Muxer *hMuxer = (Muxer*)context;
+    if(hMuxer == NULL)
+        return -1;
+
+    return hMuxer->TellContent(handle);
+}
+
+void *CallocCb(uint32 numElements, uint32 size)
+{
+    OMX_PTR ptr = FSL_MALLOC(numElements * size);
+    if(ptr != NULL)
+        fsl_osal_memset(ptr, 0, numElements * size);
+
+    return ptr;
+}
+
+void *MallocCb(uint32 size)
+{
+    return FSL_MALLOC(size);
+}
+
+void FreeCb(void * ptr)
+{
+    FSL_FREE(ptr);
+}
+
+void *ReAllocCb(void * ptr, uint32 size)
+{
+    return FSL_REALLOC(ptr, size);
+}
+
+Muxer::Muxer()
+{
+    bInContext = OMX_FALSE;
+}
+
+OMX_PTR Muxer::OpenContent(CP_ACCESSTYPE eAccess)
+{
+    if(pURL == NULL || hPipe == NULL)
+        return NULL;
+
+    hContent = NULL;
+    if(0 != hPipe->Open(&hContent, (CPstring)pURL, eAccess))
+        return NULL;
+
+    return hContent;
+}
+
+OMX_ERRORTYPE Muxer::CloseContent(OMX_PTR hContent)
+{
+    if(hContent == NULL || hPipe == NULL)
+        return OMX_ErrorBadParameter;
+
+    hPipe->Close(hContent);
+
+    return OMX_ErrorNone;
+}
+
+OMX_U32 Muxer::WriteContent(
+        OMX_PTR hContent, 
+        OMX_PTR pBuffer, 
+        OMX_S32 nSize)
+{
+    if(hContent == NULL || hPipe == NULL)
+        return 0;
+
+	CP_CHECKBYTESRESULTTYPE eResult;
+	if(nEosMask == 0) {
+		hPipe->CheckAvailableBytes(hContent, nSize, &eResult);
+		if (eResult != CP_CheckBytesOk)
+			return 0;
+	} else {
+		hPipe->CheckAvailableBytes(hContent, nSize + nHeadSize, &eResult);
+		if (eResult != CP_CheckBytesOk) {
+			LOG_WARNING("Not enough memory.\n");
+			return 0;
+		}
+	}
+
+	nTotalWrite += nSize;
+	if(hPipe->Write(hContent, (CPbyte*)pBuffer, nSize) != 0)
+		return 0;
+    else
+        return nSize;
+}
+
+OMX_ERRORTYPE Muxer::SeekContent(
+        OMX_PTR hContent, 
+        OMX_S64 nOffset, 
+        CP_ORIGINTYPE eOrigin)
+{
+    if(hContent == NULL || hPipe == NULL)
+        return OMX_ErrorBadParameter;
+
+    if(0 != hPipe->SetPosition(hContent, nOffset, eOrigin))
+        return OMX_ErrorUndefined;
+
+    return OMX_ErrorNone;
+}
+
+OMX_S64 Muxer::TellContent(OMX_PTR hContent)
+{
+    if(hContent == NULL || hPipe == NULL)
+        return -1;
+
+    OMX_S64 nPos = 0;
+    if(0 != hPipe->GetPosition(hContent, &nPos))
+        return -1;
+
+    return nPos;
+}
+
+OMX_ERRORTYPE Muxer::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+    fsl_osal_memset(pBufferHdr, 0, sizeof(OMX_BUFFERHEADERTYPE) * MAX_PORTS);
+    fsl_osal_memset(Tracks, 0, sizeof(TRACK_INFO) * MAX_PORTS);
+    fsl_osal_memcpy(TrackParameter, 0, sizeof(TrackParameter) * MAX_PORTS);
+    nMinTrackTs = 0;
+    nEosMask = 0;
+    nAddSampleMask = 0;
+    nGetCodecDataMask = 0;
+    nMaxInterleave = MAX_INTERLEAVE;
+    bCodecDataAdded = OMX_FALSE;
+    hPipe = NULL;
+    pURL = NULL;
+    nURLLen = 0;
+	nTotalWrite = 0;
+	nHeadSize = 0;
+	nMaxFileSize = MAX_VALUE_S64;
+    bFileOffset64Bits = OMX_FALSE;
+	nLongitudex = -3600000;
+	nLatitudex= -3600000;
+	bAddSampleDone = OMX_FALSE;
+    nRotateDegree = 0;
+
+    fsl_osal_memset(&streamOps, 0, sizeof(FslFileStream));
+    streamOps.Open = OpenContentCb;
+    streamOps.Close = CloseContentCb;
+    streamOps.Write = WriteContentCb;
+    streamOps.Seek = SeekContentCb;
+    streamOps.Tell = TellContentCb;
+    
+    fsl_osal_memcpy(&memOps, 0, sizeof(MuxerMemoryOps));
+    memOps.Calloc = CallocCb;
+    memOps.Malloc = MallocCb;
+    memOps.ReAlloc = ReAllocCb;
+    memOps.Free = FreeCb;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_FALSE;
+
+    OMX_U32 i;
+    for(i=0; i<nPorts; i++) {
+        sPortDef.nPortIndex = i;
+        sPortDef.eDomain = port_info[i].eDomain;
+        sPortDef.nBufferCountMin = port_info[i].nBufferCount;
+        sPortDef.nBufferCountActual = port_info[i].nBufferCount;
+        sPortDef.nBufferSize = port_info[i].nBufferSize;
+        ret = ports[i]->SetPortDefinition(&sPortDef);
+        if(ret != OMX_ErrorNone) {
+            LOG_ERROR("Set port definition for port #%d failed.\n", i);
+            return ret;
+        }
+    }
+
+    ret = InitMuxerComponent();
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("InitMuxerComponent failed, ret = %x\n", ret);
+        return ret;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::DeInitComponent()
+{
+    DeInitMuxerComponent();
+
+    if(pURL != NULL)
+        FSL_FREE(pURL);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::InstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(hPipe == NULL) {
+        ret = OMX_GetContentPipe((void **)&hPipe, (OMX_STRING)"LOCAL_FILE_PIPE_NEW");
+        if(hPipe == NULL || ret != OMX_ErrorNone) {
+            LOG_ERROR("Get LOCAL_FILE_PIPE_NEW failed.\n");
+            return OMX_ErrorInsufficientResources;
+        }
+    }
+
+    ret = InitMuxer();
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("InitMuxer failed, ret = %x\n", ret);
+        return ret;
+    }
+
+    ret = InitTracks();
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("InitTracks failed, ret = %x\n", ret);
+        return ret;
+    }
+
+    ret = InitMetaData();
+    if(ret != OMX_ErrorNone)
+        LOG_WARNING("InitMetaData failed, ret = %x\n", ret);
+
+    ret = InitDone();
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("InitDone failed, ret = %x\n", ret);
+        return ret;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::InstanceDeInit()
+{
+    DeInitMuxer();
+
+    if(pURL != NULL)
+        FSL_FREE(pURL);
+
+    OMX_U32 i = 0;
+    for(i=0; i<nPorts; i++) {
+        if(Tracks[i].CodecData.pBuffer != NULL)
+            FSL_FREE(Tracks[i].CodecData.pBuffer);
+
+        while (Tracks[i].ReadyBuffers.GetNodeCnt() > 0) {
+            TRACK_DATA *pData = NULL;
+            pData = Tracks[i].ReadyBuffers.GetNode(0);
+            if(pData != NULL) {
+                Tracks[i].ReadyBuffers.Remove(pData);
+                FSL_FREE(pData->pBuffer);
+                FSL_FREE(pData);
+            }
+        }
+
+        while (Tracks[i].FreeBuffers.GetNodeCnt() > 0) {
+            TRACK_DATA *pData = NULL;
+            pData = Tracks[i].FreeBuffers.GetNode(0);
+            if(pData != NULL) {
+                Tracks[i].FreeBuffers.Remove(pData);
+                FSL_FREE(pData->pBuffer);
+                FSL_FREE(pData);
+            }
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::ReturnAllBuffer()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 i = 0;
+
+    for(i=0; i<nPorts; i++) {
+		if (pBufferHdr[i] != NULL) {
+			ports[i]->SendBuffer(pBufferHdr[i]);
+			pBufferHdr[i] = NULL;
+		}
+        while (ports[i]->BufferNum()) {
+			ports[i]->GetBuffer(&pBufferHdr[i]);
+			if(pBufferHdr[i] == NULL) {
+                LOG_ERROR("Should not be here, %s:%d\n", __FUNCTION__, __LINE__);
+                continue;
+            }
+			ports[i]->SendBuffer(pBufferHdr[i]);
+			pBufferHdr[i] = NULL;
+		}
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE Muxer::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(nEosMask == 0) 
+        return OMX_ErrorNoMore;
+
+    ret = TakeOneBufferFromPort();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if(nGetCodecDataMask != 0)
+        return OMX_ErrorNone;
+
+    if(bCodecDataAdded != OMX_TRUE) {
+        AddCodecData();
+        AddTracksDone();
+        bCodecDataAdded = OMX_TRUE;
+    }
+
+    OMX_U32 i;
+	for(i=0; i<nPorts; i++) {
+		if(Tracks[i].bTrackAdded != OMX_TRUE)
+			continue;
+
+        TRACK_DATA *pData = NULL;
+        pData = GetOneTrackData(i);
+        if(pData != NULL) {
+          pData->nDuration = Tracks[i].nSampleDuration;
+			nHeadSize = GetTrailerSize();
+            OMX_S64 nTempMaxFileSize = nMaxFileSize;
+            if (bFileOffset64Bits == OMX_FALSE && nTempMaxFileSize > MAX_VALUE_S32) {
+                nTempMaxFileSize = MAX_VALUE_S32;
+            }
+            LOG_DEBUG("Max file size: %lld\n", nTempMaxFileSize);
+			LOG_DEBUG("nHeadSize: %d nTotalWrite: %lld pData->nFilledLen: %d\n", \
+					nHeadSize, nTotalWrite, pData->nFilledLen);
+			if(nTotalWrite + pData->nFilledLen + nHeadSize + MP4MUXER_METADATA_SIZE \
+                    >= nTempMaxFileSize && bAddSampleDone == OMX_FALSE) {
+				LOG_WARNING("Not enough memory.\n");
+				bAddSampleDone = OMX_TRUE;
+				SeekContent(hContent, nTempMaxFileSize, CP_OriginBegin);
+				if (nTotalWrite + nHeadSize > nTempMaxFileSize || nAddSampleMask != 0)
+					SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+				else
+					SendEvent(OMX_EventBufferFlag, 0, OMX_BUFFERFLAG_MAX_FILESIZE, NULL);
+
+				break;
+            }
+
+                if (nMaxFileSize == MAX_VALUE_S64) {
+                    ret = SeekContent(hContent, nTotalWrite + pData->nFilledLen \
+                            + nHeadSize, CP_OriginBegin);
+                    if (ret != OMX_ErrorNone && bAddSampleDone == OMX_FALSE) {
+                        LOG_WARNING("Not enough memory.\n");
+                        bAddSampleDone = OMX_TRUE;
+                        ret = SeekContent(hContent, nTotalWrite + nHeadSize, CP_OriginBegin);
+                        if (ret != OMX_ErrorNone || nAddSampleMask != 0)
+                            SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                        else
+                            SendEvent(OMX_EventBufferFlag, 0, OMX_BUFFERFLAG_MAX_FILESIZE, NULL);
+                        break;
+                    }
+                }
+
+			if (bAddSampleDone == OMX_FALSE) {
+				if(OMX_ErrorInsufficientResources == AddOneSample(i, pData)) {
+					bAddSampleDone = OMX_TRUE;
+					SendEvent(OMX_EventBufferFlag, 0, OMX_BUFFERFLAG_MAX_FILESIZE, NULL);
+					break;
+				}
+                nAddSampleMask &= ~(1 << i);
+			}
+
+            if(pData->nFlags & OMX_BUFFERFLAG_EOS) {
+                nEosMask &= ~(1 << i);
+				if(nEosMask == 0)
+					AddSampleDone();
+				SendEvent(OMX_EventBufferFlag, i, OMX_BUFFERFLAG_EOS, NULL);
+			}
+            ReturnTrackData(i, pData);
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::CheckEOS(OMX_S32 i)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(nEosMask == 0)
+        AddSampleDone();
+	SendEvent(OMX_EventBufferFlag, i, OMX_BUFFERFLAG_EOS, NULL);
+
+	return ret;
+}
+
+OMX_ERRORTYPE Muxer::HandleSDFull()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	for(OMX_U32 i=0; i<nPorts; i++) {
+		nEosMask &= ~(1 << i);
+		LOG_DEBUG("Track %d EOS\n");
+		CheckEOS(i);
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE Muxer::ComponentReturnBuffer(
+        OMX_U32 nPortIndex)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::FlushComponent(
+        OMX_U32 nPortIndex)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 trackId = 0;
+
+    switch((int)nParamIndex) {
+        case OMX_IndexParamCustomContentPipe:
+            hPipe =(CP_PIPETYPE* ) (((OMX_PARAM_CONTENTPIPETYPE *)pStructure)->hPipe);
+            break;
+        case OMX_IndexParamContentURI:
+            {
+                OMX_PARAM_CONTENTURITYPE * pContentURI = (OMX_PARAM_CONTENTURITYPE *)pStructure;
+
+                nURLLen = fsl_osal_strlen((const char *)&(pContentURI->contentURI)) + 1;
+                pURL = (OMX_PTR)FSL_MALLOC(nURLLen);
+                if (pURL == NULL) {
+                    ret = OMX_ErrorInsufficientResources;
+                    break;
+                }
+                fsl_osal_strcpy((char *)pURL, (const char *)&(pContentURI->contentURI));
+            }
+            break;
+        case OMX_IndexParamAudioPcm:
+            {
+                OMX_AUDIO_PARAM_PCMMODETYPE *pPcmPara = (OMX_AUDIO_PARAM_PCMMODETYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPcmPara, OMX_AUDIO_PARAM_PCMMODETYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pPcmPara->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].PcmPara, pPcmPara, sizeof(OMX_AUDIO_PARAM_PCMMODETYPE)); 
+            }
+            break;
+        case OMX_IndexParamAudioMp3:
+            {
+                OMX_AUDIO_PARAM_MP3TYPE *pMp3Para = (OMX_AUDIO_PARAM_MP3TYPE*)pStructure;
+                OMX_CHECK_STRUCT(pMp3Para, OMX_AUDIO_PARAM_MP3TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pMp3Para->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].Mp3Para, pMp3Para, sizeof(*pMp3Para)); 
+            }
+            break;
+        case OMX_IndexParamAudioAmr:
+            {
+                OMX_AUDIO_PARAM_AMRTYPE *pAmrPara = (OMX_AUDIO_PARAM_AMRTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pAmrPara, OMX_AUDIO_PARAM_AMRTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pAmrPara->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].AmrPara, pAmrPara, sizeof(*pAmrPara)); 
+            }
+            break;
+        case OMX_IndexParamAudioAac:
+            {
+                OMX_AUDIO_PARAM_AACPROFILETYPE *pAacProfile = (OMX_AUDIO_PARAM_AACPROFILETYPE*)pStructure;
+                OMX_CHECK_STRUCT(pAacProfile, OMX_AUDIO_PARAM_AACPROFILETYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pAacProfile->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].AacProfile, pAacProfile, sizeof(*pAacProfile)); 
+            }
+            break;
+        case OMX_IndexParamAudioWma:
+            {
+                OMX_AUDIO_PARAM_WMATYPE *pWmaPara = (OMX_AUDIO_PARAM_WMATYPE*)pStructure;
+                OMX_CHECK_STRUCT(pWmaPara, OMX_AUDIO_PARAM_WMATYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pWmaPara->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].WmaPara, pWmaPara, sizeof(*pWmaPara)); 
+            }
+            break;
+        case OMX_IndexParamVideoH263:
+            {
+                OMX_VIDEO_PARAM_H263TYPE *pH263Para = (OMX_VIDEO_PARAM_H263TYPE*)pStructure;
+                OMX_CHECK_STRUCT(pH263Para, OMX_VIDEO_PARAM_H263TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pH263Para->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].H263Para, pH263Para, sizeof(*pH263Para)); 
+            }
+            break;
+        case OMX_IndexParamVideoMpeg4:
+            {
+                OMX_VIDEO_PARAM_MPEG4TYPE *pMpeg4Para = (OMX_VIDEO_PARAM_MPEG4TYPE*)pStructure;
+                OMX_CHECK_STRUCT(pMpeg4Para, OMX_VIDEO_PARAM_MPEG4TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pMpeg4Para->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].Mpeg4Para, pMpeg4Para, sizeof(*pMpeg4Para)); 
+            }
+            break;
+        case OMX_IndexParamVideoAvc:
+            {
+                OMX_VIDEO_PARAM_AVCTYPE *pAvcPara = (OMX_VIDEO_PARAM_AVCTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pAvcPara, OMX_VIDEO_PARAM_AVCTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                trackId = pAvcPara->nPortIndex;
+                fsl_osal_memcpy(&TrackParameter[trackId].AvcPara, pAvcPara, sizeof(*pAvcPara)); 
+            }
+            break;
+        case OMX_IndexParamMaxFileSize:
+            {
+				 nMaxFileSize = *((OMX_TICKS*)pStructure);
+            }
+            break;
+        case OMX_IndexParamFileOffset64Bits:
+            {
+				 bFileOffset64Bits = *((OMX_BOOL *)pStructure);
+            }
+            break;
+        case OMX_IndexParamLongitudex:
+            {
+				 nLongitudex = *((OMX_S64*)pStructure);
+            }
+            break;
+        case OMX_IndexParamLatitudex:
+            {
+				 nLatitudex= *((OMX_S64*)pStructure);
+            }
+            break;
+        default:
+            ret = OMX_ErrorNotImplemented;
+            break;
+    }
+
+    if(ret == OMX_ErrorNone)
+        Tracks[trackId].bTrackSetted = OMX_TRUE;
+
+    return ret;
+}
+OMX_ERRORTYPE Muxer::SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    switch((int)nParamIndex) {
+        case OMX_IndexConfigCommonRotate:
+        {
+            OMX_CONFIG_ROTATIONTYPE *pRotate = (OMX_CONFIG_ROTATIONTYPE*)pStructure;
+            OMX_CHECK_STRUCT(pRotate, OMX_CONFIG_ROTATIONTYPE, ret);
+            if(ret != OMX_ErrorNone)
+                break;
+            nRotateDegree = (OMX_U32)pRotate->nRotation;
+            break;
+        }
+        default:
+            ret = OMX_ErrorNotImplemented;
+            break;
+    }
+    return ret;
+}
+OMX_ERRORTYPE Muxer::InitTracks()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_U32 i;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    for(i=0; i<nPorts; i++) {
+        if(ports[i]->IsEnabled() == OMX_TRUE) {
+            if(port_info[i].eDomain == OMX_PortDomainAudio)
+                ret = InitAudioTrack(i);
+            else if(port_info[i].eDomain == OMX_PortDomainVideo)
+                ret = InitVideoTrack(i);
+
+            if(ret == OMX_ErrorNone) {
+                Tracks[i].bTrackAdded = OMX_TRUE;
+                nEosMask |= 1 << i;
+                nAddSampleMask |= 1 << i;
+                nGetCodecDataMask |= 1 << i;
+            }
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::InitMetaData()
+{
+	if (nLongitudex> -3600000 && nLatitudex> -3600000) {
+		AddLocationInfo(nLongitudex, nLatitudex);
+	}
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::InitDone()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::InitAudioTrack(OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_BOOL bParamSetted = Tracks[nPortIndex].bTrackSetted;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = nPortIndex;
+    ports[nPortIndex]->GetPortDefinition(&sPortDef);
+
+    Tracks[nPortIndex].nSampleDuration = 2;
+    switch(sPortDef.format.audio.eEncoding) {
+        case OMX_AUDIO_CodingPCM:
+            {
+                if(bParamSetted != OMX_TRUE) {
+                    LOG_ERROR("No parameters for PCM track #%d\n", nPortIndex);
+                    ret = OMX_ErrorUndefined;
+                    break;
+                }
+                ret = AddPcmTrack(nPortIndex, &TrackParameter[nPortIndex].PcmPara);
+                LOG_DEBUG("Add PCM to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        case OMX_AUDIO_CodingMP3:
+            {
+                OMX_AUDIO_PARAM_MP3TYPE *pMp3Para = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pMp3Para = &TrackParameter[nPortIndex].Mp3Para;
+                ret = AddMp3Track(nPortIndex, pMp3Para);
+                LOG_DEBUG("Add MP3 to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        case OMX_AUDIO_CodingAMR:
+            {
+                OMX_AUDIO_PARAM_AMRTYPE *pAmrPara = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pAmrPara = &TrackParameter[nPortIndex].AmrPara;
+                ret = AddAmrTrack(nPortIndex, pAmrPara);
+                LOG_DEBUG("Add AMR to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        case OMX_AUDIO_CodingAAC:
+            {
+                OMX_AUDIO_PARAM_AACPROFILETYPE *pAacProfile = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pAacProfile = &TrackParameter[nPortIndex].AacProfile;
+                ret = AddAacTrack(nPortIndex, pAacProfile);
+                LOG_DEBUG("Add AAC to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        case OMX_AUDIO_CodingWMA:
+            {
+                OMX_AUDIO_PARAM_WMATYPE *pWmaPara = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pWmaPara = &TrackParameter[nPortIndex].WmaPara;
+                    ret = AddWmaTrack(nPortIndex, pWmaPara);
+                LOG_DEBUG("Add WMA to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        default:
+            ret = OMX_ErrorUndefined;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE Muxer::InitVideoTrack(OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_BOOL bParamSetted = Tracks[nPortIndex].bTrackSetted;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = nPortIndex;
+    ports[nPortIndex]->GetPortDefinition(&sPortDef);
+
+    Tracks[nPortIndex].nSampleDuration = 30000;
+    if ((sPortDef.format.video.xFramerate >> 16)) {
+        Tracks[nPortIndex].nSampleDuration = OMX_TICKS_PER_SECOND / \
+            (sPortDef.format.video.xFramerate >> 16);
+    }
+
+    switch(sPortDef.format.video.eCompressionFormat) {
+        case OMX_VIDEO_CodingH263:
+            {
+                OMX_VIDEO_PARAM_H263TYPE *pH263Para = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pH263Para = &TrackParameter[nPortIndex].H263Para;
+                ret = AddH263Track(nPortIndex, &sPortDef.format.video, pH263Para);
+                LOG_DEBUG("Add H263 to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        case OMX_VIDEO_CodingMPEG4:
+            {
+                OMX_VIDEO_PARAM_MPEG4TYPE *pMpeg4Para = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pMpeg4Para = &TrackParameter[nPortIndex].Mpeg4Para;
+                ret = AddMpeg4Track(nPortIndex, &sPortDef.format.video, pMpeg4Para);
+                LOG_DEBUG("Add MPEG4 to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        case OMX_VIDEO_CodingAVC:
+            {
+                OMX_VIDEO_PARAM_AVCTYPE *pAvcPara = NULL;
+                if(bParamSetted == OMX_TRUE)
+                    pAvcPara = &TrackParameter[nPortIndex].AvcPara;
+                ret = AddAvcTrack(nPortIndex, &sPortDef.format.video, pAvcPara);
+                LOG_DEBUG("Add AVC to track #%d, ret = %x\n", nPortIndex, ret);
+            }
+            break;
+        default:
+            ret = OMX_ErrorUndefined;
+            break;
+    }
+
+    AddTrackRotate(nPortIndex,nRotateDegree);
+
+    return ret;
+}
+
+OMX_ERRORTYPE Muxer::InitTrackMetaData(OMX_U32 nPortIndex)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::ProcessTrackCodecData(OMX_U32 track)
+{
+    OMX_U32 i = track;
+
+    LOG_DEBUG("Get Codec config data, len: %d\n", pBufferHdr[i]->nFilledLen);
+    if(Tracks[i].CodecData.pBuffer == NULL) {
+        Tracks[i].CodecData.pBuffer = FSL_MALLOC(pBufferHdr[i]->nFilledLen);
+        if(Tracks[i].CodecData.pBuffer != NULL) {
+            fsl_osal_memcpy(Tracks[i].CodecData.pBuffer, pBufferHdr[i]->pBuffer, pBufferHdr[i]->nFilledLen);
+            Tracks[i].CodecData.nFilledLen = pBufferHdr[i]->nFilledLen;
+        }
+    }
+    else {
+        Tracks[i].CodecData.pBuffer = FSL_REALLOC(Tracks[i].CodecData.pBuffer, 
+                Tracks[i].CodecData.nFilledLen + pBufferHdr[i]->nFilledLen);
+        if(Tracks[i].CodecData.pBuffer != NULL) {
+            fsl_osal_memcpy((OMX_U8*)Tracks[i].CodecData.pBuffer + Tracks[i].CodecData.nFilledLen, 
+                    pBufferHdr[i]->pBuffer, pBufferHdr[i]->nFilledLen);
+            Tracks[i].CodecData.nFilledLen += pBufferHdr[i]->nFilledLen;
+        }
+    }
+    ports[i]->SendBuffer(pBufferHdr[i]);
+    pBufferHdr[i] = NULL;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::AddCodecData()
+{
+    OMX_U32 i;
+
+    for(i=0; i<nPorts; i++) {
+        if(Tracks[i].CodecData.nFilledLen > 0)
+            AddTrackCodecData(i, Tracks[i].CodecData.pBuffer, Tracks[i].CodecData.nFilledLen);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::TakeOneBufferFromPort()
+{
+    OMX_BOOL bNoBuffer = OMX_TRUE;
+    OMX_U32 i = 0;
+
+    nMinTrackTs = -1;
+
+    for(i=0; i<nPorts; i++) {
+        OMX_U32 nReadyBuffers = Tracks[i].ReadyBuffers.GetNodeCnt();
+        OMX_U32 nPortBuffers = ports[i]->BufferNum();
+
+		LOG_LOG("Port: %d buffer num: %d\n", i, nPortBuffers);
+        if(nPortBuffers == 0 && nReadyBuffers == 0 && pBufferHdr[i] == NULL)
+            continue;
+
+        bNoBuffer = OMX_FALSE;
+
+        if(pBufferHdr[i] == NULL && nPortBuffers > 0) {
+            ports[i]->GetBuffer(&pBufferHdr[i]);
+			LOG_LOG("Input buffer TS: %lld\n", pBufferHdr[i]->nTimeStamp);
+            if(pBufferHdr[i] == NULL) {
+                LOG_ERROR("Should not be here, %s:%d\n", __FUNCTION__, __LINE__);
+                continue;
+            }
+        }
+
+        if(pBufferHdr[i] != NULL && pBufferHdr[i]->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+            ProcessTrackCodecData(i);
+            continue;
+        }
+
+        nGetCodecDataMask &= ~(1 << i);
+
+        if(nReadyBuffers > 0) {
+            if(pBufferHdr[i] != NULL)
+                AddToReadyBuffers(i);
+
+            TRACK_DATA *pData = Tracks[i].ReadyBuffers.GetNode(0);
+            if(pData == NULL) {
+                LOG_ERROR("Should not be here, %s:%d\n", __FUNCTION__, __LINE__);
+                continue;
+            }
+            if(!pData->nFlags & OMX_BUFFERFLAG_EOS)
+                Tracks[i].nHeadTs = pData->nTimeStamp;
+        }
+        else {
+            if(!pBufferHdr[i]->nFlags & OMX_BUFFERFLAG_EOS)
+                Tracks[i].nHeadTs = pBufferHdr[i]->nTimeStamp;
+        }
+
+        nMinTrackTs = MIN((OMX_U64)nMinTrackTs, (OMX_U64)(Tracks[i].nHeadTs));
+    }
+
+    if(bNoBuffer == OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::AddToReadyBuffers(OMX_U32 track)
+{
+    OMX_U32 i = track;
+    if(pBufferHdr[i] == NULL) {
+        LOG_ERROR("No buffer need to add to ready buffer list.\n");
+        return OMX_ErrorUndefined;
+    }
+
+    TRACK_DATA *pData = GetEmptyTrackData(i, pBufferHdr[i]->nFilledLen);
+    if(pData == NULL) {
+        LOG_ERROR("Can't get a free track data node, drop this buffer.\n");
+        ports[i]->SendBuffer(pBufferHdr[i]);
+        pBufferHdr[i] = NULL;
+        return OMX_ErrorNone;
+    }
+
+    pData->nTimeStamp = pBufferHdr[i]->nTimeStamp;
+    pData->nFlags = pBufferHdr[i]->nFlags;
+    pData->nFilledLen = pBufferHdr[i]->nFilledLen;
+    fsl_osal_memcpy(pData->pBuffer, pBufferHdr[i]->pBuffer, pBufferHdr[i]->nFilledLen);
+    Tracks[i].ReadyBuffers.Add(pData);
+    ports[i]->SendBuffer(pBufferHdr[i]);
+    pBufferHdr[i] = NULL;
+
+    return OMX_ErrorNone;
+}
+
+TRACK_DATA * Muxer::GetEmptyTrackData(
+        OMX_U32 track, 
+        OMX_U32 nSize)
+{
+    TRACK_DATA *pData = NULL;
+    OMX_U32 i = track;
+
+    if(Tracks[i].FreeBuffers.GetNodeCnt() > 0) {
+        pData = Tracks[i].FreeBuffers.GetNode(0);
+        if(pData == NULL) {
+            LOG_ERROR("Should not be here, %s:%d\n", __FUNCTION__, __LINE__);
+            return NULL;
+        }
+        Tracks[i].FreeBuffers.Remove(pData);
+
+        if(pData->nAllocLen >= nSize)
+            return pData;
+
+        pData->pBuffer = FSL_REALLOC(pData->pBuffer, nSize);
+        if(pData->pBuffer == NULL) {
+            LOG_ERROR("Failed to reallocate memory for track data, size changed from %d to %d\n", pData->nAllocLen, nSize);
+            FSL_FREE(pData);
+            return NULL;
+        }
+        pData->nAllocLen = nSize;
+    }
+    else {
+        pData = (TRACK_DATA*)FSL_MALLOC(sizeof(TRACK_DATA));
+        if(pData == NULL) {
+            LOG_ERROR("Failed to allcoate one track data node.\n");
+            return NULL;
+        }
+        fsl_osal_memset(pData, 0, sizeof(TRACK_DATA));
+        pData->pBuffer = (OMX_PTR)FSL_MALLOC(nSize);
+        if(pData->pBuffer == NULL) {
+            LOG_ERROR("Failed to allcoate one track data buffer, size: %d.\n", nSize);
+            FSL_FREE(pData);
+            return NULL;
+        }
+        pData->nAllocLen = nSize;
+    }
+
+    return pData;
+}
+
+TRACK_DATA * Muxer::GetOneTrackData(OMX_U32 track)
+{
+    OMX_U32 i = track;
+
+    if((Tracks[i].nHeadTs - nMinTrackTs) > nMaxInterleave) {
+        LOG_DEBUG("Track %d is ahead of max interleave %lld, head: %lld, min: %lld\n",
+                i, nMaxInterleave, Tracks[i].nHeadTs, nMinTrackTs);
+        if(pBufferHdr[i] != NULL)
+            AddToReadyBuffers(i);
+        return NULL;
+    }
+
+    if(pBufferHdr[i] != NULL) {
+        Tracks[i].TrackBuffer.nTimeStamp = pBufferHdr[i]->nTimeStamp;
+        Tracks[i].TrackBuffer.nFlags = pBufferHdr[i]->nFlags; 
+        Tracks[i].TrackBuffer.nFilledLen = pBufferHdr[i]->nFilledLen; 
+        Tracks[i].TrackBuffer.pBuffer = pBufferHdr[i]->pBuffer; 
+        return &(Tracks[i].TrackBuffer);
+    }
+
+    if(Tracks[i].ReadyBuffers.GetNodeCnt() == 0)
+        return NULL;
+
+    TRACK_DATA *pData = Tracks[i].ReadyBuffers.GetNode(0);
+    if(pData == NULL) {
+        LOG_ERROR("Should not be here, %s:%d\n", __FUNCTION__, __LINE__);
+        return NULL;
+    }
+    Tracks[i].ReadyBuffers.Remove(pData);
+
+    return pData;
+}
+
+OMX_ERRORTYPE Muxer::ReturnTrackData(
+        OMX_U32 track,
+        TRACK_DATA *pData)
+{
+    OMX_U32 i = track;
+
+    if(pBufferHdr[i] != NULL) {
+        fsl_osal_memset((OMX_PTR)(&(Tracks[i].TrackBuffer)), 0, sizeof(TRACK_DATA));
+        ports[i]->SendBuffer(pBufferHdr[i]);
+        pBufferHdr[i] = NULL;
+        return OMX_ErrorNone;
+    }
+
+    pData->nTimeStamp = 0;
+    pData->nFlags = 0;
+    pData->nFilledLen = 0;
+
+    Tracks[i].FreeBuffers.Add(pData);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::InitMuxerComponent()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::DeInitMuxerComponent()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Muxer::AddLocationInfo(
+		OMX_S64 nLongitudex, 
+		OMX_S64 nLatitudex)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddPcmTrack(
+        OMX_U32 track, 
+        OMX_AUDIO_PARAM_PCMMODETYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddMp3Track(
+        OMX_U32 track, 
+        OMX_AUDIO_PARAM_MP3TYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddAmrTrack(
+        OMX_U32 track, 
+        OMX_AUDIO_PARAM_AMRTYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddAacTrack(
+        OMX_U32 track, 
+        OMX_AUDIO_PARAM_AACPROFILETYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddWmaTrack(
+        OMX_U32 track, 
+        OMX_AUDIO_PARAM_WMATYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddH263Track(
+        OMX_U32 track, 
+        OMX_VIDEO_PORTDEFINITIONTYPE *pFormat, 
+        OMX_VIDEO_PARAM_H263TYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddMpeg4Track(
+        OMX_U32 track, 
+        OMX_VIDEO_PORTDEFINITIONTYPE *pFormat, 
+        OMX_VIDEO_PARAM_MPEG4TYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddAvcTrack(
+        OMX_U32 track, 
+        OMX_VIDEO_PORTDEFINITIONTYPE *pFormat, 
+        OMX_VIDEO_PARAM_AVCTYPE *pParameter)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Muxer::AddTracksDone()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_U32 Muxer::GetTrailerSize()
+{
+	return 0;
+}
+
+OMX_ERRORTYPE Muxer::AddSampleDone()
+{
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/Muxer.h b/OpenMAXIL/src/component/common/Muxer.h
new file mode 100755
index 0000000..571adcb
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Muxer.h
@@ -0,0 +1,146 @@
+/**
+ *  Copyright (c) 2011-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file Muxer.h
+ *  @brief Class definition of Muxer base
+ *  @ingroup Muxer
+ */
+
+#ifndef Muxer_h
+#define Muxer_h
+
+#include "ComponentBase.h"
+#include "OMX_ContentPipe.h"
+#include "fsl_muxer.h"
+
+#define MAX_PORTS 32
+
+typedef struct {
+    OMX_PORTDOMAINTYPE eDomain;
+    OMX_U32 nBufferCount;
+    OMX_U32 nBufferSize;
+} PORT_INFO;
+
+typedef struct {
+    OMX_TICKS nTimeStamp;
+    OMX_TICKS nDuration;
+    OMX_PTR pBuffer;
+    OMX_U32 nAllocLen;
+    OMX_U32 nFilledLen;
+    OMX_U32 nFlags;
+} TRACK_DATA;
+
+class Muxer : public ComponentBase {
+    public:
+        Muxer();
+        OMX_PTR OpenContent(CP_ACCESSTYPE eAccess);
+        OMX_ERRORTYPE CloseContent(OMX_PTR hContent);
+        OMX_U32 WriteContent(OMX_PTR hContent, OMX_PTR pBuffer, OMX_S32 nSize);
+        OMX_ERRORTYPE SeekContent(OMX_PTR hContent, OMX_S64 nOffset, CP_ORIGINTYPE eOrigin);
+        OMX_S64 TellContent(OMX_PTR hContent);
+		OMX_S64 nTotalWrite;
+    protected:
+        PORT_INFO port_info[MAX_PORTS];
+        FslFileStream streamOps;
+        MuxerMemoryOps memOps;
+    private:
+        typedef struct {
+            OMX_BOOL bTrackSetted;
+            OMX_BOOL bTrackAdded;
+            OMX_TICKS nHeadTs;
+            OMX_TICKS nSampleDuration;
+            List<TRACK_DATA> FreeBuffers;
+            List<TRACK_DATA> ReadyBuffers;
+            TRACK_DATA TrackBuffer;
+            TRACK_DATA CodecData;
+        } TRACK_INFO;
+
+        OMX_BUFFERHEADERTYPE *pBufferHdr[MAX_PORTS];
+        TRACK_INFO Tracks[MAX_PORTS];
+        union {
+            OMX_AUDIO_PARAM_PCMMODETYPE PcmPara;
+            OMX_AUDIO_PARAM_MP3TYPE Mp3Para;
+            OMX_AUDIO_PARAM_AMRTYPE AmrPara;
+            OMX_AUDIO_PARAM_AACPROFILETYPE AacProfile;
+            OMX_AUDIO_PARAM_WMATYPE WmaPara;
+            OMX_VIDEO_PARAM_H263TYPE H263Para;
+            OMX_VIDEO_PARAM_MPEG4TYPE Mpeg4Para;
+            OMX_VIDEO_PARAM_AVCTYPE AvcPara;
+        } TrackParameter[MAX_PORTS];
+        OMX_TICKS nMinTrackTs;
+        OMX_U32 nEosMask;
+		OMX_U32 nAddSampleMask;
+        OMX_U32 nGetCodecDataMask;
+        OMX_TICKS nMaxInterleave;
+        OMX_BOOL bCodecDataAdded;
+		OMX_U32 nHeadSize;
+		OMX_S64 nMaxFileSize;
+        OMX_BOOL bFileOffset64Bits;
+		OMX_S64 nLongitudex;
+		OMX_S64 nLatitudex;
+		OMX_BOOL bAddSampleDone;
+
+        CP_PIPETYPE *hPipe;
+        OMX_PTR pURL;
+		OMX_PTR hContent;
+		OMX_U32 nURLLen;
+        OMX_U32 nRotateDegree;
+
+        OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE InstanceInit();
+        OMX_ERRORTYPE InstanceDeInit();
+        OMX_ERRORTYPE ProcessDataBuffer();
+        OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+
+        OMX_ERRORTYPE InitTracks();
+        OMX_ERRORTYPE InitMetaData();
+        OMX_ERRORTYPE InitDone();
+        OMX_ERRORTYPE InitAudioTrack(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE InitVideoTrack(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE InitTrackMetaData(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE ProcessTrackCodecData(OMX_U32 track);
+        OMX_ERRORTYPE AddCodecData();
+        OMX_ERRORTYPE TakeOneBufferFromPort();
+        OMX_ERRORTYPE AddToReadyBuffers(OMX_U32 track);
+        TRACK_DATA *GetEmptyTrackData(OMX_U32 track, OMX_U32 nSize);
+        TRACK_DATA *GetOneTrackData(OMX_U32 track);
+		OMX_ERRORTYPE ReturnTrackData(OMX_U32 track, TRACK_DATA *pData);
+		OMX_ERRORTYPE ReturnAllBuffer();
+		OMX_ERRORTYPE HandleSDFull();
+		OMX_ERRORTYPE CheckEOS(OMX_S32 i);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+
+        virtual OMX_ERRORTYPE InitMuxerComponent();
+        virtual OMX_ERRORTYPE DeInitMuxerComponent();
+        virtual OMX_ERRORTYPE InitMuxer() = 0;
+        virtual OMX_ERRORTYPE DeInitMuxer() = 0;
+		virtual OMX_ERRORTYPE AddLocationInfo(OMX_S64 nLongitudex, OMX_S64 nLatitudex);
+        virtual OMX_ERRORTYPE AddPcmTrack(OMX_U32 track, OMX_AUDIO_PARAM_PCMMODETYPE *pParameter);
+        virtual OMX_ERRORTYPE AddMp3Track(OMX_U32 track, OMX_AUDIO_PARAM_MP3TYPE *pParameter);
+        virtual OMX_ERRORTYPE AddAmrTrack(OMX_U32 track, OMX_AUDIO_PARAM_AMRTYPE *pParameter);
+        virtual OMX_ERRORTYPE AddAacTrack(OMX_U32 track, OMX_AUDIO_PARAM_AACPROFILETYPE *pParameter);
+        virtual OMX_ERRORTYPE AddWmaTrack(OMX_U32 track, OMX_AUDIO_PARAM_WMATYPE *pParameter);
+        virtual OMX_ERRORTYPE AddH263Track(OMX_U32 track, OMX_VIDEO_PORTDEFINITIONTYPE *pFormat, OMX_VIDEO_PARAM_H263TYPE *pParameter);
+        virtual OMX_ERRORTYPE AddMpeg4Track(OMX_U32 track, OMX_VIDEO_PORTDEFINITIONTYPE *pFormat, OMX_VIDEO_PARAM_MPEG4TYPE *pParameter);
+        virtual OMX_ERRORTYPE AddAvcTrack(OMX_U32 track, OMX_VIDEO_PORTDEFINITIONTYPE *pFormat, OMX_VIDEO_PARAM_AVCTYPE *pParameter);
+        virtual OMX_ERRORTYPE AddTrackCodecData(OMX_U32 track, OMX_PTR pData, OMX_U32 nLen) = 0;
+        virtual OMX_ERRORTYPE AddTracksDone();
+        virtual OMX_ERRORTYPE AddOneSample(OMX_U32 track, TRACK_DATA *pData) = 0;
+		virtual OMX_U32 GetTrailerSize();
+        virtual OMX_ERRORTYPE AddSampleDone();
+        virtual OMX_ERRORTYPE AddTrackRotate(OMX_U32 track, OMX_U32 rotateDegree) = 0;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/Parser.cpp b/OpenMAXIL/src/component/common/Parser.cpp
new file mode 100755
index 0000000..db45e53
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Parser.cpp
@@ -0,0 +1,1785 @@
+/**
+ *  Copyright (c) 2009-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Parser.h"
+#include "string.h"
+
+#define HTTP_CACHE_TIME 1
+
+OMX_STRING Parser::GetMimeFromComponentRole(OMX_U8 *componentRole) 
+{
+    struct RoleToMime {
+              const char *mRole;
+              const char *mVideoMime;
+              const char *mVideoUnsupportMime;
+              const char *mAudioMime;
+              const char *mAudioUnsupportMime;
+    };
+    RoleToMime kRoleToMime[] = {
+            { "parser.avi", "video/avi",        "video_unsupport/avi",          "audio/avi" ,           "audio_unsupport/avi"},
+            { "parser.mp4", "video/mp4",        "video_unsupport/mp4",          "audio/mp4",            "audio_unsupport/mp4" },
+            { "parser.asf", "video/x-ms-wmv",   "video_unsupport/x-ms-wmv",     "audio/x-ms-wma",       "audio_unsupport/x-ms-wma" },
+            { "parser.mkv", "video/x-matroska",   "video_unsupport/x-matroska",     "audio/x-matroska",       "audio_unsupport/x-matroska" },
+            { "parser.flv", "video/flv",        "video_unsupport/flv",          "audio/flv",            "audio_unsupport/flv" },
+            { "parser.mpg2","video/mp2p",       "video_unsupport/mp2p",         "audio/mp2p",           "audio_unsupport/mp2p" },
+            { "parser.rmvb","video/rmff",       "video_unsupport/rmff",         "audio/rmff",           "audio_unsupport/rmff" },
+            { "parser.mp3", NULL,               NULL,                           "audio/mpeg",           "audio_unsupport/mpeg" },
+            { "parser.aac", NULL,               NULL,                           "audio/aac",            "audio_unsupport/aac" },
+            { "parser.ac3", NULL,               NULL,                           "audio/ac3",            "audio_unsupport/ac3" },
+            { "parser.wav", NULL,               NULL,                           "audio/x-wav",          "audio_unsupport/x-wav" },
+            { "parser.flac",NULL,               NULL,                           "audio/flac",           "audio_unsupport/flac" },
+            { "parser.ogg", NULL,               NULL,                           "application/ogg",      "application_unsupport/ogg" },
+            { "parser.amr", NULL,               NULL,                           "audio/amr",            "audio_unsupport/amr" },
+
+    };
+
+    for (OMX_U32 i = 0; i < sizeof(kRoleToMime) / sizeof(kRoleToMime[0]); ++i) {
+        if (!strcmp((const char *)componentRole, kRoleToMime[i].mRole)) {
+            if(nNumAvailVideoStream > 0){
+                if(bHasVideoTrack)
+                    return (OMX_STRING)kRoleToMime[i].mVideoMime;
+                else
+                    return (OMX_STRING)kRoleToMime[i].mVideoUnsupportMime;
+            }
+            else{
+                if (bHasAudioTrack)
+                    return (OMX_STRING)kRoleToMime[i].mAudioMime;
+                else
+                    return (OMX_STRING)kRoleToMime[i].mAudioUnsupportMime;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************
+ * Function:    appLocalFileOpen
+ *
+ * Description: Implements to Open the file.
+ *
+ * Return:      File Pointer.
+ ****************************************************************************/
+static FslFileHandle appLocalFileOpen ( const uint8 * file_path, const uint8 * mode, void * context)
+{
+    if(NULL == mode || !context)
+    {
+        LOG_ERROR("appLocalFileOpen: Invalid parameter\n");
+        return NULL;
+    }
+
+    Parser *h = (Parser *)context;
+    CPresult nContentPipeResult;
+    FslFileHandle sourceFileHandle;
+
+    OMX_BOOL bStreaming = h->IsStreamingSource();
+    if(bStreaming == OMX_TRUE)
+        h->SendEvent(OMX_EventBufferingData, 0, 0, NULL);
+    nContentPipeResult = h->hPipe->Open(&sourceFileHandle, (char *)h->pMediaName, CP_AccessRead);
+    if(bStreaming == OMX_TRUE)
+        h->SendEvent(OMX_EventBufferingDone, 0, 0, NULL);
+    if(nContentPipeResult == 0)
+    {
+        LOG_DEBUG("appLocalFileOpen: file  opened successfully\n");
+    }
+    else
+    {
+        LOG_ERROR("appLocalFileOpen: Fail to open file \n");
+        return NULL;
+    }
+
+
+    return sourceFileHandle;
+}
+
+/*****************************************************************************
+ * Function:    appLocalReadFile
+ *
+ * Description: Implements to read the stream from the file.
+ *
+ * Return:      Total number of bytes read. 
+ *    
+ ****************************************************************************/
+static uint32  appLocalReadFile( FslFileHandle file_handle, void * buffer, uint32 nb, void * context)
+{
+    Parser *h = (Parser *)context;
+    CPresult nContentPipeResult;
+    uint32 dwRestBytes;
+    uint32 dwReadBytes;
+    CPint64 qwPos;
+    CPint64 size;
+    if (!file_handle || !context || !buffer)
+        return 0;
+
+    if(h->bStopReading){
+        return 0;
+    }
+#if 0
+    if(OMX_ErrorNone != h->CheckContentAvailableBytes(file_handle, nb))
+        return 0;
+
+    nContentPipeResult = h->hPipe->Read(file_handle, (CPbyte *)buffer, nb);
+    if(nContentPipeResult == 0)
+    {
+        return nb; /* bytes read */
+    }
+    else {
+        return 0; /* take as nothing read */
+    }
+#else
+
+    if(OMX_ErrorNone != h->CheckContentAvailableBytes(file_handle, nb)){
+        if(h->IsStreamingSource()){
+            return 0;
+        }
+        LOG_DEBUG("appLocalReadFile NOT AVAILABLE");
+        nContentPipeResult = h->hPipe->GetPosition(file_handle,&qwPos);
+        if(nContentPipeResult != 0){
+            return 0;
+        }
+        nContentPipeResult = h->hPipe->SetPosition(file_handle, 0, CP_OriginEnd);
+        if(nContentPipeResult != 0){
+            return 0;
+        }
+        nContentPipeResult = h->hPipe->GetPosition(file_handle,&size);
+        if(nContentPipeResult != 0){
+            return 0;
+        }
+        nContentPipeResult = h->hPipe->SetPosition(file_handle,qwPos, CP_OriginBegin);
+        if(nContentPipeResult != 0){
+            return 0;
+        }
+        h->nContentLen = size;
+        dwRestBytes = ((CPint64)h->nContentLen >  qwPos) ? (uint32)(h->nContentLen -  qwPos) : 0;
+        dwReadBytes = (dwRestBytes > nb) ? nb : dwRestBytes;
+        if(dwReadBytes== 0){
+            return 0;
+        }
+    }else{
+        dwReadBytes = nb;
+    }
+
+    if(h->Lock)
+        fsl_osal_mutex_lock(h->Lock);
+
+    nContentPipeResult = h->hPipe->Read(file_handle, (CPbyte *)buffer, dwReadBytes);
+
+    if(h->Lock)
+        fsl_osal_mutex_unlock(h->Lock);
+
+    if(nContentPipeResult == 0)
+    {
+        LOG_LOG("appLocalReadFile dwReadBytes=%d",dwReadBytes);
+        return dwReadBytes;
+    }
+    else
+    {
+        LOG_LOG("appLocalReadFile 0");
+        return 0;
+    }
+#endif
+    
+}
+
+/*****************************************************************************
+ * Function:    appLocalSeekFile
+ *
+ * Description: seek the file. whence: SEEK_SET, SEEK_CUR, or SEEK_END
+ *
+ * Return:      File Pointer.
+ *    
+ ****************************************************************************/
+
+static int32   appLocalSeekFile( FslFileHandle file_handle, int64 offset, int32 whence, void * context) 
+{
+
+    Parser *h = (Parser *)context;
+    CPresult nContentPipeResult = 0;
+    if (!file_handle || !context)
+        return -1;
+
+    if (SEEK_CUR == whence)
+        nContentPipeResult = h->hPipe->SetPosition(file_handle,offset, CP_OriginCur);       
+    else if (SEEK_SET == whence)
+        nContentPipeResult = h->hPipe->SetPosition(file_handle,offset, CP_OriginBegin);       
+    else if (SEEK_END == whence)
+        nContentPipeResult = h->hPipe->SetPosition(file_handle,offset, CP_OriginEnd);
+
+    if( 0 == nContentPipeResult) /* success */
+        return 0;
+    return -1;
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalGetCurrentFilePos
+ *
+ * Description: Gets file position.
+ *
+ * Return:      File Pointer.
+ *    
+ ****************************************************************************/
+static int64  appLocalGetCurrentFilePos( FslFileHandle file_handle, void * context)
+{
+    
+    CPint64 pos;
+    Parser *h = (Parser *)context;
+    CPresult nContentPipeResult;
+    if (!file_handle || !context)
+        return -1;
+
+    nContentPipeResult = h->hPipe->GetPosition(file_handle,&pos);
+    if (0 == nContentPipeResult)
+        return pos;
+    else
+        return -1;
+}
+   
+/*****************************************************************************
+ * Function:    appLocalFileSize. For source file only
+ *
+ * Description: get the size of the file
+ *
+ * Return:      File Pointer.
+ *    
+ ****************************************************************************/
+
+static int64   appLocalFileSize( FslFileHandle file_handle, void * context)
+{
+	Parser *h = (Parser *)context;
+
+    if(NULL == file_handle)
+    {
+        file_handle = appLocalFileOpen((const uint8*) h->pMediaName,(const uint8*) "rb", context);
+    }
+
+    if(h->IsLiveSource() == OMX_TRUE)
+        return 0;
+
+    if(file_handle)
+    {
+        CPint64 size;
+        CPint64 pos;
+        CPresult nContentPipeResult;
+        Parser *h = (Parser *)context;
+        nContentPipeResult = h->hPipe->GetPosition(file_handle,&pos); if (0 != nContentPipeResult) return -1;
+        nContentPipeResult = h->hPipe->SetPosition(file_handle, 0, CP_OriginEnd);if (0 != nContentPipeResult) return -1;
+        nContentPipeResult = h->hPipe->GetPosition(file_handle,&size); if (0 != nContentPipeResult) return -1;
+        nContentPipeResult = h->hPipe->SetPosition(file_handle,pos, CP_OriginBegin);if (0 != nContentPipeResult) return -1;
+
+        h->nContentLen = size;
+        LOG_DEBUG("Content Len = %lld\n", h->nContentLen);
+
+        return size;
+    }
+    else
+        return -1; 
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalFileClose
+ *
+ * Description: Implements to close the file.
+ *
+ * Return:      Sucess or EOF.
+ *    
+ ****************************************************************************/
+static int32 appLocalFileClose( FslFileHandle file_handle, void * context)
+{
+	Parser *h = (Parser *)context;
+    if(file_handle)
+    {
+        CPresult nContentPipeResult;
+        Parser *h = (Parser *)context;
+        OMX_BOOL bStreaming = h->IsStreamingSource();
+
+        if(bStreaming == OMX_TRUE)
+            h->SendEvent(OMX_EventBufferingData, 0, 0, NULL);
+        nContentPipeResult = h->hPipe->Close(file_handle);
+        if(bStreaming == OMX_TRUE)
+            h->SendEvent(OMX_EventBufferingDone, 0, 0, NULL);
+        file_handle = NULL;
+
+        if (0 != nContentPipeResult)
+            return -1;
+    }
+
+    return 0; 
+}
+
+static int64   appLocalCheckAvailableBytes(FslFileHandle file_handle, int64 bytesRequested, void * context)
+{
+    Parser *h = (Parser *)context;
+    if(file_handle)
+    {
+        if(OMX_ErrorNone != h->CheckContentAvailableBytes(file_handle, bytesRequested))
+            return 0;
+    }
+    return bytesRequested;
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalGetFlag
+ *
+ * Description: Implements to get properties of file source
+ *
+ * Return:      flag of properties
+ *
+ ****************************************************************************/
+static uint32  appLocalGetFlag( FslFileHandle file_handle, void * context)
+{
+    uint32 flag = 0;
+    Parser *h = (Parser *)context;
+
+    if(h->IsLiveSource()){
+        flag |= FILE_FLAG_NON_SEEKABLE;
+        flag |= FILE_FLAG_READ_IN_SEQUENCE;
+    }
+    if(h->IsStreamingSource())
+        flag |= FILE_FLAG_READ_IN_SEQUENCE;
+
+    return flag;
+}
+
+static void *appLocalCalloc(uint32 TotalNumber, uint32 TotalSize)
+{
+    void *PtrCalloc = NULL;
+
+    if((0 == TotalSize)||(0==TotalNumber))
+        LOG_WARNING("\nWarning: ZERO size IN LOCAL CALLOC");
+    
+	PtrCalloc = FSL_MALLOC(TotalNumber*TotalSize);
+    
+	if (PtrCalloc == NULL) {
+
+		LOG_ERROR("\nError: MEMORY FAILURE IN LOCAL CALLOC");
+                return NULL;
+	}	
+    fsl_osal_memset(PtrCalloc, 0, TotalSize*TotalNumber);	
+	return (PtrCalloc);
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalMalloc
+ *
+ * Description: Implements the local malloc 
+ *
+ * Return:      Value of the address. 
+ *    
+ ****************************************************************************/
+
+static void* appLocalMalloc (uint32 TotalSize) 
+{
+
+	void *PtrMalloc = NULL;
+
+    if(0 == TotalSize)
+        LOG_WARNING("\nWarning: ZERO size IN LOCAL MALLOC");
+
+	PtrMalloc = FSL_MALLOC(TotalSize);	
+
+	if (PtrMalloc == NULL) {
+
+		LOG_ERROR("\nError: MEMORY FAILURE IN LOCAL MALLOC");
+	}
+	return (PtrMalloc);
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalFree
+ *
+ * Description: Implements to Free the memory.
+ *
+ * Return:      Void 
+ *    
+ ****************************************************************************/
+static void appLocalFree (void *MemoryBlock) 
+{
+    if(MemoryBlock)
+        FSL_FREE(MemoryBlock);
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalReAlloc
+ *
+ * Description: Implements to Free the memory.
+ *
+ * Return:      Void 
+ *    
+ ****************************************************************************/
+static void * appLocalReAlloc (void *MemoryBlock, uint32 TotalSize) 
+{
+    void *PtrMalloc = NULL;
+
+    if(0 == TotalSize)
+        LOG_WARNING("\nWarning: ZERO size IN LOCAL REALLOC");
+
+    PtrMalloc = (void *)FSL_REALLOC(MemoryBlock, TotalSize);
+    if (PtrMalloc == NULL) {
+    LOG_ERROR("\nError: MEMORY FAILURE IN LOCAL REALLOC");
+    }	
+    
+    return PtrMalloc;
+}
+
+Parser::Parser()
+{
+    ComponentVersion.s.nVersionMajor = 0x0;
+    ComponentVersion.s.nVersionMinor = 0x1;
+    ComponentVersion.s.nRevision = 0x0;
+    ComponentVersion.s.nStep = 0x0;
+    bInContext = OMX_FALSE;
+    nPorts = 3;
+    hPipe = NULL;
+    pAudioOutBufHdr = pVideoOutBufHdr = pClockBufHdr = NULL; 
+    nClockScale = 1*Q16_SHIFT;
+    nMediaNameLen = 0;
+    bAudioNewSegment = OMX_TRUE;
+    bVideoNewSegment = OMX_TRUE;
+    bSubtitleNewSegment=OMX_TRUE;
+    bAudioEOS = OMX_FALSE;
+    bVideoEOS = OMX_FALSE;
+    bSubtitleEOS = OMX_FALSE;
+    sCurrAudioTime = 0;
+    sCurrVideoTime = 0;
+    sCurrSubtitleTime=0;
+    pMediaName = NULL;
+    hMedia = NULL;
+    sSeekMode.eType = OMX_TIME_SeekModeFast;
+    sAudioSeekPos = 0;
+    sVideoSeekPos = 0;
+    sSubtitleSeekPos=0;
+    bSeekable = OMX_FALSE;
+    sAudioPortFormat.eEncoding = OMX_AUDIO_CodingAutoDetect;
+    sVideoPortFormat.eCompressionFormat = OMX_VIDEO_CodingAutoDetect;
+    bVideoBOS = OMX_FALSE;
+    nNumAvailAudioStream = 0;
+    nNumAvailVideoStream = 0;
+    nNumAvailSubtitleStream = 0;
+    nActiveAudioNum = 0;
+	nActiveAudioNumToClient = 0;
+	nActiveSubtitleNumToClient=-1;	//not actived
+	nActiveVideoNum = 0;
+	nActiveSubtitleNum = 0;
+    usDuration = 0;
+    nAudioDuration = 0;
+    nVideoDuration = 0;
+    nCommonRotate = 0;
+    bStopReading = OMX_FALSE;
+    fileOps.Open = appLocalFileOpen;
+    fileOps.Read= appLocalReadFile;
+    fileOps.Seek = appLocalSeekFile;
+    fileOps.Tell = appLocalGetCurrentFilePos;
+    fileOps.Size= appLocalFileSize;
+    fileOps.Close = appLocalFileClose;
+    fileOps.CheckAvailableBytes = appLocalCheckAvailableBytes;
+    fileOps.GetFlag = appLocalGetFlag;
+
+    memOps.Calloc = appLocalCalloc;
+    memOps.Malloc = appLocalMalloc;
+    memOps.Free= appLocalFree;
+    memOps.ReAlloc= appLocalReAlloc;
+
+    fsl_osal_memset(nAudioTrackNum, 0, sizeof(OMX_U32)*MAX_AVAIL_TRACK);
+    fsl_osal_memset(nVideoTrackNum, 0, sizeof(OMX_U32)*MAX_AVAIL_TRACK);
+    fsl_osal_memset(nSubtitleTrackNum, 0, sizeof(OMX_U32)*MAX_AVAIL_TRACK);
+    OMX_INIT_STRUCT(&sCompRole, OMX_PARAM_COMPONENTROLETYPE);
+	fsl_osal_memset(sCompRole.cRole, 0, OMX_MAX_STRINGNAME_SIZE);
+    numTracks = 0;
+    fsl_osal_memset(index_file_name, 0, INDEX_FILE_NAME_MAX_LEN);
+    bSendAudioFrameFirst = OMX_FALSE;
+    sActualVideoSeekPos = sActualAudioSeekPos =sActualSubtitleSeekPos= 0;
+    bHasVideoTrack = bHasAudioTrack = OMX_FALSE;
+    bAudioCodecDataSent = bVideoCodecDataSent = OMX_FALSE;
+    bStreamCorrupted = OMX_FALSE;
+    bSkip2Iframe = OMX_FALSE;
+    bAudioActived = bVideoActived = bSubtitleActived = OMX_FALSE;
+    OMX_INIT_STRUCT(&sMatadataItemCount, OMX_CONFIG_METADATAITEMCOUNTTYPE);
+	for (OMX_U32 i = 0; i < MAX_MATADATA_NUM; i ++)
+	{
+		psMatadataItem[i] = NULL;
+	}
+    isLiveSource = OMX_FALSE;
+	bGetMetadata = OMX_FALSE;
+    isStreamingSource = OMX_FALSE;
+    nPreCacheSize = 0;
+    nCheckCacheOff = 0;
+    nContentLen = 0;
+    bAbortBuffering = OMX_FALSE;
+    nVideoCodecDataLen = 0;
+    bInsertVideoCodecData = OMX_FALSE;
+    Lock = NULL;
+}
+
+
+OMX_ERRORTYPE Parser::CheckContentAvailableBytes(OMX_PTR file_handle, OMX_U32 nb)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    CPresult nContentPipeResult;
+    CP_CHECKBYTESRESULTTYPE eReady; 
+    OMX_U32 cBytes = nb;
+
+    if(file_handle == NULL)
+        return OMX_ErrorBadParameter;
+
+    nContentPipeResult = hPipe->CheckAvailableBytes(file_handle, cBytes, &eReady);
+    if(nContentPipeResult == KD_ENETWORKFAIL){
+        printf("parser send OMX_EventNetworkFail");
+        SendEvent(OMX_EventNetworkFail, 0, 0, NULL);
+        return OMX_ErrorNoMore;
+    }
+    
+    if (eReady == CP_CheckBytesInsufficientBytes) {
+        LOG_DEBUG("Resource is NOT available: %d\n", cBytes);
+        if(isStreamingSource != OMX_TRUE)
+            return OMX_ErrorNoMore;
+        else {
+            SendEvent(OMX_EventBufferingData, 0, 0, NULL);
+            cBytes = nPreCacheSize;
+            if(cBytes == 0)
+                cBytes = nb;
+            else {
+                nCheckCacheOff = 0;
+                if(0 == hPipe->GetPosition(file_handle, &nCheckCacheOff))
+                    nCheckCacheOff += cBytes;
+            }
+
+            cBytes = MAX(cBytes, nb);
+            while(1) {
+                fsl_osal_sleep(10000);
+                if (bAbortBuffering == OMX_TRUE) {
+                    LOG_DEBUG("Parser::CheckContentAvailableBytes Abort buffering data.\n");
+                    SendEvent(OMX_EventBufferingDone, 0, 0, NULL);
+                    return OMX_ErrorUndefined;
+                }
+                if (OMX_TRUE == bHasCmdToProcess()) {
+                    LOG_DEBUG("Has command to process in parser component, abort buffering data.\n");
+                    SendEvent(OMX_EventBufferingDone, 0, 0, NULL);
+                    break;
+                }
+                nContentPipeResult = hPipe->CheckAvailableBytes(file_handle,cBytes,&eReady);
+                if ((nContentPipeResult == 0 && eReady != CP_CheckBytesInsufficientBytes)|| nContentPipeResult == KD_ENETWORKFAIL ) {
+                    if(nContentPipeResult == KD_ENETWORKFAIL){
+                        printf("parser send OMX_EventNetworkFail");
+                        SendEvent(OMX_EventNetworkFail, 0, 0, NULL);
+                    }
+                    SendEvent(OMX_EventBufferingDone, 0, 0, NULL);
+                    LOG_DEBUG("Resource is available %d\n", cBytes);
+                    break;
+                }
+            }
+        }
+    }
+
+    if(isStreamingSource == OMX_TRUE && nContentLen > 0 && nCheckCacheOff > 0) {
+        hPipe->CheckAvailableBytes(file_handle, -1, &eReady);
+        OMX_S32 nAvailabe = (OMX_S32)eReady;
+        CPint64 nPos = 0;
+        hPipe->GetPosition(file_handle, &nPos);
+        nPos += eReady;
+        if(nPos >= nCheckCacheOff) {
+            OMX_S32 nPercentage = 100 * nPos / nContentLen;
+            SendEvent(OMX_EventBufferingUpdate, nPercentage, 0, NULL);
+            nCheckCacheOff = nPos + nPreCacheSize;
+        }
+        if((OMX_U64)nPos >= nContentLen) {
+            SendEvent(OMX_EventBufferingUpdate, 100, 0, NULL);
+            nCheckCacheOff = 0;
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Parser::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+    if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&Lock, fsl_osal_mutex_normal)) {
+        ret = OMX_ErrorInsufficientResources;
+        return ret;
+    }
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = AUDIO_OUTPUT_PORT;
+    sPortDef.eDir = OMX_DirOutput;
+    sPortDef.eDomain = OMX_PortDomainAudio;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 3;
+    sPortDef.nBufferSize = DEFAULT_PARSER_AUDIO_OUTPUT_BUFSIZE;
+    ret = ports[AUDIO_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for port[%d] failed.\n", AUDIO_OUTPUT_PORT);
+        return ret;
+    }
+
+    sPortDef.nPortIndex = VIDEO_OUTPUT_PORT;
+    sPortDef.eDir = OMX_DirOutput;
+    sPortDef.eDomain = OMX_PortDomainVideo;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 5;
+    sPortDef.nBufferSize = DEFAULT_PARSER_OUTPUT_BUFSIZE;
+    ret = ports[VIDEO_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for port[%d] failed.\n", VIDEO_OUTPUT_PORT);
+        return ret;
+    }
+	
+	sPortDef.nPortIndex = CLOCK_PORT;
+	sPortDef.eDir = OMX_DirInput;
+	sPortDef.eDomain = OMX_PortDomainOther;	
+	sPortDef.bPopulated = OMX_FALSE;	
+	sPortDef.bEnabled = OMX_FALSE;	
+	sPortDef.nBufferCountMin = 1;	
+	sPortDef.nBufferCountActual = 1;
+	sPortDef.nBufferSize = sizeof(OMX_TIME_MEDIATIMETYPE);
+	sPortDef.format.other.eFormat = OMX_OTHER_FormatTime;	
+	ret = ports[CLOCK_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for port[%d] failed.\n", CLOCK_PORT);
+        return ret;
+    }
+
+    if(!hPipe)
+    {
+        ret = OMX_GetContentPipe((void **)&hPipe, (OMX_STRING)"LOCAL_FILE_PIPE_NEW");
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::DeInitComponent()
+{
+    if(Lock != NULL) {
+        fsl_osal_mutex_destroy(Lock);
+        Lock = NULL;
+    }
+
+    if (pMediaName)
+    {
+        FSL_FREE(pMediaName);
+        pMediaName = NULL;
+    }
+
+	for (OMX_U32 i = 0; i < MAX_MATADATA_NUM; i ++)
+	{
+		FSL_FREE(psMatadataItem[i]);;
+	}
+
+    return OMX_ErrorNone;
+}
+
+
+OMX_ERRORTYPE Parser::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	switch ((int)nParamIndex) {
+		case OMX_IndexParamStandardComponentRole:
+			{
+                OMX_PARAM_COMPONENTROLETYPE *pRole;
+                pRole = (OMX_PARAM_COMPONENTROLETYPE*)pComponentParameterStructure;
+
+                OMX_CHECK_STRUCT(pRole, OMX_PARAM_COMPONENTROLETYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+				fsl_osal_strcpy((OMX_STRING)pRole->cRole, (OMX_STRING)sCompRole.cRole);
+
+				break;		
+			}
+		case OMX_IndexParamContentURI:
+            {
+                OMX_PARAM_CONTENTURITYPE * pContentURI = (OMX_PARAM_CONTENTURITYPE *)pComponentParameterStructure;
+
+                strcpy((char *)&pContentURI->contentURI,(const char*)pMediaName);
+            }
+            break;
+		case OMX_IndexParamNumAvailableStreams:
+			{
+				OMX_PARAM_U32TYPE *sU32Type = (OMX_PARAM_U32TYPE*)pComponentParameterStructure;
+				if (sU32Type->nPortIndex == VIDEO_OUTPUT_PORT)
+				{
+	                sU32Type->nU32 = nNumAvailVideoStream;	
+				}
+				else if (sU32Type->nPortIndex == AUDIO_OUTPUT_PORT)
+				{
+	                sU32Type->nU32 = nNumAvailAudioStream;	
+				}
+				break;
+			}
+		case OMX_IndexParamActiveStream:
+			{
+				OMX_PARAM_U32TYPE *sU32Type = (OMX_PARAM_U32TYPE*)pComponentParameterStructure;
+				if (sU32Type->nPortIndex == VIDEO_OUTPUT_PORT)
+				{
+	                sU32Type->nU32 = nActiveVideoNum;	
+				}
+				else if (sU32Type->nPortIndex == AUDIO_OUTPUT_PORT)
+				{
+	                sU32Type->nU32 = nActiveAudioNumToClient;	
+				}
+				break;
+			}	
+        case OMX_IndexParamTrackDuration:
+            {
+                OMX_TRACK_DURATION *pTrackDuration = (OMX_TRACK_DURATION *)pComponentParameterStructure;
+                if (pTrackDuration->nPortIndex == VIDEO_OUTPUT_PORT)
+                {
+                    pTrackDuration->sTrackDuration = (OMX_TICKS)nVideoDuration;
+                }
+                else if (pTrackDuration->nPortIndex == AUDIO_OUTPUT_PORT)
+                {
+                    pTrackDuration->sTrackDuration = (OMX_TICKS)nAudioDuration;
+                }
+                break;
+            }        
+        case OMX_IndexParamMediaSeekable:
+            {
+                OMX_PARAM_CAPABILITY  *pMediaSeekable;
+                pMediaSeekable    = (OMX_PARAM_CAPABILITY *)pComponentParameterStructure;
+                pMediaSeekable->bCapability = bSeekable;
+                break;
+            }        
+         case OMX_IndexParamMediaDuration:
+            {
+                OMX_TIME_CONFIG_TIMESTAMPTYPE  *pMediaDuration
+                    = (OMX_TIME_CONFIG_TIMESTAMPTYPE  *)pComponentParameterStructure;
+                pMediaDuration->nTimestamp  = (OMX_TICKS)usDuration;
+                break;
+            }        
+	case OMX_IndexParamSubtitleNumAvailableStreams:
+	    OMX_S32 *pCnt;
+	     pCnt= (OMX_S32*)pComponentParameterStructure;
+            *pCnt=nNumAvailSubtitleStream;
+	     break;
+       case OMX_IndexParamSubtitleSelect:
+            OMX_S32* pIndex;
+	     pIndex =(OMX_S32*)pComponentParameterStructure;
+            *pIndex=nActiveSubtitleNumToClient;
+            break;		 
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+	switch ((int)nParamIndex) {
+		case OMX_IndexParamStandardComponentRole:
+			{
+                OMX_PARAM_COMPONENTROLETYPE *pRole;
+                pRole = (OMX_PARAM_COMPONENTROLETYPE*)pComponentParameterStructure;
+
+                OMX_CHECK_STRUCT(pRole, OMX_PARAM_COMPONENTROLETYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+				fsl_osal_strcpy( (fsl_osal_char *)sCompRole.cRole, (fsl_osal_char *)pRole->cRole);
+				break;		
+			}
+		case OMX_IndexParamCustomContentPipe:
+			hPipe =(CP_PIPETYPE* ) (((OMX_PARAM_CONTENTPIPETYPE *)pComponentParameterStructure)->hPipe);
+			break;
+		case OMX_IndexParamContentURI:
+		{
+			OMX_PARAM_CONTENTURITYPE * pContentURI = (OMX_PARAM_CONTENTURITYPE *)pComponentParameterStructure;
+			nMediaNameLen = strlen((const char *)&(pContentURI->contentURI)) + 1;
+				
+            pMediaName = (OMX_S8 *)FSL_MALLOC(nMediaNameLen);
+            if (!pMediaName)
+            {
+                ret = OMX_ErrorInsufficientResources;
+                break;
+            }
+			strcpy((char *)pMediaName, (const char *)&(pContentURI->contentURI));
+                        if(fsl_osal_strncmp((fsl_osal_char*)pMediaName, "http://", 7) == 0
+                                || fsl_osal_strncmp((fsl_osal_char*)pMediaName, "udp://", 6) == 0
+                                || fsl_osal_strncmp((fsl_osal_char*)pMediaName, "rtsp://", 7) == 0
+                                || fsl_osal_strncmp((fsl_osal_char*)pMediaName, "rtp://", 6) == 0
+                                || fsl_osal_strncmp((fsl_osal_char*)pMediaName, "mms://", 6) == 0)
+                            isStreamingSource = OMX_TRUE;
+                        if(fsl_osal_strncmp((fsl_osal_char*)pMediaName, "udp://", 6) == 0
+                                || fsl_osal_strncmp((fsl_osal_char*)pMediaName, "rtp://", 6) == 0
+                            )
+                            isLiveSource = OMX_TRUE;
+
+			break;
+		}
+        case OMX_IndexParamActiveStream:
+            OMX_PARAM_U32TYPE *sU32Type;
+            sU32Type = (OMX_PARAM_U32TYPE*)pComponentParameterStructure;
+
+            if (sU32Type->nPortIndex == VIDEO_OUTPUT_PORT)
+            {
+                if((OMX_S32)sU32Type->nU32 < 0) {
+                    DisableTrack(nActiveVideoNum);
+                    break;
+                }
+
+                if (nActiveVideoNum != nVideoTrackNum[sU32Type->nU32])
+                    DisableTrack(nActiveVideoNum);
+                nActiveVideoNum = nVideoTrackNum[sU32Type->nU32];	
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = VIDEO_OUTPUT_PORT;
+                ports[VIDEO_OUTPUT_PORT]->GetPortDefinition(&sPortDef);
+                SetVideoCodecType(&sPortDef,nActiveVideoNum);
+                ports[VIDEO_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+                ActiveTrack(nActiveVideoNum);
+                bVideoActived = OMX_TRUE;
+            }
+            else if (sU32Type->nPortIndex == AUDIO_OUTPUT_PORT)
+            {
+                if((OMX_S32)sU32Type->nU32 < 0) {
+                    DisableTrack(nActiveAudioNum);
+                    break;
+                }
+
+                if (sU32Type->nU32 > nNumAvailAudioStream)
+                {
+                    LOG_WARNING("Audio track is out of range.\n");
+                    ret = OMX_ErrorBadParameter;
+                    break;
+                }
+
+                if(nActiveAudioNumToClient != sU32Type->nU32)
+                    DisableTrack(nActiveAudioNum);
+                nActiveAudioNumToClient = sU32Type->nU32;
+                nActiveAudioNum = nAudioTrackNum[sU32Type->nU32];	
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = AUDIO_OUTPUT_PORT;
+                ports[AUDIO_OUTPUT_PORT]->GetPortDefinition(&sPortDef);
+                SetAudioCodecType(&sPortDef,nActiveAudioNum);               
+                ports[AUDIO_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+                ActiveTrack(nActiveAudioNum);
+                bAudioActived = OMX_TRUE;
+            }
+            break;
+		case OMX_IndexParamIsGetMetadata:
+		{
+			OMX_PARAM_IS_GET_METADATA * pIsGetMetadata = (OMX_PARAM_IS_GET_METADATA *)pComponentParameterStructure;
+			bGetMetadata = pIsGetMetadata->bGetMetadata;
+			break;
+		}
+        case OMX_IndexParamSubtitleSelect:
+           OMX_S32 Index;
+	    Index =*((OMX_S32*)pComponentParameterStructure);
+           if(Index < 0) {
+                DisableTrack(nActiveSubtitleNum);  //disable subtitle
+                nActiveSubtitleNumToClient=-1;
+                bSubtitleActived=OMX_FALSE;                
+                break;
+           }
+           if(Index>=(OMX_S32)nNumAvailSubtitleStream){
+                return OMX_ErrorBadParameter;   //invalid subtitle track number
+           }
+           if ((nActiveSubtitleNum != nSubtitleTrackNum[Index])&&(OMX_TRUE==bSubtitleActived))
+                DisableTrack(nActiveSubtitleNum);
+           nActiveSubtitleNumToClient=Index;
+           nActiveSubtitleNum = nSubtitleTrackNum[Index];	
+           ActiveTrack(nActiveSubtitleNum);
+           bSubtitleActived = OMX_TRUE;
+           break;
+        default :
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentConfigStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    switch ((int)nParamIndex )
+    {
+        case OMX_IndexConfigTimeSeekMode :
+            if (sizeof(*(OMX_TIME_CONFIG_SEEKMODETYPE*)pComponentConfigStructure) < sizeof(OMX_TIME_CONFIG_SEEKMODETYPE))
+            {
+                ret = OMX_ErrorInsufficientResources;
+                break;
+            }
+            fsl_osal_memcpy(pComponentConfigStructure,&sSeekMode, sizeof(OMX_TIME_CONFIG_SEEKMODETYPE));
+            break;
+        case OMX_IndexConfigTimePosition:
+            OMX_TIME_CONFIG_TIMESTAMPTYPE* pCurrPos;
+            pCurrPos = (OMX_TIME_CONFIG_TIMESTAMPTYPE*)pComponentConfigStructure;
+
+            if (pCurrPos->nPortIndex == VIDEO_OUTPUT_PORT)
+                pCurrPos->nTimestamp = sCurrVideoTime;
+            else 
+                pCurrPos->nTimestamp = sCurrAudioTime;
+
+           break;
+		case OMX_IndexConfigMetadataItemCount:
+		   OMX_CONFIG_METADATAITEMCOUNTTYPE* pMatadataItemCount;
+		   pMatadataItemCount = (OMX_CONFIG_METADATAITEMCOUNTTYPE*)pComponentConfigStructure;
+
+		   pMatadataItemCount->nMetadataItemCount = sMatadataItemCount.nMetadataItemCount;
+
+		   break;
+		case OMX_IndexConfigMetadataItem:
+		   OMX_CONFIG_METADATAITEMTYPE* pMatadataItem;
+		   pMatadataItem = (OMX_CONFIG_METADATAITEMTYPE*)pComponentConfigStructure;
+
+		   if (pMatadataItem->nMetadataItemIndex >= sMatadataItemCount.nMetadataItemCount)
+			   break;
+
+		   if (pMatadataItem->eSearchMode == OMX_MetadataSearchValueSizeByIndex) {
+			   pMatadataItem->nValueMaxSize = psMatadataItem[pMatadataItem->nMetadataItemIndex]->nValueMaxSize;
+		   } else if (pMatadataItem->eSearchMode == OMX_MetadataSearchItemByIndex) {
+			   fsl_osal_memcpy(pMatadataItem->nKey, psMatadataItem[pMatadataItem->nMetadataItemIndex]->nKey, 128);
+			   pMatadataItem->nKeySizeUsed = 128;
+			   fsl_osal_memcpy(pMatadataItem->nValue, psMatadataItem[pMatadataItem->nMetadataItemIndex]->nValue, psMatadataItem[pMatadataItem->nMetadataItemIndex]->nValueSizeUsed);
+			   pMatadataItem->nValueSizeUsed = psMatadataItem[pMatadataItem->nMetadataItemIndex]->nValueSizeUsed;
+		   }
+
+		   break;
+                case OMX_IndexParamSubtitleNumAvailableStreams:
+                   OMX_S32 *pCnt;
+                   pCnt= (OMX_S32*)pComponentConfigStructure;
+                   *pCnt=nNumAvailSubtitleStream;
+                   break;		   
+                case OMX_IndexParamSubtitleSelect:
+                   OMX_S32* pIndex;
+                   pIndex =(OMX_S32*)pComponentConfigStructure;
+                   *pIndex=nActiveSubtitleNumToClient;
+                   break;
+                case OMX_IndexParamSubtitleNextSample:
+                   OMX_SUBTITLE_SAMPLE* pSampleHdr;
+                   pSampleHdr=(OMX_SUBTITLE_SAMPLE*)pComponentConfigStructure;
+                   pSampleHdr->pBuffer=NULL;
+                   if(OMX_FALSE==bSubtitleActived){
+                       LOG_ERROR("not subtitle actived ");
+                       return OMX_ErrorUndefined;
+                   }
+                   ret=GetAndSendOneSubtitleBuf(pSampleHdr);
+                   if(ret!=OMX_ErrorNone){
+                        pSampleHdr->pBuffer=NULL;  //avoid user use invalid data
+                   }
+                   break;
+        case OMX_IndexConfigCommonRotate:
+            OMX_CONFIG_ROTATIONTYPE *pRotation;
+            pRotation = (OMX_CONFIG_ROTATIONTYPE*)pComponentConfigStructure;
+            pRotation->nRotation = (OMX_S32)nCommonRotate;
+            break; 
+		default :
+		   break;
+	}
+	return ret;
+
+}
+
+OMX_ERRORTYPE Parser::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentConfigStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    switch ((int)nParamIndex )
+    {
+        case OMX_IndexConfigTimePosition :
+            OMX_TIME_CONFIG_TIMESTAMPTYPE* pSeekPos;
+            pSeekPos = (OMX_TIME_CONFIG_TIMESTAMPTYPE*)pComponentConfigStructure;
+
+            OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+            OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+            sPortDef.nPortIndex = VIDEO_OUTPUT_PORT;
+            ports[VIDEO_OUTPUT_PORT]->GetPortDefinition(&sPortDef);
+
+            if (!bSeekable && pSeekPos->nTimestamp > 0)
+                return OMX_ErrorUndefined;
+
+            // seeking to 0 is not supported by VPU for h264 in TS
+            if(!bSeekable && pSeekPos->nTimestamp==0 
+                    && sPortDef.format.video.eCompressionFormat == OMX_VIDEO_CodingAVC 
+                    && strcmp((char *)sCompRole.cRole, "parser.mpg2")==0)
+                return OMX_ErrorUndefined;
+
+            if (pSeekPos->nPortIndex == AUDIO_OUTPUT_PORT)
+            {
+                sAudioSeekPos = pSeekPos->nTimestamp;
+            }
+            else
+            {
+                sAudioSeekPos = pSeekPos->nTimestamp;
+                sVideoSeekPos = pSeekPos->nTimestamp;
+                sSubtitleSeekPos=pSeekPos->nTimestamp;
+            }
+
+            Seek(pSeekPos->nPortIndex);
+
+            break;
+        case OMX_IndexConfigTimeSeekMode:
+            if (sizeof(*(OMX_TIME_CONFIG_SEEKMODETYPE*)pComponentConfigStructure) < sizeof(OMX_TIME_CONFIG_SEEKMODETYPE))
+            {
+                ret = OMX_ErrorInsufficientResources;
+                break;
+            }
+            fsl_osal_memcpy(&sSeekMode, pComponentConfigStructure, sizeof(OMX_TIME_CONFIG_SEEKMODETYPE));
+            break;
+
+        case OMX_IndexConfigParserSendAudioFirst:
+            OMX_CONFIG_SENDAUDIOFIRST *pConfig;
+            pConfig = (OMX_CONFIG_SENDAUDIOFIRST*)pComponentConfigStructure;
+            bSendAudioFrameFirst = pConfig->bSendAudioFrameFirst;
+            break; 
+
+        case OMX_IndexConfigAbortBuffering:
+            OMX_CONFIG_ABORTBUFFERING *pAbort;
+            pAbort = (OMX_CONFIG_ABORTBUFFERING*)pComponentConfigStructure;
+            bAbortBuffering = pAbort->bAbort;
+            AbortReadSource(bAbortBuffering);
+            break;
+        case OMX_IndexParamSubtitleSelect:
+            OMX_S32 Index;
+            Index =*((OMX_S32*)pComponentConfigStructure);
+            if(Index < 0) {
+                DisableTrack(nActiveSubtitleNum);  //disable subtitle
+                nActiveSubtitleNumToClient=-1;
+                bSubtitleActived=OMX_FALSE;
+                break;
+            }
+            if(Index>=(OMX_S32)nNumAvailSubtitleStream){
+                return OMX_ErrorBadParameter;   //invalid subtitle track number
+            }
+            if ((nActiveSubtitleNum != nSubtitleTrackNum[Index])&&(OMX_TRUE==bSubtitleActived))
+                DisableTrack(nActiveSubtitleNum);
+            nActiveSubtitleNumToClient=Index;
+            nActiveSubtitleNum = nSubtitleTrackNum[Index];	
+            ActiveTrack(nActiveSubtitleNum);
+            bSubtitleActived = OMX_TRUE;
+            break;
+        case OMX_IndexParamSubtitleConfigTimePosition:
+            OMX_TICKS ts;
+            ts=*((OMX_TICKS*)pComponentConfigStructure);
+            if (!bSeekable || !bSubtitleActived)  return OMX_ErrorUndefined;
+            bSubtitleNewSegment=OMX_TRUE;
+            bSubtitleEOS=OMX_FALSE;
+            sSubtitleSeekPos=ts;
+            ret=DoSubtitleSeek(SEEK_FLAG_NO_LATER);
+            if (ret == OMX_ErrorStreamCorrupt)
+                bStreamCorrupted = OMX_TRUE;
+            if (ret == OMX_ErrorNoMore)
+                bSubtitleEOS = OMX_TRUE;
+            sSubtitleSeekPos=sActualSubtitleSeekPos;
+            sCurrSubtitleTime=sActualSubtitleSeekPos;
+            break;
+        case OMX_IndexConfigInsertVideoCodecData:
+            bInsertVideoCodecData = *(OMX_BOOL*)pComponentConfigStructure;
+            break;
+        default:
+            break;
+    }
+    return ret;
+}
+
+
+OMX_ERRORTYPE Parser::GetAndSendOneVideoBuf()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if ((bVideoEOS && !bVideoNewSegment) || bStreamCorrupted)
+        return ret;
+
+    ports[VIDEO_OUTPUT_PORT]->GetBuffer(&pVideoOutBufHdr);
+    if(pVideoOutBufHdr == NULL)
+        return OMX_ErrorUnderflow;
+
+        static FILE *pfTest = NULL;
+        /*
+        if (pfTest==NULL) {
+            int i = (int)random();
+            int j = i%1000;
+            char name[50], number[10];
+            strcpy(name, "/data/DumpData");
+            sprintf(number,"_%d", j);
+            strcat(name, number);
+            strcat(name,".mp4");
+            pfTest = fopen(name, "wb");
+            if(pfTest == NULL)
+                printf("Unable to open dump file! %s\n", name);
+            else
+                printf("open dump file %s\n", name);
+        }
+        */
+
+    if(bInsertVideoCodecData && nVideoCodecDataLen > 0) {
+        LOG_DEBUG("Send video codec specific data.\n");
+        fsl_osal_memcpy(pVideoOutBufHdr->pBuffer, VideoCodecData, nVideoCodecDataLen);
+        pVideoOutBufHdr->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
+        pVideoOutBufHdr->nFilledLen = nVideoCodecDataLen;
+        bInsertVideoCodecData = OMX_FALSE;
+        if(pfTest != NULL  && pVideoOutBufHdr->nFilledLen > 0)  {
+                fwrite(pVideoOutBufHdr->pBuffer, sizeof(char), pVideoOutBufHdr->nFilledLen, pfTest);
+                fflush(pfTest);
+         }
+        ports[VIDEO_OUTPUT_PORT]->SendBuffer(pVideoOutBufHdr);
+        return OMX_ErrorNone;
+    }
+
+    if(bSkip2Iframe != OMX_TRUE)
+        ret = GetNextSample(ports[VIDEO_OUTPUT_PORT],pVideoOutBufHdr);
+    else {
+        do{
+            ret = GetNextSample(ports[VIDEO_OUTPUT_PORT],pVideoOutBufHdr);
+            if (ret != OMX_ErrorNone)
+                break;
+        }while(!(pVideoOutBufHdr->nFlags&OMX_BUFFERFLAG_SYNCFRAME));
+        bSkip2Iframe = OMX_FALSE;
+    }
+
+    if (ret == OMX_ErrorNotReady) {
+        ports[VIDEO_OUTPUT_PORT]->AddBuffer(pVideoOutBufHdr);
+        fsl_osal_sleep(10000);
+        return OMX_ErrorNone;
+    }
+
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+
+    if (pVideoOutBufHdr->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+        LOG_DEBUG("Send video codec specific data.\n");
+        if(pVideoOutBufHdr->nFilledLen <= VIDEO_CODEC_DATA_BUFFER_LEN) {
+            fsl_osal_memcpy(VideoCodecData, pVideoOutBufHdr->pBuffer, pVideoOutBufHdr->nFilledLen);
+            nVideoCodecDataLen = pVideoOutBufHdr->nFilledLen;
+        }
+        else {
+            LOG_ERROR("can't copy video codec data, buffer is not enough! (%d), (%d)",
+                    pVideoOutBufHdr->nFilledLen, VIDEO_CODEC_DATA_BUFFER_LEN);
+        }
+        if(pfTest != NULL  && pVideoOutBufHdr->nFilledLen > 0)  {
+                fwrite(pVideoOutBufHdr->pBuffer, sizeof(char), pVideoOutBufHdr->nFilledLen, pfTest);
+                fflush(pfTest);
+         }
+        ports[VIDEO_OUTPUT_PORT]->SendBuffer(pVideoOutBufHdr);
+        return OMX_ErrorNone;
+    }
+
+    if (!(pVideoOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS))
+        sCurrVideoTime = pVideoOutBufHdr->nTimeStamp;
+
+    if (bVideoNewSegment)
+    {
+        pVideoOutBufHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+        LOG_DEBUG("%s,%d,send starttime, ts %lld.\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp);
+        bVideoNewSegment = OMX_FALSE;
+		if (pVideoOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS)
+		{
+			LOG_DEBUG("Seek to EOS.\n");
+			pVideoOutBufHdr->nTimeStamp = sActualVideoSeekPos;
+		}
+
+        /* Adjust actualVideo seek ts if returned from parser is not correct */
+        if(sActualVideoSeekPos != pVideoOutBufHdr->nTimeStamp) {
+            LOG_WARNING("Adjust actual video seek ts from %lld to %lld\n", sActualVideoSeekPos, pVideoOutBufHdr->nTimeStamp);
+            sActualVideoSeekPos = pVideoOutBufHdr->nTimeStamp;
+        }
+    }
+   
+    if (sSeekMode.eType == OMX_TIME_SeekModeAccurate) 
+    {
+        if (pVideoOutBufHdr->nTimeStamp < sVideoSeekPos)
+        {
+            LOG_DEBUG("%s,%d,Decode only ts %lld\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp);
+            pVideoOutBufHdr->nFlags |= OMX_BUFFERFLAG_DECODEONLY;
+        }
+        else
+            sSeekMode.eType = OMX_TIME_SeekModeFast;
+    }
+
+    if (bAbortBuffering == OMX_TRUE) {
+        pVideoOutBufHdr->nFilledLen = 0;
+        pVideoOutBufHdr->nFlags |= OMX_BUFFERFLAG_EOS;
+    }
+
+    if (pVideoOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS)
+    {
+        ComponentBase::SendEvent(OMX_EventBufferFlag,pVideoOutBufHdr->nOutputPortIndex,pVideoOutBufHdr->nFlags, NULL);
+        LOG_DEBUG("%s,%d,eos  ts %lld\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp);
+        bVideoEOS = OMX_TRUE;
+    }
+
+    LOG_DEBUG("%s,%d,send , ts %lld, flag: %x, len: %d.\n",__FUNCTION__,__LINE__,
+            pVideoOutBufHdr->nTimeStamp, pVideoOutBufHdr->nFlags, pVideoOutBufHdr->nFilledLen);
+    LOG_DEBUG("%s,%d,send , nFilledLen %d.\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nFilledLen);
+    LOG_DEBUG("%s,%d,send , nAllocLen %d.\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nAllocLen);
+    LOG_DEBUG("%s,%d,send , begin data %p.\n",__FUNCTION__,__LINE__,*((OMX_S32 *)pVideoOutBufHdr->pBuffer));
+    if(pfTest != NULL  && pVideoOutBufHdr->nFilledLen > 0)  {
+            fwrite(pVideoOutBufHdr->pBuffer, sizeof(char), pVideoOutBufHdr->nFilledLen, pfTest);
+            fflush(pfTest);
+     }
+    ports[VIDEO_OUTPUT_PORT]->SendBuffer(pVideoOutBufHdr);
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::GetAndSendOneAudioBuf()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_TICKS sActualSyncPoint = 0LL;
+
+    if ((bAudioEOS && !bAudioNewSegment) || bStreamCorrupted)
+        return ret;
+
+    ports[AUDIO_OUTPUT_PORT]->GetBuffer(&pAudioOutBufHdr);
+    if(pAudioOutBufHdr == NULL)
+        return OMX_ErrorUnderflow;
+	pAudioOutBufHdr->nFlags = 0;
+
+    ret = GetNextSample(ports[AUDIO_OUTPUT_PORT],pAudioOutBufHdr);
+    if (ret == OMX_ErrorNotReady) {
+        ports[AUDIO_OUTPUT_PORT]->AddBuffer(pAudioOutBufHdr);
+        fsl_osal_sleep(10000);
+        return OMX_ErrorNone;
+    }
+
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+
+    if (pAudioOutBufHdr->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+        LOG_DEBUG("Send audio codec specific data.\n");
+        ports[AUDIO_OUTPUT_PORT]->SendBuffer(pAudioOutBufHdr);
+        return OMX_ErrorNone;
+    }
+
+    if (bAudioNewSegment) 
+    {
+        if (sSeekMode.eType == OMX_TIME_SeekModeAccurate)
+            sActualSyncPoint = sVideoSeekPos;
+        else 
+            sActualSyncPoint = sActualVideoSeekPos;
+
+        while (pAudioOutBufHdr->nTimeStamp < sActualSyncPoint && !(pAudioOutBufHdr->nFlags&OMX_BUFFERFLAG_CODECCONFIG)
+            && !(pAudioOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS))
+        {
+            LOG_INFO("%s,%d,drop one audio buffer in parser, ts %lld sActualSyncPoint: %lld\n",__FUNCTION__,__LINE__,pAudioOutBufHdr->nTimeStamp, sActualSyncPoint);
+            ret = GetNextSample(ports[AUDIO_OUTPUT_PORT],pAudioOutBufHdr);
+            if(ret != OMX_ErrorNone)
+                break;
+        }
+    }
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+    if (ret == OMX_ErrorNoMore)
+        bAudioEOS = OMX_TRUE;
+
+    if (bAudioEOS && bAudioNewSegment) 
+            pAudioOutBufHdr->nTimeStamp = sActualSyncPoint;
+
+    if (!(pAudioOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS))
+        sCurrAudioTime = pAudioOutBufHdr->nTimeStamp;
+
+    if (bAudioNewSegment)
+    {
+        pAudioOutBufHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+        LOG_DEBUG("%s,%d,send starttime, ts %lld.\n",__FUNCTION__,__LINE__,pAudioOutBufHdr->nTimeStamp);
+        bAudioNewSegment = OMX_FALSE;
+    }
+
+    if (bAbortBuffering == OMX_TRUE) {
+        pAudioOutBufHdr->nFilledLen = 0;
+        pAudioOutBufHdr->nFlags |= OMX_BUFFERFLAG_EOS;
+    }
+
+    if (pAudioOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS)
+    {
+        ComponentBase::SendEvent(OMX_EventBufferFlag,pAudioOutBufHdr->nOutputPortIndex,pAudioOutBufHdr->nFlags, NULL);
+        LOG_DEBUG("%s,%d,send eos.\n",__FUNCTION__,__LINE__);
+        bAudioEOS = OMX_TRUE;
+    }
+
+    LOG_DEBUG("%s,%d,send , ts %lld, flag: %x, len: %d.\n",__FUNCTION__,__LINE__,
+            pAudioOutBufHdr->nTimeStamp, pAudioOutBufHdr->nFlags, pAudioOutBufHdr->nFilledLen);
+    ports[AUDIO_OUTPUT_PORT]->SendBuffer(pAudioOutBufHdr);
+
+
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::GetAndSendOneSubtitleBuf(OMX_SUBTITLE_SAMPLE* pSubtitleOutBufHdr)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_TICKS sActualSyncPoint = 0LL;
+
+    if ((bSubtitleEOS && !bSubtitleNewSegment) || bStreamCorrupted)
+        return OMX_ErrorNoMore;//return ret;
+
+    ret = GetNextSubtitleSample(pSubtitleOutBufHdr);
+
+    //LOG_INFO("ret: 0x%X, get one subtitle: track: %d, ts: %lld , length: %d, flag: 0x%X \r\n",ret,nActiveSubtitleNum,pSubtitleOutBufHdr->nTimeStamp,pSubtitleOutBufHdr->nFilledLen, pSubtitleOutBufHdr->nFlags);	
+
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+
+    if (bSubtitleNewSegment)
+    {
+        if (sSeekMode.eType == OMX_TIME_SeekModeAccurate)
+            sActualSyncPoint = sSubtitleSeekPos;
+        else 
+            sActualSyncPoint = sActualSubtitleSeekPos;
+
+        while (pSubtitleOutBufHdr->nTimeStamp < sActualSyncPoint && !(pSubtitleOutBufHdr->nFlags&OMX_BUFFERFLAG_CODECCONFIG)
+            && !(pSubtitleOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS))
+        {
+            LOG_INFO("%s,%d,drop one subtitle buffer in parser, ts %lld sActualSyncPoint: %lld\n",__FUNCTION__,__LINE__,pSubtitleOutBufHdr->nTimeStamp, sActualSyncPoint);
+            ret = GetNextSubtitleSample(pSubtitleOutBufHdr);
+            if(ret != OMX_ErrorNone)
+                break;
+        }
+    }
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+    if (ret == OMX_ErrorNoMore)
+        bSubtitleEOS = OMX_TRUE;
+
+    if (bSubtitleEOS && bSubtitleNewSegment) 
+            pSubtitleOutBufHdr->nTimeStamp = sActualSyncPoint;
+
+    if (!(pSubtitleOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS))
+        sCurrSubtitleTime = pSubtitleOutBufHdr->nTimeStamp;
+
+    if (bSubtitleNewSegment)
+    {
+        pSubtitleOutBufHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+        LOG_DEBUG("%s,%d,send starttime, ts %lld.\n",__FUNCTION__,__LINE__,pSubtitleOutBufHdr->nTimeStamp);
+        bSubtitleNewSegment = OMX_FALSE;
+    }
+
+    if (bAbortBuffering == OMX_TRUE) {
+        pSubtitleOutBufHdr->nFilledLen = 0;
+        pSubtitleOutBufHdr->nFlags |= OMX_BUFFERFLAG_EOS;
+    }
+
+    if (pSubtitleOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS)
+    {
+        bSubtitleEOS = OMX_TRUE;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::GetAndSendPrevSyncVideoBuf()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    
+    if (bVideoBOS || bStreamCorrupted)
+        return ret;
+
+    ports[VIDEO_OUTPUT_PORT]->GetBuffer(&pVideoOutBufHdr);
+    if(pVideoOutBufHdr == NULL)
+        return OMX_ErrorUnderflow;
+
+    ret = GetPrevSyncSample(ports[VIDEO_OUTPUT_PORT],pVideoOutBufHdr);
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+
+    /*equal timestamp means this buffer and its previous buffer belongs to same frame*/
+    while (sCurrVideoTime != pVideoOutBufHdr->nTimeStamp && 
+            sCurrVideoTime - pVideoOutBufHdr->nTimeStamp < OMX_TICKS_PER_SECOND)
+    {
+        ret = GetPrevSyncSample(ports[VIDEO_OUTPUT_PORT],pVideoOutBufHdr);
+        if(ret != OMX_ErrorNone)
+            break;
+    }
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+
+    if (bVideoNewSegment)
+    {
+        pVideoOutBufHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME | OMX_BUFFERFLAG_STARTTRICK;
+        LOG_DEBUG("%s,%d,send starttime, ts %lld.\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp);
+        bVideoNewSegment = OMX_FALSE;
+    }
+    if (!(pVideoOutBufHdr->nFlags&OMX_BUFFERFLAG_EOS))
+        sCurrVideoTime = pVideoOutBufHdr->nTimeStamp;
+    if (pVideoOutBufHdr->nFlags & OMX_BUFFERFLAG_EOS)
+    {
+        ComponentBase::SendEvent(OMX_EventBufferFlag,pVideoOutBufHdr->nOutputPortIndex,pVideoOutBufHdr->nFlags, NULL);
+        LOG_DEBUG("%s,%d,send eos.\n",__FUNCTION__,__LINE__);
+        bVideoBOS = OMX_TRUE;
+    }
+
+    LOG_DEBUG("%s,%d,got buff ts  %lld, flag: %x\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp, pVideoOutBufHdr->nFlags);
+    ports[VIDEO_OUTPUT_PORT]->SendBuffer(pVideoOutBufHdr);
+
+
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::GetNextSyncSample(Port *pPort,OMX_BUFFERHEADERTYPE *pOutBuffer)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Parser::GetPrevSyncSample(Port *pPort,OMX_BUFFERHEADERTYPE *pOutBuffer)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Parser::GetNextSubtitleSample(OMX_SUBTITLE_SAMPLE *pOutSample)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Parser::DoSubtitleSeek(OMX_U32 nSeekFlag)
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE Parser::GetAndSendNextSyncVideoBuf()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if (bVideoEOS || bStreamCorrupted)
+        return ret;
+
+    ports[VIDEO_OUTPUT_PORT]->GetBuffer(&pVideoOutBufHdr);
+    if(pVideoOutBufHdr == NULL)
+        return OMX_ErrorUnderflow;
+
+    ret = GetNextSyncSample(ports[VIDEO_OUTPUT_PORT],pVideoOutBufHdr);
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+
+    while (sCurrVideoTime != pVideoOutBufHdr->nTimeStamp && 
+        pVideoOutBufHdr->nTimeStamp - sCurrVideoTime < OMX_TICKS_PER_SECOND)
+    {
+        ret = GetNextSyncSample(ports[VIDEO_OUTPUT_PORT],pVideoOutBufHdr);
+        if(ret != OMX_ErrorNone)
+            break;
+    }
+    if (ret == OMX_ErrorStreamCorrupt)
+        bStreamCorrupted = OMX_TRUE;
+       
+    LOG_DEBUG("%s,%d,got buff ts  %lld\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp);
+    if (bVideoNewSegment)
+    {
+        pVideoOutBufHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME | OMX_BUFFERFLAG_STARTTRICK;
+        LOG_DEBUG("%s,%d,send starttime, ts %lld.\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp);
+        bVideoNewSegment = OMX_FALSE;
+    }
+    if (!(pVideoOutBufHdr->nFlags & OMX_BUFFERFLAG_EOS))
+        sCurrVideoTime = pVideoOutBufHdr->nTimeStamp;
+    if (pVideoOutBufHdr->nFlags & OMX_BUFFERFLAG_EOS)
+    {
+        LOG_DEBUG("%s,%d,send eos.\n",__FUNCTION__,__LINE__);
+        ComponentBase::SendEvent(OMX_EventBufferFlag,pVideoOutBufHdr->nOutputPortIndex,pVideoOutBufHdr->nFlags, NULL);
+        bVideoEOS = OMX_TRUE;
+    }
+
+    LOG_DEBUG("%s,%d,got buff ts  %lld, flag: %x\n",__FUNCTION__,__LINE__,pVideoOutBufHdr->nTimeStamp, pVideoOutBufHdr->nFlags);
+    ports[VIDEO_OUTPUT_PORT]->SendBuffer(pVideoOutBufHdr);
+
+    return ret;
+}
+
+OMX_ERRORTYPE Parser::ProcessDataBuffer()
+{
+    LOG_LOG("Parser Audio: %d, Video: %d\n", ports[AUDIO_OUTPUT_PORT]->BufferNum(), ports[VIDEO_OUTPUT_PORT]->BufferNum());
+
+    if ((((bVideoEOS && !bVideoNewSegment) || ports[VIDEO_OUTPUT_PORT]->BufferNum() == 0) 
+				&& ((bAudioEOS && !bAudioNewSegment) || ports[AUDIO_OUTPUT_PORT]->BufferNum() == 0 )) 
+			|| bStreamCorrupted)
+        return OMX_ErrorNoMore;
+
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    if(ports[AUDIO_OUTPUT_PORT]->BufferNum() == 0 
+            && ports[VIDEO_OUTPUT_PORT]->BufferNum() == 0)
+        return OMX_ErrorNoMore;
+
+    if(nPreCacheSize == 0)
+        CalcPreCacheSize();
+
+    if (nClockScale > (OMX_S32)(MAX_RATE*Q16_SHIFT))
+    {
+        if(ports[VIDEO_OUTPUT_PORT]->BufferNum() > 0)
+            ret = GetAndSendNextSyncVideoBuf();
+    }
+    else if (nClockScale < (OMX_S32)(MIN_RATE*Q16_SHIFT))
+    {
+        if(ports[VIDEO_OUTPUT_PORT]->BufferNum() > 0)
+            ret = GetAndSendPrevSyncVideoBuf();
+    }
+    else 
+    {
+        if(ports[VIDEO_OUTPUT_PORT]->BufferNum() > 0)
+            ret = GetAndSendOneVideoBuf();
+
+        if(ports[AUDIO_OUTPUT_PORT]->BufferNum() > 0)
+            ret = GetAndSendOneAudioBuf();
+    }
+
+    pAudioOutBufHdr = pVideoOutBufHdr = NULL;
+
+    return OMX_ErrorNone;
+}
+
+        
+OMX_ERRORTYPE Parser::ProcessClkBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+        
+    if(ports[CLOCK_PORT]->BufferNum() == 0)
+        return OMX_ErrorNoMore;
+
+    ports[CLOCK_PORT]->GetBuffer(&pClockBufHdr);
+    if(pClockBufHdr == NULL)
+        return OMX_ErrorUnderflow;
+
+    OMX_TIME_MEDIATIMETYPE *pTimeBuffer;
+    pTimeBuffer = (OMX_TIME_MEDIATIMETYPE*) pClockBufHdr->pBuffer;
+
+        
+    if(pTimeBuffer->eUpdateType == OMX_TIME_UpdateScaleChanged) 
+    {
+        nClockScale = pTimeBuffer->xScale;
+    }
+    else if(pTimeBuffer->eUpdateType == OMX_TIME_UpdateVideoLate) {
+        LOG_DEBUG("Parser skip to next I frame.\n");
+        bSkip2Iframe = OMX_TRUE;
+    }
+
+    ports[CLOCK_PORT]->SendBuffer(pClockBufHdr);
+
+    return ret;
+}
+
+		
+OMX_ERRORTYPE Parser::Seek(OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    LOG_DEBUG("parser want seek to: %lld\n", sVideoSeekPos);
+
+	if (nPortIndex == AUDIO_OUTPUT_PORT && bAudioActived)
+	{
+		bAudioNewSegment = OMX_TRUE;
+		bAudioEOS = OMX_FALSE;
+		ret = DoSeek(AUDIO_OUTPUT_PORT,SEEK_FLAG_NO_LATER);
+		if (ret == OMX_ErrorStreamCorrupt)
+			bStreamCorrupted = OMX_TRUE;
+                if (ret == OMX_ErrorNoMore)
+                    bAudioEOS = OMX_TRUE;
+
+		sCurrAudioTime = sActualAudioSeekPos;
+	}
+	else
+	{
+        if (bVideoActived)
+        {
+            bVideoNewSegment = OMX_TRUE;
+            bVideoEOS = OMX_FALSE;
+            bVideoBOS = OMX_FALSE;
+            ret = DoSeek(VIDEO_OUTPUT_PORT,SEEK_FLAG_NO_LATER);
+            if (ret == OMX_ErrorStreamCorrupt)
+                bStreamCorrupted = OMX_TRUE;
+            if (ret == OMX_ErrorNoMore)
+                bVideoEOS = OMX_TRUE;
+                
+            sAudioSeekPos = sActualVideoSeekPos;
+            sSubtitleSeekPos=sActualVideoSeekPos;
+        }
+
+        if (bAudioActived)
+        {
+            bAudioNewSegment = OMX_TRUE;
+            bAudioEOS = OMX_FALSE;
+            ret = DoSeek(AUDIO_OUTPUT_PORT,SEEK_FLAG_NO_LATER);
+            if (ret == OMX_ErrorStreamCorrupt)
+                bStreamCorrupted = OMX_TRUE;
+            if (ret == OMX_ErrorNoMore)
+                bAudioEOS = OMX_TRUE;
+        }
+        if(bSubtitleActived)
+        {
+            bSubtitleNewSegment=OMX_TRUE;
+            bSubtitleEOS=OMX_FALSE;
+            ret=DoSubtitleSeek(SEEK_FLAG_NO_LATER);
+            if (ret == OMX_ErrorStreamCorrupt)
+                bStreamCorrupted = OMX_TRUE;
+            if (ret == OMX_ErrorNoMore)
+                bSubtitleEOS = OMX_TRUE;
+            sSubtitleSeekPos=sActualSubtitleSeekPos;
+            sCurrSubtitleTime=sActualSubtitleSeekPos;
+        }
+
+		sCurrVideoTime = sActualVideoSeekPos;
+		sCurrAudioTime = sActualAudioSeekPos;
+	}
+
+        LOG_DEBUG("parser want seek to: %lld, actualAudio: %lld, actualVideo: %lld\n",
+                sVideoSeekPos, sActualAudioSeekPos, sActualVideoSeekPos);
+
+    return ret;
+}
+
+void Parser::MakeIndexDumpFileName(char *media_file_name)
+{
+    OMX_STRING idx_path = NULL;
+
+    idx_path = fsl_osal_getenv_new("FSL_OMX_INDEX_PATH");
+    if(idx_path != NULL) {
+        OMX_STRING ptr, ptr1;
+        ptr = fsl_osal_strrchr(media_file_name, '/') + 1;
+        if ((OMX_STRING)0x1 == ptr)
+            ptr = media_file_name;
+
+        if((fsl_osal_strlen(idx_path) + fsl_osal_strlen(media_file_name)) >= INDEX_FILE_NAME_MAX_LEN - 2){
+            index_file_name[0] = 0;
+            LOG_ERROR("media_file_name length overflow\n");
+            return;
+        }
+        fsl_osal_strcpy(index_file_name, idx_path);
+        ptr1 = index_file_name + fsl_osal_strlen(index_file_name);
+        ptr1[0] = '/';
+        ptr1[1] = '.';
+        fsl_osal_strcpy(ptr1+2, ptr);
+        ptr1 = fsl_osal_strrchr(index_file_name, '.');
+        fsl_osal_strcpy(ptr1, ".idx");
+    }
+    else {
+        /* get idx file from the same folder of media file */
+        OMX_STRING ptr, ptr1;
+        if(fsl_osal_strlen(media_file_name) >= INDEX_FILE_NAME_MAX_LEN - 2){
+            index_file_name[0] = 0;
+            LOG_ERROR("media_file_name length overflow\n");
+            return;
+        }
+        fsl_osal_strcpy(index_file_name, media_file_name);
+        ptr = fsl_osal_strrchr(media_file_name, '/') + 1;
+        if ((OMX_STRING)0x1 == ptr)
+            ptr = media_file_name;
+
+        ptr1 = fsl_osal_strrchr(index_file_name, '/') + 1;
+        if ((OMX_STRING)0x1 == ptr1)
+            ptr1 = index_file_name;
+
+        ptr1[0] = '.';
+        fsl_osal_strcpy(ptr1+1, ptr);
+        ptr1 = fsl_osal_strrchr(index_file_name, '.');
+        fsl_osal_strcpy(ptr1, ".idx");
+    }
+
+    LOG_DEBUG("Index file name: %s\n", index_file_name);
+
+    return;
+}
+
+void Parser::SetAudioCodecType(OMX_PARAM_PORTDEFINITIONTYPE *pPortDef, uint32 audio_num)
+{
+
+}
+void Parser::SetVideoCodecType(OMX_PARAM_PORTDEFINITIONTYPE *pPortDef, uint32 video_num)
+{
+
+}
+
+void Parser::ActiveTrack(uint32 track_number)
+{
+
+}
+
+void Parser::DisableTrack(uint32 track_number)
+{
+
+}
+
+void Parser::AbortReadSource(OMX_BOOL bAbort)
+{
+
+}
+
+OMX_ERRORTYPE Parser::SetMetadata(OMX_STRING key, OMX_STRING value, OMX_U32 valueSize)
+{
+	OMX_CONFIG_METADATAITEMTYPE* pMatadataItem;
+	OMX_U8 *ptr = (OMX_U8*)FSL_MALLOC(sizeof(OMX_CONFIG_METADATAITEMTYPE) + valueSize);
+	if(ptr == NULL) {
+		return OMX_ErrorInsufficientResources;
+	}
+	fsl_osal_memset(ptr, 0, sizeof(OMX_CONFIG_METADATAITEMTYPE) + valueSize);
+	pMatadataItem = (OMX_CONFIG_METADATAITEMTYPE *)ptr;
+
+	OMX_INIT_STRUCT(pMatadataItem, OMX_CONFIG_METADATAITEMTYPE);
+
+	sprintf((char *)pMatadataItem->nKey, "%s", key);
+	fsl_osal_memcpy(&pMatadataItem->nValue, value, valueSize);
+	pMatadataItem->nValueMaxSize = valueSize;
+	pMatadataItem->nValueSizeUsed = valueSize;
+	psMatadataItem[sMatadataItemCount.nMetadataItemCount] = pMatadataItem;
+	sMatadataItemCount.nMetadataItemCount ++;
+	return OMX_ErrorNone;
+}
+
+OMX_U32 Parser::CalcPreCacheSize()
+{
+    OMX_U32 nCacheSec = HTTP_CACHE_TIME;
+    OMX_U64 nDurSec = usDuration / OMX_TICKS_PER_SECOND;
+
+    LOG_DEBUG("nDurSec = %lld, nContentLen = %lld, nPreCacheSize = %d\n",
+            nDurSec, nContentLen, nPreCacheSize);
+
+    if(nDurSec < nCacheSec)
+        nCacheSec = nDurSec;
+
+    if(nDurSec > 0)
+        nPreCacheSize = nCacheSec * nContentLen / nDurSec;
+
+    if(nPreCacheSize == 0)
+        nPreCacheSize = 256 * 1024;
+
+    nCheckCacheOff = nPreCacheSize;
+
+    printf("nPreCacheSize = %d\n", nPreCacheSize);
+
+    return nPreCacheSize;
+}
+
+
+OMX_TICKS Parser::GetCurrentMediaTime()
+{
+    TUNNEL_INFO hClock;
+    OMX_TIME_CONFIG_TIMESTAMPTYPE sCur;
+
+    if(ports[CLOCK_PORT]->IsEnabled() != OMX_TRUE)
+        return 0;
+
+    ports[CLOCK_PORT]->GetTunneledInfo(&hClock);
+    OMX_INIT_STRUCT(&sCur, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+    sCur.nPortIndex = OMX_ALL;
+    OMX_GetConfig(hClock.hTunneledComp, OMX_IndexConfigTimeCurrentMediaTime, &sCur);
+    return sCur.nTimestamp;
+}
+OMX_ERRORTYPE Parser::SetStopReadingFlag()
+{
+    bStopReading = OMX_TRUE;
+    return OMX_ErrorNone;
+}
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/Parser.h b/OpenMAXIL/src/component/common/Parser.h
new file mode 100755
index 0000000..2b40b2a
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Parser.h
@@ -0,0 +1,160 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file Parser.h
+ *  @brief Class definition of Parser Component
+ *  @ingroup Parser
+ */
+
+#ifndef PARSER_H
+#define PARSER_H
+
+#include "ComponentBase.h"
+#include "OMX_ContentPipe.h"
+#include "fsl_types.h"
+#include "fsl_parser.h"
+#include "file_stream.h"
+#define PORT_NUM 3
+#define AUDIO_OUTPUT_PORT 0
+#define VIDEO_OUTPUT_PORT 1
+#define CLOCK_PORT 2
+#define DEFAULT_PARSER_AUDIO_OUTPUT_BUFSIZE (16*1024)
+#define DEFAULT_PARSER_OUTPUT_BUFSIZE (512*1024)
+#define MAX_AVAIL_TRACK 32
+#define MAX_MATADATA_NUM 64
+#define INDEX_FILE_NAME_MAX_LEN 256
+#define VIDEO_CODEC_DATA_BUFFER_LEN 128
+
+class Parser : public ComponentBase {
+    public:
+        Parser();
+        CP_PIPETYPE *hPipe;
+        OMX_S8 *pMediaName;
+        OMX_ERRORTYPE SetMetadata(OMX_STRING key, OMX_STRING value, OMX_U32 valueSize);
+        OMX_STRING GetMimeFromComponentRole(OMX_U8 *componentRole); 
+        OMX_ERRORTYPE CheckContentAvailableBytes(OMX_PTR h, OMX_U32 nb);
+        OMX_BOOL IsStreamingSource() {return isStreamingSource;}
+        OMX_BOOL IsLiveSource() {return isLiveSource;}
+        OMX_U64 nContentLen;
+        OMX_TICKS GetCurrentMediaTime();
+        OMX_ERRORTYPE SetStopReadingFlag();
+        OMX_BOOL bStopReading;
+        fsl_osal_mutex Lock;
+    private:
+        OMX_BUFFERHEADERTYPE *pAudioOutBufHdr;
+        OMX_BUFFERHEADERTYPE *pVideoOutBufHdr;
+        OMX_BUFFERHEADERTYPE *pClockBufHdr;
+        OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE ProcessDataBuffer();
+        OMX_ERRORTYPE GetAndSendOneVideoBuf();
+        OMX_ERRORTYPE GetAndSendOneAudioBuf();
+        OMX_ERRORTYPE GetAndSendOneSubtitleBuf(OMX_SUBTITLE_SAMPLE *pOutSample);
+        OMX_ERRORTYPE GetAndSendNextSyncVideoBuf();
+        OMX_ERRORTYPE GetAndSendPrevSyncVideoBuf();
+        OMX_ERRORTYPE ProcessClkBuffer();
+        OMX_ERRORTYPE Seek(OMX_U32 nPortIndex);
+        OMX_U32 CalcPreCacheSize();
+
+        OMX_S32 nClockScale;
+        OMX_BOOL bAudioNewSegment;
+        OMX_BOOL bVideoNewSegment;
+        OMX_BOOL bSubtitleNewSegment;
+        OMX_BOOL bAudioEOS;
+        OMX_BOOL bVideoEOS;
+        OMX_BOOL bSubtitleEOS;
+        OMX_BOOL bSendAudioFrameFirst;
+        OMX_TICKS sCurrAudioTime;
+        OMX_TICKS sCurrVideoTime;
+        OMX_TICKS sCurrSubtitleTime;
+
+        OMX_BOOL bStreamCorrupted;
+        OMX_BOOL bSkip2Iframe;
+
+        OMX_U32 nPreCacheSize;
+        CPint64 nCheckCacheOff;
+        OMX_BOOL bAbortBuffering;
+
+        OMX_U8 VideoCodecData[VIDEO_CODEC_DATA_BUFFER_LEN];
+        OMX_S32 nVideoCodecDataLen;
+        OMX_BOOL bInsertVideoCodecData;
+
+    protected:		
+        CPhandle hMedia;
+        OMX_BOOL isLiveSource;
+        OMX_BOOL isStreamingSource;
+		OMX_BOOL bGetMetadata;
+        OMX_TIME_CONFIG_SEEKMODETYPE sSeekMode;
+        OMX_PARAM_COMPONENTROLETYPE sCompRole;
+        OMX_TICKS sAudioSeekPos;
+        OMX_TICKS sVideoSeekPos;
+        OMX_TICKS sSubtitleSeekPos;
+        OMX_TICKS sActualVideoSeekPos;
+        OMX_TICKS sActualAudioSeekPos;
+        OMX_TICKS sActualSubtitleSeekPos;
+        OMX_BOOL bSeekable;
+        OMX_BOOL bHasVideoTrack;
+        OMX_BOOL bHasAudioTrack;
+        OMX_S32 nMediaNameLen;
+
+        OMX_CONFIG_METADATAITEMCOUNTTYPE sMatadataItemCount;
+        OMX_CONFIG_METADATAITEMTYPE *psMatadataItem[MAX_MATADATA_NUM];
+
+        OMX_AUDIO_PARAM_PORTFORMATTYPE sAudioPortFormat;
+        OMX_VIDEO_PARAM_PORTFORMATTYPE sVideoPortFormat;
+        OMX_BOOL bVideoBOS;
+        OMX_U32 nNumAvailAudioStream;
+        OMX_U32 nNumAvailVideoStream;
+        OMX_U32 nNumAvailSubtitleStream;
+        OMX_U32 nActiveAudioNum;
+        OMX_U32 nActiveAudioNumToClient;
+        OMX_U32 nActiveVideoNum;
+        OMX_U32 nActiveSubtitleNum;
+        OMX_S32 nActiveSubtitleNumToClient;
+        OMX_U32 nCommonRotate;
+        OMX_BOOL bAudioActived;
+        OMX_BOOL bVideoActived;
+        OMX_BOOL bSubtitleActived;
+
+        OMX_TICKS usDuration;
+        OMX_TICKS nAudioDuration;
+        OMX_TICKS nVideoDuration;
+        
+        FslFileStream fileOps;
+        ParserMemoryOps memOps;
+
+        OMX_U32 nAudioTrackNum[MAX_AVAIL_TRACK];
+        OMX_U32 nVideoTrackNum[MAX_AVAIL_TRACK];
+        OMX_U32 nSubtitleTrackNum[MAX_AVAIL_TRACK];		
+        uint32 numTracks;
+        char index_file_name[INDEX_FILE_NAME_MAX_LEN];
+        OMX_BOOL bAudioCodecDataSent;
+        OMX_BOOL bVideoCodecDataSent;
+        void MakeIndexDumpFileName(char *media_file_name);
+
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetNextSample(Port *pPort,OMX_BUFFERHEADERTYPE *pOutBuffer) = 0;
+        virtual OMX_ERRORTYPE GetNextSyncSample(Port *pPort,OMX_BUFFERHEADERTYPE *pOutBuffer);
+        virtual OMX_ERRORTYPE GetPrevSyncSample(Port *pPort,OMX_BUFFERHEADERTYPE *pOutBuffer);
+        virtual OMX_ERRORTYPE GetNextSubtitleSample(OMX_SUBTITLE_SAMPLE *pOutSample);
+        virtual OMX_ERRORTYPE DoSeek(OMX_U32 nPortIndex, OMX_U32 nSeekFlag) = 0;
+        virtual OMX_ERRORTYPE DoSubtitleSeek(OMX_U32 nSeekFlag);
+        virtual void SetAudioCodecType(OMX_PARAM_PORTDEFINITIONTYPE *pPortDef, uint32 audio_num);
+        virtual void SetVideoCodecType(OMX_PARAM_PORTDEFINITIONTYPE *pPortDef, uint32 video_num);
+        virtual void ActiveTrack(uint32 track_number);
+        virtual void DisableTrack(uint32 track_number);
+        virtual void AbortReadSource(OMX_BOOL bAbort);
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/PauseState.cpp b/OpenMAXIL/src/component/common/PauseState.cpp
new file mode 100755
index 0000000..991dbfb
--- /dev/null
+++ b/OpenMAXIL/src/component/common/PauseState.cpp
@@ -0,0 +1,241 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "PauseState.h"
+
+OMX_ERRORTYPE PauseState::GetVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    return State::DoGetComponentVersion(
+            pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+}
+
+OMX_ERRORTYPE PauseState::SendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam, 
+        OMX_PTR pCmdData)
+{
+    return State::DoSendCommand(Cmd, nParam, pCmdData);
+}
+
+OMX_ERRORTYPE PauseState::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    return State::DoEmptyThisBuffer(pBufferHdr);
+}
+
+OMX_ERRORTYPE PauseState::FillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    return State::DoFillThisBuffer(pBufferHdr);
+}
+
+OMX_ERRORTYPE PauseState::ProcessBuffer() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U32 i;
+
+                    
+    ret = base->ProcessClkBuffer();
+    if(ret == OMX_ErrorNoMore) {
+        for(i=0; i<base->nPorts; i++) {
+            if(OMX_ErrorNone == base->ports[i]->AcessBuffer(&pBufferHdr, 1))
+                if(pBufferHdr->hMarkTargetComponent != NULL)
+                {
+                    LOG_DEBUG("%s,%d,process a marked buffer.marked target %x\n",__FUNCTION__,__LINE__,pBufferHdr->hMarkTargetComponent);
+                    ret = base->ProcessDataBuffer();
+                }
+        }
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE PauseState::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetParameter(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE PauseState::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    OMX_U32 i;
+    OMX_BOOL bHasPortDisabled = OMX_FALSE;
+
+    for(i=0; i<base->nPorts; i++) {
+        if(base->ports[i]->IsEnabled() == OMX_FALSE) {
+            bHasPortDisabled = OMX_TRUE;
+            break;
+        }
+    }
+
+    if(bHasPortDisabled == OMX_TRUE)
+        return State::DoSetParameter(nParamIndex, pComponentParameterStructure);
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE PauseState::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoGetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE PauseState::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return State::DoSetConfig(nParamIndex, pComponentParameterStructure);
+}
+
+OMX_ERRORTYPE PauseState::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return State::DoGetExtensionIndex(cParameterName, pIndexType);
+}
+
+OMX_ERRORTYPE PauseState::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_ENABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoUseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE PauseState::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void *eglImage) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_ENABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoUseEGLImage(ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE PauseState::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_ENABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoAllocateBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE PauseState::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(IS_PORT_DISABLING(nPortIndex) == OMX_TRUE) {
+        WAIT_CONDTION(base->pendingCmd.bProcessed, OMX_TRUE, 500000);
+        return State::DoFreeBuffer(nPortIndex, pBufferHdr);
+    }
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE PauseState::TunnelRequest(
+        OMX_U32 nPort, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    if(nPort >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    if(base->ports[nPort]->IsEnabled() != OMX_TRUE)
+        return State::DoTunnelRequest(nPort, hTunneledComp, nTunneledPort, pTunnelSetup);
+    else
+        return OMX_ErrorIncorrectStateOperation;
+}
+
+OMX_ERRORTYPE PauseState::ToInvalid() 
+{
+    //TODO
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE PauseState::ToLoaded() 
+{
+    return OMX_ErrorInvalidState;
+}
+
+OMX_ERRORTYPE PauseState::ToWaitForResources() 
+{
+    return OMX_ErrorNotImplemented;
+}
+
+OMX_ERRORTYPE PauseState::ToIdle() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 i;
+
+    base->InstanceDeInit();
+
+    /* return all buffers to allocater */
+    for(i=0; i<base->nPorts; i++) {
+        if(OMX_ErrorNone != base->ports[i]->ReturnBuffers())
+            ret = OMX_ErrorNotComplete;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE PauseState::ToPause() 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE PauseState::ToExecuting() 
+{
+    LOG_DEBUG("%s pause->exec.\n", base->name);
+    base->DoPause2Exec();
+    if(OMX_TRUE == base->bInContext)
+        base->ProcessDataBuffer();
+
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/PauseState.h b/OpenMAXIL/src/component/common/PauseState.h
new file mode 100755
index 0000000..2daf4d5
--- /dev/null
+++ b/OpenMAXIL/src/component/common/PauseState.h
@@ -0,0 +1,56 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file PauseState.h
+ *  @brief class definition of PauseState
+ *  @ingroup State
+ */
+
+#ifndef PauseState_h
+#define PauseState_h
+
+#include "State.h"
+
+class PauseState : public State {
+    public:
+        PauseState(ComponentBase *pBase) : State(pBase) {};
+        virtual OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                         OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID);
+        virtual OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData);
+        virtual OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE ProcessBuffer();
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        virtual OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, void *eglImage);
+        virtual OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                             OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        virtual OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        virtual OMX_ERRORTYPE TunnelRequest(OMX_U32 nPort, OMX_HANDLETYPE hTunneledComp,
+                                            OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+    private:
+        OMX_ERRORTYPE ToInvalid();
+        OMX_ERRORTYPE ToLoaded();
+        OMX_ERRORTYPE ToWaitForResources();
+        OMX_ERRORTYPE ToIdle();
+        OMX_ERRORTYPE ToPause();
+        OMX_ERRORTYPE ToExecuting();
+        OMX_ERRORTYPE DoGetParameter();
+
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/Port.cpp b/OpenMAXIL/src/component/common/Port.cpp
new file mode 100755
index 0000000..667cbc5
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Port.cpp
@@ -0,0 +1,867 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Port.h"
+
+#define FLASH_WORKAROUND
+#ifdef FLASH_WORKAROUND
+#define PRE_SIZE 8
+
+#ifdef FSL_MALLOC
+#undef FSL_MALLOC
+#endif
+#define FSL_MALLOC(size) \
+    ({\
+     fsl_osal_ptr __buf = NULL; \
+     __buf = fsl_osal_malloc_new(size+PRE_SIZE); \
+     __buf = (fsl_osal_ptr)((fsl_osal_u32)__buf + PRE_SIZE); \
+     __buf; \
+     })
+
+#ifdef FSL_FREE
+#undef FSL_FREE
+#endif
+#define FSL_FREE(ptr) \
+    do { \
+        fsl_osal_ptr __mem = ptr; \
+        if(__mem) { \
+            __mem = (fsl_osal_ptr)((fsl_osal_u32)__mem - PRE_SIZE); \
+            fsl_osal_dealloc(__mem); \
+            ptr=NULL; \
+        }\
+    }while(0);
+#endif
+
+static OMX_BOOL IntersectBufferSupplier(
+        OMX_BUFFERSUPPLIERTYPE Supplier1,
+        OMX_BUFFERSUPPLIERTYPE Supplier2,
+        OMX_BUFFERSUPPLIERTYPE *pSupplierResult)
+{
+    if(Supplier1 == OMX_BufferSupplyUnspecified) {
+        if(Supplier2 == OMX_BufferSupplyUnspecified)
+            *pSupplierResult = OMX_BufferSupplyOutput;
+    }
+    else {
+        if(Supplier2 == Supplier1
+                ||Supplier2 == OMX_BufferSupplyUnspecified)
+            *pSupplierResult = Supplier1;
+        else
+            return OMX_FALSE;
+    }
+
+    return OMX_TRUE;
+}
+
+static OMX_BOOL IntersectPortDef(
+        OMX_PARAM_PORTDEFINITIONTYPE *pDef1,
+        OMX_PARAM_PORTDEFINITIONTYPE *pDef2)
+{
+    OMX_U32 nBufferCount, nBufferSize, nBufferAlignment;
+
+    if(pDef1->eDomain != pDef2->eDomain)
+        return OMX_FALSE;
+    if(pDef1->eDomain == OMX_PortDomainAudio)
+        if(pDef1->format.audio.eEncoding != pDef2->format.audio.eEncoding)
+            return OMX_FALSE;
+    if(pDef1->eDomain == OMX_PortDomainVideo)
+        if(pDef1->format.video.eCompressionFormat != pDef2->format.video.eCompressionFormat)
+            return OMX_FALSE;
+    if(pDef1->eDomain == OMX_PortDomainImage)
+        if(pDef1->format.image.eCompressionFormat != pDef2->format.image.eCompressionFormat)
+            return OMX_FALSE;
+
+    nBufferCount = MAX(pDef1->nBufferCountActual, pDef2->nBufferCountActual);
+    pDef1->nBufferCountActual = pDef2->nBufferCountActual = nBufferCount;
+    nBufferSize = MAX(pDef1->nBufferSize, pDef2->nBufferSize);
+    pDef1->nBufferSize = pDef2->nBufferSize = nBufferSize;
+    nBufferAlignment = MAX(pDef1->nBufferAlignment, pDef2->nBufferAlignment);
+    pDef1->nBufferAlignment = pDef2->nBufferAlignment = nBufferAlignment;
+
+    return OMX_TRUE;
+}
+
+Port::Port(ComponentBase *pBase, OMX_U32 nPortIdx)
+{
+    base = pBase;
+    nPortIndex = nPortIdx;
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = nPortIndex;
+    pPortQueue = NULL;
+    nBufferHdrNum = 0;
+    nMarkDataNum = 0;
+    nGetMarkData = 0;
+    nAddMarkData = 0;
+	nSupportColorFormatNum = 0;
+    bTunneled = OMX_FALSE;
+    bNeedReturnBuffers = OMX_FALSE;
+    eBufferSupplier = OMX_BufferSupplyUnspecified;
+    bPendingDisable = OMX_FALSE;
+}
+
+OMX_ERRORTYPE Port::Init()
+{
+    /**< setup Port queue */
+    pPortQueue = FSL_NEW(Queue, ());
+    if(pPortQueue == NULL) {
+        LOG_ERROR("New port queue for port[%d] failed.\n", nPortIndex);
+        return OMX_ErrorInsufficientResources;
+    }
+
+    if(pPortQueue->Create(MAX_PORT_BUFFER, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)
+            != QUEUE_SUCCESS) {
+        LOG_ERROR("Init port queue failed.\n");
+        DeInit();
+        return OMX_ErrorUndefined;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::DeInit()
+{
+    /**< Free Port queue */
+    pPortQueue->Free();
+    FSL_DELETE(pPortQueue);
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::SetPortDefinition(
+        OMX_PARAM_PORTDEFINITIONTYPE *pPortDef) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pPortDef == NULL)
+        return OMX_ErrorBadParameter;
+
+    OMX_CHECK_STRUCT(pPortDef, OMX_PARAM_PORTDEFINITIONTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if(pPortDef->nPortIndex != nPortIndex)
+        return OMX_ErrorBadPortIndex;
+
+    fsl_osal_memcpy(&sPortDef, pPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
+
+    return ret;
+}
+
+OMX_ERRORTYPE Port::SetPortFormat(
+        OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortFormat) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pPortFormat == NULL)
+        return OMX_ErrorBadParameter;
+
+    OMX_CHECK_STRUCT(pPortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if(pPortFormat->nPortIndex != nPortIndex)
+        return OMX_ErrorBadPortIndex;
+
+	nSupportColorFormatNum ++;
+    fsl_osal_memcpy(&sPortFormat[pPortFormat->nIndex], pPortFormat, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
+
+    return ret;
+}
+
+OMX_ERRORTYPE Port::GetPortDefinition(
+        OMX_PARAM_PORTDEFINITIONTYPE *pPortDef)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pPortDef == NULL)
+        return OMX_ErrorBadParameter;
+    
+    OMX_CHECK_STRUCT(pPortDef, OMX_PARAM_PORTDEFINITIONTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if(pPortDef->nPortIndex != nPortIndex)
+        return OMX_ErrorBadPortIndex;
+
+    fsl_osal_memcpy(pPortDef, &sPortDef, sizeof(OMX_PARAM_PORTDEFINITIONTYPE));
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::GetPortFormat(
+        OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortFormat)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pPortFormat == NULL)
+        return OMX_ErrorBadParameter;
+    
+    OMX_CHECK_STRUCT(pPortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if(pPortFormat->nPortIndex != nPortIndex)
+        return OMX_ErrorBadPortIndex;
+
+	if (pPortFormat->nIndex == 0 && nSupportColorFormatNum == 0) {	
+		pPortFormat->eCompressionFormat = sPortDef.format.video.eCompressionFormat;
+		pPortFormat->eColorFormat = sPortDef.format.video.eColorFormat;
+		pPortFormat->xFramerate = sPortDef.format.video.xFramerate;
+		LOG_DEBUG("Not set. Get support color format: %d Port index: %d index: %d\n", \
+			pPortFormat->eColorFormat, pPortFormat->nPortIndex, pPortFormat->nIndex);
+		return OMX_ErrorNone;
+	}
+	
+	if(pPortFormat->nIndex >= nSupportColorFormatNum)
+        return OMX_ErrorNoMore;
+
+    fsl_osal_memcpy(pPortFormat, &sPortFormat[pPortFormat->nIndex], sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
+	LOG_DEBUG("Get support color format: %d Port index: %d index: %d\n", \
+		pPortFormat->eColorFormat, pPortFormat->nPortIndex, pPortFormat->nIndex);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_PTR pAppPrivate,
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+
+    if(ppBufferHdr == NULL || nSizeBytes < sPortDef.nBufferSize )
+        return OMX_ErrorBadParameter;
+
+    if(sPortDef.bPopulated == OMX_TRUE)
+        return OMX_ErrorIncorrectStateOperation;
+
+    if(nBufferHdrNum >= sPortDef.nBufferCountActual)
+        return OMX_ErrorOverflow;
+
+    if(bTunneled == OMX_TRUE && bSupplier == OMX_TRUE) {
+        LOG_ERROR("Supplier shall not use a buffer.\n");
+        return OMX_ErrorUndefined;
+    }
+
+    if(bTunneled != OMX_TRUE) {
+        pBufferHdr = (OMX_BUFFERHEADERTYPE*)FSL_MALLOC(sizeof(OMX_BUFFERHEADERTYPE));
+        if(pBufferHdr == NULL) {
+            LOG_ERROR("Failed to allocate buffer header for port #%d.\n", nPortIndex);
+            base->SendEvent(OMX_EventError, OMX_ErrorInsufficientResources, 0, NULL);
+            return OMX_ErrorInsufficientResources;
+        }
+        fsl_osal_memset(pBufferHdr, 0, sizeof(OMX_BUFFERHEADERTYPE));
+        OMX_INIT_STRUCT(pBufferHdr, OMX_BUFFERHEADERTYPE);
+        pBufferHdr->pBuffer = pBuffer;
+        pBufferHdr->nAllocLen = nSizeBytes;
+        pBufferHdr->pAppPrivate = pAppPrivate;
+        *ppBufferHdr = pBufferHdr;
+    }
+    else
+        pBufferHdr = *ppBufferHdr;
+
+    bAllocater = OMX_FALSE;
+    BufferHdrArry[nBufferHdrNum] = pBufferHdr;
+    if(sPortDef.eDir == OMX_DirInput)
+        pBufferHdr->nInputPortIndex = nPortIndex;
+    if(sPortDef.eDir == OMX_DirOutput)
+        pBufferHdr->nOutputPortIndex = nPortIndex;
+
+    nBufferHdrNum ++;
+
+    if(nBufferHdrNum >= sPortDef.nBufferCountActual) {
+        sPortDef.bEnabled = OMX_TRUE;
+        sPortDef.bPopulated = OMX_TRUE;
+        base->PortNotify(nPortIndex,PORT_ON);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_PTR pAppPrivate, 
+        void* eglImage)
+{
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+
+    if(ppBufferHdr == NULL)
+        return OMX_ErrorBadParameter;
+
+    if(sPortDef.bPopulated == OMX_TRUE)
+        return OMX_ErrorIncorrectStateOperation;
+
+    if(nBufferHdrNum >= sPortDef.nBufferCountActual)
+        return OMX_ErrorOverflow;
+
+    if(bTunneled == OMX_TRUE) {
+        LOG_ERROR("EglImage shall not be used for tunneled port.\n");
+        return OMX_ErrorUndefined;
+    }
+
+    pBufferHdr = (OMX_BUFFERHEADERTYPE*)FSL_MALLOC(sizeof(OMX_BUFFERHEADERTYPE));
+    if(pBufferHdr == NULL) {
+        LOG_ERROR("Failed to allocate buffer header for port #%d.\n", nPortIndex);
+        base->SendEvent(OMX_EventError, OMX_ErrorInsufficientResources, 0, NULL);
+        return OMX_ErrorInsufficientResources;
+    }
+    fsl_osal_memset(pBufferHdr, 0, sizeof(OMX_BUFFERHEADERTYPE));
+    OMX_INIT_STRUCT(pBufferHdr, OMX_BUFFERHEADERTYPE);
+    pBufferHdr->pAppPrivate = pAppPrivate;
+    pBufferHdr->pPlatformPrivate = eglImage;
+    *ppBufferHdr = pBufferHdr;
+
+    bAllocater = OMX_FALSE;
+    BufferHdrArry[nBufferHdrNum] = pBufferHdr;
+    if(sPortDef.eDir == OMX_DirInput)
+        pBufferHdr->nInputPortIndex = nPortIndex;
+    if(sPortDef.eDir == OMX_DirOutput) 
+        pBufferHdr->nOutputPortIndex = nPortIndex;
+
+    nBufferHdrNum ++;
+
+    if(nBufferHdrNum >= sPortDef.nBufferCountActual) {
+        sPortDef.bEnabled = OMX_TRUE;
+        sPortDef.bPopulated = OMX_TRUE;
+        base->PortNotify(nPortIndex,PORT_ON);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_PTR pAppPrivate,
+        OMX_U32 nSizeBytes) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_PTR pBuffer = NULL;
+
+    LOG_DEBUG("Port AllocateBuffer.\n");
+
+    if(ppBufferHdr == NULL || nSizeBytes < sPortDef.nBufferSize )
+        return OMX_ErrorBadParameter;
+
+    if(sPortDef.bPopulated == OMX_TRUE)
+        return OMX_ErrorIncorrectStateOperation;
+
+    if(nBufferHdrNum >= sPortDef.nBufferCountActual)
+        return OMX_ErrorOverflow;
+
+    pBufferHdr = (OMX_BUFFERHEADERTYPE*)FSL_MALLOC(sizeof(OMX_BUFFERHEADERTYPE));
+    if(pBufferHdr == NULL) {
+        LOG_ERROR("Failed to allocate buffer header for port #%d.\n", nPortIndex);
+        base->SendEvent(OMX_EventError, OMX_ErrorInsufficientResources, 0, NULL);
+        return OMX_ErrorInsufficientResources;
+    }
+
+    ret = base->DoAllocateBuffer(&pBuffer, nSizeBytes,nPortIndex);
+    if(ret != OMX_ErrorNone) {
+        FSL_FREE(pBufferHdr);
+        base->SendEvent(OMX_EventError, ret, 0, NULL);
+        LOG_ERROR("Failed to allocate buffer resource for port #%d\n", nPortIndex);
+        return ret;
+    }
+
+    fsl_osal_memset(pBufferHdr, 0, sizeof(OMX_BUFFERHEADERTYPE));
+    OMX_INIT_STRUCT(pBufferHdr, OMX_BUFFERHEADERTYPE);
+    BufferHdrArry[nBufferHdrNum] = pBufferHdr;
+    nBufferHdrNum ++;
+
+    bAllocater = OMX_TRUE;
+    pBufferHdr->pBuffer = (OMX_U8*)pBuffer;
+    pBufferHdr->nAllocLen = nSizeBytes;
+    pBufferHdr->pAppPrivate = pAppPrivate;
+    if(sPortDef.eDir == OMX_DirInput)
+        pBufferHdr->nInputPortIndex = nPortIndex;
+    if(sPortDef.eDir == OMX_DirOutput)
+        pBufferHdr->nOutputPortIndex = nPortIndex;
+
+    *ppBufferHdr = pBufferHdr;
+
+    LOG_DEBUG("Allocated: %d, required: %d\n", nBufferHdrNum, sPortDef.nBufferCountActual);
+
+    if(nBufferHdrNum >= sPortDef.nBufferCountActual) {
+        sPortDef.bEnabled = OMX_TRUE;
+        sPortDef.bPopulated = OMX_TRUE;
+        base->PortNotify(nPortIndex,PORT_ON);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::FreeBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_BOOL bMatch = OMX_FALSE;
+    OMX_U32 nMatchIdx, i;
+
+    LOG_DEBUG("%s Port %d FreeBuffer.\n", base->name, nPortIndex);
+
+    if(pBufferHdr == NULL)
+        return OMX_ErrorBadParameter;
+
+    if(IsAllBuffersReturned() != OMX_TRUE) {
+        LOG_DEBUG("Not all buffer returned when freebuffer of Port[%d], return now.\n", nPortIndex);
+        ReturnBuffers();
+    }
+
+    for(i=0; i<MAX_PORT_BUFFER ; i++) {
+        if(pBufferHdr == BufferHdrArry[i]) {
+            bMatch = OMX_TRUE;
+            nMatchIdx = i;
+            break;
+        }
+    }
+
+    if(bMatch != OMX_TRUE) {
+        LOG_ERROR("Buffer header [%p] not belongs to component when Free.\n", pBufferHdr);
+        return OMX_ErrorBadParameter;
+    }
+
+    if(bAllocater == OMX_TRUE) {
+        ret = base->DoFreeBuffer(pBufferHdr->pBuffer,nPortIndex);
+        if(ret != OMX_ErrorNone) {
+            LOG_ERROR("Failed to free buffer resource.\n");
+        }
+        pBufferHdr->pBuffer = NULL;
+    }
+
+    if(bTunneled != OMX_TRUE || (bTunneled == OMX_TRUE && bSupplier == OMX_TRUE))
+        FSL_FREE(pBufferHdr);
+
+    BufferHdrArry[nMatchIdx] = NULL;
+    nBufferHdrNum --;
+
+    LOG_DEBUG("Remained buffer cnt: %d\n", nBufferHdrNum);
+
+    if(nBufferHdrNum == 0) {
+        sPortDef.bEnabled = OMX_FALSE;
+        sPortDef.bPopulated = OMX_FALSE;
+        base->PortNotify(nPortIndex,PORT_OFF);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::TunnelRequest(
+        OMX_HANDLETYPE hTunneledComp, 
+        OMX_U32 nTunneledPort,
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pTunnelSetup == NULL)
+        return OMX_ErrorBadParameter;
+
+    if(hTunneledComp == NULL) {
+        bTunneled = OMX_FALSE;
+        sTunnelInfo.hTunneledComp = NULL;
+        return OMX_ErrorNone;
+    }
+
+    if(sPortDef.eDir == OMX_DirOutput) {
+        bTunneled = OMX_TRUE;
+        sTunnelInfo.hTunneledComp = hTunneledComp;
+        sTunnelInfo.nTunneledPort = nTunneledPort;
+        pTunnelSetup->eSupplier = eBufferSupplier;
+    }
+    else {
+        OMX_BUFFERSUPPLIERTYPE sSupplier = OMX_BufferSupplyUnspecified;
+        OMX_PARAM_PORTDEFINITIONTYPE sPortOutDef;
+
+        if(OMX_TRUE != IntersectBufferSupplier(pTunnelSetup->eSupplier, eBufferSupplier, &sSupplier))
+            return OMX_ErrorPortsNotCompatible;
+
+        if(sSupplier != pTunnelSetup->eSupplier) {
+            OMX_PARAM_BUFFERSUPPLIERTYPE sBufferSupplierType;
+            OMX_INIT_STRUCT(&sBufferSupplierType, OMX_PARAM_BUFFERSUPPLIERTYPE);
+            sBufferSupplierType.nPortIndex = nTunneledPort;
+            sBufferSupplierType.eBufferSupplier = sSupplier;
+            ret = OMX_SetParameter(hTunneledComp, OMX_IndexParamCompBufferSupplier, &sBufferSupplierType);
+            if(ret != OMX_ErrorNone)
+                return ret;
+        }
+
+        SetSupplierType(sSupplier);
+        pTunnelSetup->eSupplier = sSupplier;
+
+        OMX_INIT_STRUCT(&sPortOutDef, OMX_PARAM_PORTDEFINITIONTYPE);
+        sPortOutDef.nPortIndex = nTunneledPort;
+        OMX_GetParameter(hTunneledComp, OMX_IndexParamPortDefinition, &sPortOutDef);
+        if(OMX_TRUE != IntersectPortDef(&sPortOutDef, &sPortDef))
+            return OMX_ErrorPortsNotCompatible;
+
+        ret = OMX_SetParameter(hTunneledComp, OMX_IndexParamPortDefinition, &sPortOutDef);
+        if(ret != OMX_ErrorNone)
+            return ret;
+
+        bTunneled = OMX_TRUE;
+        sTunnelInfo.hTunneledComp = hTunneledComp;
+        sTunnelInfo.nTunneledPort = nTunneledPort;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::SupplierAllocateBuffers()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U32 i;
+
+    for(i=0; i<sPortDef.nBufferCountActual ; i++)
+        AllocateBuffer(&pBufferHdr,NULL,sPortDef.nBufferSize);
+
+    for(i=0; i<sPortDef.nBufferCountActual ; i++) {
+        //TODO: UseBuffer may return NotReady as Tunneded componnet not received command
+        OMX_UseBuffer(sTunnelInfo.hTunneledComp, &BufferHdrArry[i], 
+                sTunnelInfo.nTunneledPort, NULL, sPortDef.nBufferSize, BufferHdrArry[i]->pBuffer);
+    }
+
+    /* supplier add all allocated buffers to its port queue */
+    for(i=0; i<sPortDef.nBufferCountActual ; i++)
+        AddBuffer(BufferHdrArry[i]);
+
+    return ret;
+}
+
+OMX_ERRORTYPE Port::SupplierFreeBuffers()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U32 i;
+
+    LOG_DEBUG("%s Supplier port %d free buffer\n", base->name, nPortIndex);
+
+        for(i=0; i<nBufferHdrNum; i++)
+        //TODO: FreeBuffer may return NotReady as Tunneded componnet not received command
+        OMX_FreeBuffer(sTunnelInfo.hTunneledComp, sTunnelInfo.nTunneledPort, BufferHdrArry[i]);
+
+    while(BufferNum() > 0)
+        GetBuffer(&pBufferHdr);
+
+    for(i=0; nBufferHdrNum>0 && i<sPortDef.nBufferCountActual ; i++)
+        FreeBuffer(BufferHdrArry[i]);
+
+    return ret;
+}
+
+OMX_ERRORTYPE Port::Disable() 
+{
+    OMX_STATETYPE eState = OMX_StateInvalid;
+
+    LOG_DEBUG("%s disable port %d\n", base->name, nPortIndex);
+
+    if(sPortDef.bEnabled == OMX_FALSE)
+        return OMX_ErrorSameState;
+
+    base->GetState(&eState);
+    if(eState == OMX_StateLoaded) {
+        sPortDef.bEnabled = OMX_FALSE;
+        return OMX_ErrorNone;
+    }
+
+    if(bTunneled == OMX_FALSE) {
+        sPortDef.bEnabled = OMX_FALSE;
+        ReturnBuffers();
+    }
+    else {
+        if(bSupplier == OMX_TRUE) {
+            bNeedReturnBuffers = OMX_TRUE;
+            OMX_SendCommand(sTunnelInfo.hTunneledComp, OMX_CommandPortDisable, sTunnelInfo.nTunneledPort, NULL);
+            while(BufferNum() < nBufferHdrNum) {
+                LOG_DEBUG("%s wait for buffer return to supplier port %d.\n", base->name, nPortIndex);
+                fsl_osal_sleep(10000);
+            }
+            bNeedReturnBuffers = OMX_FALSE;
+            SupplierFreeBuffers();
+        }
+        else
+            ReturnBuffers();
+    }
+
+    LOG_DEBUG("%s disable port %d done\n", base->name, nPortIndex);
+
+    return OMX_ErrorNotComplete;
+}
+
+OMX_ERRORTYPE Port::Enable() 
+{
+    OMX_STATETYPE eState = OMX_StateInvalid;
+
+    if(sPortDef.bEnabled == OMX_TRUE)
+        return OMX_ErrorSameState;
+
+    base->GetState(&eState);
+    if(eState == OMX_StateLoaded) {
+        sPortDef.bEnabled = OMX_TRUE;
+        return OMX_ErrorNone;
+    }
+
+    if(bTunneled == OMX_TRUE && bSupplier == OMX_TRUE) {
+        OMX_SendCommand(sTunnelInfo.hTunneledComp, OMX_CommandPortEnable, sTunnelInfo.nTunneledPort, NULL);
+        SupplierAllocateBuffers();
+    }
+
+    return OMX_ErrorNotComplete;
+}
+
+OMX_ERRORTYPE Port::Flush() 
+{
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U32 nBuffer = 0;
+    OMX_U32 i;
+
+    base->FlushComponent(nPortIndex);
+    nBuffer = BufferNum();
+    LOG_DEBUG("%s flush port %d return buffer: %d\n", base->name, nPortIndex, nBuffer);
+    for(i=0; i<nBuffer; i++) {
+        GetBuffer(&pBufferHdr);
+        SendBuffer(pBufferHdr);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::ReturnBuffers() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    LOG_DEBUG("%s port %d return buffers.\n", base->name, nPortIndex);
+
+    base->ComponentReturnBuffer(nPortIndex);
+
+    if(bTunneled != OMX_TRUE ||
+            (bTunneled == OMX_TRUE && bSupplier != OMX_TRUE)) {
+        while(BufferNum() > 0) {
+            OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+            GetBuffer(&pBufferHdr);
+            SendBuffer(pBufferHdr);
+        }
+    }
+
+    LOG_DEBUG("%s port %d return buffers done.\n", base->name, nPortIndex);
+
+    return ret;
+}
+
+// in case that someone wants to deal with mark data without calling SendBuffer()
+OMX_ERRORTYPE Port::SendEventMark(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    if (nMarkDataNum > 0)
+    {
+        OMX_MARKTYPE *pMarkData = NULL;
+        pMarkData = &MarkDatas[nGetMarkData];
+
+        if(pMarkData->hMarkTargetComponent == base->GetComponentHandle()){
+            LOG_DEBUG("%s,%d,component %s send mark event for target %x.\n",__FUNCTION__,__LINE__,base->name,pMarkData->hMarkTargetComponent);
+            base->SendEvent(OMX_EventMark, 0, 0, pMarkData);
+            pBufferHdr->hMarkTargetComponent = NULL;
+            pMarkData->hMarkTargetComponent = NULL;
+        }
+         
+    }
+
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE Port::SendBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    if(pBufferHdr == NULL)
+        return OMX_ErrorBadParameter;
+
+    if (nMarkDataNum > 0)
+    {
+        OMX_MARKTYPE *pMarkData = NULL;
+        pMarkData = &MarkDatas[nGetMarkData];
+        nGetMarkData ++;
+        nMarkDataNum --;
+        if(nGetMarkData >= MAX_PORT_BUFFER)
+            nGetMarkData = 0;
+
+        if(pMarkData->hMarkTargetComponent == base->GetComponentHandle()){
+            LOG_DEBUG("%s,%d,component %s send mark event for target %x.\n",__FUNCTION__,__LINE__,base->name,pMarkData->hMarkTargetComponent);
+            base->SendEvent(OMX_EventMark, 0, 0, pMarkData);
+            pBufferHdr->hMarkTargetComponent = NULL;
+        }
+        else if(pMarkData->hMarkTargetComponent != NULL){
+            if(sPortDef.eDir == OMX_DirOutput) {
+                pBufferHdr->hMarkTargetComponent = pMarkData->hMarkTargetComponent;
+                pBufferHdr->pMarkData = pMarkData->pMarkData;
+                LOG_DEBUG("%s,%d,component %s,out port %d, do mark target %x on buf %x.\n",__FUNCTION__,__LINE__,base->name,nPortIndex,pBufferHdr->hMarkTargetComponent,pBufferHdr);
+            }else {
+                base->MarkOtherPortsBuffer(pMarkData);
+                LOG_DEBUG("%s,%d,in component %s relay mark target %x to output port.\n",__FUNCTION__,__LINE__,base->name,pMarkData->hMarkTargetComponent);
+            }
+        }
+         
+    }
+
+    if(sPortDef.eDir == OMX_DirInput) {
+        if(bTunneled == OMX_TRUE)
+            OMX_FillThisBuffer(sTunnelInfo.hTunneledComp, pBufferHdr);
+        else
+            base->EmptyDone(pBufferHdr);
+    }
+
+    if(sPortDef.eDir == OMX_DirOutput) {
+        if(bTunneled == OMX_TRUE)
+            OMX_EmptyThisBuffer(sTunnelInfo.hTunneledComp, pBufferHdr);
+        else
+            base->FillDone(pBufferHdr);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::MarkBuffer(
+        OMX_MARKTYPE *pMarkData) 
+{
+    if(pMarkData == NULL)
+        return OMX_ErrorBadParameter;
+
+    fsl_osal_memcpy(&MarkDatas[nAddMarkData],pMarkData,sizeof(OMX_MARKTYPE));
+    nMarkDataNum ++;
+    nAddMarkData ++;
+    if(nAddMarkData >= MAX_PORT_BUFFER)
+        nAddMarkData = 0;
+        
+//    LOG_ERROR("%s,%d,mark target %x.\n",__FUNCTION__,__LINE__,pMarkData->hMarkTargetComponent);
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::AddBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    if(pBufferHdr == NULL)
+        return OMX_ErrorBadParameter;
+
+    pPortQueue->Add(&pBufferHdr);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::GetBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr) 
+{
+    if(ppBufferHdr == NULL)
+        return OMX_ErrorBadParameter;
+
+    pPortQueue->Get(ppBufferHdr);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::AcessBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nIndex)
+{
+    if(ppBufferHdr == NULL)
+        return OMX_ErrorBadParameter;
+
+    if(QUEUE_SUCCESS != pPortQueue->Access(ppBufferHdr, nIndex))
+        return OMX_ErrorOverflow;
+
+    return OMX_ErrorNone;
+}
+
+OMX_U32 Port::BufferNum() 
+{
+    return pPortQueue->Size();
+}
+
+OMX_ERRORTYPE Port::GetTunneledInfo(
+        TUNNEL_INFO *pTunnelInfo) 
+{
+    fsl_osal_memcpy(pTunnelInfo, &sTunnelInfo, sizeof(TUNNEL_INFO));
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::SetSupplierType(
+        OMX_BUFFERSUPPLIERTYPE eSupplier) 
+{
+    eBufferSupplier = eSupplier;
+    if((eBufferSupplier == OMX_BufferSupplyInput && sPortDef.eDir == OMX_DirInput)
+            || (eBufferSupplier == OMX_BufferSupplyOutput && sPortDef.eDir == OMX_DirOutput))
+        bSupplier = OMX_TRUE;
+    else
+        bSupplier = OMX_FALSE;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Port::GetSupplierType(
+        OMX_BUFFERSUPPLIERTYPE *pSupplier) 
+{
+    *pSupplier = eBufferSupplier;
+    return OMX_ErrorNone;
+}
+
+OMX_DIRTYPE Port::GetPortDir() 
+{
+    return sPortDef.eDir;
+}
+
+OMX_BOOL Port::IsEnabled() 
+{
+    return sPortDef.bEnabled;
+}
+
+OMX_BOOL Port::IsPopulated() 
+{
+    return sPortDef.bPopulated;
+}
+
+OMX_BOOL Port::IsAllocater() 
+{
+    return bAllocater;
+}
+
+OMX_BOOL Port::IsTunneled() 
+{
+    return bTunneled;
+}
+
+OMX_BOOL Port::IsSupplier() 
+{
+    return bSupplier;
+}
+
+OMX_BOOL Port::IsBufferMarked() 
+{
+    return OMX_TRUE;
+
+}
+
+OMX_BOOL Port::NeedReturnBuffers()
+{
+    return bNeedReturnBuffers;
+}
+
+OMX_BOOL Port::IsAllBuffersReturned() 
+{
+    if(bTunneled == OMX_TRUE && bSupplier == OMX_TRUE) {
+        if(nBufferHdrNum != BufferNum())
+            return OMX_FALSE;
+    }
+    else {
+        if(BufferNum() > 0)
+            return OMX_FALSE;
+    }
+
+    return OMX_TRUE;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/Port.h b/OpenMAXIL/src/component/common/Port.h
new file mode 100755
index 0000000..9636a66
--- /dev/null
+++ b/OpenMAXIL/src/component/common/Port.h
@@ -0,0 +1,88 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file Port.h
+ *  @brief class definition of port
+ *  @ingroup Port
+ */
+
+#ifndef Port_h
+#define Port_h
+
+#include "Queue.h"
+#include "ComponentCommon.h"
+#include "ComponentBase.h"
+
+class Port {
+    public:
+        Port(ComponentBase *pBase, OMX_U32 nPortIdx);
+        OMX_ERRORTYPE Init();
+        OMX_ERRORTYPE DeInit();
+        OMX_ERRORTYPE SetPortDefinition(OMX_PARAM_PORTDEFINITIONTYPE *pPortDef);
+        OMX_ERRORTYPE GetPortDefinition(OMX_PARAM_PORTDEFINITIONTYPE *pPortDef);
+        OMX_ERRORTYPE SetPortFormat(OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortDef);
+        OMX_ERRORTYPE GetPortFormat(OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortDef);
+        OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_PTR pAppPrivate,
+                OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_PTR pAppPrivate, void* eglImage);
+        OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_PTR pAppPrivate,
+                OMX_U32 nSizeBytes);
+        OMX_ERRORTYPE FreeBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE TunnelRequest(OMX_HANDLETYPE hTunneledComp, OMX_U32 nTunneledPort,
+                OMX_TUNNELSETUPTYPE* pTunnelSetup);
+        OMX_ERRORTYPE Disable();
+        OMX_ERRORTYPE Enable();
+        OMX_ERRORTYPE Flush();
+        OMX_ERRORTYPE ReturnBuffers();
+        OMX_ERRORTYPE SendBuffer(OMX_BUFFERHEADERTYPE* pBufferHdr);
+        OMX_ERRORTYPE MarkBuffer(OMX_MARKTYPE *pMarkData);
+        OMX_ERRORTYPE SupplierAllocateBuffers();
+        OMX_ERRORTYPE SupplierFreeBuffers();
+        OMX_ERRORTYPE AddBuffer(OMX_BUFFERHEADERTYPE* pBufferHdr);
+        OMX_ERRORTYPE GetBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr);
+        OMX_ERRORTYPE AcessBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nIndex);
+        OMX_U32 BufferNum();
+        OMX_ERRORTYPE GetTunneledInfo(TUNNEL_INFO *pTunnelInfo);
+        OMX_ERRORTYPE SetSupplierType(OMX_BUFFERSUPPLIERTYPE eSupplier);
+        OMX_ERRORTYPE GetSupplierType(OMX_BUFFERSUPPLIERTYPE *pSupplier);
+        OMX_DIRTYPE GetPortDir();
+        OMX_BOOL IsEnabled();
+        OMX_BOOL IsPopulated();
+        OMX_BOOL IsAllocater();
+        OMX_BOOL IsTunneled();
+        OMX_BOOL IsSupplier();
+        OMX_BOOL IsBufferMarked();
+        OMX_BOOL NeedReturnBuffers();
+        OMX_ERRORTYPE SendEventMark(OMX_BUFFERHEADERTYPE* pBufferHdr) ;
+    private:
+        OMX_U32 nPortIndex;
+        ComponentBase *base;
+        Queue *pPortQueue;
+        OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+        OMX_VIDEO_PARAM_PORTFORMATTYPE sPortFormat[MAX_PORT_FORMAT_NUM];
+		OMX_U32 nSupportColorFormatNum;
+        OMX_U32 nBufferHdrNum;
+        OMX_BUFFERHEADERTYPE *BufferHdrArry[MAX_PORT_BUFFER];
+        OMX_U32 nMarkDataNum;
+        OMX_U32 nGetMarkData;
+        OMX_U32 nAddMarkData;
+        OMX_MARKTYPE MarkDatas[MAX_PORT_BUFFER];
+        OMX_BOOL bAllocater;
+        OMX_BOOL bTunneled;
+        OMX_BOOL bSupplier;
+        OMX_BOOL bNeedReturnBuffers;
+        OMX_BUFFERSUPPLIERTYPE eBufferSupplier;
+        TUNNEL_INFO sTunnelInfo;
+        OMX_BOOL IsAllBuffersReturned();
+        OMX_BOOL bPendingDisable;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/State.cpp b/OpenMAXIL/src/component/common/State.cpp
new file mode 100755
index 0000000..50fbb7f
--- /dev/null
+++ b/OpenMAXIL/src/component/common/State.cpp
@@ -0,0 +1,805 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "State.h"
+#include <string.h>
+
+State::State(ComponentBase *pBase) : base(pBase)
+{
+    if(base->bInContext == OMX_TRUE)
+        Process = &ComponentBase::ProcessInContext;
+    else
+        Process = &ComponentBase::ProcessOutContext;
+}
+
+OMX_ERRORTYPE State::ProcessCmd() 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    CMD_MSG sMsg;
+    OMX_U32 i;
+
+    if(base->pCmdQueue->Size() == 0)
+        return OMX_ErrorNoMore;
+
+    base->pCmdQueue->Get(&sMsg);
+
+    LOG_DEBUG("Processing Command[cmd:%d, param: %d, data: %d] in Component[%s].\n",
+            sMsg.Cmd, sMsg.nParam, sMsg.pCmdData, base->name);
+
+    switch (sMsg.Cmd)
+    {
+        case OMX_CommandStateSet:
+            switch (sMsg.nParam)
+            {
+                case OMX_StateInvalid:
+                    ret = ToInvalid();
+                    break;
+                case OMX_StateLoaded:
+                    ret = ToLoaded();
+                    break;
+                case OMX_StateIdle:
+                    ret = ToIdle();
+                    break;
+                case OMX_StateExecuting:
+                    ret = ToExecuting();
+                    break;
+                case OMX_StatePause:
+                    ret = ToPause();
+                    break;
+                case OMX_StateWaitForResources:
+                    ret = ToWaitForResources();
+                    break;
+                default:
+                    LOG_ERROR("Invalid state transation.\n");
+                    ret = OMX_ErrorBadParameter;
+                    break;
+            }
+            break;
+        case OMX_CommandFlush:
+            if(sMsg.nParam == OMX_ALL) {
+                for( i=0 ; i<base->nPorts ; i++ ) {
+                    ret = base->ports[i]->Flush();
+                    if(ret != OMX_ErrorNone)
+                        break;
+                }
+            }
+            else {
+                if(sMsg.nParam >= base->nPorts) {
+                    LOG_ERROR("Port number[%d] is not correct for flush command.\n", sMsg.nParam);
+                    ret = OMX_ErrorBadParameter;
+                    break;
+                }
+                ret = base->ports[sMsg.nParam]->Flush();
+            }
+            break;
+        case OMX_CommandPortDisable:
+            if(sMsg.nParam == OMX_ALL) {
+                for( i=0 ; i<base->nPorts ; i++ ) {
+                    ret = base->ports[i]->Disable();
+                }
+            }
+            else {
+                if(sMsg.nParam >= base->nPorts) {
+                    LOG_ERROR("Port number[%d] is not correct for PortDisable command.\n", sMsg.nParam);
+                    ret = OMX_ErrorBadParameter;
+                    break;
+                }
+                ret = base->ports[sMsg.nParam]->Disable();
+            }
+            break;
+        case OMX_CommandPortEnable:
+            if(sMsg.nParam == OMX_ALL) {
+                for( i=0 ; i<base->nPorts ; i++ ) {
+                    ret = base->ports[i]->Enable();
+                }
+            }
+            else {
+                if(sMsg.nParam >= base->nPorts) {
+                    LOG_ERROR("Port number[%d] is not correct for PortEnable command.\n", sMsg.nParam);
+                    ret = OMX_ErrorBadParameter;
+                    break;
+                }
+                ret = base->ports[sMsg.nParam]->Enable();
+            }
+            break;
+        case OMX_CommandMarkBuffer:
+            if(sMsg.nParam >= base->nPorts) {
+                LOG_ERROR("Port number[%d] is not correct for MarkBuffer command.\n", sMsg.nParam);
+                ret = OMX_ErrorBadParameter;
+                break;
+            }
+
+            LOG_DEBUG("%s,%d,mark buffer on port %d.\n",__FUNCTION__,__LINE__ ,sMsg.nParam);
+            ret = base->ports[sMsg.nParam]->MarkBuffer((OMX_MARKTYPE*)(sMsg.pCmdData));
+            break;
+        default:
+            LOG_ERROR("Invalid command.\n");
+            ret = OMX_ErrorBadParameter;
+            break;
+    }
+
+    base->pendingCmd.bProcessed = OMX_TRUE;
+
+    if(ret == OMX_ErrorNone) {
+		if(sMsg.nParam == OMX_ALL) {
+			for( i=0 ; i<base->nPorts ; i++ ) {
+				LOG_DEBUG("Process Command [cmd:%d, param: %d, data: %d] finished.\n",
+						sMsg.Cmd, i, sMsg.pCmdData);
+				base->SendEvent(OMX_EventCmdComplete, sMsg.Cmd, i, sMsg.pCmdData);
+			}
+		} else {
+				LOG_DEBUG("Process Command [cmd:%d, param: %d, data: %d] finished.\n",
+						sMsg.Cmd, sMsg.nParam, sMsg.pCmdData);
+				base->SendEvent(OMX_EventCmdComplete, sMsg.Cmd, sMsg.nParam, sMsg.pCmdData);
+		}
+    }
+    else if(ret == OMX_ErrorNotComplete)
+        ret = OMX_ErrorNone;
+    else {
+		if(sMsg.nParam == OMX_ALL) {
+			for( i=0 ; i<base->nPorts ; i++ ) {
+				LOG_DEBUG("%s Process Command [cmd:%d, param: %d, data: %d] failed, ret = %x.\n",
+						base->name, sMsg.Cmd, i, sMsg.pCmdData, ret);
+				base->pendingCmd.cmd = OMX_CommandMax;
+				base->SendEvent(OMX_EventError, ret, sMsg.Cmd, NULL);
+			}
+		} else {
+			LOG_DEBUG("%s Process Command [cmd:%d, param: %d, data: %d] failed, ret = %x.\n",
+					base->name, sMsg.Cmd, sMsg.nParam, sMsg.pCmdData, ret);
+			base->pendingCmd.cmd = OMX_CommandMax;
+			base->SendEvent(OMX_EventError, ret, sMsg.Cmd, NULL);
+		}
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoGetComponentVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    if(pComponentName == NULL || pComponentVersion == NULL
+            || pSpecVersion == NULL || pComponentUUID == NULL)
+        return OMX_ErrorBadParameter;
+
+    fsl_osal_strcpy(pComponentName, (OMX_STRING)(base->name));
+    fsl_osal_memcpy(pComponentVersion, &(base->ComponentVersion), sizeof(OMX_VERSIONTYPE));
+    fsl_osal_memcpy(pSpecVersion, &(base->SpecVersion), sizeof(OMX_VERSIONTYPE));
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE State::DoSendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam, 
+        OMX_PTR pCmdData) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    CMD_MSG sMsg;
+
+    /* reset Cmd pool if pendingCmd is dead */
+    if(Cmd == OMX_CommandMax) {
+        base->pendingCmd.cmd = OMX_CommandMax;
+        return OMX_ErrorNone;
+    }
+
+    if(base->pendingCmd.cmd != OMX_CommandMax)
+        return OMX_ErrorNotReady;
+
+    LOG_DEBUG("Sending Command[cmd:%d, param: %d, data: %d] to Component[%s].\n",
+            Cmd, nParam, pCmdData, base->name);
+
+    ret = CheckCommand(Cmd, nParam, pCmdData);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    base->pendingCmd.cmd = Cmd;
+    base->pendingCmd.nParam = nParam;
+    base->pendingCmd.pCmdData = pCmdData;
+    base->pendingCmd.bProcessed = OMX_FALSE;
+
+    sMsg.Cmd = Cmd;
+    sMsg.nParam = nParam;
+    sMsg.pCmdData = pCmdData;
+    base->pCmdQueue->Add(&sMsg);
+
+    LOG_DEBUG("Sending Command[cmd:%d, param: %d, data: %d] to Component[%s] done.\n",
+            Cmd, nParam, pCmdData, base->name);
+
+    ret = (base->*Process)(COMMAND);
+
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoEmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 nPortIndex;
+
+    LOG_DEBUG("%s EmptyBuffer %p.\n", base->name, pBuffer);
+
+    if(pBuffer == NULL)
+        return OMX_ErrorBadParameter;
+
+    /**< check buffer structure version*/
+    OMX_CHECK_STRUCT(pBuffer, OMX_BUFFERHEADERTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    nPortIndex = pBuffer->nInputPortIndex;
+    if(nPortIndex >= base->nPorts
+            || base->ports[nPortIndex]->GetPortDir() != OMX_DirInput)
+        return OMX_ErrorBadPortIndex;
+
+    if(base->ports[nPortIndex]->IsEnabled() != OMX_TRUE) {
+        LOG_WARNING("%s Port %d is not populated.\n", base->name, nPortIndex);
+        return OMX_ErrorPortUnpopulated;
+    }
+
+    LOG_DEBUG("%s Sending Input buffer[%p]\n", base->name, pBuffer);
+    if (NULL != pBuffer->hMarkTargetComponent)
+    {
+        OMX_MARKTYPE sMarkData;
+        sMarkData.hMarkTargetComponent = pBuffer->hMarkTargetComponent;
+        sMarkData.pMarkData = pBuffer->pMarkData;
+        if(pBuffer->hMarkTargetComponent != base->GetComponentHandle()) {
+            base->MarkOtherPortsBuffer(&sMarkData);
+            LOG_DEBUG("%s,%d,in component %s relay mark target %x to output port.\n",__FUNCTION__,__LINE__,base->name,sMarkData.hMarkTargetComponent);
+        }
+        else {
+            base->ports[nPortIndex]->MarkBuffer(&sMarkData);
+            LOG_DEBUG("%s,%d,in component %s mark target %x to input port.\n",__FUNCTION__,__LINE__,base->name,pBuffer->hMarkTargetComponent);
+        }
+    }
+
+    base->ports[nPortIndex]->AddBuffer(pBuffer);
+    if(base->ports[nPortIndex]->NeedReturnBuffers() == OMX_TRUE)
+        return ret;
+
+    ret = (base->*Process)(BUFFER);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoFillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 nPortIndex;
+
+    LOG_DEBUG("%s FillBuffer %p.\n", base->name, pBuffer);
+
+    if(pBuffer == NULL)
+        return OMX_ErrorBadParameter;
+
+    /**< check buffer structure version*/
+    OMX_CHECK_STRUCT(pBuffer, OMX_BUFFERHEADERTYPE, ret);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    nPortIndex = pBuffer->nOutputPortIndex;
+    if(nPortIndex >= base->nPorts
+            || base->ports[nPortIndex]->GetPortDir() != OMX_DirOutput)
+        return OMX_ErrorBadPortIndex;
+
+    if(base->ports[nPortIndex]->IsEnabled() != OMX_TRUE) {
+        LOG_WARNING("%s Port %d is not populated.\n", base->name, nPortIndex);
+        return OMX_ErrorPortUnpopulated;
+    }
+
+
+    LOG_DEBUG("%s Sending Output buffer[%p]\n", base->name, pBuffer);
+    base->ports[nPortIndex]->AddBuffer(pBuffer);
+    if(base->ports[nPortIndex]->NeedReturnBuffers() == OMX_TRUE)
+        return ret;
+        
+    ret = (base->*Process)(BUFFER);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoGetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pStructure == NULL)
+        return OMX_ErrorBadParameter;
+
+    switch(nParamIndex) {
+        case OMX_IndexParamPortDefinition:
+            {
+                OMX_PARAM_PORTDEFINITIONTYPE *pPortDef;
+
+                pPortDef = (OMX_PARAM_PORTDEFINITIONTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortDef, OMX_PARAM_PORTDEFINITIONTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+                if(pPortDef->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                ret = base->ports[pPortDef->nPortIndex]->GetPortDefinition(pPortDef);
+            }
+            break;
+        case OMX_IndexParamCompBufferSupplier:
+            {
+                OMX_PARAM_BUFFERSUPPLIERTYPE *pBufferSupplierType;
+                OMX_U32 nPortIndex;
+
+                pBufferSupplierType = (OMX_PARAM_BUFFERSUPPLIERTYPE*) pStructure;
+                OMX_CHECK_STRUCT(pBufferSupplierType, OMX_PARAM_BUFFERSUPPLIERTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    return ret;
+
+                nPortIndex = pBufferSupplierType->nPortIndex;
+                if(nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                ret = base->ports[nPortIndex]->GetSupplierType(&(pBufferSupplierType->eBufferSupplier));
+            }
+            break;
+       case OMX_IndexParamAudioInit:
+            {
+                OMX_PORT_PARAM_TYPE *pPortPara;
+
+                pPortPara = (OMX_PORT_PARAM_TYPE*) pStructure;
+                OMX_CHECK_STRUCT(pPortPara, OMX_PORT_PARAM_TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+                pPortPara->nPorts = base->PortParam[AudioPortParamIdx].nPorts;
+                pPortPara->nStartPortNumber = base->PortParam[AudioPortParamIdx].nStartPortNumber;
+            }
+            break;
+        case OMX_IndexParamVideoInit:
+            {
+                OMX_PORT_PARAM_TYPE *pPortPara;
+
+                pPortPara = (OMX_PORT_PARAM_TYPE*) pStructure;
+                OMX_CHECK_STRUCT(pPortPara, OMX_PORT_PARAM_TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+                pPortPara->nPorts = base->PortParam[VideoPortParamIdx].nPorts;
+                pPortPara->nStartPortNumber = base->PortParam[VideoPortParamIdx].nStartPortNumber;
+            }
+            break;
+        case OMX_IndexParamImageInit:
+            {
+                OMX_PORT_PARAM_TYPE *pPortPara;
+
+                pPortPara = (OMX_PORT_PARAM_TYPE*) pStructure;
+                OMX_CHECK_STRUCT(pPortPara, OMX_PORT_PARAM_TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+                pPortPara->nPorts = base->PortParam[ImagePortParamIdx].nPorts;
+                pPortPara->nStartPortNumber = base->PortParam[ImagePortParamIdx].nStartPortNumber;
+            }
+            break;
+        case OMX_IndexParamOtherInit:
+            {
+                OMX_PORT_PARAM_TYPE *pPortPara;
+
+                pPortPara = (OMX_PORT_PARAM_TYPE*) pStructure;
+                OMX_CHECK_STRUCT(pPortPara, OMX_PORT_PARAM_TYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+
+                pPortPara->nPorts = base->PortParam[OtherPortParamIdx].nPorts;
+                pPortPara->nStartPortNumber = base->PortParam[OtherPortParamIdx].nStartPortNumber;
+            }
+            break;
+        case OMX_IndexParamAudioPortFormat:
+            {
+                OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_AUDIO_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_AUDIO_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainAudio)
+                    return OMX_ErrorBadPortIndex;
+                pPortFmt->eEncoding = sPortDef.format.audio.eEncoding;
+            }
+            break;
+        case OMX_IndexParamVideoPortFormat:
+            {
+                OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_VIDEO_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_VIDEO_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+				
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainVideo)
+                    return OMX_ErrorBadPortIndex;
+				
+                return base->ports[pPortFmt->nPortIndex]->GetPortFormat(pPortFmt);
+            }
+            break;
+        case OMX_IndexParamImagePortFormat:
+            {
+                OMX_IMAGE_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_IMAGE_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_IMAGE_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainImage)
+                    return OMX_ErrorBadPortIndex;
+                pPortFmt->eCompressionFormat = sPortDef.format.image.eCompressionFormat;
+                pPortFmt->eColorFormat = sPortDef.format.image.eColorFormat;
+            }
+            break;
+        case OMX_IndexParamOtherPortFormat:
+            {
+                OMX_OTHER_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_OTHER_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_OTHER_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainOther)
+                    return OMX_ErrorBadPortIndex;
+                pPortFmt->eFormat = sPortDef.format.other.eFormat;
+            }
+            break;
+        default:
+            ret = base->GetParameter(nParamIndex, pStructure);
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoSetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pStructure == NULL)
+        return OMX_ErrorBadParameter;
+
+    switch(nParamIndex) {
+        case OMX_IndexParamPortDefinition:
+            {
+                OMX_PARAM_PORTDEFINITIONTYPE *pPortDef;
+
+                pPortDef = (OMX_PARAM_PORTDEFINITIONTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortDef, OMX_PARAM_PORTDEFINITIONTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    return ret;
+                if(pPortDef->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                ret = base->ports[pPortDef->nPortIndex]->SetPortDefinition(pPortDef);
+                if(ret == OMX_ErrorNone)
+                    base->PortFormatChanged(pPortDef->nPortIndex);
+            }
+            break;
+        case OMX_IndexParamCompBufferSupplier:
+            {
+                OMX_PARAM_BUFFERSUPPLIERTYPE *pBufferSupplierType;
+                OMX_U32 nPortIndex;
+
+                pBufferSupplierType = (OMX_PARAM_BUFFERSUPPLIERTYPE*) pStructure;
+                OMX_CHECK_STRUCT(pBufferSupplierType, OMX_PARAM_BUFFERSUPPLIERTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    return ret;
+
+                nPortIndex = pBufferSupplierType->nPortIndex;
+                if(nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                base->ports[nPortIndex]->SetSupplierType(pBufferSupplierType->eBufferSupplier);
+            }
+            break;
+        case OMX_IndexParamAudioPortFormat:
+            {
+                OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_AUDIO_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_AUDIO_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainAudio)
+                    return OMX_ErrorBadPortIndex;
+                sPortDef.format.audio.eEncoding = pPortFmt->eEncoding;
+                base->ports[pPortFmt->nPortIndex]->SetPortDefinition(&sPortDef);
+            }
+            break;
+        case OMX_IndexParamVideoPortFormat:
+            {
+                OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_VIDEO_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_VIDEO_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainVideo)
+                    return OMX_ErrorBadPortIndex;
+                sPortDef.format.video.eCompressionFormat = pPortFmt->eCompressionFormat;
+                sPortDef.format.video.eColorFormat = pPortFmt->eColorFormat;
+                sPortDef.format.video.xFramerate = pPortFmt->xFramerate;
+                base->ports[pPortFmt->nPortIndex]->SetPortDefinition(&sPortDef);
+            }
+            break;
+        case OMX_IndexParamImagePortFormat:
+            {
+                OMX_IMAGE_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_IMAGE_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_IMAGE_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainImage)
+                    return OMX_ErrorBadPortIndex;
+                sPortDef.format.image.eCompressionFormat = pPortFmt->eCompressionFormat;
+                sPortDef.format.image.eColorFormat = pPortFmt->eColorFormat;
+                base->ports[pPortFmt->nPortIndex]->SetPortDefinition(&sPortDef);
+            }
+            break;
+        case OMX_IndexParamOtherPortFormat:
+            {
+                OMX_OTHER_PARAM_PORTFORMATTYPE *pPortFmt;
+                OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+                OMX_U32 nParamIndex;
+
+                pPortFmt = (OMX_OTHER_PARAM_PORTFORMATTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pPortFmt, OMX_OTHER_PARAM_PORTFORMATTYPE, ret);
+                if(ret != OMX_ErrorNone)
+                    break;
+                if(pPortFmt->nPortIndex >= base->nPorts)
+                    return OMX_ErrorBadPortIndex;
+
+                OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                sPortDef.nPortIndex = pPortFmt->nPortIndex;
+                base->ports[pPortFmt->nPortIndex]->GetPortDefinition(&sPortDef);
+                if(sPortDef.eDomain != OMX_PortDomainOther)
+                    return OMX_ErrorBadPortIndex;
+                sPortDef.format.other.eFormat = pPortFmt->eFormat;
+                base->ports[pPortFmt->nPortIndex]->SetPortDefinition(&sPortDef);
+            }
+            break;
+        default:
+            ret = base->SetParameter(nParamIndex, pStructure);
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoGetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure) 
+{
+    if(pStructure == NULL)
+        return OMX_ErrorBadParameter;
+
+    return base->GetConfig(nParamIndex, pStructure);
+}
+
+OMX_ERRORTYPE State::DoSetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure) 
+{
+    if(pStructure == NULL)
+        return OMX_ErrorBadParameter;
+
+    return base->SetConfig(nParamIndex, pStructure);
+}
+
+OMX_ERRORTYPE State::DoGetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return base->GetExtensionIndex(cParameterName, pIndexType);
+}
+
+OMX_ERRORTYPE State::DoUseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pBuffer == NULL || nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    ret = base->ports[nPortIndex]->UseBuffer(
+            ppBufferHdr, pAppPrivate, nSizeBytes, pBuffer);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoAllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    ret = base->ports[nPortIndex]->AllocateBuffer(
+            ppBufferHdr, pAppPrivate, nSizeBytes);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoFreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBufferHdr) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    ret = base->ports[nPortIndex]->FreeBuffer(pBufferHdr);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoTunnelRequest(
+        OMX_U32 nPortIndex, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    ret = base->ports[nPortIndex]->TunnelRequest(
+            hTunneledComp,nTunneledPort,pTunnelSetup);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::DoUseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void* eglImage)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(nPortIndex >= base->nPorts)
+        return OMX_ErrorBadParameter;
+
+    ret = base->ports[nPortIndex]->UseEGLImage(
+            ppBufferHdr, pAppPrivate, eglImage);
+
+    return ret;
+}
+
+OMX_ERRORTYPE State::CheckCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam, 
+        OMX_PTR pCmdData)
+{
+    OMX_STATETYPE eState = OMX_StateInvalid;
+    OMX_U32 i;
+
+    if(Cmd == OMX_CommandStateSet) {
+        base->GetState(&eState);
+        if((OMX_U32)eState == nParam)
+            return OMX_ErrorSameState;
+    }
+    else if(Cmd == OMX_CommandPortDisable) {
+        if(nParam == OMX_ALL) {
+            OMX_BOOL bAllDisabled = OMX_TRUE;
+            for(i=0; i<base->nPorts; i++) {
+                if(base->ports[i]->IsEnabled() == OMX_TRUE) {
+                    bAllDisabled = OMX_FALSE;
+                    break;
+                }
+            }
+            if(bAllDisabled == OMX_TRUE)
+                return OMX_ErrorSameState;
+        }
+        else {
+            if(nParam >= base->nPorts)
+                return OMX_ErrorBadParameter;
+            if(base->ports[nParam]->IsEnabled() != OMX_TRUE)
+                return OMX_ErrorSameState;
+        }
+    }
+    else if(Cmd == OMX_CommandPortEnable) {
+        if(nParam == OMX_ALL) {
+            OMX_BOOL bAllEnabled = OMX_TRUE;
+            for(i=0; i<base->nPorts; i++) {
+                if(base->ports[i]->IsEnabled() != OMX_TRUE) {
+                    bAllEnabled = OMX_FALSE;
+                    break;
+                }
+            }
+            if(bAllEnabled == OMX_TRUE)
+                return OMX_ErrorSameState;
+        }
+        else {
+            if(nParam >= base->nPorts)
+                return OMX_ErrorBadParameter;
+            if(base->ports[nParam]->IsEnabled() == OMX_TRUE)
+                return OMX_ErrorSameState;
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/State.h b/OpenMAXIL/src/component/common/State.h
new file mode 100755
index 0000000..bc4ccce
--- /dev/null
+++ b/OpenMAXIL/src/component/common/State.h
@@ -0,0 +1,88 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file State.h
+ *  @brief Base class definition of State
+ *  @ingroup State
+ */
+
+#ifndef State_h
+#define State_h
+
+#include "ComponentCommon.h"
+#include "ComponentBase.h"
+
+#define IS_PORT_ENABLING(idx) \
+    ((base->pendingCmd.cmd == OMX_CommandPortEnable) && (base->pendingCmd.nParam == idx) ? OMX_TRUE : OMX_FALSE)
+
+#define IS_PORT_DISABLING(idx) \
+    ((base->pendingCmd.cmd == OMX_CommandPortDisable) && (base->pendingCmd.nParam == idx) ? OMX_TRUE : OMX_FALSE)
+
+class State {
+    public:
+        State(ComponentBase *pBase);
+        virtual ~State() {};
+        virtual OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID) = 0;
+        virtual OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData) = 0;
+        virtual OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer) = 0;
+        virtual OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer) = 0;
+        OMX_ERRORTYPE ProcessCmd();
+        virtual OMX_ERRORTYPE ProcessBuffer() = 0;
+        virtual OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) = 0;
+        virtual OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) = 0;
+        virtual OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) = 0;
+        virtual OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) = 0;
+        virtual OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType) = 0;
+        virtual OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer) = 0;
+        virtual OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                        OMX_PTR pAppPrivate, void *eglImage) = 0;
+        virtual OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes) = 0;
+        virtual OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer) = 0;
+        virtual OMX_ERRORTYPE TunnelRequest(OMX_U32 nPortIndex, OMX_HANDLETYPE hTunneledComp,
+                OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup) = 0;
+    protected:
+        ComponentBase *base;
+        OMX_ERRORTYPE DoGetComponentVersion(OMX_STRING pComponentName, 
+                OMX_VERSIONTYPE* pComponentVersion, 
+                OMX_VERSIONTYPE* pSpecVersion, 
+                OMX_UUIDTYPE* pComponentUUID);
+        OMX_ERRORTYPE DoSendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam, OMX_PTR pCmdData);
+        OMX_ERRORTYPE DoEmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE DoFillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE DoGetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE DoSetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE DoGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE DoSetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE DoGetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        OMX_ERRORTYPE DoUseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        OMX_ERRORTYPE DoAllocateBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        OMX_ERRORTYPE DoFreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBufferHdr);
+        OMX_ERRORTYPE DoTunnelRequest(OMX_U32 nPortIndex, OMX_HANDLETYPE hTunneledComp,
+                OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+        OMX_ERRORTYPE DoUseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                OMX_PTR pAppPrivate, void* eglImage);
+    private:
+        OMX_ERRORTYPE (ComponentBase::*Process)(MSG_TYPE msg);
+        OMX_ERRORTYPE CheckCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam, OMX_PTR pCmdData);
+        virtual OMX_ERRORTYPE ToInvalid() = 0;
+        virtual OMX_ERRORTYPE ToLoaded() = 0;
+        virtual OMX_ERRORTYPE ToWaitForResources() = 0;
+        virtual OMX_ERRORTYPE ToIdle() = 0;
+        virtual OMX_ERRORTYPE ToPause() = 0;
+        virtual OMX_ERRORTYPE ToExecuting() = 0;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/UniaDecoder.cpp b/OpenMAXIL/src/component/common/UniaDecoder.cpp
new file mode 100755
index 0000000..79ee53e
--- /dev/null
+++ b/OpenMAXIL/src/component/common/UniaDecoder.cpp
@@ -0,0 +1,683 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "UniaDecoder.h"
+//#undef LOG_DEBUG
+//#define LOG_DEBUG printf
+//#undef LOG_LOG
+//#define LOG_LOG printf
+#define MAX_PROFILE_ERROR_COUNT 1500 //about 1 second decoding time, 30 seconds' audio data length
+/*****************************************************************************
+ * Function:    appLocalMalloc
+ *
+ * Description: Implements the local malloc
+ *
+ * Return:      Value of the address.
+ *
+ ****************************************************************************/
+
+static void* appLocalMalloc (uint32 TotalSize)
+{
+
+    void *PtrMalloc = NULL;
+
+    if(0 == TotalSize)
+        LOG_WARNING("\nWarning: ZERO size IN LOCAL MALLOC");
+
+    PtrMalloc = FSL_MALLOC(TotalSize);
+
+    if (PtrMalloc == NULL) {
+
+        LOG_ERROR("\nError: MEMORY FAILURE IN LOCAL MALLOC");
+    }
+    return (PtrMalloc);
+}
+
+
+/*****************************************************************************
+ * Function:    appLocalFree
+ *
+ * Description: Implements to Free the memory.
+ *
+ * Return:      Void
+ *
+ ****************************************************************************/
+static void appLocalFree (void *MemoryBlock)
+{
+    if(MemoryBlock)
+        FSL_FREE(MemoryBlock);
+}
+
+static void *appLocalCalloc(uint32 TotalNumber, uint32 TotalSize)
+{
+    void *PtrCalloc = NULL;
+
+    if((0 == TotalSize)||(0==TotalNumber))
+        LOG_WARNING("\nWarning: ZERO size IN LOCAL CALLOC");
+
+    PtrCalloc = FSL_MALLOC(TotalNumber*TotalSize);
+
+    if (PtrCalloc == NULL) {
+
+        LOG_ERROR("\nError: MEMORY FAILURE IN LOCAL CALLOC");
+                return NULL;
+    }
+    fsl_osal_memset(PtrCalloc, 0, TotalSize*TotalNumber);
+    return (PtrCalloc);
+}
+
+/*****************************************************************************
+ * Function:    appLocalReAlloc
+ *
+ * Description: Implements to Free the memory.
+ *
+ * Return:      Void
+ *
+ ****************************************************************************/
+static void * appLocalReAlloc (void *MemoryBlock, uint32 TotalSize)
+{
+    void *PtrMalloc = NULL;
+
+    if(0 == TotalSize)
+        LOG_WARNING("\nWarning: ZERO size IN LOCAL REALLOC");
+
+    PtrMalloc = (void *)FSL_REALLOC(MemoryBlock, TotalSize);
+    if (PtrMalloc == NULL) {
+    LOG_ERROR("\nError: MEMORY FAILURE IN LOCAL REALLOC");
+    }
+
+    return PtrMalloc;
+}
+UniaDecoder::UniaDecoder()
+{
+    nPorts = AUDIO_FILTER_PORT_NUMBER;
+    nPushModeInputLen = 2048;
+    bInContext = OMX_FALSE;
+    nRingBufferScale = RING_BUFFER_SCALE;
+
+    //these values must be reset by subclass
+    role_cnt = 0;
+    fsl_osal_memset(role,0,sizeof(role));
+    codingType = OMX_AUDIO_CodingUnused;
+    outputPortBufferSize = 0;
+    decoderLibName = NULL;
+
+    //optional value
+    frameInput = OMX_FALSE;
+    optionaDecoderlLibName = NULL;
+    LOG_DEBUG("UniaDecoder::UniaDecoder");
+}
+OMX_ERRORTYPE UniaDecoder::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    LOG_DEBUG("UniaDecoder::InitComponent");
+
+
+    memOps.Calloc = appLocalCalloc;
+    memOps.Malloc = appLocalMalloc;
+    memOps.Free= appLocalFree;
+    memOps.ReAlloc= appLocalReAlloc;
+
+    errorCount = 0;
+    inputFrameCount = 0;
+    consumeFrameCount= 0;
+    profileErrorCount = 0;
+
+    IDecoder = NULL;
+    libMgr = NULL;
+    hLib = NULL;
+
+    if(decoderLibName == NULL || outputPortBufferSize == 0 || nPushModeInputLen == 0){
+        LOG_ERROR("audio decoder param not inited!");
+        return OMX_ErrorInsufficientResources;
+    }
+    LOG_DEBUG("nPushModeInputLen=%d,outputPortBufferSize=%d,codingType=%d"\
+        ,nPushModeInputLen,outputPortBufferSize,codingType);
+    ret = InitPort();
+
+    if(ret != OMX_ErrorNone){
+        return ret;
+    }
+
+
+    libMgr = FSL_NEW(ShareLibarayMgr, ());
+
+    if(libMgr == NULL){
+        ret = OMX_ErrorInsufficientResources;
+        return ret;
+    }
+
+    ret = CreateDecoderInterface();
+
+    return ret;
+}
+OMX_ERRORTYPE UniaDecoder::InitPort()
+{
+
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    do{
+        LOG_DEBUG("UniaDec::InitPort");
+
+        OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+        OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+        sPortDef.nPortIndex = AUDIO_FILTER_INPUT_PORT;
+        sPortDef.eDir = OMX_DirInput;
+        sPortDef.eDomain = OMX_PortDomainAudio;
+        sPortDef.format.audio.eEncoding = (OMX_AUDIO_CODINGTYPE)codingType;
+        sPortDef.bPopulated = OMX_FALSE;
+        sPortDef.bEnabled = OMX_TRUE;
+        sPortDef.nBufferCountMin = 1;
+        sPortDef.nBufferCountActual = 3;
+        sPortDef.nBufferSize = 1024;
+
+        ret = ports[AUDIO_FILTER_INPUT_PORT]->SetPortDefinition(&sPortDef);
+
+        if(ret != OMX_ErrorNone) {
+            break;
+        }
+
+        sPortDef.nPortIndex = AUDIO_FILTER_OUTPUT_PORT;
+        sPortDef.eDir = OMX_DirOutput;
+        sPortDef.eDomain = OMX_PortDomainAudio;
+        sPortDef.format.audio.eEncoding = OMX_AUDIO_CodingPCM;
+        sPortDef.bPopulated = OMX_FALSE;
+        sPortDef.bEnabled = OMX_TRUE;
+        sPortDef.nBufferCountMin = 1;
+        sPortDef.nBufferCountActual = 3;
+        sPortDef.nBufferSize = outputPortBufferSize;
+
+        ret = ports[AUDIO_FILTER_OUTPUT_PORT]->SetPortDefinition(&sPortDef);
+
+        if(ret != OMX_ErrorNone) {
+            break;
+        }
+
+        OMX_INIT_STRUCT(&PcmMode, OMX_AUDIO_PARAM_PCMMODETYPE);
+
+        PcmMode.nPortIndex = AUDIO_FILTER_OUTPUT_PORT;
+        PcmMode.nChannels = 2;
+        PcmMode.nSamplingRate = 44100;
+        PcmMode.nBitPerSample = 16;
+        PcmMode.bInterleaved = OMX_TRUE;
+        PcmMode.eNumData = OMX_NumericalDataSigned;
+        PcmMode.ePCMMode = OMX_AUDIO_PCMModeLinear;
+        PcmMode.eEndian = OMX_EndianLittle;
+        PcmMode.eChannelMapping[0] = OMX_AUDIO_ChannelNone;
+
+    }while(0);
+
+    if(ret != OMX_ErrorNone){
+        LOG_ERROR("UniaDec::InitPort failed ret=%d\n",ret);
+    }
+    return ret;
+}
+OMX_ERRORTYPE UniaDecoder::DeInitComponent()
+{
+    if (libMgr) {
+
+        if (hLib)
+            libMgr->unload(hLib);
+        hLib = NULL;
+        FSL_FREE(IDecoder);
+        FSL_DELETE(libMgr);
+    }
+    LOG_DEBUG("UniaDec::DeInitComponent inputFrameCount=%d,consumeFrameCount=%d",inputFrameCount,consumeFrameCount);
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE UniaDecoder::AudioFilterInstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    do{
+
+        codecConfig.buf = NULL;
+        codecConfig.size = 0;
+        errorCount = 0;
+        profileErrorCount = 0;
+        uniaHandle = NULL;
+
+
+        LOG_DEBUG("SetupDecoder %s \n", IDecoder->GetVersionInfo());
+        uniaHandle = IDecoder->CreateDecoder(&memOps);
+
+        if(uniaHandle == NULL){
+            ret = OMX_ErrorNotImplemented;
+            break;
+        }
+
+        //todo: query decoder buffer size for 
+
+        SetParameterToDecoder();
+    }while(0);
+
+    if(ret != OMX_ErrorNone)
+        LOG_ERROR("UniaDec::AudioDecoderBaseInstanceInit ret=%d",ret);
+
+    return ret;
+}
+OMX_ERRORTYPE UniaDecoder::CreateDecoderInterface()
+{
+    OMX_S32 ret = OMX_ErrorNone;
+
+    do{
+
+        tUniACodecQueryInterface  myQueryInterface;
+
+        if(NULL == role || decoderLibName == NULL){
+            ret = OMX_ErrorInsufficientResources;
+            break;
+        }
+        if(optionaDecoderlLibName){
+            hLib = libMgr->load((fsl_osal_char *)optionaDecoderlLibName);
+            LOG_DEBUG("Audio Decoder library name 1: %s\n", optionaDecoderlLibName);
+        }
+
+        if(hLib == NULL){
+            hLib = libMgr->load((fsl_osal_char *)decoderLibName);
+            LOG_DEBUG("Audio Decoder library name 2: %s\n", decoderLibName);
+        }
+
+        if(NULL == hLib){
+            LOG_ERROR("Fail to open Decoder library for %s\n", role);
+            ret = OMX_ErrorComponentNotFound;
+            break;
+        }
+
+        IDecoder = (UniaDecInterface *)FSL_MALLOC(sizeof(UniaDecInterface));
+        if(IDecoder == NULL){
+            ret = OMX_ErrorUndefined;
+        }
+        fsl_osal_memset(IDecoder,0 ,sizeof(UniaDecInterface));
+
+        myQueryInterface = (tUniACodecQueryInterface)libMgr->getSymbol(hLib, (fsl_osal_char *)"UniACodecQueryInterface");
+        if(NULL == myQueryInterface)
+        {
+            LOG_ERROR("Fail to query decoder interface\n");
+            ret = OMX_ErrorNotImplemented;
+            break;
+        }
+
+        ret = myQueryInterface(ACODEC_API_GET_VERSION_INFO, (void **)&IDecoder->GetVersionInfo);
+
+        ret |= myQueryInterface(ACODEC_API_CREATE_CODEC, (void **)&IDecoder->CreateDecoder);
+        ret |= myQueryInterface(ACODEC_API_DELETE_CODEC, (void **)&IDecoder->DeleteDecoder);
+        ret |= myQueryInterface(ACODEC_API_RESET_CODEC, (void **)&IDecoder->ResetDecoder);
+        ret |= myQueryInterface(ACODEC_API_SET_PARAMETER, (void **)&IDecoder->SetParameter);
+        ret |= myQueryInterface(ACODEC_API_GET_PARAMETER, (void **)&IDecoder->GetParameter);
+        ret |= myQueryInterface(ACODEC_API_DEC_FRAME, (void **)&IDecoder->DecodeFrame);
+        ret |= myQueryInterface(ACODEC_API_GET_LAST_ERROR, (void **)&IDecoder->GetLastError);
+
+        if(ret != OMX_ErrorNone){
+            LOG_ERROR("Fail to query decoder API\n");
+            ret = OMX_ErrorNotImplemented;
+            break;
+        }
+
+    }while(0);
+
+    if(ret != OMX_ErrorNone){
+        LOG_ERROR("UniaDecoder::CreateDecoderInterface ret=%d",ret);
+        if (hLib)
+            libMgr->unload(hLib);
+        hLib = NULL;
+        FSL_FREE(IDecoder);
+        FSL_DELETE(libMgr);
+    }
+
+    return (OMX_ERRORTYPE)ret;
+}
+OMX_ERRORTYPE UniaDecoder::AudioFilterInstanceDeInit(){
+
+    LOG_DEBUG("UniaDecoder::AudioDecoderBaseInstanceDeInit");
+    FSL_FREE(codecConfig.buf);
+    codecConfig.buf = NULL;
+
+    if(IDecoder != NULL && uniaHandle != NULL){
+        IDecoder->DeleteDecoder(uniaHandle);
+        uniaHandle = NULL;
+    }
+
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE UniaDecoder::AudioFilterCodecInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_S32 value = 0;
+    //set stream type here for aac type after got from frame header
+    if(OMX_ErrorNone == UniaDecoderGetParameter(UNIA_STREAM_TYPE,&value)){
+        LOG_DEBUG("AudioFilterCodecInit UNIA_STREAM_TYPE=%d",value);
+        IDecoder->SetParameter(uniaHandle,UNIA_STREAM_TYPE,(UniACodecParameter*)&value);
+    }
+    return ret;
+}
+OMX_ERRORTYPE UniaDecoder::SetParameterToDecoder()
+{
+    OMX_S32 value;
+
+    for ( OMX_U32 i = UNIA_SAMPLERATE; i < UNIA_STREAM_TYPE; i++){
+        if(i == UNIA_CODEC_DATA)
+            continue;
+
+        value = 0;
+        if(OMX_ErrorNone == UniaDecoderGetParameter((UA_ParaType)i,&value)){
+            IDecoder->SetParameter(uniaHandle,(UA_ParaType)i,(UniACodecParameter*)&value);
+        }
+    }
+
+    //set output format for channel layout
+    fsl_osal_memset(&channelTable,0,sizeof(CHAN_TABLE));
+    if(OMX_ErrorNone == UniaDecoderGetParameter(UNIA_CHAN_MAP_TABLE,(OMX_S32*)&channelTable)){
+        IDecoder->SetParameter(uniaHandle,UNIA_CHAN_MAP_TABLE,(UniACodecParameter*)&channelTable);
+    }
+
+    value = 0;
+    if(OMX_ErrorNone == UniaDecoderGetParameter(UNIA_WMA_BlOCKALIGN,&value)){
+        IDecoder->SetParameter(uniaHandle,UNIA_WMA_BlOCKALIGN,(UniACodecParameter*)&value);
+    }
+
+    value = 0;
+    if(OMX_ErrorNone == UniaDecoderGetParameter(UNIA_WMA_VERSION,&value)){
+        IDecoder->SetParameter(uniaHandle,UNIA_WMA_VERSION,(UniACodecParameter*)&value);
+    }
+
+    LOG_DEBUG("SetParameterToDecoder");
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE UniaDecoder::ResetParameterWhenOutputChange()
+{
+    UniAcodecOutputPCMFormat outputValue;
+    OMX_S32 value = 0;
+
+    if(ACODEC_SUCCESS == IDecoder->GetParameter(uniaHandle,UNIA_OUTPUT_PCM_FORMAT,(UniACodecParameter*)&outputValue)){
+        if(outputValue.samplerate == 0 || outputValue.channels == 0 || outputValue.depth == 0){
+            LOG_ERROR("ResetParameterWhenOutputChange HAS 0");
+            return OMX_ErrorBadParameter;
+        }
+
+        PcmMode.nSamplingRate = outputValue.samplerate;
+        PcmMode.nChannels = outputValue.channels;
+        PcmMode.nBitPerSample = outputValue.depth;
+        PcmMode.bInterleaved = (OMX_BOOL)outputValue.interleave;
+
+        #ifndef OMX_STEREO_OUTPUT
+        if(PcmMode.nChannels > 2){
+            MapOutputLayoutChannel(&outputValue);
+        }
+        #endif
+
+        LOG_DEBUG("OUTPUT CHANGED channel=%d,layout=%d,%d,%d,%d,%d,%d,%d,%d",PcmMode.nChannels,
+            PcmMode.eChannelMapping[0],PcmMode.eChannelMapping[1],PcmMode.eChannelMapping[2],
+            PcmMode.eChannelMapping[3],PcmMode.eChannelMapping[4],PcmMode.eChannelMapping[5],
+            PcmMode.eChannelMapping[6],PcmMode.eChannelMapping[7]);
+    }
+
+    value = 0;
+    if(ACODEC_SUCCESS == IDecoder->GetParameter(uniaHandle,UNIA_SAMPLERATE,(UniACodecParameter*)&value)){
+        UniaDecoderSetParameter(UNIA_SAMPLERATE,value);
+    }
+
+    value = 0;
+    if(ACODEC_SUCCESS == IDecoder->GetParameter(uniaHandle,UNIA_CHANNEL,(UniACodecParameter*)&value)){
+        UniaDecoderSetParameter(UNIA_CHANNEL,value);
+    }
+
+    value = 0;
+    if(ACODEC_SUCCESS == IDecoder->GetParameter(uniaHandle,UNIA_BITRATE,(UniACodecParameter*)&value)){
+        UniaDecoderSetParameter(UNIA_BITRATE,value);
+    }
+
+    value = 0;
+    if(ACODEC_SUCCESS == IDecoder->GetParameter(uniaHandle,UNIA_DEPTH,(UniACodecParameter*)&value)){
+        UniaDecoderSetParameter(UNIA_DEPTH,value);
+    }
+    LOG_DEBUG("ResetParameterWhenOutputChange nSamplingRate=%d,nChannels=%d",PcmMode.nSamplingRate,PcmMode.nChannels);
+
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE UniaDecoder::MapOutputLayoutChannel(UniAcodecOutputPCMFormat * outputValue)
+{
+    OMX_U32 nChannels = outputValue->channels;
+    OMX_U32 i = 0;
+
+    if(nChannels == 0 || nChannels > OMX_AUDIO_MAXCHANNELS){
+        return OMX_ErrorBadParameter;
+    }
+
+    fsl_osal_memset(&PcmMode.eChannelMapping[0],0 ,OMX_AUDIO_MAXCHANNELS*sizeof(OMX_AUDIO_CHANNELTYPE));
+
+    for( i = 0; i < nChannels; i++){
+        
+        switch(outputValue->layout[i]){
+            case UA_CHANNEL_FRONT_LEFT:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelLF;
+                break;
+            case UA_CHANNEL_FRONT_RIGHT:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelRF;
+                break;
+            case UA_CHANNEL_REAR_CENTER:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelCS;
+                break;
+            case UA_CHANNEL_REAR_LEFT:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelLR;
+                break;
+            case UA_CHANNEL_REAR_RIGHT:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelRR;
+                break;
+            case UA_CHANNEL_LFE:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelLFE;
+                break;
+            case UA_CHANNEL_FRONT_CENTER:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelCF;
+                break;
+            case UA_CHANNEL_FRONT_LEFT_CENTER:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelLF;
+                break;
+            case UA_CHANNEL_FRONT_RIGHT_CENTER:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelRF;
+                break;
+            case UA_CHANNEL_SIDE_LEFT:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelLS;
+                break;
+            case UA_CHANNEL_SIDE_RIGHT:
+                PcmMode.eChannelMapping[i] = OMX_AUDIO_ChannelRS;
+                break;
+            default:
+                break;
+            }
+
+    }
+
+    return OMX_ErrorNone;
+}
+AUDIO_FILTERRETURNTYPE UniaDecoder::AudioFilterFrame()
+{
+    AUDIO_FILTERRETURNTYPE ret = AUDIO_FILTER_SUCCESS;
+    OMX_S32 decoderRet = ACODEC_SUCCESS;
+    OMX_U32 nActuralLen = 0;
+    //OMX_U32 InputOffsetBegin = 0;
+    OMX_U32 consumeLen = 0;
+    OMX_U32 InputLen = 0;;
+    OMX_U32 InputOffset = 0;
+    OMX_U8* pBuffer = NULL;
+
+    AudioRingBuffer.BufferGet(&pBuffer, nPushModeInputLen, &InputLen);
+
+    if(frameInput && InputLen != 0){
+        OMX_U32 nFrameLen;
+        nFrameLen = TS_Manager.GetFrameLen();
+        if (nFrameLen == 0)
+            nFrameLen = nActuralLen;
+
+        AudioRingBuffer.BufferGet(&pBuffer, nFrameLen, &InputLen);
+    }
+
+    //InputOffsetBegin = InputOffset;
+    if(pBuffer && InputLen > 0){
+        decoderRet = IDecoder->DecodeFrame(uniaHandle,pBuffer,InputLen,
+            &InputOffset,&pOutBufferHdr->pBuffer,&nActuralLen);
+        if(!frameInput){
+            AudioRingBuffer.BufferConsumered(InputOffset);
+        }
+        inputFrameCount += InputOffset;
+    }else{
+        decoderRet = IDecoder->DecodeFrame(uniaHandle,NULL,0,&InputOffset,&pOutBufferHdr->pBuffer,&nActuralLen);
+    }
+    LOG_LOG("decoderRet=%d,InputLen=%d,InputOffset=%d,nActuralLen=%d",decoderRet,InputLen,InputOffset,nActuralLen);
+    if(decoderRet == ACODEC_SUCCESS || decoderRet == ACODEC_CAPIBILITY_CHANGE){
+
+        if(decoderRet & ACODEC_CAPIBILITY_CHANGE && OMX_ErrorNone == ResetParameterWhenOutputChange()){
+            if(nActuralLen != 0){
+                TS_PerFrame = (OMX_S64)nActuralLen*8*OMX_TICKS_PER_SECOND/PcmMode.nChannels \
+                    /PcmMode.nSamplingRate/PcmMode.nBitPerSample;
+            }
+            LOG_DEBUG("send output port changed event");
+            SendEvent(OMX_EventPortSettingsChanged, AUDIO_FILTER_OUTPUT_PORT, 0, NULL);
+        }
+        pOutBufferHdr->nOffset = 0;
+        pOutBufferHdr->nFilledLen = nActuralLen;
+
+        TS_PerFrame = (OMX_S64)pOutBufferHdr->nFilledLen*8*OMX_TICKS_PER_SECOND/PcmMode.nChannels \
+                /PcmMode.nSamplingRate/PcmMode.nBitPerSample;
+
+        IDecoder->GetParameter(uniaHandle,UNIA_CONSUMED_LENGTH,(UniACodecParameter*)&consumeLen);
+
+        TS_Manager.Consumered(consumeLen);
+        LOG_LOG("AudioTime.TS_Increase TS_PerFrame=%lld,consumeLen=%d",TS_PerFrame,consumeLen);
+        TS_Manager.TS_SetIncrease(TS_PerFrame);
+        consumeFrameCount += consumeLen;
+        if(frameInput){
+            //more than one frames could be in a frame buffer, so consume one frame's length.
+            AudioRingBuffer.BufferConsumered(consumeLen);
+        }
+
+        if(nActuralLen == 0){
+            ret = AUDIO_FILTER_NEEDMORE;
+        }
+
+        LOG_LOG("Decoder outputLength=%d,pOutBufferHdr->nTimeStamp=%lld",\
+            pOutBufferHdr->nFilledLen,pOutBufferHdr->nTimeStamp);
+        LOG_LOG("OUTPUT = %x%x%x%x",pOutBufferHdr->pBuffer[0],pOutBufferHdr->pBuffer[1],pOutBufferHdr->pBuffer[2],pOutBufferHdr->pBuffer[3]);
+
+        #if 0
+        FILE * pfile;
+        pfile = fopen("/data/data/pcm","ab");
+        if(pfile){
+            fwrite(pOutBufferHdr->pBuffer,1,pOutBufferHdr->nFilledLen,pfile);
+            fclose(pfile);
+        }
+        #endif
+        if(nActuralLen != 0){
+            profileErrorCount = 0;
+        }
+    }else if(decoderRet == ACODEC_END_OF_STREAM){
+        pOutBufferHdr->nOffset = 0;
+        pOutBufferHdr->nFilledLen = 0;
+        LOG_DEBUG("ACODEC_END_OF_STREAM");
+        ret = AUDIO_FILTER_EOS;
+    }else if(decoderRet == ACODEC_NOT_ENOUGH_DATA){
+        ret = AUDIO_FILTER_NEEDMORE;
+    }else if((decoderRet == ACODEC_ERROR_STREAM || decoderRet == ACODEC_ERR_UNKNOWN) && pBuffer){
+        IDecoder->GetParameter(uniaHandle,UNIA_CONSUMED_LENGTH,(UniACodecParameter*)&consumeLen);
+        IDecoder->ResetDecoder(uniaHandle);
+        if(frameInput){
+            AudioRingBuffer.BufferConsumered(InputOffset);
+        }
+        TS_Manager.Consumered(InputOffset);
+        consumeFrameCount += InputOffset;
+        LOG_DEBUG("ERROR CONSUME LEN=%d,getlen=%d",consumeLen,InputOffset);
+        ret = AUDIO_FILTER_FAILURE;
+        errorCount ++;
+        LOG_DEBUG("ACODEC_ERROR_STREAM no more data");
+    }else if((decoderRet == ACODEC_ERROR_STREAM || decoderRet == ACODEC_ERR_UNKNOWN) && !pBuffer){
+        pOutBufferHdr->nOffset = 0;
+        pOutBufferHdr->nFilledLen = 0;
+        LOG_DEBUG("SET TO EOS");
+        ret = AUDIO_FILTER_EOS;
+    }else if(decoderRet == ACODEC_PROFILE_NOT_SUPPORT){
+        pOutBufferHdr->nOffset = 0;
+        pOutBufferHdr->nFilledLen = 0;
+        LOG_DEBUG("ACODEC_PROFILE_NOT_SUPPORT");
+        ret = AUDIO_FILTER_EOS;
+        profileErrorCount++;
+    }else if(decoderRet == ACODEC_INIT_ERR){
+        pOutBufferHdr->nOffset = 0;
+        pOutBufferHdr->nFilledLen = 0;
+        LOG_DEBUG("ACODEC RESULT ACODEC_INIT_ERR!");
+        ret = AUDIO_FILTER_FATAL_ERROR;
+    }else{
+        pOutBufferHdr->nOffset = 0;
+        pOutBufferHdr->nFilledLen = 0;
+        LOG_LOG("error decoderRet=%d",decoderRet);
+        ret = AUDIO_FILTER_FAILURE;
+        errorCount ++;
+    }
+
+    //for test usage
+    if(errorCount > 500){
+        LOG_DEBUG("Unia Decoder error count > 500 ***!!!");
+        errorCount = 0;
+    }
+
+    //check if count of profile error reaches the limited.
+    if(profileErrorCount > MAX_PROFILE_ERROR_COUNT){
+        ret = AUDIO_FILTER_FATAL_ERROR;
+        profileErrorCount = 0;
+        LOG_DEBUG("return AUDIO_FILTER_FATAL_ERROR instead of ACODEC_PROFILE_NOT_SUPPORT");
+    }
+    return ret;
+}
+OMX_ERRORTYPE UniaDecoder::AudioFilterReset()
+{
+    OMX_S32 ret = ACODEC_SUCCESS;
+
+    if(IDecoder == NULL || uniaHandle == NULL)
+        return OMX_ErrorUndefined;
+    
+    ret = IDecoder->ResetDecoder(uniaHandle);
+    LOG_LOG("UniaDec::AudioDecoderBaseReset ret=%d",ret);
+
+    return OMX_ErrorNone;
+}
+OMX_ERRORTYPE UniaDecoder::AudioFilterCheckCodecConfig()
+{
+    OMX_S32 ret = OMX_ErrorNone;
+    if(IDecoder == NULL || uniaHandle == NULL)
+        return OMX_ErrorUndefined;
+
+    if (codecConfig.buf != NULL) {
+        codecConfig.buf = (char *)FSL_REALLOC(codecConfig.buf, \
+            codecConfig.size + pInBufferHdr->nFilledLen);
+        if (codecConfig.buf == NULL)
+        {
+            LOG_ERROR("Can't get memory.\n");
+            return OMX_ErrorInsufficientResources;
+        }
+        fsl_osal_memcpy(codecConfig.buf + codecConfig.size, pInBufferHdr->pBuffer, pInBufferHdr->nFilledLen);
+        codecConfig.size += pInBufferHdr->nFilledLen;
+
+    } else {
+         codecConfig.buf = (char *)FSL_MALLOC(pInBufferHdr->nFilledLen);
+        if (codecConfig.buf == NULL)
+        {
+            LOG_ERROR("Can't get memory.\n");
+            return OMX_ErrorInsufficientResources;
+        }
+        fsl_osal_memcpy(codecConfig.buf, pInBufferHdr->pBuffer, pInBufferHdr->nFilledLen);
+        codecConfig.size = pInBufferHdr->nFilledLen;
+    }
+
+    ret = IDecoder->SetParameter(uniaHandle,UNIA_CODEC_DATA,(UniACodecParameter*)&codecConfig);
+
+    LOG_DEBUG("UniaDec::AudioDecoderBaseCheckCodecConfig nFilledLen=%d,ret=%d",pInBufferHdr->nFilledLen,ret);
+    pInBufferHdr->nFilledLen = 0;
+
+    return (OMX_ERRORTYPE)ret;
+}
diff --git a/OpenMAXIL/src/component/common/UniaDecoder.h b/OpenMAXIL/src/component/common/UniaDecoder.h
new file mode 100755
index 0000000..bc574ff
--- /dev/null
+++ b/OpenMAXIL/src/component/common/UniaDecoder.h
@@ -0,0 +1,75 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file UniaDecoder.h
+ *  @brief Class definition of UniaDecoder Component
+ *  @ingroup UniaDecoder
+ */
+#ifndef UniaDecoder_h
+#define UniaDecoder_h
+
+#include "AudioFilter.h"
+#include "ShareLibarayMgr.h"
+#include "fsl_unia.h"
+
+typedef struct
+{
+    UniACodecVersionInfo                GetVersionInfo;
+    UniACodecCreate                     CreateDecoder;
+    UniACodecDelete                     DeleteDecoder;
+    UniACodecReset                      ResetDecoder;
+    UniACodecSetParameter               SetParameter;
+    UniACodecGetParameter               GetParameter;
+    UniACodec_decode_frame              DecodeFrame;
+    UniACodec_get_last_error            GetLastError;
+
+}UniaDecInterface;
+
+class UniaDecoder : public AudioFilter {
+    public:
+        UniaDecoder();
+    protected:
+        OMX_S32 codingType;
+        OMX_U32 outputPortBufferSize;
+        const char * decoderLibName;
+        const char * optionaDecoderlLibName;
+        OMX_BOOL frameInput;
+    private:
+        OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE AudioFilterInstanceInit();
+        OMX_ERRORTYPE AudioFilterCodecInit();
+        OMX_ERRORTYPE AudioFilterInstanceDeInit();
+        AUDIO_FILTERRETURNTYPE AudioFilterFrame();
+        OMX_ERRORTYPE AudioFilterReset();
+        OMX_ERRORTYPE AudioFilterCheckCodecConfig();
+        OMX_ERRORTYPE CreateDecoderInterface();
+        OMX_ERRORTYPE InitPort();
+        OMX_ERRORTYPE SetParameterToDecoder();
+        OMX_ERRORTYPE ResetParameterWhenOutputChange();
+        OMX_ERRORTYPE MapOutputLayoutChannel(UniAcodecOutputPCMFormat * outputValue);
+        virtual OMX_ERRORTYPE UniaDecoderSetParameter(UA_ParaType index,OMX_S32 value) = 0;
+        virtual OMX_ERRORTYPE UniaDecoderGetParameter(UA_ParaType index,OMX_S32 * value) = 0;
+        ShareLibarayMgr *libMgr;
+        OMX_PTR hLib;
+        UniaDecInterface * IDecoder;
+
+        UniACodecMemoryOps memOps;
+        UniACodec_Handle uniaHandle;
+
+        OMX_S32 errorCount;//debug
+        OMX_S32 profileErrorCount;
+
+        UniACodecParameterBuffer codecConfig;
+        CHAN_TABLE channelTable;
+        OMX_U32 inputFrameCount;
+        OMX_U32 consumeFrameCount;
+};
+#endif
diff --git a/OpenMAXIL/src/component/common/VideoFilter.cpp b/OpenMAXIL/src/component/common/VideoFilter.cpp
new file mode 100755
index 0000000..e377d22
--- /dev/null
+++ b/OpenMAXIL/src/component/common/VideoFilter.cpp
@@ -0,0 +1,989 @@
+/**
+ *  Copyright (c) 2010-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "VideoFilter.h"
+#include "Tsm_wrapper.h"
+
+#define MOSAIC_COUNT 3
+
+VideoFilter::VideoFilter()
+{
+    bInContext = OMX_FALSE;
+    nPorts = NUM_PORTS;
+}
+
+OMX_ERRORTYPE VideoFilter:: SetDefaultSetting()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+	OMX_VIDEO_PARAM_PORTFORMATTYPE sPortFormat;
+    //OMX_BUFFERSUPPLIERTYPE SupplierType;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = IN_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainVideo;
+    fsl_osal_memcpy(&sPortDef.format.video, &sInFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = nInBufferCnt;
+    sPortDef.nBufferCountActual = nInBufferCnt;
+    sPortDef.nBufferSize = nInBufferSize;
+    ret = ports[IN_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for in port failed.\n");
+        return ret;
+    }
+
+	for (OMX_U32 i=0; i<nInPortFormatCnt; i++) {
+    	OMX_INIT_STRUCT(&sPortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE);
+    	sPortFormat.nPortIndex = IN_PORT;
+		sPortFormat.nIndex = i;
+		sPortFormat.eCompressionFormat = sPortDef.format.video.eCompressionFormat;
+		sPortFormat.eColorFormat = eInPortPormat[i];
+		sPortFormat.xFramerate = sPortDef.format.video.xFramerate;
+		LOG_DEBUG("Set support color format: %d\n", eInPortPormat[i]);
+		ret = ports[IN_PORT]->SetPortFormat(&sPortFormat);
+		if(ret != OMX_ErrorNone) {
+			LOG_ERROR("Set port format for in port failed.\n");
+			return ret;
+		}
+	}
+
+    sPortDef.nPortIndex = OUT_PORT;
+    sPortDef.eDir = OMX_DirOutput;
+    sPortDef.nBufferCountMin = nOutBufferCnt;
+    sPortDef.nBufferCountActual = nOutBufferCnt;
+    fsl_osal_memcpy(&sPortDef.format.video, &sOutFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+    sPortDef.nBufferSize=nOutBufferSize;
+    ret = ports[OUT_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for out port failed.\n");
+        return ret;
+    }
+
+	for (OMX_U32 i=0; i<nOutPortFormatCnt; i++) {
+    	OMX_INIT_STRUCT(&sPortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE);
+    	sPortFormat.nPortIndex = OUT_PORT;
+		sPortFormat.nIndex = i;
+		sPortFormat.eCompressionFormat = sPortDef.format.video.eCompressionFormat;
+		sPortFormat.eColorFormat = eOutPortPormat[i];
+		sPortFormat.xFramerate = sPortDef.format.video.xFramerate;
+		LOG_DEBUG("Set support color format: %d\n", eOutPortPormat[i]);
+		ret = ports[OUT_PORT]->SetPortFormat(&sPortFormat);
+		if(ret != OMX_ErrorNone) {
+			LOG_ERROR("Set port format for in port failed.\n");
+			return ret;
+		}
+	}
+
+    bInit = OMX_FALSE;
+    bGetNewSegment = OMX_TRUE;
+    bNewSegment = OMX_FALSE;
+	nInvalidFrameCnt = 0;
+	bFilterSupportPartilInput = OMX_FALSE;
+    bLastInput = OMX_FALSE;
+    bLastOutput = OMX_FALSE;
+    pCodecData = NULL;
+    nCodecDataLen = 0;
+    bFilterSupportFrmSizeRpt=OMX_FALSE;
+    fsl_osal_memset(&PartialInputHdr, 0, sizeof(OMX_BUFFERHEADERTYPE));
+    bInReturnBufferState = OMX_FALSE;
+    nDecodeOnly = 0;
+    pInBufferHdr = NULL;
+    bNeedOutBuffer = OMX_TRUE;
+    bNeedInputBuffer = OMX_TRUE;
+
+	OMX_INIT_STRUCT(&Rotation, OMX_CONFIG_ROTATIONTYPE);
+
+	Rotation.nPortIndex = OMX_ALL;
+	Rotation.nRotation = 0;
+
+    hTsHandle = NULL;
+
+    bNeedMapDecAndOutput=OMX_FALSE;   //default: needn't map decoded frame and output frame
+    return ret;
+}
+
+OMX_ERRORTYPE VideoFilter::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = InitFilterComponent();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    ret=SetDefaultSetting();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoFilter::DeInitComponent()
+{
+    DeInitFilterComponent();
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::DoAllocateBuffer(OMX_PTR *buffer, OMX_U32 nSize,OMX_U32 nPortIndex)
+{
+    if(nPortIndex == IN_PORT)
+        *buffer = AllocateInputBuffer(nSize);
+    if(nPortIndex == OUT_PORT)
+        *buffer = AllocateOutputBuffer(nSize);
+
+    if (*buffer == NULL)
+        return OMX_ErrorInsufficientResources;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::DoFreeBuffer(OMX_PTR buffer,OMX_U32 nPortIndex)
+{
+    if(nPortIndex == IN_PORT)
+        FreeInputBuffer(buffer);
+    if(nPortIndex == OUT_PORT)
+        FreeOutputBuffer(buffer);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::FlushComponent(OMX_U32 nPortIndex)
+{
+    LOG_DEBUG("Flush filter port: %d\n", (int)nPortIndex);
+
+    if(nPortIndex == IN_PORT) {
+        FlushInputBuffer();
+        tsmFlush(hTsHandle);
+        while(InBufferHdrList.GetNodeCnt()>0) {
+            OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+            pBufferHdr = InBufferHdrList.GetNode(0);
+            InBufferHdrList.Remove(pBufferHdr);
+            ports[IN_PORT]->SendBuffer(pBufferHdr);
+        }
+        ReturnInputBuffer();
+        bLastInput = OMX_FALSE;
+        bLastOutput = OMX_FALSE;
+        nDecodeOnly = 0;
+        bGetNewSegment = OMX_TRUE;
+    }
+
+    if(nPortIndex == OUT_PORT) {
+        FlushOutputBuffer();
+        while(1) {
+            OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+            pBufferHdr = GetFirstOutBufferHdrFromList();
+            if(pBufferHdr == NULL)
+                break;
+            ports[OUT_PORT]->SendBuffer(pBufferHdr);
+        }
+        bNeedOutBuffer = OMX_TRUE;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ComponentReturnBuffer(OMX_U32 nPortIndex)
+{
+    if(nPortIndex == IN_PORT) {
+        FlushInputBuffer();
+        while(InBufferHdrList.GetNodeCnt()>0) {
+            OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+            pBufferHdr = InBufferHdrList.GetNode(0);
+            InBufferHdrList.Remove(pBufferHdr);
+            ports[IN_PORT]->SendBuffer(pBufferHdr);
+        }
+        ReturnInputBuffer();
+    }
+
+    if(nPortIndex == OUT_PORT) {
+        FlushOutputBuffer();
+        while(1) {
+            OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+            pBufferHdr = GetFirstOutBufferHdrFromList();
+            if(pBufferHdr == NULL)
+                break;
+            ports[OUT_PORT]->SendBuffer(pBufferHdr);
+        }
+        bNeedOutBuffer = OMX_TRUE;
+    }
+
+    bInReturnBufferState = OMX_FALSE;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::InputFmtChanged()
+{
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;  
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = IN_PORT;
+    ports[IN_PORT]->GetPortDefinition(&sPortDef);
+
+    if(sInFmt.eCompressionFormat != OMX_VIDEO_CodingUnused) {
+        //decoder
+        fsl_osal_memcpy(&(sPortDef.format.video), &sInFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+        ports[IN_PORT]->SetPortDefinition(&sPortDef);
+    }
+    else{
+        //encoder
+        return CheckPortResource(IN_PORT);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::OutputFmtChanged()
+{
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;  
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = OUT_PORT;
+    ports[OUT_PORT]->GetPortDefinition(&sPortDef);
+
+    if(sOutFmt.eCompressionFormat != OMX_VIDEO_CodingUnused) {
+        //encoder
+        fsl_osal_memcpy(&(sPortDef.format.video), &sOutFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+        ports[OUT_PORT]->SetPortDefinition(&sPortDef);
+    }
+    else{
+        //decoder
+        sPortDef.nPortIndex = IN_PORT;
+        ports[IN_PORT]->GetPortDefinition(&sPortDef);
+        sPortDef.format.video.nFrameWidth = sInFmt.nFrameWidth;
+        sPortDef.format.video.nFrameHeight = sInFmt.nFrameHeight;
+        ports[IN_PORT]->SetPortDefinition(&sPortDef);
+        return CheckPortResource(OUT_PORT);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_TICKS VideoFilter::QueryStreamTs()
+{
+    return (OMX_TICKS)tsmQueryCurrTs(hTsHandle);
+}
+
+OMX_ERRORTYPE VideoFilter::CheckPortResource(OMX_U32 nPortIndex)
+{
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;  
+    OMX_VIDEO_PORTDEFINITIONTYPE *pFmt;
+    OMX_U32 nBufferCnt = 0;
+    OMX_BOOL bResourceChanged = OMX_FALSE;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = nPortIndex;
+    ports[nPortIndex]->GetPortDefinition(&sPortDef);
+
+    if(nPortIndex == IN_PORT) {
+        pFmt = &sInFmt;
+        nBufferCnt = nInBufferCnt;
+    }
+    else {
+        pFmt = &sOutFmt;
+        nBufferCnt = nOutBufferCnt;
+    }
+
+    if(pFmt->nFrameWidth != sPortDef.format.video.nFrameWidth
+            || pFmt->nFrameHeight != sPortDef.format.video.nFrameHeight
+            || nBufferCnt != sPortDef.nBufferCountActual) {
+        LOG_INFO("Filter port #%d resource changed, need reconfigure.\n", nPortIndex);
+        LOG_INFO("from %dx%dx%d to %dx%dx%d.\n", 
+                sPortDef.format.video.nFrameWidth,
+                sPortDef.format.video.nFrameHeight,
+                sPortDef.nBufferCountActual,
+                pFmt->nFrameWidth, pFmt->nFrameHeight, nBufferCnt);
+
+        bResourceChanged = OMX_TRUE;
+        sPortDef.nBufferSize = pFmt->nFrameWidth * pFmt->nFrameHeight * pxlfmt2bpp(pFmt->eColorFormat) / 8;
+        sPortDef.nBufferCountActual = nBufferCnt;
+        LOG_DEBUG("Need buffer size: %d\n", sPortDef.nBufferSize);
+    }
+
+    fsl_osal_memcpy(&(sPortDef.format.video), pFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+    ports[nPortIndex]->SetPortDefinition(&sPortDef);
+
+    if(bResourceChanged) {
+        tsmClearCachedFrameTs(hTsHandle);
+        SendEvent(OMX_EventPortSettingsChanged, nPortIndex, 0, NULL);
+        LOG_DEBUG("Send Port setting changed event.\n");
+        bInReturnBufferState = OMX_TRUE;
+        return OMX_ErrorNotReady;
+    }
+
+    return OMX_ErrorNoMore;
+}
+
+OMX_ERRORTYPE VideoFilter::GetInputDataDepthThreshold(OMX_S32* pDurationThr, OMX_S32* pBufCntThr)
+{
+    /*
+      for some application, such rtsp/http, we need to set some thresholds to avoid input data is consumed by decoder too fast.
+      -1: no threshold
+    */
+    *pDurationThr=-1;
+    *pBufCntThr=-1;
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::GetReturnedInputDataPtr(OMX_PTR* ppInput)
+{
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::InitFilterComponent()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::DeInitFilterComponent()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::PortFormatChanged(OMX_U32 nPortIndex)
+{
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;  
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+
+    if(nPortIndex == IN_PORT) {
+        sPortDef.nPortIndex = IN_PORT;
+        ports[IN_PORT]->GetPortDefinition(&sPortDef);
+        //fsl_osal_memcpy(&sInFmt, &(sPortDef.format.video), sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+        sInFmt.nFrameWidth = sPortDef.format.video.nFrameWidth;
+        sInFmt.nFrameHeight = sPortDef.format.video.nFrameHeight;
+        sInFmt.eCompressionFormat = sPortDef.format.video.eCompressionFormat;
+        sInFmt.eColorFormat = sPortDef.format.video.eColorFormat;	
+        sInFmt.xFramerate = sPortDef.format.video.xFramerate;
+
+		OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+		sPortDef.nPortIndex = OUT_PORT;
+		ports[OUT_PORT]->GetPortDefinition(&sPortDef);
+		if (Rotation.nRotation == 90 || Rotation.nRotation == 270) {
+			sPortDef.format.video.nFrameWidth = sInFmt.nFrameHeight;
+			sPortDef.format.video.nFrameHeight = sInFmt.nFrameWidth;
+
+		} else {
+			sPortDef.format.video.nFrameWidth = sInFmt.nFrameWidth;
+			sPortDef.format.video.nFrameHeight = sInFmt.nFrameHeight;
+
+		}
+		sPortDef.format.video.xFramerate = sInFmt.xFramerate;
+                if(sInFmt.eCompressionFormat != OMX_VIDEO_CodingUnused)
+                    sPortDef.nBufferSize = sPortDef.format.video.nFrameWidth * sPortDef.format.video.nFrameHeight
+                                            * pxlfmt2bpp(sPortDef.format.video.eColorFormat) / 8;
+		ports[OUT_PORT]->SetPortDefinition(&sPortDef);
+
+        if(hTsHandle != NULL)
+            tsmSetFrmRate(hTsHandle, sInFmt.xFramerate, Q16_SHIFT);
+    }
+
+    if(nPortIndex == OUT_PORT) {
+        sPortDef.nPortIndex = OUT_PORT;
+        ports[OUT_PORT]->GetPortDefinition(&sPortDef);
+        //fsl_osal_memcpy(&sOutFmt, &(sPortDef.format.video), sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+        sOutFmt.nFrameWidth = sPortDef.format.video.nFrameWidth;
+        sOutFmt.nFrameHeight = sPortDef.format.video.nFrameHeight;
+        sOutFmt.xFramerate=sPortDef.format.video.xFramerate;
+        sOutFmt.nBitrate=sPortDef.format.video.nBitrate;
+        sOutFmt.eCompressionFormat = sPortDef.format.video.eCompressionFormat;
+        sOutFmt.eColorFormat = sPortDef.format.video.eColorFormat;		
+        nOutBufferCnt = sPortDef.nBufferCountActual;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 flags=0;
+
+    if(bInReturnBufferState == OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+    ret = ProcessInputBuffer();
+    if(ret == OMX_ErrorNotReady)
+        return OMX_ErrorNone;
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    ret = ProcessOutputBuffer();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    FilterBufRetCode DecRet = FILTER_OK;
+    DecRet = FilterOneBuffer();
+    if(DecRet & FILTER_INPUT_CONSUMED) {
+        DecRet = (FilterBufRetCode)(DecRet & ~FILTER_INPUT_CONSUMED);
+        ReturnInputBuffer();
+    }
+    if(DecRet & FILTER_INPUT_CONSUMED_EXT_READ) {
+        DecRet = (FilterBufRetCode)(DecRet & ~FILTER_INPUT_CONSUMED_EXT_READ);        
+        if(pInBufferHdr){
+            InBufferHdrList.Add(pInBufferHdr);
+            pInBufferHdr = NULL;
+        }
+        else{
+            //for eos buffer with size=0, pInBufferHdr may be retured aleady before (in ProcessInputBuffer()) 
+        }
+    }
+    if(DecRet & FILTER_INPUT_CONSUMED_EXT_RETURN) {
+        OMX_PTR ptr;
+        DecRet = (FilterBufRetCode)(DecRet & ~FILTER_INPUT_CONSUMED_EXT_RETURN);
+        GetReturnedInputDataPtr(&ptr);
+        //since the list is FIFO, we needn't map ptr and pHdr
+        if(InBufferHdrList.GetNodeCnt()>0){
+            OMX_BUFFERHEADERTYPE* pHdr;
+            pHdr=InBufferHdrList.GetNode(0);
+            if(pHdr==NULL){
+                LOG_ERROR("warning: get one null hdr from InBufferHdrList !\n");
+            }
+            if(pHdr->pBuffer!=ptr){
+                LOG_ERROR("warning: the address doesn't match between ptr and pHdr->pBuffer !\n");
+            }
+            InBufferHdrList.Remove(pHdr);
+            ports[IN_PORT]->SendBuffer(pHdr);
+        }
+        else{
+            //this path is only for eos
+            if((DecRet&FILTER_LAST_OUTPUT)==0){
+                LOG_ERROR("warning: the numbers between insert and get doesn't matched !\n");
+            }
+        }
+    }
+
+    if(DecRet & FILTER_ONE_FRM_DECODED){
+        OMX_S32 nStuffSize;
+        OMX_S32 nFrmSize;
+        OMX_PTR pFrm;
+        ret=GetDecBuffer(&pFrm, &nStuffSize, &nFrmSize);
+        if(ret == OMX_ErrorNone){
+            LOG_DEBUG("%s: get one decoded frm: 0x%X(%d,%d) \n",__FUNCTION__,(int)pFrm,(int)nStuffSize,(int)nFrmSize);	
+            tsmSetFrmBoundary(hTsHandle, nStuffSize, nFrmSize, pFrm);
+        }
+        else{
+            LOG_ERROR("%s: get decoded buffer failure !\n",__FUNCTION__);
+        }
+        DecRet = (FilterBufRetCode)(DecRet & ~FILTER_ONE_FRM_DECODED);
+    }
+
+    switch(DecRet & FILTER_FLAGS_MASK) {
+        case FILTER_FLAG_CODEC_DATA:
+            flags=OMX_BUFFERFLAG_CODECCONFIG;
+            break;
+        case FILTER_FLAG_NONKEY_FRAME:
+            flags=OMX_BUFFERFLAG_ENDOFFRAME;
+            break;
+        case FILTER_FLAG_KEY_FRAME:
+            flags=OMX_BUFFERFLAG_SYNCFRAME|OMX_BUFFERFLAG_ENDOFFRAME;
+            break;
+        default:
+            flags=0;
+            break;
+    }
+    DecRet = (FilterBufRetCode)(DecRet & ~FILTER_FLAGS_MASK);
+
+    if(DecRet > 0) {
+        LOG_DEBUG("DecRet: %d\n", DecRet);
+    }
+
+    switch(DecRet) {
+        case FILTER_OK:
+            break;
+        case FILTER_NO_INPUT_BUFFER:
+            if(pInBufferHdr != NULL)
+                SetInputBuffer(pInBufferHdr->pBuffer + pInBufferHdr->nOffset, pInBufferHdr->nFilledLen, bLastInput);
+            else
+                bNeedInputBuffer = OMX_TRUE;
+            break;
+        case FILTER_NO_OUTPUT_BUFFER:
+            bNeedOutBuffer = OMX_TRUE;
+            break;
+        case FILTER_DO_INIT:
+            ret = InitFilter();
+            if(ret == OMX_ErrorNone)
+                bInit = OMX_TRUE;
+            break;
+        case FILTER_LAST_OUTPUT:
+            HandleLastOutput(flags);
+            ret = OMX_ErrorNoMore;
+            break;
+        case FILTER_HAS_OUTPUT:
+            {
+                OMX_PTR pBuffer = NULL;
+                OMX_S32 nOutSize=0;
+                OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+                GetOutputBuffer(&pBuffer,&nOutSize);
+				if (nOutSize == 0) {
+					nInvalidFrameCnt ++;
+					if (nInvalidFrameCnt <= MOSAIC_COUNT) {
+						SetOutputBuffer(pBuffer);	//still need to return it to vpu to avoid the frame is isolated in the pipeline
+						tsmGetFrmTs(hTsHandle, NULL);
+						break;
+					}
+				} else {
+					nInvalidFrameCnt = 0;
+				}
+                pBufferHdr = GetOutBufferHdrFromList(pBuffer);
+                if(pBufferHdr != NULL) {
+                    pBufferHdr->nFlags = flags;
+                    pBufferHdr->nFilledLen = nOutSize;//pBufferHdr->nAllocLen;
+                    ReturnOutputBuffer(pBufferHdr,flags);
+                }
+                else{
+                    SetOutputBuffer(pBuffer);	//still need to return it to vpu to avoid the frame is isolated in the pipeline
+                    LOG_ERROR("Can't find related bufferhdr with frame: %p\n", pBuffer);
+                }
+            }
+            break;
+        case FILTER_SKIP_OUTPUT:
+            tsmGetFrmTs(hTsHandle, NULL);
+            break;
+        case FILTER_ERROR:
+            SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+            ret=OMX_ErrorStreamCorrupt;
+            break;
+        default: 
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoFilter::ProcessInputBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    LOG_DEBUG("Filter In port has #%d buffers.\n", ports[IN_PORT]->BufferNum());
+
+    if(pInBufferHdr == NULL) {
+        if(ports[IN_PORT]->BufferNum() > 0) {
+            if(OMX_TRUE != tsmHasEnoughSlot(hTsHandle)) {
+                LOG_DEBUG("No more space to handle input ts.\n");
+                if(bInit == OMX_FALSE){
+                    LOG_ERROR("init operation timeout, clip is corrupted ! \n");
+                    SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+                    return OMX_ErrorStreamCorrupt; 
+                }
+                return OMX_ErrorNone;
+            }
+
+            ports[IN_PORT]->GetBuffer(&pInBufferHdr);
+            if(pInBufferHdr == NULL)
+                return OMX_ErrorUnderflow;
+
+            LOG_DEBUG("Get Inbuffer %p:%d:%lld:%x\n", pInBufferHdr->pBuffer, pInBufferHdr->nFilledLen, pInBufferHdr->nTimeStamp, pInBufferHdr->nFlags);
+
+            ret = ProcessInBufferFlags();
+            if(ret != OMX_ErrorNone)
+                return ret;
+
+            ret = SetInputBuffer(pInBufferHdr->pBuffer + pInBufferHdr->nOffset, pInBufferHdr->nFilledLen, bLastInput);
+            if(ret != OMX_ErrorNone) {
+                ReturnInputBuffer();
+                return ret;
+            }
+
+            if(pInBufferHdr->nFilledLen == 0) {
+                ReturnInputBuffer();
+                return OMX_ErrorNone;
+            }
+
+            bNeedInputBuffer = OMX_FALSE;
+
+            tsmSetBlkTs(hTsHandle, pInBufferHdr->nFilledLen, pInBufferHdr->nTimeStamp);
+        }
+        else {
+            if(bNeedInputBuffer == OMX_TRUE)
+                return OMX_ErrorNoMore;
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ProcessOutputBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(bLastOutput == OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+    LOG_DEBUG("Filter Out port has #%d buffers.\n", ports[OUT_PORT]->BufferNum());
+
+    if(bNeedOutBuffer != OMX_FALSE) {
+        if(ports[OUT_PORT]->BufferNum() > 0) {
+            OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+            ports[OUT_PORT]->GetBuffer(&pBufferHdr);
+            if(pBufferHdr == NULL)
+                return OMX_ErrorUnderflow;
+/*  
+            if(bNewSegment == OMX_TRUE && bLastInput == OMX_TRUE) {
+                bLastOutput = OMX_TRUE;
+                pBufferHdr->nFlags = OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_STARTTIME;
+                pBufferHdr->nTimeStamp = tsmGetFrmTs(hTsHandle, NULL);
+                ports[OUT_PORT]->SendBuffer(pBufferHdr);
+                return OMX_ErrorNoMore;
+            }
+*/
+            ret = SetOutputBuffer(pBufferHdr->pBuffer);
+            if(ret != OMX_ErrorNone) {
+                pBufferHdr->nFilledLen = 0;
+                ports[OUT_PORT]->SendBuffer(pBufferHdr);
+                bNeedOutBuffer = OMX_FALSE;
+                return OMX_ErrorNone;
+            }
+
+            LOG_DEBUG("Get Outbuffer: %p\n", pBufferHdr->pBuffer);
+
+          
+
+            OutBufferHdrList.Add(pBufferHdr);
+            bNeedOutBuffer = OMX_FALSE;
+        }
+        else {
+            OMX_S32 nCnt = OutBufferHdrList.GetNodeCnt();
+            LOG_DEBUG("No more OutBuffer, #%d buffers holded by filter.\n", nCnt);
+            return OMX_ErrorNoMore;
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::DoLoaded2Idle()
+{
+    hTsHandle = tsmCreate();
+    if(hTsHandle == NULL) {
+        LOG_ERROR("Create Ts manager failed.\n");
+        return OMX_ErrorUndefined;
+    }
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::DoIdle2Loaded()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    if(bInit == OMX_TRUE)
+        DeInitFilter();
+
+    if(pCodecData != NULL)
+        FSL_FREE(pCodecData);
+
+    tsmDestroy(hTsHandle);
+
+    ret=SetDefaultSetting(); //restore default to support following switch from loaded to idle
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ProcessInBufferFlags()
+{
+    if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME) 
+        bGetNewSegment = OMX_TRUE;
+
+    if(bGetNewSegment == OMX_TRUE && (!(pInBufferHdr->nFlags & OMX_BUFFERFLAG_CODECCONFIG))) {
+        OMX_S32 nDurationThr,nBufCntThr;
+        LOG_DEBUG("Get New sement buffer, ts %lld\n", pInBufferHdr->nTimeStamp);
+        bGetNewSegment = OMX_FALSE;
+        bNewSegment = OMX_TRUE;
+		bLastInput = OMX_FALSE;
+        bLastOutput = OMX_FALSE;
+		nInvalidFrameCnt = 0;
+        if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTRICK) {
+            LOG_DEBUG("Set ts manager to FIFO mode.\n");
+            tsmReSync(hTsHandle, pInBufferHdr->nTimeStamp, MODE_FIFO);
+        }
+        else {
+            LOG_DEBUG("Set ts manager to AI mode.\n");
+            tsmReSync(hTsHandle, pInBufferHdr->nTimeStamp, MODE_AI);
+        }
+        GetInputDataDepthThreshold(&nDurationThr, &nBufCntThr);
+        LOG_INFO("nDurationThr: %d, nBufCntThr: %d\n", nDurationThr, nBufCntThr);
+        tsmSetDataDepthThreshold(hTsHandle, nDurationThr, nBufCntThr);
+    }
+
+    if(bLastInput != OMX_FALSE) {
+        LOG_DEBUG("Filter drop input buffers in EOS state.\n");
+        ReturnInputBuffer();
+        return OMX_ErrorNoMore;
+    }
+
+    if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_EOS) {
+        bLastInput = OMX_TRUE;
+        bNeedInputBuffer = OMX_FALSE;
+        return OMX_ErrorNone;
+    }
+
+    if(!(pInBufferHdr->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) && bFilterSupportPartilInput != OMX_TRUE) {
+        ProcessPartialInput();
+        return OMX_ErrorNotReady;
+    }
+
+    if(PartialInputHdr.pBuffer != NULL) {
+        ProcessPartialInput();
+        pInBufferHdr = &PartialInputHdr;
+    }
+
+    if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_DECODEONLY)
+        nDecodeOnly ++;
+
+    if(pInBufferHdr->nFlags & OMX_BUFFERFLAG_CODECCONFIG && pInBufferHdr->nFilledLen > 0) {
+        if(pCodecData == NULL) {
+            pCodecData = FSL_MALLOC(pInBufferHdr->nFilledLen);
+            if(pCodecData == NULL) {
+                SendEvent(OMX_EventError, OMX_ErrorInsufficientResources, 0, NULL);
+                return OMX_ErrorInsufficientResources;
+            }
+        }
+        else {
+            pCodecData = FSL_REALLOC(pCodecData, nCodecDataLen + pInBufferHdr->nFilledLen);
+            if(pCodecData == NULL) {
+                SendEvent(OMX_EventError, OMX_ErrorInsufficientResources, 0, NULL);
+                return OMX_ErrorInsufficientResources;
+            }
+        }
+        fsl_osal_memcpy((char *)pCodecData + nCodecDataLen, pInBufferHdr->pBuffer, pInBufferHdr->nFilledLen);
+        nCodecDataLen += pInBufferHdr->nFilledLen;
+        LOG_INFO("Get Codec configure data, len: %d\n", nCodecDataLen);
+        ReturnInputBuffer();
+        return OMX_ErrorNotReady;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ProcessPartialInput()
+{
+    if(PartialInputHdr.pBuffer == NULL) {
+        PartialInputHdr.pBuffer = (OMX_U8*)AllocateInputBuffer(2*pInBufferHdr->nAllocLen);
+        if(PartialInputHdr.pBuffer == NULL) {
+            LOG_WARNING("Allocate buffer for partial input failed, size: %d.\n", 2*pInBufferHdr->nAllocLen);
+            return OMX_ErrorInsufficientResources;
+        }
+        PartialInputHdr.nAllocLen = 2*pInBufferHdr->nAllocLen;
+        PartialInputHdr.nFlags = pInBufferHdr->nFlags;
+        PartialInputHdr.nTimeStamp = pInBufferHdr->nTimeStamp;
+    }
+    else {
+        if(PartialInputHdr.nAllocLen - PartialInputHdr.nFilledLen < pInBufferHdr->nFilledLen) {
+            OMX_PTR pBuffer = NULL;
+            pBuffer = AllocateInputBuffer(2*PartialInputHdr.nAllocLen);
+            if(pBuffer == NULL) {
+                LOG_WARNING("Allocate buffer for partial input failed, size: %d.\n", PartialInputHdr.nAllocLen);
+                return OMX_ErrorInsufficientResources;
+            }
+            fsl_osal_memcpy(pBuffer, PartialInputHdr.pBuffer, PartialInputHdr.nFilledLen);
+            FreeInputBuffer(PartialInputHdr.pBuffer);
+            PartialInputHdr.pBuffer = (OMX_U8 *)pBuffer;
+            PartialInputHdr.nAllocLen *= 2;
+        }
+    }
+
+    fsl_osal_memcpy(PartialInputHdr.pBuffer + PartialInputHdr.nFilledLen, pInBufferHdr->pBuffer, pInBufferHdr->nFilledLen);
+    PartialInputHdr.nFilledLen += pInBufferHdr->nFilledLen;
+    ports[IN_PORT]->SendBuffer(pInBufferHdr);
+    pInBufferHdr = NULL;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ReturnInputBuffer()
+{
+    if(PartialInputHdr.pBuffer != NULL) {
+        FreeInputBuffer(PartialInputHdr.pBuffer);
+        fsl_osal_memset(&PartialInputHdr, 0, sizeof(OMX_BUFFERHEADERTYPE));
+        pInBufferHdr = NULL;
+    }
+    else if(pInBufferHdr != NULL) {
+        ports[IN_PORT]->SendBuffer(pInBufferHdr);
+        pInBufferHdr = NULL;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::ReturnOutputBuffer(OMX_BUFFERHEADERTYPE *pBufferHdr,OMX_U32 flags)
+{
+    OMX_PTR pMappedOut=NULL;
+    if(nDecodeOnly > 0) {
+        LOG_INFO("VideoFilter drop frame as decode only: %d\n", nDecodeOnly);
+        nDecodeOnly --;
+        pBufferHdr->nFilledLen = 0;
+        if(bNeedMapDecAndOutput){
+            GetPostMappedDecBuffer((OMX_PTR)pBufferHdr->pBuffer,(OMX_PTR*)(&pMappedOut));
+            tsmGetFrmTs(hTsHandle, pMappedOut);
+        }
+        else{
+            tsmGetFrmTs(hTsHandle, pBufferHdr->pBuffer);
+        }
+        SetOutputBuffer(pBufferHdr->pBuffer);
+        OutBufferHdrList.Add(pBufferHdr);
+        return OMX_ErrorNone;
+    }
+
+    if(bNewSegment == OMX_TRUE) {
+        pBufferHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+        bNewSegment = OMX_FALSE;
+    }
+
+    pBufferHdr->nOffset = 0;
+    if(flags!=OMX_BUFFERFLAG_CODECCONFIG){   //check for encoder
+        if(bNeedMapDecAndOutput){
+            GetPostMappedDecBuffer((OMX_PTR)pBufferHdr->pBuffer,(OMX_PTR*)(&pMappedOut));
+            pBufferHdr->nTimeStamp = tsmGetFrmTs(hTsHandle, pMappedOut);
+        }
+        else{
+            pBufferHdr->nTimeStamp = tsmGetFrmTs(hTsHandle, pBufferHdr->pBuffer);
+        }
+    }
+
+    LOG_DEBUG("VideoDecoder send bufer: %p:%lld:%x\n", pBufferHdr->pBuffer, pBufferHdr->nTimeStamp, pBufferHdr->nFlags);
+
+    if(0){
+        static int iiCnt=0;
+        static FILE *pfTest = NULL;
+        iiCnt ++;
+        if (iiCnt==1) {
+            pfTest = fopen("/sdcard/DumpData.yuv", "wb");
+            if(pfTest == NULL)
+                printf("Unable to open test file! \n");
+        }
+        if(iiCnt > 0 && pfTest != NULL) {        
+            if(pBufferHdr->nFilledLen > 0)  {
+                printf("dump data %d\n", pBufferHdr->nFilledLen);
+                fwrite(pBufferHdr->pBuffer, sizeof(char), pBufferHdr->nFilledLen, pfTest);
+                fflush(pfTest);
+                fclose(pfTest);
+                pfTest = NULL;
+           }
+         }
+    }
+    
+    ports[OUT_PORT]->SendBuffer(pBufferHdr);
+
+    return OMX_ErrorNone;
+}
+
+OMX_BUFFERHEADERTYPE* VideoFilter::GetOutBufferHdrFromList(OMX_PTR pBuffer)
+{
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U32 nBufferHdr = 0;
+
+    if(pBuffer == NULL)
+        return NULL;
+
+    nBufferHdr = OutBufferHdrList.GetNodeCnt();
+
+    OMX_S32 i;
+    OMX_BOOL bFound = OMX_FALSE;
+    for(i=0; i<(int)nBufferHdr; i++) {
+        pBufferHdr = OutBufferHdrList.GetNode(i);
+        if(pBufferHdr == NULL) {
+            LOG_ERROR("VideoFilter outbuffer list has one NULL buffer.\n");
+            continue;
+        }
+        if(pBufferHdr->pBuffer == pBuffer) {
+            bFound = OMX_TRUE;
+            break;
+        }
+    }
+
+    if(bFound != OMX_TRUE)
+        return NULL;
+
+    LOG_DEBUG("Remove buffer %p from list.\n", pBufferHdr->pBuffer);
+    OutBufferHdrList.Remove(pBufferHdr);
+
+    return pBufferHdr;
+}
+
+OMX_BUFFERHEADERTYPE * VideoFilter::GetFirstOutBufferHdrFromList()
+{
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U32 nBufferHdr = 0;
+
+    nBufferHdr = OutBufferHdrList.GetNodeCnt();
+    if(nBufferHdr == 0)
+        return NULL;
+
+    pBufferHdr = OutBufferHdrList.GetNode(0);
+    if(pBufferHdr == NULL)
+        LOG_ERROR("VideoFilter outbuffer list has one NULL buffer.\n");
+    LOG_DEBUG("Remove buffer %p from list.\n", pBufferHdr->pBuffer);
+    OutBufferHdrList.Remove(pBufferHdr);
+
+    return pBufferHdr;
+}
+
+OMX_ERRORTYPE VideoFilter::HandleLastOutput(OMX_U32 flags)
+{
+    OMX_PTR pBuffer = NULL;
+    OMX_S32 nOutSize=0;	
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+
+    bLastOutput = OMX_TRUE;
+    GetOutputBuffer(&pBuffer,&nOutSize);
+    if(pBuffer != NULL)
+        pBufferHdr = GetOutBufferHdrFromList(pBuffer);
+
+    if(pBuffer == NULL || pBufferHdr == NULL) {
+        pBufferHdr = GetFirstOutBufferHdrFromList();
+        if(pBufferHdr == NULL) {
+            LOG_ERROR("No buffer holded by VideoFilter.\n");
+            return OMX_ErrorUndefined;
+        }
+    }
+
+    pBufferHdr->nFilledLen = nOutSize;//0;
+    pBufferHdr->nFlags = OMX_BUFFERFLAG_EOS|flags;
+    ReturnOutputBuffer(pBufferHdr,flags);
+    LOG_INFO("VideoFilter send last output frame.\n");
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::GetDecBuffer(OMX_PTR *ppBuffer,OMX_S32 * pOutStuffSize,OMX_S32* pOutFrmSize)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoFilter::GetPostMappedDecBuffer(OMX_PTR pPostBuf,OMX_PTR *ppDecBuffer)
+{
+    return OMX_ErrorNone;
+}
+
+OMX_PTR VideoFilter::AllocateInputBuffer(OMX_U32 nSize)
+{
+    return FSL_MALLOC(nSize);
+}
+
+OMX_ERRORTYPE VideoFilter::FreeInputBuffer(OMX_PTR pBuffer)
+{
+    FSL_FREE(pBuffer);
+    return OMX_ErrorNone;
+}
+
+OMX_PTR VideoFilter::AllocateOutputBuffer(OMX_U32 nSize)
+{
+    return FSL_MALLOC(nSize);
+}
+
+OMX_ERRORTYPE VideoFilter::FreeOutputBuffer(OMX_PTR pBuffer)
+{
+    FSL_FREE(pBuffer);
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/VideoFilter.h b/OpenMAXIL/src/component/common/VideoFilter.h
new file mode 100755
index 0000000..24c3086
--- /dev/null
+++ b/OpenMAXIL/src/component/common/VideoFilter.h
@@ -0,0 +1,133 @@
+/**
+ *  Copyright (c) 2010-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file VideoFilter.h
+ *  @brief Class definition of VideoFilter base Component
+ *  @ingroup VideoFilter
+ */
+
+#ifndef VideoFilter_h
+#define VideoFilter_h
+
+#include "ComponentBase.h"
+#include "Mem.h"
+
+#define NUM_PORTS 2
+#define IN_PORT   0
+#define OUT_PORT  1
+
+typedef enum {
+    FILTER_OK = 0,
+    FILTER_DO_INIT,
+    FILTER_NO_INPUT_BUFFER,
+    FILTER_NO_OUTPUT_BUFFER,
+    FILTER_HAS_OUTPUT,
+    FILTER_SKIP_OUTPUT,
+    FILTER_LAST_OUTPUT,
+    FILTER_ERROR,
+    FILTER_INPUT_CONSUMED = 0x100,    /* can release input data*/
+    FILTER_ONE_FRM_DECODED = 0x200,
+    FILTER_INPUT_CONSUMED_EXT_READ = 0x400, /* can feed next input, but shouldn't release current input */
+    FILTER_INPUT_CONSUMED_EXT_RETURN = 0x800, /* can release previous input data, in such case, need to get 'GetReturnedInputDataPtr' to fetch the corresponding input pointer*/
+    /*related flags for encoder*/
+    FILTER_FLAGS_MASK =0xF000,
+    FILTER_FLAG_CODEC_DATA =0x1000,
+    FILTER_FLAG_NONKEY_FRAME =0x2000,
+    FILTER_FLAG_KEY_FRAME =0x4000,
+} FilterBufRetCode;
+
+class VideoFilter : public ComponentBase {
+    public:
+        VideoFilter();
+        OMX_ERRORTYPE DoAllocateBuffer(OMX_PTR *buffer, OMX_U32 nSize,OMX_U32 nPortIndex);
+        OMX_ERRORTYPE DoFreeBuffer(OMX_PTR buffer,OMX_U32 nPortIndex);
+        OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE InputFmtChanged();
+        OMX_ERRORTYPE OutputFmtChanged();
+        OMX_TICKS QueryStreamTs();
+    protected:
+        OMX_VIDEO_PORTDEFINITIONTYPE sInFmt;
+        OMX_VIDEO_PORTDEFINITIONTYPE sOutFmt;
+		OMX_U32 nInPortFormatCnt;
+		OMX_COLOR_FORMATTYPE eInPortPormat[MAX_PORT_FORMAT_NUM];
+		OMX_U32 nOutPortFormatCnt;
+		OMX_COLOR_FORMATTYPE eOutPortPormat[MAX_PORT_FORMAT_NUM];
+        OMX_BOOL bFilterSupportPartilInput;
+        OMX_U32 nInBufferCnt;
+        OMX_U32 nInBufferSize;
+        OMX_U32 nOutBufferCnt;
+        OMX_U32 nOutBufferSize;
+        OMX_PTR pCodecData;
+        OMX_U32 nCodecDataLen;
+        OMX_CONFIG_ROTATIONTYPE Rotation;
+        OMX_BOOL bFilterSupportFrmSizeRpt;
+        OMX_BOOL bNeedMapDecAndOutput;
+    private:
+        OMX_BUFFERHEADERTYPE PartialInputHdr;
+        OMX_BUFFERHEADERTYPE *pInBufferHdr;
+        List<OMX_BUFFERHEADERTYPE> OutBufferHdrList;
+        List<OMX_BUFFERHEADERTYPE> InBufferHdrList;  /* added for flag: FILTER_INPUT_CONSUMED_EXT_XXX */
+        OMX_PTR hTsHandle;
+        OMX_S32 nDecodeOnly;
+        OMX_BOOL bGetNewSegment;
+        OMX_BOOL bNewSegment;
+        OMX_BOOL bLastInput;
+        OMX_BOOL bLastOutput;
+        OMX_BOOL bInReturnBufferState;
+        OMX_BOOL bNeedOutBuffer;
+        OMX_BOOL bNeedInputBuffer;
+        OMX_BOOL bInit;
+		OMX_U32 nInvalidFrameCnt;
+
+        OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE PortFormatChanged(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE ProcessDataBuffer();
+        OMX_ERRORTYPE ProcessInputBuffer();
+        OMX_ERRORTYPE ProcessOutputBuffer();
+        OMX_ERRORTYPE DoIdle2Loaded();
+        OMX_ERRORTYPE DoLoaded2Idle();
+        OMX_ERRORTYPE ProcessInBufferFlags();
+        OMX_ERRORTYPE ProcessPartialInput();
+        OMX_ERRORTYPE ReturnInputBuffer();
+        OMX_ERRORTYPE ReturnOutputBuffer(OMX_BUFFERHEADERTYPE *pBufferHdr,OMX_U32 flags);
+        OMX_BOOL HasFreeTsSlot();
+        OMX_ERRORTYPE AddOneTimeStampToTM(OMX_TICKS ts);
+        OMX_TICKS GetOneTimeStampFromTM();
+        OMX_TICKS GetOneTimeStamp();
+        OMX_BUFFERHEADERTYPE *GetOutBufferHdrFromList(OMX_PTR pBuffer);
+        OMX_BUFFERHEADERTYPE *GetFirstOutBufferHdrFromList();
+        OMX_ERRORTYPE HandleLastOutput(OMX_U32 flags);
+        OMX_ERRORTYPE CheckPortResource(OMX_U32 nPortIndex);
+        OMX_ERRORTYPE SetDefaultSetting();
+
+        virtual OMX_ERRORTYPE InitFilterComponent();
+        virtual OMX_ERRORTYPE DeInitFilterComponent();
+        virtual OMX_ERRORTYPE SetInputBuffer(OMX_PTR pBuffer, OMX_S32 nSize, OMX_BOOL bLast) = 0;
+        virtual OMX_ERRORTYPE SetOutputBuffer(OMX_PTR pBuffer) = 0;
+        virtual OMX_ERRORTYPE InitFilter() = 0;
+        virtual OMX_ERRORTYPE DeInitFilter() = 0;
+        virtual FilterBufRetCode FilterOneBuffer() = 0;
+        virtual OMX_ERRORTYPE GetDecBuffer(OMX_PTR *ppBuffer,OMX_S32 * pOutStuffSize,OMX_S32* pOutFrmSize);
+        virtual OMX_ERRORTYPE GetPostMappedDecBuffer(OMX_PTR pPostBuf,OMX_PTR *ppDecBuffer);
+        virtual OMX_ERRORTYPE GetOutputBuffer(OMX_PTR *ppBuffer,OMX_S32 * pOutSize) = 0;
+        virtual OMX_ERRORTYPE FlushInputBuffer() = 0;
+        virtual OMX_ERRORTYPE FlushOutputBuffer() = 0;
+        virtual OMX_PTR AllocateInputBuffer(OMX_U32 nSize);
+        virtual OMX_ERRORTYPE FreeInputBuffer(OMX_PTR pBuffer);
+        virtual OMX_PTR AllocateOutputBuffer(OMX_U32 nSize);
+        virtual OMX_ERRORTYPE FreeOutputBuffer(OMX_PTR pBuffer);
+        virtual OMX_ERRORTYPE GetInputDataDepthThreshold(OMX_S32* pDurationThr, OMX_S32* pBufCntThr);
+        virtual OMX_ERRORTYPE GetReturnedInputDataPtr(OMX_PTR* ppInput);
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/VideoRender.cpp b/OpenMAXIL/src/component/common/VideoRender.cpp
new file mode 100755
index 0000000..8846f8a
--- /dev/null
+++ b/OpenMAXIL/src/component/common/VideoRender.cpp
@@ -0,0 +1,558 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "VideoRender.h"
+
+#define MAX_DELAY 20000 //20ms
+
+VideoRender::VideoRender()
+{
+    bInContext = OMX_FALSE;
+    nPorts = NUM_PORTS;
+}
+
+OMX_ERRORTYPE VideoRender::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_BUFFERSUPPLIERTYPE SupplierType;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = IN_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainVideo;
+    fsl_osal_memcpy(&sPortDef.format.video, &sVideoFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = nFrameBufferMin;
+    sPortDef.nBufferCountActual = nFrameBufferActual;
+    sPortDef.nBufferSize = sPortDef.format.video.nFrameWidth
+        * sPortDef.format.video.nFrameHeight
+        * pxlfmt2bpp(sVideoFmt.eColorFormat) / 8;
+    ret = ports[IN_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for in port failed.\n");
+        return ret;
+    }
+
+    ports[IN_PORT]->SetSupplierType(TunneledSupplierType);
+
+    sPortDef.nPortIndex = CLK_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainOther;
+    sPortDef.format.other.eFormat = OMX_OTHER_FormatTime;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_FALSE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 1;
+    sPortDef.nBufferSize = sizeof(OMX_TIME_MEDIATIMETYPE);
+    ret = ports[CLK_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for clk port failed.\n");
+        return ret;
+    }
+
+    SupplierType = OMX_BufferSupplyOutput;
+    ports[CLK_PORT]->SetSupplierType(SupplierType);
+
+    fsl_osal_memset(&hClock, 0, sizeof(TUNNEL_INFO));
+    ClockState = OMX_TIME_ClockStateStopped;
+    ClockScale = Q16_SHIFT;
+    pSyncFrame = NULL;
+    nFrameCnt = nDropCnt = nDeviceDropCnt = nContiniousDrop = 0;
+
+    InitVideoVisitors();
+
+    ret = InitRenderComponent();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoRender::DeInitComponent()
+{
+    DeInitRenderComponent();
+    DeInitVideoVisitors();
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::InitRenderComponent()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::DeInitRenderComponent()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::DoLoaded2Idle()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = OpenDevice();
+    if(ret != OMX_ErrorNone) {
+        CloseDevice();
+        SendEvent(OMX_EventError, ret, 0, NULL);
+        return ret;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::DoIdle2Loaded()
+{
+    CloseDevice();
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::GetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigCommonRotate:
+            {
+                OMX_CONFIG_ROTATIONTYPE *pRotate;
+                pRotate = (OMX_CONFIG_ROTATIONTYPE*)pStructure;
+                CHECK_STRUCT(pRotate, OMX_CONFIG_ROTATIONTYPE, ret);
+                pRotate->nRotation = eRotation;
+            }
+            break;
+        case OMX_IndexConfigCommonMirror:
+            ret = OMX_ErrorNotImplemented;
+            break;
+        case OMX_IndexConfigCommonScale:
+            ret = OMX_ErrorNotImplemented;
+            break;
+        case OMX_IndexConfigCommonInputCrop:
+            {
+                OMX_CONFIG_RECTTYPE *pRect;
+                pRect = (OMX_CONFIG_RECTTYPE*)pStructure;
+                CHECK_STRUCT(pRect, OMX_CONFIG_RECTTYPE, ret);
+                fsl_osal_memcpy(pRect, &sRectIn, sizeof(OMX_CONFIG_RECTTYPE));
+            }
+            break;
+        default:
+            ret = RenderGetConfig(nParamIndex, pStructure);
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoRender::SetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigCommonRotate:
+            {
+                OMX_CONFIG_ROTATIONTYPE *pRotate;
+                pRotate = (OMX_CONFIG_ROTATIONTYPE*)pStructure;
+                CHECK_STRUCT(pRotate, OMX_CONFIG_ROTATIONTYPE, ret);
+                //not accomplished with openmax il api about the rotate value
+                if(pRotate->nRotation == 90){
+                    eRotation = ROTATE_90_LEFT;
+                }else if(pRotate->nRotation == 180){
+                    eRotation = ROTATE_180;
+                }else if(pRotate->nRotation == 270){
+                    eRotation = ROTATE_90_RIGHT;
+                }else{
+                    eRotation = (ROTATION)pRotate->nRotation;
+                }
+                SetDeviceRotation();
+            }
+            break;
+        case OMX_IndexConfigCommonMirror:
+            ret = OMX_ErrorNotImplemented;
+            break;
+        case OMX_IndexConfigCommonScale:
+            ret = OMX_ErrorNotImplemented;
+            break;
+        case OMX_IndexConfigCommonInputCrop:
+            {
+                OMX_CONFIG_RECTTYPE *pRect;
+                pRect = (OMX_CONFIG_RECTTYPE*)pStructure;
+                CHECK_STRUCT(pRect, OMX_CONFIG_RECTTYPE, ret);
+                fsl_osal_memcpy(&sRectIn, pRect, sizeof(OMX_CONFIG_RECTTYPE));
+                SetDeviceInputCrop();
+            }
+            break;
+        default:
+            ret = RenderSetConfig(nParamIndex, pStructure);
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoRender::RenderGetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    return OMX_ErrorUnsupportedIndex;
+}
+
+OMX_ERRORTYPE VideoRender::RenderSetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    return OMX_ErrorUnsupportedIndex;
+}
+
+OMX_ERRORTYPE VideoRender::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+
+    if(ports[IN_PORT]->BufferNum() == 0)
+        return OMX_ErrorNoMore;
+
+    if(pSyncFrame != NULL)
+        return OMX_ErrorNoMore;
+
+    ports[IN_PORT]->GetBuffer(&pBufferHdr);
+
+    if(nFrameCnt == 0 && ports[CLK_PORT]->IsEnabled() == OMX_TRUE) {
+        OMX_TIME_CONFIG_CLOCKSTATETYPE sState;
+        OMX_INIT_STRUCT(&sState, OMX_TIME_CONFIG_CLOCKSTATETYPE);
+        ports[CLK_PORT]->GetTunneledInfo(&hClock);
+        OMX_GetConfig(hClock.hTunneledComp, OMX_IndexConfigTimeClockState, &sState);
+        ClockState = sState.eState;
+    }
+
+    nFrameCnt ++;
+
+    LOG_DEBUG("VideoRender get bufer: %p:%lld:%x\n", 
+            pBufferHdr->pBuffer, pBufferHdr->nTimeStamp, pBufferHdr->nFlags);
+
+    if(ports[CLK_PORT]->IsEnabled() == OMX_TRUE)
+        ret = SyncFrame(pBufferHdr);
+    else
+        ret = RenderFrame(pBufferHdr);
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoRender::ProcessClkBuffer()
+{
+    OMX_BUFFERHEADERTYPE *pClkBuffer = NULL;
+    OMX_TIME_MEDIATIMETYPE *pUpdate = NULL;
+    OMX_TIME_UPDATETYPE eType;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+    if(ports[CLK_PORT]->BufferNum() == 0)
+        return OMX_ErrorNoMore;
+
+    ports[CLK_PORT]->GetBuffer(&pClkBuffer);
+    pUpdate = (OMX_TIME_MEDIATIMETYPE*)pClkBuffer->pBuffer;
+    eType = pUpdate->eUpdateType;
+
+    switch(eType) {
+        case OMX_TIME_UpdateClockStateChanged:
+            ClockState = pUpdate->eState;
+            if(ClockState == OMX_TIME_ClockStateRunning 
+                    || ClockState == OMX_TIME_ClockStateStopped) {
+                if(pSyncFrame != NULL) {
+                    SyncRequest(pSyncFrame);
+                    pSyncFrame = NULL;
+                }
+            }
+            break;
+        case OMX_TIME_UpdateScaleChanged:
+            ClockScale = pUpdate->xScale;
+            break;
+        case OMX_TIME_UpdateRequestFulfillment:
+            {
+                OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+                pBufferHdr = (OMX_BUFFERHEADERTYPE*)pUpdate->nClientPrivate;
+                if(pBufferHdr->nFlags & OMX_BUFFERFLAG_EOS) {
+                    nDeviceDropCnt = GetDeviceDropFames();
+                    LOG_INFO("Total frames: %d, Total Droped frames: %d, Render device dropped frames: %d\n", 
+                            nFrameCnt, nDropCnt + nDeviceDropCnt, nDeviceDropCnt);
+                    RenderFrame(pBufferHdr);
+                    SendEvent(OMX_EventBufferFlag, IN_PORT, OMX_BUFFERFLAG_EOS, NULL);
+                    break;
+                }
+
+                if(OMX_TRUE == IsDropFrame(pBufferHdr->nTimeStamp, pUpdate->nMediaTimestamp)) {
+                    LOG_DEBUG("Buffer is late, drop. Buffer ts: %lld, Media ts: %lld\n",
+                            pBufferHdr->nTimeStamp, pUpdate->nMediaTimestamp);
+                    nDropCnt ++;
+                    pBufferHdr->nTimeStamp = -1;
+                    ports[IN_PORT]->SendBuffer(pBufferHdr);
+                    break;
+                }
+                RenderFrame(pBufferHdr);
+            }
+            break;
+        default :
+            break;
+    }
+
+    ports[CLK_PORT]->SendBuffer(pClkBuffer);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::SyncFrame(
+        OMX_BUFFERHEADERTYPE *pBufferHdr)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ports[CLK_PORT]->GetTunneledInfo(&hClock);
+    if(pBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME) {
+        OMX_TIME_CONFIG_TIMESTAMPTYPE sStartTime;
+        OMX_INIT_STRUCT(&sStartTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+        sStartTime.nPortIndex = hClock.nTunneledPort;
+        sStartTime.nTimestamp = pBufferHdr->nTimeStamp;
+        ret = OMX_SetConfig(hClock.hTunneledComp, OMX_IndexConfigTimeClientStartTime, &sStartTime);
+        if(ret == OMX_ErrorNone) {
+            pSyncFrame = pBufferHdr;
+            return OMX_ErrorNone;
+        }
+    }
+
+    SyncRequest(pBufferHdr);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::SyncRequest(
+        OMX_BUFFERHEADERTYPE *pBufferHdr)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ClockState == OMX_TIME_ClockStateRunning) {
+        if(pBufferHdr->nFlags & OMX_BUFFERFLAG_STARTTIME ||
+                ClockScale < (OMX_S32)(MIN_RATE*Q16_SHIFT) || ClockScale > (OMX_S32)(MAX_RATE*Q16_SHIFT)) {
+            OMX_TIME_CONFIG_TIMESTAMPTYPE sRefTime;
+            OMX_INIT_STRUCT(&sRefTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+            sRefTime.nPortIndex = hClock.nTunneledPort;
+            sRefTime.nTimestamp = pBufferHdr->nTimeStamp;
+            OMX_SetConfig(hClock.hTunneledComp, OMX_IndexConfigTimeCurrentVideoReference, &sRefTime);
+        }
+
+        OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE sRequest;
+        OMX_INIT_STRUCT(&sRequest, OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE);
+        sRequest.nPortIndex = hClock.nTunneledPort;
+        sRequest.nMediaTimestamp = pBufferHdr->nTimeStamp;
+        sRequest.pClientPrivate = (OMX_PTR)pBufferHdr;
+
+        // In case of some fuzzy seeked file, the first I frame timestamp after seeking will
+        // have big difference of the seeked time, then cause this frame waiting for AV sync,
+        // then cause waiting for mark buffer timeout in client.
+        if(pBufferHdr->hMarkTargetComponent != NULL)
+            sRequest.nMediaTimestamp = -1;
+
+        do {
+            ret = OMX_SetConfig(hClock.hTunneledComp, OMX_IndexConfigTimeMediaTimeRequest, &sRequest);
+            if (OMX_TRUE == bHasCmdToProcess())
+                break;
+        } while (ret == OMX_ErrorNotReady);
+        if(ret != OMX_ErrorNone)
+            ports[IN_PORT]->SendBuffer(pBufferHdr);
+    }
+    else
+        ports[IN_PORT]->SendBuffer(pBufferHdr);
+
+    return OMX_ErrorNone;
+}
+
+
+OMX_ERRORTYPE VideoRender::RenderFrame(
+        OMX_BUFFERHEADERTYPE *pBufferHdr)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    Report2VideoVisitors(pBufferHdr);
+    WriteDevice(pBufferHdr);
+    return ret;
+}
+
+#define DROP_TH_CNT 6
+static OMX_TICKS drop_th[DROP_TH_CNT] = {
+    300000,
+    400000,
+    500000,
+    600000,
+    700000,
+    800000,
+};
+
+static OMX_U32 frame_th[DROP_TH_CNT] = {
+    1, 2, 3, 4, 5, 6
+};
+
+OMX_BOOL VideoRender::IsDropFrame(
+        OMX_TICKS ts, 
+        OMX_TICKS meida)
+{
+    OMX_BOOL ret = OMX_FALSE;
+    OMX_TICKS diff = meida - ts;
+
+    if(diff > MAX_DELAY) {
+        OMX_S32 i;
+        for(i=0; i<DROP_TH_CNT; i++) {
+            if(diff < drop_th[i]) {
+                if(nContiniousDrop >= frame_th[i]) {
+                    nContiniousDrop = 0;
+                    return OMX_FALSE;
+                }
+                else {
+                    nContiniousDrop ++;
+                    return OMX_TRUE;
+                }
+            }
+        }
+
+        if(i == DROP_TH_CNT) {
+            //NotifyClkVideoLate();
+            //nContiniousDrop = 0;
+            return OMX_TRUE;
+        }
+    }
+    else
+        nContiniousDrop = 0;
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoRender::NotifyClkVideoLate()
+{
+    TUNNEL_INFO sTunnelInfo;
+    OMX_TIME_CONFIG_TIMEVIDEOLATE sVideoLate;
+
+    fsl_osal_memset(&sTunnelInfo, 0, sizeof(TUNNEL_INFO));
+    ports[CLK_PORT]->GetTunneledInfo(&sTunnelInfo);
+    if(sTunnelInfo.hTunneledComp == NULL)
+        return OMX_ErrorInvalidComponent;
+
+    OMX_INIT_STRUCT(&sVideoLate, OMX_TIME_CONFIG_TIMEVIDEOLATE);
+    sVideoLate.nPortIndex = sTunnelInfo.nTunneledPort;
+    sVideoLate.bLate = OMX_TRUE;
+    OMX_SetConfig(sTunnelInfo.hTunneledComp, OMX_IndexConfigTimeVideoLate, &sVideoLate);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::SetDeviceRotation()
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::SetDeviceInputCrop()
+{
+    return OMX_ErrorNone;
+}
+
+typedef int (*CREATE_ITF)(VFV_INTERFACE *interface);
+
+OMX_ERRORTYPE VideoRender::InitVideoVisitors()
+{
+    OMX_STRING lib_name = (OMX_STRING)"libfslxec.so";
+    OMX_STRING symbol_name = (OMX_STRING)"CreateVFVInterface";
+    CREATE_ITF CreateItf = NULL;
+
+    hVisitorLib = NULL;
+    hVistor = NULL;
+    fsl_osal_memset(&hVistorItf, 0, sizeof(VFV_INTERFACE));
+
+    //phase out libfslxec
+    return OMX_ErrorNotImplemented;
+
+    hVisitorLib = LibMgr.load(lib_name);
+    if(hVisitorLib == NULL) {
+        LOG_WARNING("Unable to load %s\n", lib_name);
+        return OMX_ErrorBadParameter;
+    }
+
+    CreateItf = (CREATE_ITF)LibMgr.getSymbol(hVisitorLib, symbol_name);
+    if(CreateItf == NULL) {
+        LibMgr.unload(hVisitorLib);
+        hVisitorLib = NULL;
+        LOG_ERROR("Get symbol %s from %s failed.\n", symbol_name, lib_name);
+        return OMX_ErrorBadParameter;
+    }
+
+    if(CreateItf(&hVistorItf) < 0) {
+        LibMgr.unload(hVisitorLib);
+        hVisitorLib = NULL;
+        LOG_ERROR("Create interface from %s failed.\n", lib_name);
+        return OMX_ErrorUndefined;
+    }
+
+    hVistor = (*hVistorItf.init)();
+    if(hVistor == NULL) {
+        LibMgr.unload(hVisitorLib);
+        hVisitorLib = NULL;
+        LOG_ERROR("init visitor failed, visitor is %s\n", lib_name);
+        return OMX_ErrorUndefined;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::DeInitVideoVisitors()
+{
+    if(hVistor != NULL) {
+        (*hVistorItf.deinit)(hVistor);
+        hVistor = NULL;
+    }
+
+    if(hVisitorLib != NULL) {
+        LibMgr.unload(hVisitorLib);
+        hVisitorLib = NULL;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoRender::Report2VideoVisitors(OMX_BUFFERHEADERTYPE *pBufferHdr)
+{
+    VIDEO_FMT fmt = FMT_NONE;
+
+    switch(sVideoFmt.eColorFormat) {
+        case OMX_COLOR_FormatYUV420Planar:
+            fmt = YUV420Planar;
+            break;
+        case OMX_COLOR_FormatYUV420PackedPlanar:
+            fmt = YUV420PackedPlanar;
+            break;
+        case OMX_COLOR_FormatYUV420SemiPlanar:
+            fmt = YUV420SemiPlanar;
+            break;
+        case OMX_COLOR_FormatYUV422Planar:
+            fmt = YUV422Planar;
+            break;
+        case OMX_COLOR_FormatYUV422PackedPlanar:
+            fmt = YUV422PackedPlanar;
+            break;
+        case OMX_COLOR_FormatYUV422SemiPlanar:
+            fmt = YUV422SemiPlanar;
+            break;
+        default:
+            break;
+    }
+
+    if(hVistorItf.report != NULL && hVistor != NULL)
+        (*hVistorItf.report)(hVistor, nFrameCnt, sVideoFmt.nFrameWidth, sVideoFmt.nFrameHeight, fmt, (char*)pBufferHdr->pBuffer);
+
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/VideoRender.h b/OpenMAXIL/src/component/common/VideoRender.h
new file mode 100755
index 0000000..47d0e2b
--- /dev/null
+++ b/OpenMAXIL/src/component/common/VideoRender.h
@@ -0,0 +1,90 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file VideoRender.h
+ *  @brief Class definition of VideoRender Component
+ *  @ingroup VideoRender
+ */
+
+#ifndef VideoRender_h
+#define VideoRender_h
+
+#include "ComponentBase.h"
+#include "ShareLibarayMgr.h"
+#include "video_frame_visitor.h"
+
+#define NUM_PORTS 2
+#define IN_PORT 0
+#define CLK_PORT 1
+
+#define CHECK_STRUCT(ps,t,r) \
+    do { \
+        OMX_CHECK_STRUCT(ps, t, r); \
+        if(r != OMX_ErrorNone) \
+        break; \
+        if(ps->nPortIndex != IN_PORT) { \
+            r = OMX_ErrorBadPortIndex; \
+            break; \
+        } \
+    } while(0);
+
+class VideoRender : public ComponentBase {
+    public:
+        VideoRender();
+    protected:
+        OMX_U32 nFrameBufferMin;
+        OMX_U32 nFrameBufferActual;
+        OMX_BUFFERSUPPLIERTYPE TunneledSupplierType;
+        OMX_VIDEO_PORTDEFINITIONTYPE sVideoFmt;
+        ROTATION eRotation;
+        OMX_CONFIG_RECTTYPE sRectIn;
+    private:
+        TUNNEL_INFO hClock;
+        OMX_TIME_CLOCKSTATE ClockState;
+        OMX_S32 ClockScale;
+        OMX_BUFFERHEADERTYPE *pSyncFrame;
+        OMX_U32 nFrameCnt;
+        OMX_U32 nDropCnt;
+        OMX_U32 nDeviceDropCnt;
+        OMX_U32 nContiniousDrop;
+        ShareLibarayMgr LibMgr;
+        OMX_PTR hVisitorLib;
+        VFV_INTERFACE hVistorItf;
+        OMX_PTR hVistor;
+        OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        virtual OMX_ERRORTYPE InitRenderComponent();
+        virtual OMX_ERRORTYPE DeInitRenderComponent();
+        OMX_ERRORTYPE DoLoaded2Idle();
+        OMX_ERRORTYPE DoIdle2Loaded();
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        virtual OMX_ERRORTYPE RenderGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        virtual OMX_ERRORTYPE RenderSetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE ProcessDataBuffer();
+        OMX_ERRORTYPE ProcessClkBuffer();
+        OMX_ERRORTYPE SyncFrame(OMX_BUFFERHEADERTYPE *pBufferHdr);
+        OMX_ERRORTYPE SyncRequest(OMX_BUFFERHEADERTYPE *pBufferHdr);
+        OMX_ERRORTYPE RenderFrame(OMX_BUFFERHEADERTYPE *pBufferHdr);
+        OMX_BOOL IsDropFrame(OMX_TICKS ts, OMX_TICKS meida);
+        OMX_ERRORTYPE NotifyClkVideoLate();
+        virtual OMX_ERRORTYPE OpenDevice() = 0;
+        virtual OMX_ERRORTYPE CloseDevice() = 0;
+        virtual OMX_ERRORTYPE WriteDevice(OMX_BUFFERHEADERTYPE *pBufferHdr) = 0;
+        virtual OMX_ERRORTYPE SetDeviceRotation();
+        virtual OMX_ERRORTYPE SetDeviceInputCrop();
+        OMX_ERRORTYPE InitVideoVisitors();
+        OMX_ERRORTYPE DeInitVideoVisitors();
+        OMX_ERRORTYPE Report2VideoVisitors(OMX_BUFFERHEADERTYPE *pBufferHdr);
+        virtual OMX_U32 GetDeviceDropFames() { return 0;};
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/VideoSource.cpp b/OpenMAXIL/src/component/common/VideoSource.cpp
new file mode 100755
index 0000000..ed7388b
--- /dev/null
+++ b/OpenMAXIL/src/component/common/VideoSource.cpp
@@ -0,0 +1,785 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+ 
+#include "VideoSource.h"
+ 
+#define CHECK_STRUCT(ps,t,r) \
+    do { \
+        OMX_CHECK_STRUCT(ps, t, r); \
+        if(r != OMX_ErrorNone) \
+        break; \
+        if(ps->nPortIndex != CAPTURED_FRAME_PORT) { \
+            r = OMX_ErrorBadPortIndex; \
+            break; \
+        } \
+    } while(0);
+
+VideoSource::VideoSource()
+{
+    bInContext = OMX_FALSE;
+    nPorts = NUM_PORTS;
+}
+
+OMX_ERRORTYPE VideoSource::InitComponent()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = PREVIEW_PORT;
+    sPortDef.eDir = OMX_DirOutput;
+    sPortDef.eDomain = OMX_PortDomainVideo;
+    fsl_osal_memcpy(&sPortDef.format.video, &sVideoFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_FALSE;
+    sPortDef.nBufferCountMin = nFrameBufferMin;
+    sPortDef.nBufferCountActual = nFrameBufferActual;
+    sPortDef.nBufferSize = sPortDef.format.video.nFrameWidth
+        * sPortDef.format.video.nFrameHeight
+        * pxlfmt2bpp(sVideoFmt.eColorFormat) / 8;
+    ret = ports[PREVIEW_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for in port failed.\n");
+        return ret;
+    }
+
+    ports[PREVIEW_PORT]->SetSupplierType(PreviewPortSupplierType);
+
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = CAPTURED_FRAME_PORT;
+    sPortDef.eDir = OMX_DirOutput;
+    sPortDef.eDomain = OMX_PortDomainVideo;
+    fsl_osal_memcpy(&sPortDef.format.video, &sVideoFmt, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_TRUE;
+    sPortDef.nBufferCountMin = nFrameBufferMin;
+    sPortDef.nBufferCountActual = nFrameBufferActual;
+    sPortDef.nBufferSize = sPortDef.format.video.nFrameWidth
+        * sPortDef.format.video.nFrameHeight
+        * pxlfmt2bpp(sVideoFmt.eColorFormat) / 8;
+    ret = ports[CAPTURED_FRAME_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for in port failed.\n");
+        return ret;
+    }
+
+    ports[CAPTURED_FRAME_PORT]->SetSupplierType(CapturePortSupplierType);
+
+    sPortDef.nPortIndex = CLK_PORT;
+    sPortDef.eDir = OMX_DirInput;
+    sPortDef.eDomain = OMX_PortDomainOther;
+    sPortDef.format.other.eFormat = OMX_OTHER_FormatTime;
+    sPortDef.bPopulated = OMX_FALSE;
+    sPortDef.bEnabled = OMX_FALSE;
+    sPortDef.nBufferCountMin = 1;
+    sPortDef.nBufferCountActual = 1;
+    sPortDef.nBufferSize = sizeof(OMX_TIME_MEDIATIMETYPE);
+    ret = ports[CLK_PORT]->SetPortDefinition(&sPortDef);
+    if(ret != OMX_ErrorNone) {
+        LOG_ERROR("Set port definition for clk port failed.\n");
+        return ret;
+    }
+
+	OMX_INIT_STRUCT(&SensorMode, OMX_PARAM_SENSORMODETYPE);
+
+	SensorMode.nPortIndex = OMX_ALL;
+	SensorMode.nFrameRate = 30 * Q16_SHIFT;
+	SensorMode.bOneShot = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&PortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE);
+
+	PortFormat.nPortIndex = OMX_ALL;
+	PortFormat.nIndex = 0;
+	PortFormat.eCompressionFormat = OMX_VIDEO_CodingUnused;
+	PortFormat.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+	PortFormat.xFramerate = 30 * Q16_SHIFT;
+
+	OMX_INIT_STRUCT(&WhiteBalControl, OMX_CONFIG_WHITEBALCONTROLTYPE);
+
+	WhiteBalControl.nPortIndex = OMX_ALL;
+	WhiteBalControl.eWhiteBalControl = OMX_WhiteBalControlOff;
+
+	OMX_INIT_STRUCT(&ScaleFactor, OMX_CONFIG_SCALEFACTORTYPE);
+
+	ScaleFactor.nPortIndex = OMX_ALL;
+	ScaleFactor.xWidth = 1.0 * Q16_SHIFT;
+	ScaleFactor.xHeight = 1.0 * Q16_SHIFT;
+
+	OMX_INIT_STRUCT(&ExposureValue, OMX_CONFIG_EXPOSUREVALUETYPE);
+
+	ExposureValue.nPortIndex = OMX_ALL;
+	ExposureValue.eMetering = OMX_MeteringModeAverage;
+	ExposureValue.xEVCompensation = 1.0 * Q16_SHIFT;
+	ExposureValue.nApertureFNumber = 1;
+	ExposureValue.bAutoAperture = OMX_TRUE;
+	ExposureValue.nShutterSpeedMsec = 33;
+	ExposureValue.bAutoShutterSpeed = OMX_TRUE;
+	ExposureValue.nSensitivity = 100;
+	ExposureValue.bAutoSensitivity = OMX_TRUE;
+
+	OMX_INIT_STRUCT(&Capturing, OMX_CONFIG_BOOLEANTYPE);
+
+	Capturing.bEnabled = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&EOS, OMX_CONFIG_BOOLEANTYPE);
+
+	EOS.bEnabled = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&AutoPauseAfterCapture, OMX_CONFIG_BOOLEANTYPE);
+
+	AutoPauseAfterCapture.bEnabled = OMX_FALSE;
+
+	OMX_INIT_STRUCT(&Rotation, OMX_CONFIG_ROTATIONTYPE);
+
+	Rotation.nPortIndex = OMX_ALL;
+	Rotation.nRotation = 0;
+
+	bFirstFrame = OMX_TRUE;
+	nFrameDelay = 0;
+	nBaseTime = 0;
+	nMediaTimestampPre = 0;
+	pOutBufferHdr = NULL;
+	nCaptureFrameCnt = 0;
+	bSendEOS = OMX_FALSE;
+	nMaxDuration = MAX_VALUE_S64;
+	nTimeLapseUs = 0;
+	nNextLapseTS = 0;
+	nLastSendTS = 0;
+	nFrameInterval = 0;
+	cameraPtr = NULL;
+	nCameraId = 0;
+	previewSurface = NULL;
+
+    ret = InitSourceComponent();
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+	return ret;
+}
+
+OMX_ERRORTYPE VideoSource::DeInitComponent()
+{
+    DeInitSourceComponent();
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoSource::InstanceInit()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+	
+	nFrameInterval = (1000000LL / (sVideoFmt.xFramerate / Q16_SHIFT));
+	StartDevice();
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoSource::InstanceDeInit()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	StopDevice();
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoSource::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+		case OMX_IndexParamCommonSensorMode:
+            {
+                OMX_PARAM_SENSORMODETYPE *pSensorMode;
+                pSensorMode = (OMX_PARAM_SENSORMODETYPE*)pStructure;
+                OMX_CHECK_STRUCT(pSensorMode, OMX_PARAM_SENSORMODETYPE, ret);
+				fsl_osal_memcpy(pSensorMode, &SensorMode,	sizeof(OMX_PARAM_SENSORMODETYPE));
+			}
+			break;
+		case OMX_IndexParamVideoPortFormat:
+            {
+				OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortFormat;
+				pPortFormat = (OMX_VIDEO_PARAM_PORTFORMATTYPE*)pStructure;
+				OMX_CHECK_STRUCT(pPortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE, ret);
+				fsl_osal_memcpy(pPortFormat, &PortFormat,	sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
+			}
+			break;
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoSource::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch ((int)nParamIndex) {
+		case OMX_IndexParamCommonSensorMode:
+            {
+                OMX_PARAM_SENSORMODETYPE *pSensorMode;
+                pSensorMode = (OMX_PARAM_SENSORMODETYPE*)pStructure;
+                OMX_CHECK_STRUCT(pSensorMode, OMX_PARAM_SENSORMODETYPE, ret);
+				fsl_osal_memcpy(&SensorMode, pSensorMode, sizeof(OMX_PARAM_SENSORMODETYPE));
+				SetSensorMode();
+			}
+			break;
+		case OMX_IndexParamVideoPortFormat:
+            {
+				OMX_VIDEO_PARAM_PORTFORMATTYPE *pPortFormat;
+				pPortFormat = (OMX_VIDEO_PARAM_PORTFORMATTYPE*)pStructure;
+				OMX_CHECK_STRUCT(pPortFormat, OMX_VIDEO_PARAM_PORTFORMATTYPE, ret);
+				fsl_osal_memcpy(&PortFormat, pPortFormat, sizeof(OMX_VIDEO_PARAM_PORTFORMATTYPE));
+				if (nParamIndex == CAPTURED_FRAME_PORT)
+					SetVideoFormat();
+			}
+			break;
+		case OMX_IndexParamStoreMetaDataInBuffers:
+            {
+                OMX_CONFIG_BOOLEANTYPE *pParams = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+                bStoreMetaData = pParams->bEnabled;
+            }
+			break;
+		case OMX_IndexParamVideoCamera:
+            {
+				 cameraPtr = (OMX_PTR)pStructure;
+			}
+			break;
+		case OMX_IndexParamVideoCameraProxy:
+            {
+				 cameraProxyPtr = (OMX_PTR)pStructure;
+			}
+			break;
+		case OMX_IndexParamVideoCameraId:
+			{
+				 nCameraId = *((OMX_S32*)pStructure);
+			}
+			break;
+		case OMX_IndexParamVideoSurface:
+			{
+				previewSurface = (OMX_PTR)pStructure;
+			}
+			break;
+		case OMX_IndexParamMaxFileDuration:
+			{
+				nMaxDuration = *((OMX_TICKS*)pStructure);
+			}
+			break;
+		case OMX_IndexParamTimeLapseUs:
+			{
+				nTimeLapseUs = *((OMX_TICKS*)pStructure);
+			}
+			break;
+		case OMX_IndexParamClientName:
+			{
+				clientName = (const OMX_U16 *)pStructure;
+			}
+			break;
+		case OMX_IndexParamClientUID:
+			{
+				clientUID = *((OMX_S32*)pStructure);
+			}
+			break;
+		default:
+			ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoSource::GetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch (nParamIndex) {
+		case OMX_IndexConfigCommonWhiteBalance:
+			{
+				OMX_CONFIG_WHITEBALCONTROLTYPE *pWhiteBalControl;
+				pWhiteBalControl = (OMX_CONFIG_WHITEBALCONTROLTYPE*)pStructure;
+				OMX_CHECK_STRUCT(pWhiteBalControl, OMX_CONFIG_WHITEBALCONTROLTYPE, ret);
+				fsl_osal_memcpy(pWhiteBalControl, &WhiteBalControl, sizeof(OMX_CONFIG_WHITEBALCONTROLTYPE));
+			}
+            break;
+        case OMX_IndexConfigCommonDigitalZoom:
+             {
+                OMX_CONFIG_SCALEFACTORTYPE *pScaleFactor;
+                pScaleFactor = (OMX_CONFIG_SCALEFACTORTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pScaleFactor, OMX_CONFIG_SCALEFACTORTYPE, ret);
+				fsl_osal_memcpy(pScaleFactor, &ScaleFactor, sizeof(OMX_CONFIG_SCALEFACTORTYPE));
+            }
+            break;
+        case OMX_IndexConfigCommonExposureValue:
+             {
+                OMX_CONFIG_EXPOSUREVALUETYPE *pExposureValue;
+                pExposureValue = (OMX_CONFIG_EXPOSUREVALUETYPE*)pStructure;
+                OMX_CHECK_STRUCT(pExposureValue, OMX_CONFIG_EXPOSUREVALUETYPE, ret);
+				fsl_osal_memcpy(pExposureValue, &ExposureValue, sizeof(OMX_CONFIG_EXPOSUREVALUETYPE));
+            }
+            break;
+        case OMX_IndexConfigCapturing:
+             {
+                OMX_CONFIG_BOOLEANTYPE *pCapturing;
+                pCapturing = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pCapturing, OMX_CONFIG_BOOLEANTYPE, ret);
+				fsl_osal_memcpy(pCapturing, &Capturing, sizeof(OMX_CONFIG_BOOLEANTYPE));
+            }
+            break;
+        case OMX_IndexAutoPauseAfterCapture:
+             {
+                OMX_CONFIG_BOOLEANTYPE *pAutoPauseAfterCapture;
+                pAutoPauseAfterCapture = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pAutoPauseAfterCapture, OMX_CONFIG_BOOLEANTYPE, ret);
+				fsl_osal_memcpy(pAutoPauseAfterCapture, &AutoPauseAfterCapture, sizeof(OMX_CONFIG_BOOLEANTYPE));
+            }
+            break;
+		case OMX_IndexConfigCommonRotate:
+			 {
+				 OMX_CONFIG_ROTATIONTYPE *pRotation;
+				 pRotation = (OMX_CONFIG_ROTATIONTYPE*)pStructure;
+				 OMX_CHECK_STRUCT(pRotation, OMX_CONFIG_ROTATIONTYPE, ret);
+				 fsl_osal_memcpy(pRotation, &Rotation, sizeof(OMX_CONFIG_ROTATIONTYPE));
+			 }
+        default:
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE VideoSource::SetConfig(
+        OMX_INDEXTYPE nParamIndex,
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    switch ((int)nParamIndex) {
+		case OMX_IndexConfigCommonWhiteBalance:
+			{
+				OMX_CONFIG_WHITEBALCONTROLTYPE *pWhiteBalControl;
+				pWhiteBalControl = (OMX_CONFIG_WHITEBALCONTROLTYPE*)pStructure;
+				OMX_CHECK_STRUCT(pWhiteBalControl, OMX_CONFIG_WHITEBALCONTROLTYPE, ret);
+				fsl_osal_memcpy(&WhiteBalControl, pWhiteBalControl, sizeof(OMX_CONFIG_WHITEBALCONTROLTYPE));
+				SetWhiteBalance();
+			}
+            break;
+        case OMX_IndexConfigCommonDigitalZoom:
+             {
+                OMX_CONFIG_SCALEFACTORTYPE *pScaleFactor;
+                pScaleFactor = (OMX_CONFIG_SCALEFACTORTYPE*)pStructure;
+                OMX_CHECK_STRUCT(pScaleFactor, OMX_CONFIG_SCALEFACTORTYPE, ret);
+				fsl_osal_memcpy(&ScaleFactor, pScaleFactor, sizeof(OMX_CONFIG_SCALEFACTORTYPE));
+				SetDigitalZoom();
+            }
+            break;
+        case OMX_IndexConfigCommonExposureValue:
+             {
+                OMX_CONFIG_EXPOSUREVALUETYPE *pExposureValue;
+                pExposureValue = (OMX_CONFIG_EXPOSUREVALUETYPE*)pStructure;
+                OMX_CHECK_STRUCT(pExposureValue, OMX_CONFIG_EXPOSUREVALUETYPE, ret);
+				fsl_osal_memcpy(&ExposureValue, pExposureValue, sizeof(OMX_CONFIG_EXPOSUREVALUETYPE));
+				SetExposureValue();
+            }
+            break;
+        case OMX_IndexConfigCapturing:
+             {
+                OMX_CONFIG_BOOLEANTYPE *pCapturing;
+				OMX_TIME_CONFIG_TIMESTAMPTYPE StartTime;
+				OMX_INIT_STRUCT(&StartTime, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+				StartTime.nTimestamp = 0;
+
+				pCapturing = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+				OMX_CHECK_STRUCT(pCapturing, OMX_CONFIG_BOOLEANTYPE, ret);
+				fsl_osal_memcpy(&Capturing, pCapturing, sizeof(OMX_CONFIG_BOOLEANTYPE));
+
+				if (Capturing.bEnabled == OMX_TRUE)
+					ClockSetConfig(OMX_IndexConfigTimeClientStartTime, &StartTime);
+			 }
+			 break;
+		case OMX_IndexAutoPauseAfterCapture:
+			 {
+				 OMX_CONFIG_BOOLEANTYPE *pAutoPauseAfterCapture;
+				 pAutoPauseAfterCapture = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+				 OMX_CHECK_STRUCT(pAutoPauseAfterCapture, OMX_CONFIG_BOOLEANTYPE, ret);
+				 fsl_osal_memcpy(&AutoPauseAfterCapture, pAutoPauseAfterCapture, sizeof(OMX_CONFIG_BOOLEANTYPE));
+			 }
+			 break;
+		case OMX_IndexConfigCommonRotate:
+			 {
+				 OMX_CONFIG_ROTATIONTYPE *pRotation;
+				 pRotation = (OMX_CONFIG_ROTATIONTYPE*)pStructure;
+				 OMX_CHECK_STRUCT(pRotation, OMX_CONFIG_ROTATIONTYPE, ret);
+				 fsl_osal_memcpy(&Rotation, pRotation, sizeof(OMX_CONFIG_ROTATIONTYPE));
+				 SetRotation();
+			 }
+			 break;
+		case OMX_IndexConfigEOS:
+			 {
+				 OMX_CONFIG_BOOLEANTYPE *pEOS;
+				 pEOS = (OMX_CONFIG_BOOLEANTYPE*)pStructure;
+				 OMX_CHECK_STRUCT(pEOS, OMX_CONFIG_BOOLEANTYPE, ret);
+				 fsl_osal_memcpy(&EOS, pEOS, sizeof(OMX_CONFIG_BOOLEANTYPE));
+			 }
+			 break;
+		default:
+			 ret = OMX_ErrorUnsupportedIndex;
+			 break;
+    }
+
+    return ret;
+}
+ 
+#if (ANDROID_VERSION <= ICS)
+OMX_ERRORTYPE VideoSource::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	LOG_DEBUG("VideoSource port number: %d\n", ports[CAPTURED_FRAME_PORT]->BufferNum());
+	if (bSendEOS == OMX_TRUE)
+		return OMX_ErrorNoMore;
+
+    while (ports[CAPTURED_FRAME_PORT]->BufferNum() > 0) {
+		ports[CAPTURED_FRAME_PORT]->GetBuffer(&pOutBufferHdr);
+		if(pOutBufferHdr != NULL) {
+			ret = SendBufferToDevice();
+			if (ret != OMX_ErrorNone)
+			{
+				LOG_ERROR("Send buffer to device fail.\n");
+				return ret;
+			}
+		}
+	}
+
+	ret = GetOneFrameFromDevice();
+	if (ret != OMX_ErrorNone) {
+		if (ret == OMX_ErrorNotReady)
+			return OMX_ErrorNone;
+		else
+			return ret;
+	}
+
+	ret = ProcessOutputBufferFlag();
+	if (ret != OMX_ErrorNone)
+		return ret;
+	ret = ProcessPreviewPort();
+	if (ret != OMX_ErrorNone)
+		return ret;
+	ret = SendOutputBuffer();
+	if (ret != OMX_ErrorNone)
+		return ret;
+
+	return OMX_ErrorNone;
+}
+
+#elif (ANDROID_VERSION >= JELLY_BEAN_42)
+OMX_ERRORTYPE VideoSource::ProcessDataBuffer()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	LOG_DEBUG("VideoSource port number: %d\n", ports[CAPTURED_FRAME_PORT]->BufferNum());
+	if (bSendEOS == OMX_TRUE || ports[CAPTURED_FRAME_PORT]->BufferNum() <= 0)
+		return OMX_ErrorNoMore;
+
+    ports[CAPTURED_FRAME_PORT]->GetBuffer(&pOutBufferHdr);
+    if(pOutBufferHdr != NULL) {
+        ret = SendBufferToDevice();
+        if (ret != OMX_ErrorNone)
+        {
+            LOG_ERROR("Send buffer to device fail.\n");
+            return ret;
+        }
+    }
+
+	ret = GetOneFrameFromDevice();
+	if (ret != OMX_ErrorNone)
+		return ret;
+	ret = ProcessOutputBufferFlag();
+	if (ret != OMX_ErrorNone)
+		return ret;
+	ret = ProcessPreviewPort();
+	if (ret != OMX_ErrorNone)
+		return ret;
+	ret = SendOutputBuffer();
+	if (ret != OMX_ErrorNone)
+		return ret;
+
+	return OMX_ErrorNone;
+}
+#endif
+
+OMX_ERRORTYPE VideoSource::ProcessOutputBufferFlag()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	if (bFirstFrame == OMX_TRUE) {
+		nBaseTime = GetFrameTimeStamp();
+		pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_STARTTIME;
+		bFirstFrame = OMX_FALSE;
+	}
+	pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+
+	return ret;
+}
+
+OMX_ERRORTYPE VideoSource::ProcessPreviewPort()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_BUFFERHEADERTYPE *pPreviewBufferHdr;
+
+	if (ports[PREVIEW_PORT]->IsEnabled() != OMX_TRUE)
+        return ret;
+
+    if (ports[PREVIEW_PORT]->BufferNum() > 0) {
+		ports[PREVIEW_PORT]->GetBuffer(&pPreviewBufferHdr);
+		if(pPreviewBufferHdr != NULL) {
+			OMX_PTR pFrame = NULL;
+			GetHwBuffer(pPreviewBufferHdr->pBuffer, &pFrame);
+			if(pFrame == NULL)
+				fsl_osal_memcpy(pPreviewBufferHdr->pBuffer, pOutBufferHdr->pBuffer, pOutBufferHdr->nFilledLen);
+			pPreviewBufferHdr->nFilledLen = pOutBufferHdr->nFilledLen;
+			pPreviewBufferHdr->nFlags = pOutBufferHdr->nFlags;
+			ports[PREVIEW_PORT]->SendBuffer(pPreviewBufferHdr);
+		}
+	}
+	
+	return ret;
+}
+
+OMX_ERRORTYPE VideoSource::SendOutputBuffer()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_TICKS nMediaTimestamp;
+
+	if (Capturing.bEnabled != OMX_TRUE)
+		pOutBufferHdr->nFilledLen = 0;
+
+	OMX_TIME_CONFIG_TIMESTAMPTYPE sCur;
+	OMX_INIT_STRUCT(&sCur, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+	ClockGetConfig(OMX_IndexConfigTimeCurrentMediaTime, &sCur);
+
+	nFrameDelay = GetDelayofFrame();
+
+	nMediaTimestamp = sCur.nTimestamp - nFrameDelay;
+	LOG_DEBUG("Media time diff: %lld\n", nMediaTimestamp - nMediaTimestampPre);
+	if (nMediaTimestamp <= 0) {
+		pOutBufferHdr->nFilledLen = 0;
+		nMediaTimestamp = 0;
+	}
+	if (nMediaTimestamp < nMediaTimestampPre)
+		nMediaTimestamp = nMediaTimestampPre + 1000;
+	nMediaTimestampPre = nMediaTimestamp;
+
+	pOutBufferHdr->nTimeStamp = nMediaTimestamp;
+ 
+	if (EOS.bEnabled == OMX_TRUE || nMediaTimestamp > nMaxDuration) {
+		bSendEOS = OMX_TRUE;
+		pOutBufferHdr->nFlags |= OMX_BUFFERFLAG_EOS;
+		pOutBufferHdr->nFilledLen = 0;
+		SendEvent(OMX_EventBufferFlag, 0, OMX_BUFFERFLAG_MAX_DURATION, NULL);
+		if (nMediaTimestamp)
+			printf("Video frame rate: %f\n", ((OMX_S64)nCaptureFrameCnt) * \
+					OMX_TICKS_PER_SECOND * 1000 / nMediaTimestamp / ((float)1000));
+	} else {
+        if (pOutBufferHdr->nFilledLen)
+            nCaptureFrameCnt ++;
+        LOG_DEBUG("VideoSource time: %lld\n", pOutBufferHdr->nTimeStamp);
+	}
+
+	if (nTimeLapseUs > 0) {
+		if (pOutBufferHdr->nTimeStamp > nNextLapseTS) {
+			nNextLapseTS += nTimeLapseUs;
+			pOutBufferHdr->nTimeStamp = nLastSendTS + nFrameInterval;
+			nLastSendTS += nFrameInterval;
+		} else {
+			pOutBufferHdr->nFilledLen = 0;
+			pOutBufferHdr->nTimeStamp = 0;
+		}
+	}
+
+	LOG_DEBUG("VideoSource send nFilledLen: %d\n", pOutBufferHdr->nFilledLen);
+	ports[CAPTURED_FRAME_PORT]->SendBuffer(pOutBufferHdr);
+	
+	return ret;
+}
+
+
+OMX_ERRORTYPE VideoSource::ClockGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+	{
+		switch (nParamIndex) {
+			case OMX_IndexConfigTimeCurrentMediaTime:
+				{
+					OMX_TIME_CONFIG_TIMESTAMPTYPE *pCur = (OMX_TIME_CONFIG_TIMESTAMPTYPE *)pStructure;
+					pCur->nTimestamp = GetFrameTimeStamp() - nBaseTime;
+				}
+				break;
+			default :
+				ret = OMX_ErrorUnsupportedIndex;
+				break;
+		}
+
+		return ret;
+	}
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+	{
+		switch (nParamIndex) {
+			case OMX_IndexConfigTimeCurrentMediaTime:
+				{
+					OMX_TIME_CONFIG_TIMESTAMPTYPE *pCur = (OMX_TIME_CONFIG_TIMESTAMPTYPE *)pStructure;
+					pCur->nTimestamp = GetFrameTimeStamp() - nBaseTime;
+				}
+				break;
+			default :
+				ret = OMX_ErrorUnsupportedIndex;
+				break;
+		}
+
+		return ret;
+	}
+
+	switch (nParamIndex) {
+		case OMX_IndexConfigTimeClockState:
+			{
+				OMX_TIME_CONFIG_CLOCKSTATETYPE *pClockState = (OMX_TIME_CONFIG_CLOCKSTATETYPE *)pStructure;
+				ret = OMX_GetConfig(hClockComp, OMX_IndexConfigTimeClockState, pClockState);
+			}
+			break;
+		case OMX_IndexConfigTimeCurrentMediaTime:
+			{
+				OMX_TIME_CONFIG_TIMESTAMPTYPE *pCur = (OMX_TIME_CONFIG_TIMESTAMPTYPE *)pStructure;
+				pCur->nPortIndex = TunnelInfo.nTunneledPort;
+				ret = OMX_GetConfig(hClockComp, OMX_IndexConfigTimeCurrentMediaTime, pCur);
+			}
+			break;
+		default :
+			ret = OMX_ErrorUnsupportedIndex;
+			break;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE VideoSource::ClockSetConfig(OMX_INDEXTYPE nParamIndex, OMX_TIME_CONFIG_TIMESTAMPTYPE *pTimeStamp)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+		return ret;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+		return ret;
+
+	pTimeStamp->nPortIndex = TunnelInfo.nTunneledPort;
+
+    switch (nParamIndex) {
+        case OMX_IndexConfigTimeClientStartTime:
+			ret = OMX_SetConfig(hClockComp, OMX_IndexConfigTimeClientStartTime,pTimeStamp);
+            break;
+        case OMX_IndexConfigTimeCurrentVideoReference:
+			ret = OMX_SetConfig(hClockComp, OMX_IndexConfigTimeCurrentVideoReference,pTimeStamp);
+            break;
+        default :
+            ret = OMX_ErrorUnsupportedIndex;
+            break;
+    }
+
+	return ret;
+}
+
+OMX_ERRORTYPE VideoSource::ProcessClkBuffer()
+{
+    if(ports[CLK_PORT]->IsEnabled() != OMX_TRUE)
+        return OMX_ErrorNoMore;
+
+	TUNNEL_INFO TunnelInfo;
+    ports[CLK_PORT]->GetTunneledInfo(&TunnelInfo);
+	OMX_COMPONENTTYPE *hClockComp = (OMX_COMPONENTTYPE *)TunnelInfo.hTunneledComp;
+    if(hClockComp == NULL)
+        return OMX_ErrorNoMore;
+
+    if(ports[CLK_PORT]->BufferNum() == 0)
+		return OMX_ErrorNoMore;
+
+	OMX_BUFFERHEADERTYPE *pClockBufferHdr;
+	ports[CLK_PORT]->GetBuffer(&pClockBufferHdr);
+	OMX_TIME_MEDIATIMETYPE *pTimeBuffer = (OMX_TIME_MEDIATIMETYPE*) pClockBufferHdr->pBuffer;
+
+	if ((pTimeBuffer->eUpdateType == OMX_TIME_UpdateClockStateChanged)
+		&& (pTimeBuffer->eState == OMX_TIME_ClockStateRunning))
+	{
+	}
+	else if (pTimeBuffer->eUpdateType == OMX_TIME_UpdateScaleChanged)
+	{
+	}
+	else
+	{
+		LOG_WARNING("Unknow clock buffer.\n");
+	}
+
+	ports[CLK_PORT]->SendBuffer(pClockBufferHdr);
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoSource::DoLoaded2Idle()
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    ret = OpenDevice();
+    if(ret != OMX_ErrorNone) {
+        CloseDevice();
+        SendEvent(OMX_EventError, ret, 0, NULL);
+        return ret;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoSource::DoIdle2Loaded()
+{
+ 	CloseDevice();
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoSource::ComponentReturnBuffer(
+        OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VideoSource::FlushComponent(
+        OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/VideoSource.h b/OpenMAXIL/src/component/common/VideoSource.h
new file mode 100755
index 0000000..aa7a197
--- /dev/null
+++ b/OpenMAXIL/src/component/common/VideoSource.h
@@ -0,0 +1,107 @@
+/**
+ *  Copyright (c) 2009-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file VideoSource.h
+ *  @brief Class definition of VideoSource Component
+ *  @ingroup VideoSource
+ */
+
+#ifndef VideoSource_h
+#define VideoSource_h
+
+#include "ComponentBase.h"
+
+#define NUM_PORTS 3
+#define PREVIEW_PORT 0
+#define CAPTURED_FRAME_PORT 1
+#define CLK_PORT 2
+
+class VideoSource : public ComponentBase {
+    public:
+		VideoSource();
+    protected:
+		OMX_PTR cameraPtr;
+		OMX_PTR cameraProxyPtr;
+		OMX_S32 nCameraId;
+		OMX_PTR previewSurface;
+        ROTATION eRotation;
+        OMX_U32 nFrameBufferMin;
+        OMX_U32 nFrameBufferActual;
+        OMX_BOOL bStoreMetaData;
+		OMX_BUFFERHEADERTYPE *pOutBufferHdr;
+        OMX_BUFFERSUPPLIERTYPE CapturePortSupplierType;
+        OMX_BUFFERSUPPLIERTYPE PreviewPortSupplierType;
+        OMX_VIDEO_PORTDEFINITIONTYPE sVideoFmt;
+		OMX_PARAM_SENSORMODETYPE SensorMode;
+		OMX_VIDEO_PARAM_PORTFORMATTYPE PortFormat;
+		OMX_CONFIG_WHITEBALCONTROLTYPE WhiteBalControl;
+		OMX_CONFIG_SCALEFACTORTYPE ScaleFactor;
+		OMX_CONFIG_EXPOSUREVALUETYPE ExposureValue;
+		OMX_CONFIG_BOOLEANTYPE Capturing;
+		OMX_CONFIG_BOOLEANTYPE AutoPauseAfterCapture;
+		OMX_CONFIG_ROTATIONTYPE Rotation;
+		const OMX_U16 * clientName;
+		OMX_S32 clientUID;
+	private:
+		OMX_ERRORTYPE InitComponent();
+        OMX_ERRORTYPE DeInitComponent();
+        OMX_ERRORTYPE InstanceInit();
+        OMX_ERRORTYPE InstanceDeInit();
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+		OMX_ERRORTYPE DoLoaded2Idle();
+		OMX_ERRORTYPE DoIdle2Loaded();
+		OMX_ERRORTYPE ComponentReturnBuffer(OMX_U32 nPortIndex);
+		OMX_ERRORTYPE FlushComponent(OMX_U32 nPortIndex);
+		OMX_ERRORTYPE ProcessDataBuffer();
+		OMX_ERRORTYPE ProcessOutputBufferFlag();
+		OMX_ERRORTYPE ProcessPreviewPort();
+		OMX_ERRORTYPE SendOutputBuffer();
+		OMX_ERRORTYPE ClockGetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+		OMX_ERRORTYPE ClockSetConfig(OMX_INDEXTYPE nParamIndex, \
+				OMX_TIME_CONFIG_TIMESTAMPTYPE *pTimeStamp);
+        OMX_ERRORTYPE ProcessClkBuffer();
+
+		/** Video source device related */
+        virtual OMX_ERRORTYPE InitSourceComponent() = 0;
+        virtual OMX_ERRORTYPE DeInitSourceComponent() = 0;
+        virtual OMX_ERRORTYPE OpenDevice() = 0;
+		virtual OMX_ERRORTYPE CloseDevice() = 0;
+		virtual OMX_ERRORTYPE SetSensorMode() = 0;
+		virtual OMX_ERRORTYPE SetVideoFormat() = 0;
+		virtual OMX_ERRORTYPE SetWhiteBalance() = 0;
+		virtual OMX_ERRORTYPE SetDigitalZoom() = 0;
+		virtual OMX_ERRORTYPE SetExposureValue() = 0;
+		virtual OMX_ERRORTYPE SetRotation() = 0;
+		virtual OMX_ERRORTYPE StartDevice() = 0;
+		virtual OMX_ERRORTYPE StopDevice() = 0;
+        virtual OMX_ERRORTYPE SendBufferToDevice() = 0;
+        virtual OMX_ERRORTYPE GetOneFrameFromDevice() = 0;
+        virtual OMX_TICKS GetDelayofFrame() = 0;
+        virtual OMX_TICKS GetFrameTimeStamp() = 0;
+
+		OMX_BOOL bFirstFrame;
+		OMX_TICKS nFrameDelay;
+		OMX_TICKS nBaseTime;
+		OMX_TICKS nMediaTimestampPre;
+		OMX_CONFIG_BOOLEANTYPE EOS;
+		OMX_U32 nCaptureFrameCnt;
+		OMX_BOOL bSendEOS;
+		OMX_TICKS nMaxDuration;
+		OMX_TICKS nTimeLapseUs;
+		OMX_TICKS nNextLapseTS;
+		OMX_TICKS nLastSendTS;
+		OMX_TICKS nFrameInterval;
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/WaitForResourcesState.cpp b/OpenMAXIL/src/component/common/WaitForResourcesState.cpp
new file mode 100755
index 0000000..ce4fe3c
--- /dev/null
+++ b/OpenMAXIL/src/component/common/WaitForResourcesState.cpp
@@ -0,0 +1,175 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "WaitForResourcesState.h"
+
+OMX_ERRORTYPE WaitForResourcesState::GetVersion(
+        OMX_STRING pComponentName, 
+        OMX_VERSIONTYPE* pComponentVersion, 
+        OMX_VERSIONTYPE* pSpecVersion, 
+        OMX_UUIDTYPE* pComponentUUID) 
+{
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE WaitForResourcesState::SendCommand(
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam1, 
+        OMX_PTR pCmdData)
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::FillThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ProcessBuffer() 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::GetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE WaitForResourcesState::SetConfig(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::UseBuffer(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes, 
+        OMX_U8* pBuffer) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::UseEGLImage(
+        OMX_BUFFERHEADERTYPE** ppBufferHdr, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        void *eglImage) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::AllocateBuffer(
+        OMX_BUFFERHEADERTYPE** ppBuffer, 
+        OMX_U32 nPortIndex,
+        OMX_PTR pAppPrivate, 
+        OMX_U32 nSizeBytes) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBuffer) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::TunnelRequest(
+        OMX_U32 nPort, 
+        OMX_HANDLETYPE hTunneledComp,
+        OMX_U32 nTunneledPort, 
+        OMX_TUNNELSETUPTYPE* pTunnelSetup) 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ToInvalid() 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ToLoaded() 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ToWaitForResources() 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ToIdle() 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ToPause() 
+{
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE WaitForResourcesState::ToExecuting() 
+{
+    return OMX_ErrorNone;
+
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/WaitForResourcesState.h b/OpenMAXIL/src/component/common/WaitForResourcesState.h
new file mode 100755
index 0000000..fbe2db3
--- /dev/null
+++ b/OpenMAXIL/src/component/common/WaitForResourcesState.h
@@ -0,0 +1,54 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file WaitForResourcesState.h
+ *  @brief class definition of WaitForResourcesState
+ *  @ingroup State
+ */
+
+#ifndef WaitForResourcesState_h
+#define WaitForResourcesState_h
+
+#include "State.h"
+
+class WaitForResourcesState : public State {
+    public:
+        WaitForResourcesState(ComponentBase *pBase) : State(pBase) {};
+        OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                 OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID);
+        OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData);
+        OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE ProcessBuffer();
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+        OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer);
+        OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                OMX_PTR pAppPrivate, void *eglImage);
+        OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes);
+        OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE TunnelRequest(OMX_U32 nPort, OMX_HANDLETYPE hTunneledComp,
+                                            OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup);
+    private:
+        OMX_ERRORTYPE ToInvalid();
+        OMX_ERRORTYPE ToLoaded();
+        OMX_ERRORTYPE ToWaitForResources();
+        OMX_ERRORTYPE ToIdle();
+        OMX_ERRORTYPE ToPause();
+        OMX_ERRORTYPE ToExecuting();
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/common/file_stream.h b/OpenMAXIL/src/component/common/file_stream.h
new file mode 100755
index 0000000..39cbd7e
--- /dev/null
+++ b/OpenMAXIL/src/component/common/file_stream.h
@@ -0,0 +1,36 @@
+/*
+***********************************************************************
+* Copyright 2009-2010 by Freescale Semiconductor, Inc.
+* All modifications are confidential and proprietary information
+* of Freescale Semiconductor, Inc. ALL RIGHTS RESERVED.
+***********************************************************************
+*
+*  History :
+*  Date             Author              Version    Description
+*
+*  Aug,2009         B18987              0.1        Initial Version
+*
+*/
+#ifndef FSL_MEDIA_STREAM_H
+#define FSL_MEDIA_STREAM_H
+
+/* Deprecated API, to be replaced by the new one. */
+typedef void* file_handle_t;
+
+typedef struct file_stream_s
+{
+    file_handle_t 	file_handle;
+     uint8 * 	file_path; 
+    
+    int32	(*pf_fopen)( struct file_stream_s *stream, const uint8 * mode, void * context); 
+    uint32  (*pf_fread)( struct file_stream_s *stream, void * buffer, uint32 nb, void * context);
+    int64  	(*pf_fseek)( struct file_stream_s *stream, int64 offset, int32 whence, void * context); /* whence: SEEK_SET, SEEK_CUR, or SEEK_END */
+    int64  	(*pf_ftell)( struct file_stream_s *stream, void * context); /* get current pointer postion of the stream */
+    int64 	(*pf_fsize)( struct file_stream_s *stream, void * context); /* get size of the entire file size */
+    int32 	(*pf_fclose)( struct file_stream_s *stream, void * context);
+   
+} file_stream_t;
+
+
+#endif
+  
diff --git a/OpenMAXIL/src/component/common/fsl_media_types.h b/OpenMAXIL/src/component/common/fsl_media_types.h
new file mode 100755
index 0000000..e61726c
--- /dev/null
+++ b/OpenMAXIL/src/component/common/fsl_media_types.h
@@ -0,0 +1,260 @@
+/*
+***********************************************************************
+* Copyright 2009-2013 by Freescale Semiconductor, Inc.
+* All modifications are confidential and proprietary information
+* of Freescale Semiconductor, Inc. ALL RIGHTS RESERVED.
+***********************************************************************
+*
+*  History :
+*  Date             Author              Version    Description
+*
+*  Oct,2009         Amanda              1.0        Initial Version
+*
+*/
+
+#ifndef _FSL_MMLAYER_MEDIA_TYPES_H
+#define _FSL_MMLAYER_MEDIA_TYPES_H
+
+
+/*
+ * Media types of a track. 
+ */
+typedef enum
+{    
+    MEDIA_TYPE_UNKNOWN = 0,
+    MEDIA_VIDEO,
+    MEDIA_AUDIO,
+    MEDIA_TEXT, /* subtitle text or stand-alone application, string-based or bitmap-based */
+    MEDIA_MIDI    
+}MediaType;
+
+
+#define UNKNOWN_CODEC_TYPE 0
+#define UNKNOWN_CODEC_SUBTYPE 0 /*  Value 0 is reserved for unknown subtypes or no subtypes. */
+
+/*
+ * Video codec types. 
+ */
+typedef enum
+{    
+    VIDEO_TYPE_UNKNOWN = 0,
+    VIDEO_UNCOMPRESSED, /* uncompressed video, every frame is a key frame */
+    VIDEO_MPEG2, /* MPEG-2 video, ISO/IEC 13818-2 */
+    VIDEO_MPEG4, /* MPEG-4 video, ISO/IEC 14496-2 */
+    VIDEO_MS_MPEG4, /* Microsoft MPEG-4 video*/   
+    VIDEO_H263, /* ITU-T H.263 */
+    VIDEO_H264, /* H.264, ISO/IEC 14496-10 */
+    VIDEO_MJPG, /* Motion-JPEG (M-JPEG) is a variant of the ISO JPEG specification 
+                for use with digital video streams.
+                Instead of compressing an entire image into a single bitstream, 
+                Motion-JPEG compresses each video field separately, returning 
+                the resulting JPEG bitstreams consecutively in a single frame.*/
+    VIDEO_DIVX, /* DivX video types*/
+    VIDEO_XVID,
+    VIDEO_WMV,    
+    VIDEO_SORENSON_H263, /* Sorenson Spark. Deprecated value. 
+                            Please use type "VIDEO_SORENSON" and subtype "VIDEO_SORENSON_SPARK.*/
+    VIDEO_FLV_SCREEN, /* Screen videos, by Adobe */    
+    VIDEO_ON2_VP, /* True Motion video types by On2 */
+    VIDEO_REAL, /* Real video types */
+    VIDEO_JPEG, /* ISO JPEG still image */
+    VIDEO_SORENSON /* Sorenson video types, including Sorenson Spark, SVQ1, SVQ3 etc */ 
+}VideoCodecType;
+
+
+/*
+ * Audio codec types. 
+ */
+typedef enum
+{    
+    AUDIO_TYPE_UNKNOWN = 0,
+    AUDIO_PCM, /* Linear PCM, little-endian or big-endian */
+    AUDIO_PCM_ALAW,
+    AUDIO_PCM_MULAW,
+    AUDIO_ADPCM,
+    AUDIO_MP3,  /* MPEG-1/2 Layer 1,2,3 */  
+    AUDIO_AAC,   /* MPEG-4 AAC, 14496-3 */
+    AUDIO_MPEG2_AAC, /* MPEG-2 AAC, 13818-7 */
+    AUDIO_AC3,
+    AUDIO_WMA,    
+    AUDIO_AMR,  /* Adaptive Multi-Rate audio */  
+    AUDIO_DTS,
+    AUDIO_VORBIS,
+    AUDIO_FLAC,
+    AUDIO_NELLYMOSER,
+    AUIDO_SPEEX,
+    AUDIO_REAL, /* Real audio types */
+    AUDIO_EC3,
+    
+}AudioCodecType;
+
+
+/*
+ * text types. 
+ */
+typedef enum
+{    
+    TXT_TYPE_UNKNOWN = 0,
+    TXT_3GP_STREAMING_TEXT, /* 3GP streaming text, timed code, string-based */
+    TXT_DIVX_FEATURE_SUBTITLE, /* DivX feature subtitle, bitmap-based */
+    TXT_DIVX_MENU_SUBTITLE, /* DivX menu subtitle, bitmap-based */
+    
+    //TXT_QT_TIMECODE, /* Quicktime timed code */
+    TXT_QT_TEXT,            /* Quicktime text */
+    TXT_SUBTITLE_SSA,       /* SubStation Alpha */
+    TXT_SUBTITLE_ASS,       /* Advanced SubStation Alpha */
+    TXT_SUBTITLE_TEXT                 
+}TextType;
+
+
+/*******************************************************************************
+ *  Video Subtypes.
+ *******************************************************************************/
+typedef enum
+{
+    VIDEO_DIVX3 = 1,    /* version 3*/
+    VIDEO_DIVX4,    /* version 4*/
+    VIDEO_DIVX5_6 /* version 5 & 6*/
+    
+}DivXVideoTypes; /* DivX video types */
+
+typedef enum
+{
+    VIDEO_MS_MPEG4_V2 = 1, /* Microsoft MPEG-4 video version 2, fourcc 'mp42'*/
+    VIDEO_MS_MPEG4_V3 /* Microsoft MPEG-4 video version 3, fourcc 'mp43' */
+    
+}MsMPEG4VideoTypes; /* Microsoft MPEG-4 video types */
+
+
+typedef enum
+{
+    MPEG4_VIDEO_AS_PROFILE  = 1 /* Fourcc 'RMP4', MPEG-4 AS profile */
+    
+}MPEG4VideoTypes; /* Microsoft MPEG-4 video types */
+
+
+typedef enum
+{
+    VIDEO_WMV7 = 1,
+    VIDEO_WMV8,
+    VIDEO_WMV9,
+    VIDEO_WMV9A,    /* Windows Media Video 9 Advanced Profile. The codec originally submitted for consideration as SMPTE VC1. 
+                    This is not VC1 compliant and is no longer supported by Microsoft */
+                    
+    VIDEO_WVC1      /* Microsoft's implementation of the SMPTE VC1 codec */
+    
+}WMVVideoTypes; /* WMV video types */
+
+
+typedef enum
+{
+    FLV_SCREEN_VIDEO = 1, /* Screen video version 1*/
+    FLV_SCREEN_VIDEO_2  /* Screen video version 2 */
+    
+}ScreenVideoTypes;  /* Screen video types by Adobe*/
+
+
+typedef enum
+{
+    VIDEO_VP6 = 1,
+    VIDEO_VP6A,
+    VIDEO_VP7,
+    VIDEO_VP8
+}On2VideoTypes; /* On2 video types */
+
+
+typedef enum
+{
+    REAL_VIDEO_RV10 = 1,
+    REAL_VIDEO_RV20,   
+    REAL_VIDEO_RV30,
+    REAL_VIDEO_RV40
+}RealVideoTypes;
+
+/*
+There are two flavors of Motion-JPEG currently in use. These two formats differ 
+based on their use of markers.
+Motion-JPEG format A supportsmarkers;Motion-JPEG format B does not.
+Each field of Motion-JPEG format A fully complies with the ISO JPEG specification, 
+and therefore supports application markers.*/
+typedef enum
+{
+    VIDEO_MJPEG_FORMAT_A = 1, /* Motion-JPEG(format A), support markers */
+    VIDEO_MJPEG_FORMAT_B,      /* Motion-JPEG(format B), not support markers */
+    VIDEO_MJPEG_2000
+
+}MotionJPEGVideoTypes;
+
+
+
+typedef enum
+{
+    VIDEO_SORENSON_SPARK = 1, /* Sorenson H.263, almost H.263 but not standard */
+    VIDEO_SVQ1, /* Sorenson Video 1, a custom beast */
+    VIDEO_SVQ3  /* Sorenson Video 3, SVQ3 is quite similar to H.264, not H.263 */
+    
+}SorensonVideoTypes;
+
+
+/*******************************************************************************
+ *  Audio Subtypes
+ *******************************************************************************/
+
+typedef enum
+{
+    REAL_AUDIO_SIPR = 1,
+    REAL_AUDIO_COOK,    
+    REAL_AUDIO_ATRC,
+    REAL_AUDIO_RAAC,
+}RealAudioTypes;
+
+typedef enum
+{
+    AUDIO_WMA1 = 1,
+    AUDIO_WMA2,
+    AUDIO_WMA3
+    
+}WMAAudioTypes; 
+
+typedef enum
+{
+    AUDIO_AMR_NB = 1, /* Adaptive Multi-Rate - narrow band */
+    AUDIO_AMR_WB, /* Adaptive Multi-Rate - Wideband */
+    AUDIO_AMR_WB_PLUS   /* Extended Adaptive Multi-Rate - Wideband */
+    
+}AmrAudioTypes;
+
+
+typedef enum
+{  
+    AUDIO_PCM_U8 = 1,   /* PCM, unsigned, 8 pits per sample */
+    AUDIO_PCM_S16LE,    /* PCM, signed little-endian, 16 bits per sample */
+    AUDIO_PCM_S24LE,    /* PCM, signed little-endian, 24 bits per sample */
+    AUDIO_PCM_S32LE,    /* PCM, signed little-endian, 32 bits per sample */
+
+    AUDIO_PCM_S16BE,    /* PCM, signed big-endian, 16 bits per sample */
+    AUDIO_PCM_S24BE,    /* PCM, signed big-endian, 24 bits per sample */
+    AUDIO_PCM_S32BE,     /* PCM, signed big-endian, 32 bits per sample */
+
+    AUDIO_PCM_DVD,    /* PCM, dvd, 24 bits per sample */
+    AUDIO_PCM_S8
+}PCMAudioTypes;
+
+
+typedef enum
+{
+    AUDIO_IMA_ADPCM = 1,  /* IMA 4:1 */
+    AUDIO_ADPCM_MS = 2  /* Microsoft ADPCM audio */
+
+}ADPCMAudioTypes;
+
+typedef enum
+{
+    AUDIO_ER_BSAC = 1, /* In fact we only care about whether it's BSAC or not */
+    AUDIO_AAC_RAW = 2, /* ADTS without sync word, such as in mp4 container */
+    AUDIO_AAC_ADTS = 3,
+    AUDIO_AAC_ADIF = 4
+}AACAudioTypes;
+
+#endif /* _FSL_MMLAYER_MEDIA_TYPES_H */
+
diff --git a/OpenMAXIL/src/component/common/fsl_muxer.h b/OpenMAXIL/src/component/common/fsl_muxer.h
new file mode 100755
index 0000000..0ca0f1f
--- /dev/null
+++ b/OpenMAXIL/src/component/common/fsl_muxer.h
@@ -0,0 +1,485 @@
+
+/***********************************************************************
+* Copyright (c) 2011-2013, Freescale Semiconductor, Inc.
+* All modifications are confidential and proprietary information
+* of Freescale Semiconductor, Inc. ALL RIGHTS RESERVED.
+***********************************************************************/
+ 
+/*
+ *
+ *  History :
+ *  Date             Author              Version    Description
+ *
+ *  Apr, 2011        Lou Zhan            1.0        Initial Version
+ *  Sep, 2011        Fang Hui            1.0.1      Fix ENGR157476. Support long duration.
+ *  Oct, 2011        Fang Hui            1.0.2      Add FslMuxerGetTrailerSize, Fix ENGR160218 
+ *	May, 2012        Fang Hui            1.0.3      Support geographic location meta data	 
+ */
+
+#ifndef _FSL_MUXER_H
+#define _FSL_MUXER_H
+
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN 
+#endif
+
+#include "fsl_types.h"
+
+#define MUXER_API_VERSION_STR "MUXER_API_01.00.04"
+
+
+/* Warning:
+ * It's not recommended to use any enum types as API arguments or return value!
+ * Please use data types that can explicitly tell the data length and asign 
+ * them the listed enum values. It's because different compilers can treat enum 
+ * as different types such as integer or unsinged char. If the muxer library 
+ * and plug-in(filter) are built by different compliers, the data length 
+ * mismatch will cause error.
+ */
+
+
+typedef void * FslMuxerHandle;
+
+#define MUXER_UNKNOWN_DURATION 0    /* Unknown sample duration */
+                                       
+#define MUXER_UNKNOWN_TIME_STAMP (-1) /* Unknown time stamp */ 
+                                       
+#define MUXER_UNKNOWN_TRACK_ID (0xFFFFFFFF) /* Unknown track id */ 
+ 
+
+/*
+ * Common error codes of muxers, 
+ * within the range [-100 , +100].
+ * Different muxers can extend the format specific errors OUTSIDE this range, 
+ * in their own API header files. 
+ */
+
+enum
+{
+    MUXER_SUCCESS  = 0,
+   
+    /* errors */
+    MUXER_ERR_UNKNOWN = -1, /* Unknow error, not captured by muxer logic */
+
+    MUXER_ERR_INVALID_API = -2, /* Some common API is not implemented properly */
+    
+    MUXER_NOT_IMPLEMENTED = -3, /* No support for some feature. */
+    MUXER_ERR_INVALID_PARAMETER = -4, /* parameters are invalid */
+    MUXER_ERR_INVALID_STATE_OPT = -5, /* api operation in wrong muxer state*/
+
+    MUXER_INSUFFICIENT_MEMORY = -6, /* memory not enough, causing general memory allocation failure */
+    MUXER_INSUFFICIENT_DATA = -7, /* data not enough, muxer need more data to go ahead */
+    
+    MUXER_FILE_OPEN_ERROR = -8, /* Can not open the movie file. */
+    MUXER_WRITE_ERROR = -9, /* Error on file writing. */
+    MUXER_SEEK_ERROR = -10, /* file system seeking error */
+
+    MUXER_ERR_INVALID_MEDIA = -11, /* invalid or unsupported media format */
+    MUXER_ERR_INVALID_CODEC = -12, /* invalid or unsupported codec format */
+
+    MUXER_WRITE_HEADER_FAILURE = -13, /* can not write movie header. */
+    MUXER_WRITE_INDEX_FAILURE = -14, /* can not write index table */
+
+    MUXER_ERR_TRACK_EXISTS = -15, /* track ID has already existed */
+    MUXER_ERR_INVALID_TRACK_ID = -16, /* invalid track ID or inexistent track  */
+    
+};
+
+
+
+
+/********************************************************************* 
+ * sample flags : 
+ * 32-bit long, properties of a sample read.
+ * The low 16 bits is reserved for common flag.
+ * Muxers can use high 16 bits to define their own flags.
+ ********************************************************************/
+#define FLAG_SYNC_SAMPLE         0x00000001  /* This is a sync sample */
+#define FLAG_SAMPLE_NOT_FINISHED 0X00000008  /* only partial sample in the input buffer */
+
+
+
+/********************************************************************* 
+ * Property Type
+*********************************************************************/
+typedef enum FSL_MUXER_PROPERTY_TYPE
+{
+    /* common */
+    PROPERTY_MODE = 0,              /* muxer mode. */
+    PROPERTY_TIMESCALE,             /* time-scale of track or movie. this is 
+                                     * the number of time units that pass in 
+                                     * one second. For example, a time 
+                                     * coordinate system that measures time in 
+                                     * sixtieths of a second has a time scale 
+                                     * of 60. Default is 1,000,000 */
+    PROPERTY_DURATION,              /* movie or track duration in time-scale */
+    PROPERTY_AVERAGE_BIT_RATE,      /* average bit rate of movie or track */
+    PROPERTY_CODEC_SPECIFIC_INFO,   /* codec specific information */
+    
+    /* video/text */
+    PROPERTY_FRAME_WIDTH = 64,      /* width of video frame or text window */
+    PROPERTY_FRAME_HEIGHT,          /* height of video frame or text window */
+    PROPERTY_FRAME_RATE,
+    PROPERTY_FRAME_ROTATE_DEGREE,   /* rotate degree of video frame */
+
+    /* audio */
+    PROPERTY_CHANNEL_NUMBER = 128,  /* audio channel number */
+    PROPERTY_SAMPLE_RATE,           /* audio sample rate */
+    PROPERTY_BIT_DEPTH,             /* audio sample bit depth */
+    PROPERTY_BLOCK_ALIGNMENT,       /* audio block alignment */
+    PROPERTY_BITS_PER_FRAME,        /* bits per audio frame */
+    PROPERTY_CHANNEL_MASK           /* audio channel mask */
+} PropertyID;
+
+
+/********************************************************************* 
+ * Metadata Type
+*********************************************************************/
+typedef enum FSL_MUXER_METADATA_TYPE
+{
+    METADATA_TITLE = 0,        /* title of the content */
+    METADATA_LANGUAGE,         /* language of movie or track, ISO 639-2/T code (DATA_FORMAT_UTF8) */
+    METADATA_GENRE,            /* genre of the content, mainly music */   
+    METADATA_ARTIST,           /* main artist and performer */
+    METADATA_COPYRIGHT,        /* copyright statement */
+    METADATA_COMMENTS,         /* comments of the content */
+    METADATA_CREATION_DATE,    /* date the movie content was created */
+    METADATA_RATING,           /* rating */
+    METADATA_ALBUM,            /* album name of music content */
+    METADATA_VCODECNAME,       /* video codec name */
+    METADATA_ACODECNAME = 10,  /* audio codec name */
+    METADATA_ARTWORK,          /* artwork of movie or music */
+    METADATA_COMPOSER,         /* name of composer */
+    METADATA_DIRECTOR,         /* name of movie's director */
+    METADATA_INFORMATION,      /* information about the movie */
+    METADATA_CREATOR,          /* name of the file creator or maker */
+    METADATA_PRODUCER,         /* name of producer */
+    METADATA_PERFORMER,        /* name of performer */
+    METADATA_REQUIREMENTS,     /* special hardware and software requirements */
+    METADATA_SONGWRITER,       /* name of songwriter */
+    METADATA_MOVIEWRITER = 20, /* name of movie's writer */
+    METADATA_TOOL,             /* writing application */
+    METADATA_DESCRIPTION,      /* movie description */
+    METADATA_LOCATION,         /* Geographic point location by coordinates as defined in ISO 6709:2008.*/
+    
+    METADATA_MAX
+} MetadataID;
+
+/********************************************************************* 
+ * User data format
+*********************************************************************/
+typedef enum FSL_DATA_FORMAT
+{
+    DATA_FORMAT_UTF8 = 0,       /* all strings in stream should be 
+                                 * convert to UTF-8 and output */
+
+    DATA_FORMAT_INT8,           /* signed 8-bit integer */
+    DATA_FORMAT_INT16,          /* signed 16-bit integer */
+    DATA_FORMAT_INT32,          /* signed 32-bit integer */
+    DATA_FORMAT_INT64,          /* signed 64-bit integer */
+    DATA_FORMAT_UINT8,          /* unsigned 8-bit integer */
+    DATA_FORMAT_UINT16,         /* unsigned 16-bit integer */
+    DATA_FORMAT_UINT32,         /* unsigned 32-bit integer */
+    DATA_FORMAT_UINT64,         /* unsigned 64-bit integer */
+    DATA_FORMAT_FLOAT32,        /* floating 32-bit point */
+    DATA_FORMAT_FLOAT64,        /* floating 64-bit point */
+    DATA_FORMAT_FRACTION,       /* fraction. shall be istance of FractionData */
+
+    DATA_FORMAT_JPEG,           /* JPEG picture */
+    DATA_FORMAT_PNG,            /* PNG picture */
+    DATA_FORMAT_BMP,            /* BMP picture */
+    DATA_FORMAT_GIF,            /* GIF picture */
+
+    DATA_FORMAT_GENERAL_BINARY, /* general binary */
+    
+    DATA_FORMAT_MAX
+} DataFormat;
+
+
+/********************************************************************* 
+ * Fraction structure
+*********************************************************************/
+typedef struct _FSL_FRACTION_DATA
+{
+    int32 numerator;
+    int32 denominator;
+} FractionData;
+
+
+/********************************************************************* 
+ * file I/O interface on a file or live source. 
+
+open
+    Open a local file or URL.
+    Arguments:
+        fileName [in] File name or url to open. 
+                      To open the movie source file, just set file name to NULL.
+                      To open another external file for some track (eg. MP4), set the url. 
+                      
+        mode [in] Open mode, same as libc. Such as "rb".
+        
+    Return value:
+        Handle of the opened file. NULL for failure.
+
+read
+    Read data from the file.
+    Arguments:
+        handle [in] Handle of the file.
+        buffer [in] Pointer to a block of memory, to receive the data.
+        size[in] Data size to read, in bytes.
+
+    Return value:
+        The total number of bytes successfully read.
+        If this number differs from the size parameter, either an error occured or the EOF was reached.
+
+
+seek    
+    Seek the stream.
+    Arguments:
+        handle [in] Handle of the file.
+        offset [in] The offset.
+                    To move to a position before the end-of-file, you need to pass a negative value in offset and set whence to SEEK_END. 
+
+        whence in]  The new position, measured in bytes from the beginning of the file, 
+                    is obtained by adding offset to the position specified by whence. 
+                    SEEK_SET - Set position equal to offset bytes. 
+                    SEEK_CUR - Set position to current location plus offset . 
+                    SEEK_END - Set position to end-of-file plus offset.
+    Return value:
+        Upon success, returns 0; otherwise, returns -1. 
+
+tell
+    Tell the position of the file pointer 
+    Arguments:
+        handle [in] Handle of the file.
+
+    Return value:
+        Returns the position of the file pointer in bytes; i.e., its offset into the file stream.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.        
+
+size
+    Tell the size of the entire file.
+    Arguments:
+        handle [in] Handle of the file.
+    Return value:
+        Returns the file size in bytes.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+check_available_bytes
+    Tell the availble bytes of the file. Especially useful for a live source file (streaming).
+    The muxer can decide not to read if cached data is not enough and so avoid reading failure in unexpected context.
+    For a local file, any bytes request from the muxer can be met as long as it's within the file range.
+    
+    Arguments:
+        handle [in] Handle of the file.
+        bytes_requested [in]    Bytes requested for further parsing. This information can help the application 
+                                to cache enough data before calling muxer API next time.
+                                If the muxer can not know the exact data size needed, set it to 0.
+        
+    Return value:
+        If the file source can always meet the data reading request unless EOF (eg. a local file or a pull-mode live source),
+        returns the data size from the current file pointer to the file end.
+
+        Otherwise (eg. a push-mode live source), returns the cached data size.        
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+close
+    Close the file.
+    Arguments:
+        handle [in] Handle of the file.        
+        
+    Return value:
+        Upon success, returns 0; otherwise, returns -1. 
+*/
+
+typedef void * FslFileHandle;
+
+/* Seek origin, position from where offset is added, same as libc */
+#ifndef FSL_SEEK_SET
+#define FSL_SEEK_SET 0 /* SEEK_SET, Beginning of file */
+#endif
+#ifndef FSL_SEEK_CUR
+#define FSL_SEEK_CUR 1  /* SEEK_CUR, Current position of file pointer */
+#endif
+#ifndef FSL_SEEK_END
+#define FSL_SEEK_END 2  /* SEEK_END, End of file */
+#endif
+
+typedef struct _FslFileStream
+{
+    FslFileHandle (*Open)(const uint8 * fileName, 
+                          const uint8 * mode, 
+                          void * context); /* Open a file or URL */
+    int32 	(*Close)(FslFileHandle handle, 
+                     void * context); /* Close the stream */   
+    uint32  (*Write)(FslFileHandle handle, 
+                     void * buffer, 
+                     uint32 size, 
+                     void * context); /* Write data to stream */
+    int32 	(*Seek)(FslFileHandle handle, 
+                    int64 offset, 
+                    int32 whence, 
+                    void * context);  /* Seek the stream */
+    int64  	(*Tell)(FslFileHandle handle, 
+                    void * context); /* Tell the current position from start of the stream */
+    
+    void * reserved[2];
+} FslFileStream;
+
+
+/********************************************************************* 
+ * Core muxer memory callback funtion pointer table.
+ *********************************************************************/
+typedef struct 
+{  
+    void* (*Calloc) (uint32 numElements, uint32 size);
+    void* (*Malloc) (uint32 size);
+    void  (*Free) (void * ptr);     
+    void* (*ReAlloc)(void * ptr, uint32 size);
+    
+    void * reserved[2];
+
+} MuxerMemoryOps; /* callback operation callback table */
+
+
+
+/*********************************************************************************************************
+ *                  API Funtion Prototypes List
+ *
+ * There are mandotory and optional APIs.
+ * A core muxer must implent the mandory APIs while need not implement the optional one. 
+ * And in its DLL entry point "FslMuxerInit", it shall set the not-implemented function pointers to NULL. 
+ *
+ *********************************************************************************************************/
+
+/***************************************************************************************
+ *
+ *                Creation & Deletion
+ *
+ ***************************************************************************************/
+/* all mandatory */
+typedef const char * (*FslMuxerApiVersionInfo)(uint32 *mainVersion, 
+                                                 uint32 *minorVersion);
+
+typedef const char * (*FslMuxerVersionInfo)();
+
+typedef int32 (*FslCreateMuxer)(bool isLive, 
+                                FslFileStream *streamOps, 
+                                MuxerMemoryOps *memOps, 
+                                void *context, 
+                                FslMuxerHandle *muxerHandle);
+
+typedef int32 (*FslDeleteMuxer)(FslMuxerHandle muxerHandle); 
+
+
+/************************************************************************************************************
+ *
+ *               Movie Level
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslMuxerSetMovieProperty)(FslMuxerHandle muxerHandle, 
+                                          PropertyID propertyId, 
+                                          DataFormat propertyFormat, 
+                                          void *propertyData, 
+                                          uint32 propertyDataLength);
+
+/* optional */
+typedef int32 (*FslMuxerSetMovieMetadata)(FslMuxerHandle muxerHandle, 
+                                          MetadataID metadataId, 
+                                          DataFormat metadataFormat, 
+                                          void *metadata, 
+                                          uint32 metadataLength);
+
+/* mandatory */
+typedef int32 (*FslMuxerWriteHeader)(FslMuxerHandle muxerHandle);
+
+/* mandatory */
+typedef int32 (*FslMuxerWriteTrailer)(FslMuxerHandle muxerHandle);
+
+/* mandatory */
+typedef int32 (*FslMuxerAddTrack)(FslMuxerHandle muxerHandle, 
+                                  uint32 mediaType, 
+                                  uint32 codecType, 
+                                  uint32 codecSubType, 
+                                  uint32 *trackId);
+
+/* optional */
+typedef int32 (*FslMuxerGetTrailerSize)(FslMuxerHandle muxerHandle, uint32 *tailerSize);
+
+
+/************************************************************************************************************
+ *
+ *              Track Level
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslMuxerSetTrackProperty)(FslMuxerHandle muxerHandle, 
+                                          uint32 trackId, 
+                                          PropertyID propertyId, 
+                                          DataFormat propertyFormat, 
+                                          void *propertyData, 
+                                          uint32 propertyDataLength);
+
+/* optional */
+typedef int32 (*FslMuxerSetTrackMetadata)(FslMuxerHandle muxerHandle, 
+                                          uint32 trackId, 
+                                          MetadataID metadataId, 
+                                          DataFormat metadataFormat, 
+                                          void *metadata, 
+                                          uint32 metadataLength);
+
+/* mandatory */
+typedef int32 (*FslMuxerAddSample)(FslMuxerHandle muxerHandle, 
+                                   uint32 trackId, 
+                                   uint8 *sampleBuffer, 
+                                   uint32 sampleSize, 
+                                   uint64 pts, 
+                                   uint64 dts, 
+                                   uint64 duration, 
+                                   uint32 flags);
+
+
+/************************************************************************************************************
+ *
+ *               DLL entry point (mandatory) - to query muxer interface
+ *
+ ************************************************************************************************************/
+enum /* API function ID */
+{
+    MUXER_API_VERSION = 0, 
+
+    /* creation & deletion */
+    MUXER_API_GET_VERSION_INFO     = 1,
+    MUXER_API_CREATE_MUXER         = 2,
+    MUXER_API_DELETE_MUXER         = 3,
+    
+    /* movie */
+    MUXER_API_SET_MOVIE_PROPERTY   = 20,
+    MUXER_API_SET_MOVIE_METADATA   = 21,
+    MUXER_API_WRITE_MOVIE_HEADER   = 22,
+    MUXER_API_WRITE_MOVIE_TRAILER  = 23,
+    MUXER_API_GET_MOVIE_TAILER_SIZE = 24,
+    
+    /* track */
+    MUXER_API_ADD_TRACK            = 30,
+    MUXER_API_SET_TRACK_PROPERTY   = 31,
+    MUXER_API_SET_TRACK_METADATA   = 32,
+    MUXER_API_ADD_SAMPLE           = 33,
+}; 
+
+/* prototype of entry point */
+typedef int32 (*tFslMuxerQueryInterface)(uint32 id, void ** func);
+
+/* 
+Every core muxer shall implement this function and tell a specific API function pointer.
+If the queried API is not implemented, the muxer shall set funtion pointer to NULL and return MUXER_SUCCESS. */
+
+EXTERN int32 FslMuxerQueryInterface(uint32 id, void ** func);
+
+
+#endif /* _FSL_MUXER_COMMON_H */
+
diff --git a/OpenMAXIL/src/component/common/fsl_parser.h b/OpenMAXIL/src/component/common/fsl_parser.h
new file mode 100755
index 0000000..7e77865
--- /dev/null
+++ b/OpenMAXIL/src/component/common/fsl_parser.h
@@ -0,0 +1,845 @@
+
+/***********************************************************************
+ * Copyright (c) 2009-2013, Freescale Semiconductor, Inc.
+ * All modifications are confidential and proprietary information
+ * of Freescale Semiconductor, Inc. ALL RIGHTS RESERVED.
+ ***********************************************************************/
+
+/*
+ *
+ *  History :
+ *  Date             Author              Version    Description
+ *
+ *  Oct, 2009        Amanda              1.0        Initial Version
+ *  Jan, 2010        Amanda              1.1        Extend user data ID.
+ *  Apr, 2010        Amanda              2.0        Further unify API, add entry point "FslParserInit" for DLL loading.
+ *  Mar, 2010        Larry               2.1        Add API for getting Meta data
+ *  Sep, 2011        Fanghui             2.2        Add USER_DATA_TRACKNUMBER, USER_DATA_TOTALTRACKNUMBER
+ *  May, 2012        Fanghui             2.3		Change FslParserGetProgramTracks definition
+ *  May, 2012        Fanghui             2.4		Add USER_DATA_LOCATION
+ *  Jun, 2012        Fanghui             2.5		Add USER_DATA_PROGRAMINFO
+ *  Sep, 2012        Fanghui             2.6		Add USER_DATA_PMT
+ */
+
+#ifndef _FSL_PARSER_COMMON_H
+#define _FSL_PARSER_COMMON_H
+
+#include "fsl_media_types.h"
+#include "fsl_types.h"
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+
+/* Warning:
+ * It's not recommended to use any enum types as API arguments or return value!
+ * Please use data types that can explicitly tell the data length and asign them the listed enum values.
+ * It's because different compilers can treat enum as different types such as integer or unsinged char.
+ * If the parser library and plug-in(filter) are built by different compliers, the data length mismatch
+ * will cause error.
+ */
+
+
+#ifdef __WINCE
+	#define DEBUGMSG
+    //#define PARSERMSG(cond, fmt, ...) DEBUGMSG(cond, _T(fmt), __VA_ARGS__))
+    //#define PARSERMSG(fmt, ...) DEBUGMSG(1, (_T(fmt),  __VA_ARGS__))
+    #define PARSERMSG(fmt, ...)
+#elif WIN32
+	#define DEBUGMSG(cond, fmt) printf fmt
+	#define PARSERMSG(fmt, ...) printf(fmt, __VA_ARGS__)
+#else /* linux platform */
+    #ifdef DEBUG
+        #define PARSERMSG printf
+    #else
+        #define PARSERMSG(fmt...)
+    #endif
+#endif
+
+
+typedef void * FslParserHandle;
+
+#define PARSER_INVALID_TRACK_NUMBER   (-1)
+
+#define PARSER_UNKNOWN_DURATION 0    /* Unknown movie, track or sample duration.
+                                       In some broadcasting sources (eg. MMS of broadcasting)
+                                       or recording clips, the movie or track's duration is set to 0.
+                                       It means the duration is unknown, not an empty clip or track.
+                                       The plug-in and the core parser shall just try to read as many sample as possible until EOF.*/
+
+#define PARSER_UNKNOWN_TIME_STAMP (-1) /* The time stamp is unknown. Usually used when the exact audio samples
+                                        are not known until after decoding. And so only audio decoder can give
+                                        a valid time stamp for each decoded audio frame.
+                                        However, for the 1st sample after seeking,
+                                        the parser MUST NOT use this value but shall give a valid time stamp.*/
+
+#define PARSER_UNKNOWN_BITRATE  0    /* unknown bitrate */
+
+
+/*
+ * Common error codes of parsers,
+ * within the range [-100 , +100].
+ * Different parsers can extend the format specific errors OUTSIDE this range,
+ * in their own API header files.
+ */
+
+enum
+{
+    PARSER_SUCCESS  = 0,
+    PARSER_EOS = 1,    /* reach the end of the track/movie */
+    PARSER_BOS = 2,    /* reach the beginning of the track/movie */
+    PARSER_NEED_MORE_DATA = 3,  /* No longer used. Shall use "PARSER_INSUFFICIENT_DATA" */
+
+    /* errors */
+    PARSER_ERR_UNKNOWN = -1, /* Unknown error, not captured by parser logic */
+
+    PARSER_ERR_INVALID_API = -2, /* Some common API is not implemented properly */
+
+    PARSER_NOT_IMPLEMENTED = -5, /* No support for some feature. */
+    PARSER_ERR_INVALID_PARAMETER = -6, /* parameters are invalid */
+
+    PARSER_INSUFFICIENT_MEMORY = -7, /* memory not enough, causing general memory allocation failure */
+    PARSER_INSUFFICIENT_DATA = -8, /* data not enough, parser need more data to go ahead */
+
+    PARSER_ERR_NO_OUTPUT_BUFFER = -9, /* can not get sample buffer for output */
+
+    PARSER_FILE_OPEN_ERROR = -10,
+    PARSER_READ_ERROR = -11, /* file read error, no need for further error concealment */
+    PARSER_WRITE_ERROR = -12,
+    PARSER_SEEK_ERROR = -13, /* file system seeking error */
+    PARSER_ILLEAGAL_FILE_SIZE = -14, /* file size is wrong or exceeds parser's capacity.
+                                       (some parser can not handle file larger than 2GB)*/
+    PARSER_ILLEAGAL_OPERATION =-15, /* the parser is being used improperly */
+
+    PARSER_ERR_INVALID_MEDIA = -20, /* invalid or unsupported media format */
+
+    PARSER_ERR_NOT_SEEKABLE = -21, /* This file is not seekable and does not support trick mode */
+
+    /* error concealment */
+    PARSER_ERR_CONCEAL_FAIL = -22, /* Error in bitstream and no sample can be found by error concealment.
+                                If the file is seekable, it's better to perform a seeking than further
+                                searching the bit stream for the next sample. */
+
+    PARSER_ERR_MEMORY_ACCESS_VIOLATION = -25, /* internal memory access error */
+
+    PARSER_ERR_TRACK_DISABLED = -30, /* The track is disabled and no media samples can be read from it. Only enabled track can output samples.*/
+    PARSER_ERR_INVALID_READ_MODE = -32, /* The reading mode is invalid, or some operation is illegal under current reading mode */
+
+
+};
+
+
+/*********************************************************************
+ * Reading mode. There are two options:
+ * a. File-based sample reading.
+ *      The reading order is same as that of track interleaving in the file.
+ *      Mainly for streaming application.
+ *
+ * b. Track-based sample reading.
+ *      Each track can be read independently from each other.
+ *
+ * Note:
+ * A parser may support only one reading mode. Setting it to a not-supported mode will fail.
+ * And it usually has a default reading mode.
+ ********************************************************************/
+enum
+{
+    PARSER_READ_MODE_FILE_BASED = 0, /* File-based sample reading.*/
+    PARSER_READ_MODE_TRACK_BASED /* Track-based sample reading.*/
+};
+
+
+
+
+/*********************************************************************
+ * sample flags :
+ * 32-bit long, properties of a sample read.
+ * The low 16 bits is reserved for common flag.
+ * Parsers can use high 16 bits to define their own flags.
+ ********************************************************************/
+#define FLAG_SYNC_SAMPLE 0X01  /* This is a sync sample */
+
+#define FLAG_SAMPLE_ERR_CONCEALED 0X02 /* This sample is got by error concealment, such as searching the bitstream.*/
+
+#define FLAG_SAMPLE_SUGGEST_SEEK 0X04   /* A seeking is suggested. Although sample is got by error concealment,
+                                        A/V sync may be impacted.
+                                        If the file is seekable, a seeking on all tracks can save the A/V sync.*/
+#define FLAG_SAMPLE_NOT_FINISHED 0X08   /* Sample is NOT finished at this call, large samples can be output in several calls. */
+
+#define FLAG_UNCOMPRESSED_SAMPLE 0X10 /* This is a uncompressed sample.
+                                        Warning:
+                                        A track may have both compressed & uncompressed samples.
+                                        But some AVI clips seem to abuse this flag, sync samples are mark as uncompressed,
+                                        although they are actually compressed ones.
+                                        Now suggest not care this flag.*/
+
+#define FLAG_SAMPLE_NEWSEG       0x20 /* A new segment of new sample */
+
+/*********************************************************************
+ * seeking flags :
+ when to seek, must set one of the following flags
+ ********************************************************************/
+#define SEEK_FLAG_NEAREST 0X01  /* Default flag. The actual seeked time shall be nearest one to the given time (can be later or earlier)*/
+#define SEEK_FLAG_NO_LATER  0X02    /* The actual seeked time shall be no later than the given time */
+#define SEEK_FLAG_NO_EARLIER 0X03    /* The actual seeked time shall be no earlier than the given time */
+#define SEEK_FLAG_FUZZ 0X04 /* Reserved. No accurate request on time but request quick response.
+                               Parsers shall optimize performances with other flags.*/
+
+
+/*********************************************************************
+ * direction for trick mode/sync sample reading
+ ********************************************************************/
+#define FLAG_BACKWARD   0X00
+#define FLAG_FORWARD    0x01
+
+/*********************************************************************
+ * file flags:
+ * return flags of GetFlag() in FslFileStream
+ * Return value for some cases:
+ *   0 local playback.(default)
+ *   1 illegal
+ *   2 http streaming, which source is seekable, but seek may affect the fluency of playback.
+ *   3 live streaming such as rtp or udp streaming.
+ ********************************************************************/
+#define FILE_FLAG_NON_SEEKABLE   0X01
+//file source should be read in sequence. You should not read from random position even if the file is seekable
+#define FILE_FLAG_READ_IN_SEQUENCE   0X02
+
+/*********************************************************************
+ * User data ID
+ * Some File level metadata
+*********************************************************************/
+typedef enum FSL_PARSER_USER_DATA_TYPE
+{
+    USER_DATA_TITLE = 0,      /* title of the content */
+    USER_DATA_LANGUAGE,       /* user data may tell the language of the movie as a string */
+    USER_DATA_GENRE,          /* genre of the content, mainly music */
+    USER_DATA_ARTIST,         /* main artist and performer */
+    USER_DATA_COPYRIGHT,      /* copyright statement */
+    USER_DATA_COMMENTS,       /* comments of the content */
+    USER_DATA_CREATION_DATE,  /* date the movie content was created */
+    USER_DATA_RATING,         /* ? */
+    USER_DATA_ALBUM,          /* album name of music content */
+    USER_DATA_VCODECNAME,     /* video codec name */
+    USER_DATA_ACODECNAME,     /* audio codec name */
+    USER_DATA_ARTWORK,        /* artwork of movie or music */
+    USER_DATA_COMPOSER,       /* name of composer */
+    USER_DATA_DIRECTOR,       /* name of movie's director */
+    USER_DATA_INFORMATION,    /* information about the movie */
+    USER_DATA_CREATOR,        /* name of the file creator or maker */
+    USER_DATA_PRODUCER,       /* name of producer */
+    USER_DATA_PERFORMER,      /* name of performer */
+    USER_DATA_REQUIREMENTS,   /* special hardware and software requirements */
+    USER_DATA_SONGWRITER,     /* name of songwriter */
+    USER_DATA_MOVIEWRITER,    /* name of movie's writer */
+    USER_DATA_TOOL,           /* writing application */
+    USER_DATA_DESCRIPTION,    /* movie description */
+    USER_DATA_TRACKNUMBER,    /* track number */
+    USER_DATA_TOTALTRACKNUMBER,    /* total track number */
+    USER_DATA_LOCATION,       /* geographic location */  
+
+    /* add more? */
+    USER_DATA_CHAPTER_MENU,     /* Chapter Menu information */
+    USER_DATA_FORMATVERSION,   /* container format version */
+    USER_DATA_PROFILENAME,     /* Profile Name (DivX)*/
+
+    USER_DATA_PROGRAMINFO,     /* program info for ts */
+    USER_DATA_PMT,             /* program map table */
+
+    USER_DATA_AUD_ENC_DELAY,   /* audio encoding delay */
+    USER_DATA_AUD_ENC_PADDING, /* audio encoding padding */
+    USER_DATA_DISCNUMBER,      /* disc number */
+
+    USER_DATA_MAX
+} UserDataID;
+
+/*********************************************************************
+ * User data format
+*********************************************************************/
+typedef enum FSL_PARSER_USER_DATA_FORMAT
+{
+    USER_DATA_FORMAT_UTF8,         /* all strings in stream should be convert to UTF-8 and output */
+
+    USER_DATA_FORMAT_INT_BE,
+    USER_DATA_FORMAT_UINT_BE,
+    USER_DATA_FORMAT_FLOAT32_BE,
+    USER_DATA_FORMAT_FLOAT64_BE,
+
+    USER_DATA_FORMAT_JPEG,
+    USER_DATA_FORMAT_PNG,
+    USER_DATA_FORMAT_BMP,
+    USER_DATA_FORMAT_GIF,
+
+    USER_DATA_FORMAT_CHAPTER_MENU,
+    /* add more? */
+
+    USER_DATA_FORMAT_PROGRAM_INFO,
+    USER_DATA_FORMAT_PMT_INFO,
+
+    USER_DATA_FORMAT_INT_LE,
+    USER_DATA_FORMAT_UINT_LE,
+
+    USER_DATA_FORMAT_MAX
+} UserDataFormat;
+
+
+/*********************************************************************
+ * file I/O interface on a file or live source.
+
+open
+    Open a local file or URL.
+    Arguments:
+        fileName [in] File name or url to open.
+                      To open the movie source file, just set file name to NULL.
+                      To open another external file for some track (eg. MP4), set the url.
+
+        mode [in] Open mode, same as libc. Such as "rb".
+
+    Return value:
+        Handle of the opened file. NULL for failure.
+
+read
+    Read data from the file.
+    Arguments:
+        handle [in] Handle of the file.
+        buffer [in] Pointer to a block of memory, to receive the data.
+        size[in] Data size to read, in bytes.
+
+    Return value:
+        The total number of bytes successfully read.
+        If this number differs from the size parameter, either an error occurred or the EOF was reached.
+
+
+seek
+    Seek the stream.
+    Arguments:
+        handle [in] Handle of the file.
+        offset [in] The offset.
+                    To move to a position before the end-of-file, you need to pass a negative value in offset and set whence to SEEK_END.
+
+        whence in]  The new position, measured in bytes from the beginning of the file,
+                    is obtained by adding offset to the position specified by whence.
+                    SEEK_SET - Set position equal to offset bytes.
+                    SEEK_CUR - Set position to current location plus offset .
+                    SEEK_END - Set position to end-of-file plus offset.
+    Return value:
+        Upon success, returns 0; otherwise, returns -1.
+
+tell
+    Tell the position of the file pointer
+    Arguments:
+        handle [in] Handle of the file.
+
+    Return value:
+        Returns the position of the file pointer in bytes; i.e., its offset into the file stream.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+size
+    Tell the size of the entire file.
+    Arguments:
+        handle [in] Handle of the file.
+    Return value:
+        Returns the file size in bytes.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+check_available_bytes
+    Tell the availble bytes of the file. Especially useful for a live source file (streaming).
+    The parser can decide not to read if cached data is not enough and so avoid reading failure in unexpected context.
+    For a local file, any bytes request from the parser can be met as long as it's within the file range.
+
+    Arguments:
+        handle [in] Handle of the file.
+        bytes_requested [in]    Bytes requested for further parsing. This information can help the application
+                                to cache enough data before calling parser API next time.
+                                If the parser can not know the exact data size needed, set it to 0.
+
+    Return value:
+        If the file source can always meet the data reading request unless EOF (eg. a local file or a pull-mode live source),
+        returns the data size from the current file pointer to the file end.
+
+        Otherwise (eg. a push-mode live source), returns the cached data size.
+        If error occurs or this feature can not be supported (eg. broadcast application), returns -1.
+
+close
+    Close the file.
+    Arguments:
+        handle [in] Handle of the file.
+
+    Return value:
+        Upon success, returns 0; otherwise, returns -1.
+*/
+
+typedef void * FslFileHandle;
+
+/* Seek origin, position from where offset is added, same as libc */
+#ifndef FSL_SEEK_SET
+#define FSL_SEEK_SET 0 /* SEEK_SET, Beginning of file */
+#endif
+#ifndef FSL_SEEK_CUR
+#define FSL_SEEK_CUR 1  /* SEEK_CUR, Current position of file pointer */
+#endif
+#ifndef FSL_SEEK_END
+#define FSL_SEEK_END 2  /* SEEK_END, End of file */
+#endif
+
+typedef struct _FslFileStream
+{
+    FslFileHandle (*Open)(const uint8 * fileName, const uint8 * mode, void * context); /* Open a file or URL */
+    int32 	(*Close)(FslFileHandle handle, void * context); /* Close the stream */
+    uint32  (*Read)(FslFileHandle handle, void * buffer, uint32 size, void * context); /* Read data from the stream */
+    int32 	(*Seek)(FslFileHandle handle, int64 offset, int32 whence, void * context);  /* Seek the stream */
+    int64  	(*Tell)(FslFileHandle handle, void * context); /* Tell the current position from start of the stream */
+    int64 	(*Size)(FslFileHandle handle, void * context); /* Get the size of the entire stream */
+    int64   (*CheckAvailableBytes)(FslFileHandle handle, int64 bytesRequested, void * context); /* How many bytes cached but not read yet */
+    uint32  (*GetFlag)(FslFileHandle handle, void * context);
+    void * reserved[1];
+
+} FslFileStream;
+
+
+/*********************************************************************
+ * Core parser memory callback function pointer table.
+ *********************************************************************/
+typedef struct
+{
+    void* (*Calloc) (uint32 numElements, uint32 size);
+    void* (*Malloc) (uint32 size);
+    void  (*Free) (void * ptr);
+    void* (*ReAlloc)(void * ptr, uint32 size); /* necessary for index scanning!*/
+
+}ParserMemoryOps; /* callback operation callback table */
+
+
+/********************************************************************************************************
+Callback functions to request/release an output buffer.
+Usually, the core parser requests an output buffer, fill the media data and return it to the application
+on GetNextSample(). But, on flushing (eg. on seek or deletion), the core parser need explicitly release
+all buffers not returned yet.
+
+RequestBuffer
+    Request an output buffer.
+
+    Arguments:
+        streamNum [in] Track number, 0-based.
+
+        size [in,out] The requested buffer size as input, and the size actually got as output, both in bytes.
+                      The actually got size can be larger than the requested size, and the parser can
+                      make full use of the buffer.
+
+        bufContext [out] A buffer context from the application. The parser shall not modify it.
+
+        parserContext [in] The parser context from the application, got on parser creation.
+
+    Return value:
+        Buffer pointer. NULL for failure.
+
+
+ReleaseBuffer
+    Release an output buffer explicitly.
+
+    Arguments:
+        streamNum [in] Track number, 0-based.
+        pBuffer [in] Buffer to release.
+        bufContext [in] The buffer context from the application, got on requestBuffer().
+        parserContext [in] The parser context from the application, got on parser creation.
+
+    Return value: none.
+
+********************************************************************************************************/
+
+typedef struct
+{
+    uint8* (*RequestBuffer) (uint32 streamNum, uint32 *size, void ** bufContext, void * parserContext);
+    void (*ReleaseBuffer) (uint32 streamNum, uint8 * pBuffer, void * bufContext, void * parserContext);
+
+}ParserOutputBufferOps;
+
+typedef struct _ChapterInfo
+{
+    uint32 ChapterUID;      /* UID for chapter */
+    uint32 dwStartTime;     /* Chapter's Start time in ms unit */
+    uint32 dwStopTime;      /* Chapter's Stop time in ms unit */
+    uint32 dwTitleSize;     /* Chapter Title size in byte */
+    char * Title;           /* The string for Title */
+}ChapterInfo;
+
+typedef struct _strChapterMenu
+{
+    uint32 EditionUID;      /* UID for Movie/Edition */
+    uint32 EdtionFlags;     /* Flags for Movie/Edition */
+    uint32 dwChapterNum;    /* Total number of chapters in this Edition */
+    ChapterInfo * pChapterList; /* the pointer to Chapter information list */
+}ChapterMenu;
+
+typedef struct _ProgramInfo
+{
+    uint32 m_dwChannel; //program_number in spec, for a broadcast channel.
+    uint32 m_dwPID; //program PID(packet ID)
+}ProgramInfo;
+
+typedef struct _ProgramInfoMenu
+{
+    uint32 m_dwProgramNum;
+    ProgramInfo m_atProgramInfo[0];
+}ProgramInfoMenu;
+
+
+#define INVALID_PID         (uint32)(-1)
+#define INVALID_CHANNEL     (uint32)(-1)
+
+
+typedef struct _TrackInfo
+{
+    uint32 m_dwTrackNo; //global track No
+    uint32 m_dwPID;     //PID(packet ID)
+    uint8 m_byLan[3];   //language
+    uint32 m_dwReserved[16];    
+}TrackInfo;
+
+//single program map table
+typedef struct _PMTInfo
+{
+    uint32 m_dwChannel; //program_number in spec, for a broadcast channel.
+    uint32 m_dwPID;     //PID(packet ID)
+    uint32 m_dwReserved[8];
+    uint32 m_dwTrackNum;    
+    TrackInfo *m_ptTrackInfo;
+}PMTInfo;
+
+//total program map table
+typedef struct _PMTInfoList
+{
+    uint32 m_dwProgramNum;
+    PMTInfo *m_ptPMTInfo;
+}PMTInfoList;
+
+/*********************************************************************************************************
+ *                  API Function Prototypes List
+ *
+ * There are mandatory and optional APIs.
+ * A core parser must implement the mandatory APIs while need not implement the optional one.
+ * And in its DLL entry point "FslParserInit", it shall set the not-implemented function pointers to NULL.
+ *
+ *********************************************************************************************************/
+
+/***************************************************************************************
+ *
+ *                Creation & Deletion
+ *
+ ***************************************************************************************/
+/* mandatory */
+typedef const char * (*FslParserVersionInfo)();
+
+typedef int32  (*FslCreateParser)(  bool isLive,
+                                    FslFileStream * streamOps,
+                                    ParserMemoryOps * memOps,
+                                    ParserOutputBufferOps * outputBufferOps,
+                                    void * context,
+                                    FslParserHandle * parserHandle);
+
+typedef int32 (*FslDeleteParser)(FslParserHandle parserHandle);
+
+
+/***************************************************************************************
+ *
+ *                 Index Table Loading, Export & Import
+ *
+ ***************************************************************************************/
+/* optional */
+typedef int32 (*FslParserInitializeIndex)(FslParserHandle parserHandle); /*Loading index from the movie file */
+
+typedef int32 (*FslParserImportIndex)(  FslParserHandle parserHandle, /* Import index from outside */
+                                        uint8 * buffer,
+                                        uint32 size);
+
+typedef int32 (*FslParserExportIndex)(  FslParserHandle parserHandle,
+                                        uint8 * buffer,
+                                        uint32 *size);
+
+
+/************************************************************************************************************
+ *
+ *               Movie Properties
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserIsSeekable)(FslParserHandle parserHandle, bool * seekable);
+
+typedef int32 (*FslParserGetMovieDuration)(FslParserHandle parserHandle,  uint64 * usDuration);
+
+typedef int32 (*FslParserGetUserData)(  FslParserHandle parserHandle,
+                                        uint32 userDataId,
+                                        uint16 ** unicodeString,
+                                        uint32 * stringLength);
+
+typedef int32 (*FslParserGetMetaData)(  FslParserHandle parserHandle,
+                                        UserDataID userDataId,
+                                        UserDataFormat * userDataFormat,
+                                        uint8 ** userData,
+                                        uint32 * userDataLength);
+
+typedef int32 (*FslParserGetNumTracks)(FslParserHandle parserHandle, uint32 * numTracks); /* single program interface */
+
+typedef int32 (*FslParserGetNumPrograms)(FslParserHandle parserHandle, uint32 * numPrograms); /* multiple program interface */
+typedef int32 (*FslParserGetProgramTracks)( FslParserHandle parserHandle,
+                                            uint32 programNum,
+                                            uint32 * numTracks,
+                                            uint32 ** ppTrackNumList);
+
+/************************************************************************************************************
+ *
+ *              General Track Properties
+ *
+ ************************************************************************************************************/
+typedef int32 (*FslParserGetTrackType)( FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint32 * mediaType,
+                                        uint32 * decoderType,
+                                        uint32 * decoderSubtype);
+
+typedef int32 (*FslParserGetTrackDuration)( FslParserHandle parserHandle,
+                                            uint32 trackNum,
+                                            uint64 * usDuration); /* Duration 0 means an empty track */
+
+typedef int32 (*FslParserGetLanguage)(  FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint8 * threeCharCode);
+
+/* optional */
+typedef int32 (*FslParserGetBitRate)(   FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint32 * bitrate);
+
+typedef int32 (*FslParserGetDecSpecificInfo)(   FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint8 ** data,
+                                                uint32 * size);
+
+
+/************************************************************************************************************
+ *
+ *               Video Properties, only for video media
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef    int32 (*FslParserGetVideoFrameWidth)(FslParserHandle parserHandle, uint32 trackNum, uint32 *width);
+
+typedef    int32 (*FslParserGetVideoFrameHeight)(FslParserHandle parserHandle, uint32 trackNum, uint32 *height);
+
+/* optional */
+typedef    int32 (*FslParserGetVideoFrameRate)( FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * rate,
+                                                uint32 * scale);
+
+typedef    int32 (*FslParserGetVideoFrameRotation)(FslParserHandle parserHandle, uint32 trackNum, uint32 *rotation);
+
+/************************************************************************************************************
+ *
+ *               Audio Properties
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserGetAudioNumChannels)(  FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * numchannels);
+
+typedef int32 (*FslParserGetAudioSampleRate)(   FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * sampleRate);
+
+typedef int32 (*FslParserGetAudioBitsPerSample)(FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * bitsPerSample); /* bit depth */
+
+/* optional */
+typedef int32 (*FslParserGetAudioBlockAlign)(FslParserHandle parserHandle,
+                                             uint32 trackNum,
+                                             uint32 * blockAlign);
+
+typedef int32 (*FslParserGetAudioBitsPerFrame)( FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 *bits_per_frame); /* for Real audio */
+
+typedef int32 (*FslParserGetAudioChannelMask)(  FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * channelMask); /* for WMA audio */
+
+
+/************************************************************************************************************
+ *
+ *               Text/Subtitle Properties
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserGetTextTrackWidth)(FslParserHandle parserHandle,
+                                            uint32 trackNum,
+                                            uint32 * width);
+
+typedef int32 (*FslParserGetTextTrackHeight)(   FslParserHandle parserHandle,
+                                                uint32 trackNum,
+                                                uint32 * height);
+
+
+/************************************************************************************************************
+ *
+ *               Sample Reading, Seek & Trick Mode
+ *
+ * NOTE: if the core parser can not give a valid sample duration,
+ *       setting the sample duration to ZERO is a good choice.
+ *
+ ************************************************************************************************************/
+/* mandatory */
+typedef int32 (*FslParserGetReadMode)(FslParserHandle parserHandle, uint32 * readMode);
+typedef int32 (*FslParserSetReadMode)(FslParserHandle parserHandle, uint32 readMode);
+
+typedef int32 (*FslParserEnableTrack)(  FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        bool enable);
+
+typedef int32 (*FslParserGetNextSample)(FslParserHandle parserHandle,
+                                        uint32 trackNum,
+                                        uint8 ** sampleBuffer,
+                                        void  ** bufferContext,
+                                        uint32 * dataSize,
+                                        uint64 * usStartTime,
+                                        uint64 * usDuration,
+                                        uint32 * sampleFlags); /* Only for track-based sample reading. The application tell which track to read.*/
+
+
+/* optional */
+typedef int32 (*FslParserGetNextSyncSample)(FslParserHandle parserHandle,
+                                            uint32 direction,
+                                            uint32 trackNum,
+                                            uint8 ** sampleBuffer,
+                                            void  ** bufferContext,
+                                            uint32 * dataSize,
+                                            uint64 * usStartTime,
+                                            uint64 * usDuration,
+                                            uint32 * flags); /* only for trick mode on video track */
+
+
+typedef int32 (*FslParserGetFileNextSample)(FslParserHandle parserHandle,
+                                            uint32 * trackNum,
+                                            uint8 ** sampleBuffer,
+                                            void  ** bufferContext,
+                                            uint32 * dataSize,
+                                            uint64 * usStartTime,
+                                            uint64 * usDuration,
+                                            uint32 * sampleFlags); /* Only for file-based sample reading. The parser tell which track is being read.*/
+
+
+/* optional */
+typedef int32 (*FslParserGetFileNextSyncSample)(FslParserHandle parserHandle,
+                                            uint32 direction,
+                                            uint32 * trackNum,
+                                            uint8 ** sampleBuffer,
+                                            void  ** bufferContext,
+                                            uint32 * dataSize,
+                                            uint64 * usStartTime,
+                                            uint64 * usDuration,
+                                            uint32 * flags); /* only for trick mode on video track */
+
+
+/* mandatory */
+typedef int32 (*FslParserSeek)( FslParserHandle parserHandle,
+                                uint32 trackNum,
+                                uint64 * usTime,
+                                uint32 flag);
+
+
+
+
+/************************************************************************************************************
+ *
+ *               DLL entry point (mandatory) - to query parser interface
+ *
+ ************************************************************************************************************/
+enum /* API function ID */
+{
+    /* creation & deletion */
+    PARSER_API_GET_VERSION_INFO  = 0,
+    PARSER_API_CREATE_PARSER     = 1,
+    PARSER_API_DELETE_PARSER     = 2,
+
+    /* index export/import */
+    PARSER_API_INITIALIZE_INDEX  = 10,
+    PARSER_API_IMPORT_INDEX      = 11,
+    PARSER_API_EXPORT_INDEX      = 12,
+
+
+    /* movie properties */
+    PARSER_API_IS_MOVIE_SEEKABLE    = 20,
+    PARSER_API_GET_MOVIE_DURATION   = 21,
+    PARSER_API_GET_USER_DATA       = 22,
+    PARSER_API_GET_META_DATA       = 23,
+
+    PARSER_API_GET_NUM_TRACKS       = 25,
+
+    PARSER_API_GET_NUM_PROGRAMS     = 26,
+    PARSER_API_GET_PROGRAM_TRACKS   = 27,
+
+
+    /* generic track properties */
+    PARSER_API_GET_TRACK_TYPE                   = 30,
+    PARSER_API_GET_TRACK_DURATION               = 31,
+    PARSER_API_GET_LANGUAGE                     = 32,
+    PARSER_API_GET_BITRATE                      = 36,
+    PARSER_API_GET_DECODER_SPECIFIC_INFO        = 37,
+
+
+    /* video properties */
+    PARSER_API_GET_VIDEO_FRAME_WIDTH        = 50,
+    PARSER_API_GET_VIDEO_FRAME_HEIGHT       = 51,
+    PARSER_API_GET_VIDEO_FRAME_RATE         = 52,
+    PARSER_API_GET_VIDEO_FRAME_ROTATION     = 53,
+
+
+    /* audio properties */
+    PARSER_API_GET_AUDIO_NUM_CHANNELS       = 60,
+    PARSER_API_GET_AUDIO_SAMPLE_RATE        = 61,
+    PARSER_API_GET_AUDIO_BITS_PER_SAMPLE    = 62,
+
+    PARSER_API_GET_AUDIO_BLOCK_ALIGN        = 65,
+    PARSER_API_GET_AUDIO_CHANNEL_MASK       = 66,
+    PARSER_API_GET_AUDIO_BITS_PER_FRAME     = 67,
+
+
+    /* text/subtitle properties */
+    PARSER_API_GET_TEXT_TRACK_WIDTH = 80,
+    PARSER_API_GET_TEXT_TRACK_HEIGHT= 81,
+
+    /* sample reading, seek & trick mode */
+    PARSER_API_GET_READ_MODE = 100,
+    PARSER_API_SET_READ_MODE = 101,
+
+    PARSER_API_ENABLE_TRACK = 105,
+
+    PARSER_API_GET_NEXT_SAMPLE = 110,
+    PARSER_API_GET_NEXT_SYNC_SAMPLE = 111,
+
+
+    PARSER_API_GET_FILE_NEXT_SAMPLE = 115,
+    PARSER_API_GET_FILE_NEXT_SYNC_SAMPLE = 116,
+
+
+    PARSER_API_SEEK  = 120
+
+
+};
+
+/* prototype of entry point */
+typedef int32 (*tFslParserQueryInterface)(uint32 id, void ** func);
+
+/*
+Every core parser shall implement this function and tell a specific API function pointer.
+If the queried API is not implemented, the parser shall set funtion pointer to NULL and return PARSER_SUCCESS. */
+
+EXTERN int32 FslParserQueryInterface(uint32 id, void ** func);
+
+
+#endif /* _FSL_PARSER_COMMON_H */
+
diff --git a/OpenMAXIL/src/component/common/fsl_types.h b/OpenMAXIL/src/component/common/fsl_types.h
new file mode 100755
index 0000000..7393d30
--- /dev/null
+++ b/OpenMAXIL/src/component/common/fsl_types.h
@@ -0,0 +1,57 @@
+/*
+***********************************************************************
+* Copyright 2009-2010 by Freescale Semiconductor, Inc.
+* All modifications are confidential and proprietary information
+* of Freescale Semiconductor, Inc. ALL RIGHTS RESERVED.
+***********************************************************************
+*
+*  History :
+*  Date             Author              Version    Description
+*
+*  Aug,2009         B06543              0.1        Initial Version
+*
+*/
+
+#ifndef _FSL_MMLAYER_TYPES_H
+#define _FSL_MMLAYER_TYPES_H
+
+#include <stdio.h>
+
+#ifndef uint64
+#ifdef WIN32
+	typedef  unsigned __int64 uint64;	
+#else
+	typedef  unsigned long long uint64;	
+#endif
+#endif /*uint64*/
+
+
+#ifndef int64
+#ifdef WIN32	
+	typedef  __int64 int64;
+#else	
+	typedef  long long int64;
+#endif
+#endif /*int64*/
+
+typedef unsigned long uint32;
+typedef unsigned short uint16;
+typedef unsigned char uint8;
+typedef long int32;
+typedef short int16;
+typedef char int8;
+
+#ifndef bool
+    #define bool int
+#endif
+
+#ifndef TRUE
+    #define TRUE 1    
+#endif
+
+#ifndef FALSE
+    #define FALSE 0    
+#endif
+
+#endif /* _FSL_MMLAYER_TYPES_H */
+
diff --git a/OpenMAXIL/src/component/common/fsl_unia.h b/OpenMAXIL/src/component/common/fsl_unia.h
new file mode 100755
index 0000000..d7f331b
--- /dev/null
+++ b/OpenMAXIL/src/component/common/fsl_unia.h
@@ -0,0 +1,306 @@
+
+/***********************************************************************
+ * Copyright (c) 2011-2013, Freescale Semiconductor, Inc.
+ * All modifications are confidential and proprietary information
+ * of Freescale Semiconductor, Inc. ALL RIGHTS RESERVED.
+ ***********************************************************************/
+
+/*
+ *
+ *  History :
+ *  Date             Author              Version    Description
+ *
+ *  Sep, 2011        Lyon               1.0        Initial Version
+ *
+ */
+
+#ifndef _Uni_ADEC_WRAPPER_H_
+#define _Uni_ADEC_WRAPPER_H_
+
+#include "fsl_types.h"
+
+
+#ifdef __cplusplus
+#define EXTERN extern "C"
+#else
+#define EXTERN
+#endif
+
+
+/* Warning:
+ * It's not recommended to use any enum types as API arguments or return value!
+ * Please use data types that can explicitly tell the data length and asign them the listed enum values.
+ * It's because different compilers can treat enum as different types such as integer or unsinged char.
+ * If the ACodec library and plug-in(filter) are built by different compliers, the data length mismatch
+ * will cause error.
+ */
+ typedef void * UniACodec_Handle;
+//typedef void * UniACodec_Config;
+//typedef void * UniACodec_Info;
+
+/*
+ * Common error codes of ACodec,
+ * within the range [-100 , +100].
+ * Different ACodecs can extend the format specific errors OUTSIDE this range,
+ * in their own API header files.
+ */
+typedef enum
+{
+    ACODEC_SUCCESS = 0,
+      
+    ACODEC_ERROR_STREAM,
+    ACODEC_PARA_ERROR,
+    ACODEC_INSUFFICIENT_MEM,
+    ACODEC_ERR_UNKNOWN,
+    ACODEC_PROFILE_NOT_SUPPORT,
+    ACODEC_INIT_ERR,
+    
+    ACODEC_NOT_ENOUGH_DATA = 0x100,
+    ACODEC_CAPIBILITY_CHANGE = 0x200, /* output format changes, caller should reget format from getparameter API */
+    ACODEC_END_OF_STREAM = 0x300, /* no output */
+} UA_ERROR_TYPE;
+
+
+/* Parameter type to Set /Get */
+typedef enum
+{
+/* Set parmameters */
+/* common  */
+    UNIA_SAMPLERATE= 0,
+    UNIA_CHANNEL,
+    UNIA_FRAMED,
+    UNIA_DEPTH,
+    UNIA_CODEC_DATA,
+    UNIA_BITRATE,
+    UNIA_DOWNMIX_STEREO,
+    UNIA_STREAM_TYPE,
+    UNIA_CHAN_MAP_TABLE,
+    //UNIA_CHANNEL_MASK,
+    
+/* dedicate for wma */
+    UNIA_WMA_BlOCKALIGN= 0x100,
+    UNIA_WMA_VERSION,
+
+/*dedicate for RealAudio */
+	UNIA_RA_FLAVOR_INDEX = 0x110,
+	UNIA_RA_FRAME_BITS,
+	
+/* Get parmameters */
+    UNIA_CODEC_DESCRIPTION= 0x200, 
+    UNIA_OUTPUT_PCM_FORMAT,
+    UNIA_CONSUMED_LENGTH,
+    UNIA_OUTBUF_ALLOC_SIZE,  /* used for allocate output buffer outside */
+    
+    UA_TYPE_MAX
+} UA_ParaType;
+
+
+
+typedef enum
+{
+  UA_CHANNEL_FRONT_MONO,
+  UA_CHANNEL_FRONT_LEFT,
+  UA_CHANNEL_FRONT_RIGHT,
+  
+  UA_CHANNEL_REAR_CENTER,
+  UA_CHANNEL_REAR_LEFT,
+  UA_CHANNEL_REAR_RIGHT,
+
+  UA_CHANNEL_LFE,
+
+  UA_CHANNEL_FRONT_CENTER,
+  UA_CHANNEL_FRONT_LEFT_CENTER,
+  UA_CHANNEL_FRONT_RIGHT_CENTER,
+
+  UA_CHANNEL_SIDE_LEFT,
+  UA_CHANNEL_SIDE_RIGHT,
+
+  UA_CHANNEL_MAX
+  
+}UA_CHANNEL_LAYOUT;
+
+typedef enum
+{
+    STREAM_UNKNOW = 0,
+    STREAM_ADTS,
+    STREAM_ADIF,
+    STREAM_RAW,  
+	
+} STREAM_TYPE;
+
+/*********************************************************************
+ * Uni Audio memory callback funtion pointer table.
+ *********************************************************************/
+typedef struct
+{
+    void* (*Calloc) (uint32 numElements, uint32 size);
+    void* (*Malloc) (uint32 size);
+    void  (*Free) (void * ptr);
+    void* (*ReAlloc)(void * ptr, uint32 size);
+}UniACodecMemoryOps; /* callback operation callback table */
+
+typedef struct
+{
+  uint32 samplerate;
+  uint32 width;
+  uint32 depth;
+  uint32 channels;
+  uint32 endian;
+  bool interleave;
+  uint32 layout[UA_CHANNEL_MAX];
+  bool chan_pos_set;  // indicate if channel position is set outside or use codec default
+}UniAcodecOutputPCMFormat;
+
+
+typedef struct 
+{
+     uint32 size;		/* The size in bytes of the data in this buffer */
+     char * buf;		/* Buffer pointer */
+}UniACodecParameterBuffer;
+
+typedef struct
+{   uint32 size;
+    uint32* channel_table[10]; //assume the max channel is less than 10
+}CHAN_TABLE;
+
+typedef struct
+{
+    union {
+        uint32 samplerate;
+        uint32 channels;
+        uint32 bitrate;
+        uint32 depth;
+        uint32 blockalign;
+        uint32 version;
+        bool downmix;
+        bool framed;
+        UniACodecParameterBuffer codecData;
+        STREAM_TYPE stream_type;
+        CHAN_TABLE chan_map_tab;
+		
+		/* for real audio decoder */
+        uint32 frame_bits;
+		uint32 flavor_index;
+		
+        char ** codecDesc;
+        UniAcodecOutputPCMFormat outputFormat;
+        uint32 consumed_length;
+        uint32 outbuf_alloc_size;
+    };
+}UniACodecParameter;
+
+
+/* typedef struct
+{
+    uint32 (*wma10dec_callback) (void *state, uint64 offset, uint32 * num_bytes, uint8 **ppData, void* pAppContext, uint32 *compress_payload);
+
+}UniACodecCallbackOps;
+*/
+/*********************************************************************************************************
+ *                  API Funtion Prototypes List
+ *
+ * There are mandotory and optional APIs.
+ * A core wrapper must implent the mandory APIs while need not implement the optional one.
+ * And in its DLL entry point "UniACodecInit", it shall set the not-implemented function pointers to NULL.
+ *
+ *********************************************************************************************************/
+/************************************************************************************************************
+ *
+ *               DLL entry point (mandatory) - to query ACodec interface
+ *
+ ************************************************************************************************************/
+/* prototype of entry point */
+typedef int32 (*tUniACodecQueryInterface)(uint32 id, void ** func);
+
+/*
+Every core ACodec shall implement this function and tell a specific API function pointer.
+If the queried API is not implemented, the ACodec shall set funtion pointer to NULL and return ACODEC_SUCCESS. */
+
+EXTERN int32 UniACodecQueryInterface(uint32 id, void ** func);
+
+
+/*******************************************************************
+ * Codec Version Info
+*******************************************************************/
+typedef const char * (*UniACodecVersionInfo)();
+
+/*******************************************************************
+ * Codec  Create & Delete
+*******************************************************************/
+typedef UniACodec_Handle (*UniACodecCreate)(  UniACodecMemoryOps * memOps);
+
+typedef int32 (*UniACodecDelete) (UniACodec_Handle pua_handle);
+
+typedef int32 (*UniACodecReset) (UniACodec_Handle pua_handle);
+
+/*******************************************************************
+ * Codec  Initializaation
+*******************************************************************/
+/*typedef int32  (*UniACodecInit) (UniACodec_Handle pua_handle,
+                                    uint8 * InputBuffer,
+                                    uint32 inputLength,
+                                    uint8 * codec_data);
+*/
+/*******************************************************************
+ * Codec Query Memory
+*******************************************************************/
+//typedef int32  (*UniACodecQueryMem) (UniACodec_Config pADec_config);
+
+/*******************************************************************
+ * Codec set  & get parameter
+*******************************************************************/
+typedef int32 (*UniACodecSetParameter) (UniACodec_Handle pua_handle, UA_ParaType ParaType, UniACodecParameter * parameter);
+
+typedef int32 (*UniACodecGetParameter) (UniACodec_Handle pua_handle, UA_ParaType ParaType, UniACodecParameter * parameter);
+
+/*******************************************************************
+ * Codec decode & encode frame
+*******************************************************************/
+typedef int32 (*UniACodec_decode_frame) (UniACodec_Handle pua_handle,
+                                         uint8 * InputBuf,
+                                         uint32 InputSize,
+                                         uint32 * offset,
+                                         uint8 ** OutputBuf,
+                                         uint32 *OutputSize);
+
+/*
+typedef int32 (*UniACodec_encode_frame) (UniACodec_Handle pua_handle,
+                                         uint8 * InputBuf,
+                                         uint32 InputLength,
+                                         uint32 * out_buf
+                                         uint32 end_flag
+                                         UA_ERROR_TYPE error_ret);
+*/
+
+typedef char * (*UniACodec_get_last_error) (UniACodec_Handle pua_handle);
+
+/*******************************************************************
+ *
+API function ID
+*******************************************************************/
+
+enum /* API function ID */
+{
+    ACODEC_API_GET_VERSION_INFO  = 0x0,
+    /* creation & deletion */
+    ACODEC_API_CREATE_CODEC     = 0x1,
+    ACODEC_API_DELETE_CODEC     = 0x2,
+    /* reset */
+    ACODEC_API_RESET_CODEC = 0x3,
+
+    /* set parameter */
+    ACODEC_API_SET_PARAMETER  = 0x10,
+    ACODEC_API_GET_PARAMETER  = 0x11,
+
+    /* process frame */
+    ACODEC_API_DEC_FRAME    = 0x20,
+    //ACODEC_API_ENC_FRAME    = 0x21,
+
+    ACODEC_API_GET_LAST_ERROR = 0x1000,
+
+};
+
+
+
+#endif /* _Uni_ADEC_WRAPPER_H_ */
+
diff --git a/OpenMAXIL/src/component/common/video_frame_visitor.h b/OpenMAXIL/src/component/common/video_frame_visitor.h
new file mode 100755
index 0000000..20110c0
--- /dev/null
+++ b/OpenMAXIL/src/component/common/video_frame_visitor.h
@@ -0,0 +1,29 @@
+/**
+ *  Copyright (c) 2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+typedef enum {
+    FMT_NONE,
+    YUV420Planar,
+    YUV420PackedPlanar,
+    YUV420SemiPlanar,
+    YUV422Planar,
+    YUV422PackedPlanar,
+    YUV422SemiPlanar
+} VIDEO_FMT;
+
+typedef struct {
+    void * (*init)();
+    int (*deinit)(void *handle);
+    int (*report)(void *handle, int idx, int width, int height, VIDEO_FMT fmt, char *data);
+} VFV_INTERFACE;
+
+extern "C" {
+int CreateVFVInterface(VFV_INTERFACE *interface);
+}
+
diff --git a/OpenMAXIL/src/component/vpu_dec_v2/Android.mk b/OpenMAXIL/src/component/vpu_dec_v2/Android.mk
new file mode 100755
index 0000000..7b5cf35
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_dec_v2/Android.mk
@@ -0,0 +1,28 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	VpuDecComponent.cpp
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+ 
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) -DDPB_FIX_APP -DDPB_FIX -Dbool $(LOCAL_PATH)/../vpu_wrapper
+
+LOCAL_SHARED_LIBRARIES := lib_omx_common_v2_arm11_elinux \
+                          lib_omx_osal_v2_arm11_elinux \
+                          lib_omx_utils_v2_arm11_elinux \
+			  lib_omx_res_mgr_v2_arm11_elinux \
+			  libvpu \
+			  lib_vpu_wrapper
+
+LOCAL_PRELINK_MODULE := false
+	
+LOCAL_MODULE:= lib_omx_vpu_dec_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/OpenMAXIL/src/component/vpu_dec_v2/Makefile b/OpenMAXIL/src/component/vpu_dec_v2/Makefile
new file mode 100755
index 0000000..0c2e0ab
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_dec_v2/Makefile
@@ -0,0 +1,39 @@
+#####################################################################################
+#
+#   Copyright (c) 2010-2011, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+#Set the root directory
+OMX_ROOT_DIR=../../../..
+
+#Set the component directory
+OMX_COMPONENT_DEFINE_DIR=..
+
+# Set the BUILD information 
+include $(OMX_COMPONENT_DEFINE_DIR)/Makefile_component.defines
+
+COMPONENT_NAME=vpu_dec_v2
+COMPONENT_SO_NAME=lib_omx_$(COMPONENT_NAME)_$(PROCESSOR)_$(OSTYPE).so
+
+#LFLAGS+= -l_WMV789_dec_$(PROCESSOR)_$(OSTYPE)
+
+SOURCE_FILES = $(SRC_DIR)/VpuDecComponent.cpp
+
+LFLAGS +=-l_vpu_wrapper -lvpu
+LFLAGS +=-L$(BSP_RELATED_LIB_DIR)               
+
+#Include rules Makefile
+include $(OMX_COMPONENT_DEFINE_DIR)/Makefile.rules	
+
+
+
diff --git a/OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.cpp b/OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.cpp
new file mode 100755
index 0000000..0cf63d7
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.cpp
@@ -0,0 +1,4207 @@
+/**
+ *  Copyright (c) 2010-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "VpuDecComponent.h"
+#include "Mem.h"
+#include "sys/ioctl.h"
+#include "fcntl.h"
+
+#define Align(ptr,align)	(((OMX_U32)(ptr)+(align)-1)/(align)*(align))
+#define IPU_FOURCC(a,b,c,d) (((OMX_U32)(a)<<0)|((OMX_U32)(b)<<8)|((OMX_U32)(c)<<16)|((OMX_U32)(d)<<24))
+#define Max(a,b)	((OMX_S32)(a)>=(OMX_S32)(b)?(a):(b))
+
+//#define VPU_COMP_DIS_POST			//disable post-process
+#define DEFAULT_BUF_IN_CNT			0x1
+#define DEFAULT_BUF_IN_SIZE		(1024*1024)
+#define DEFAULT_BUF_OUT_POST_ZEROCNT (0)
+#define DEFAULT_BUF_OUT_POST_CNT	(5)	//5 will bring better performance than 4
+#define DEFAULT_BUF_OUT_DEC_CNT	(3)
+#define DEFAULT_BUF_OUT_CNT		((DEFAULT_BUF_OUT_POST_ZEROCNT)+(DEFAULT_BUF_OUT_DEC_CNT))
+#define MAX_POST_QUEUE_SIZE		(VPU_DEC_MAX_NUM_MEM)
+
+#define DEFAULT_FRM_WIDTH			(176)
+#define DEFAULT_FRM_HEIGHT		(144)
+#define DEFAULT_FRM_RATE			(30 * Q16_SHIFT)
+
+#define DEFAULT_BUF_DELAY			(0)
+
+#define MAX_FRAME_NUM	(VPU_DEC_MAX_NUM_MEM)
+
+#if (ANDROID_VERSION >= ICS) && defined(MX5X)
+#define FRAME_ALIGN		(64) //set 64 for gpu y/u/v alignment in iMX5 ICS 
+#define CHROMA_ALIGN            (4096)
+#elif (ANDROID_VERSION == GINGER_BREAD)
+#define FRAME_ALIGN		(16) //set 16 for gpu y/u/v alignment in iMX5 GingerBread
+#define CHROMA_ALIGN            (1)
+#else
+#define FRAME_ALIGN		(32) //set 32 for gpu y/u/v alignment 
+#define CHROMA_ALIGN            (1)  //default, needn't align
+#endif
+
+//nOutBufferCntDec=nMinFrameBufferCount + FRAME_SURPLUS
+#if 0
+#define FRAME_SURPLUS	(0)
+#define FRAME_MIN_FREE_THD		(((nOutBufferCntDec-2)>2)?(nOutBufferCntDec-2):2)//(nOutBufferCntDec-1)
+#else
+#define FRAME_SURPLUS	(2)
+//#define FRAME_MIN_FREE_THD	((nOutBufferCntDec-FRAME_SURPLUS)-1)	// eg => FrameBuffers must be > (nMinFrameBufferCount - 1)
+/*
+to improve performance with limited frame buffers, we may set smaller threshold for FRAME_MIN_FREE_THD
+for smaller FRAME_MIN_FREE_THD, vpu wrapper may return VPU_DEC_NO_ENOUGH_BUF_***
+*/
+#define FRAME_MIN_FREE_THD ((nOutBufferCntDec-FRAME_SURPLUS)-3) //adjust performance: for clip: Divx5_1920x1080_30fps_19411kbps_MP3_44.1khz_112kbps_JS.avi
+#endif
+#define FRAME_POST_MIN_FREE_THD	(2)//(nOutBufferCntPost-2)
+#define POST_INDEX_EOS			(0x1)
+#define POST_INDEX_MOSAIC		(0x2)
+
+//#define VPUDEC_IN_PORT 		IN_PORT
+#define VPUDEC_OUT_PORT 	OUT_PORT
+
+#undef NULL
+#define NULL (0)
+#define INVALID (0xFFFFFFFF)		// make sure the match between "return FILTER_INPUT_CONSUMED" and SetInputBuffer()
+typedef int INT32;
+typedef unsigned int UINT32;
+
+#define VPU_DEC_COMP_DROP_B	//drop B frames automatically
+#ifdef VPU_DEC_COMP_DROP_B
+#define DROP_B_THRESHOLD	30000
+#endif
+
+//#define VPU_COMP_DBGLOG
+#ifdef VPU_COMP_DBGLOG
+#define VPU_COMP_LOG	printf
+#else
+#define VPU_COMP_LOG(...)
+#endif
+
+//#define VPU_COMP_API_DBGLOG
+#ifdef VPU_COMP_API_DBGLOG
+#define VPU_COMP_API_LOG	printf
+#else
+#define VPU_COMP_API_LOG(...)
+#endif
+
+//#define VPU_COMP_ERR_DBGLOG
+#ifdef VPU_COMP_ERR_DBGLOG
+#define VPU_COMP_ERR_LOG	printf
+#define ASSERT(exp)	if(!(exp)) {printf("%s: %d : assert condition !!!\r\n",__FUNCTION__,__LINE__);}
+#else
+#define VPU_COMP_ERR_LOG LOG_ERROR //(...)
+#define ASSERT(...)
+#endif
+
+//#define VPU_COMP_DEBUG
+#ifdef VPU_COMP_DEBUG
+#define MAX_NULL_LOOP	(0xFFFFFFF)	
+#define MAX_DEC_FRAME  (0xFFFFFFF)
+#define MAX_YUV_FRAME  (200)
+#endif
+
+#define VPU_COMP_NAME_H263DEC	"OMX.Freescale.std.video_decoder.h263.hw-based"
+#define VPU_COMP_NAME_SORENSONDEC	"OMX.Freescale.std.video_decoder.sorenson.hw-based"
+#define VPU_COMP_NAME_AVCDEC		"OMX.Freescale.std.video_decoder.avc.hw-based"
+#define VPU_COMP_NAME_MPEG2DEC	"OMX.Freescale.std.video_decoder.mpeg2.hw-based"
+#define VPU_COMP_NAME_MPEG4DEC	"OMX.Freescale.std.video_decoder.mpeg4.hw-based"
+#define VPU_COMP_NAME_WMVDEC		"OMX.Freescale.std.video_decoder.wmv.hw-based"
+#define VPU_COMP_NAME_DIV3DEC	"OMX.Freescale.std.video_decoder.div3.hw-based"
+#define VPU_COMP_NAME_DIV4DEC	"OMX.Freescale.std.video_decoder.div4.hw-based"
+#define VPU_COMP_NAME_DIVXDEC	"OMX.Freescale.std.video_decoder.divx.hw-based"
+#define VPU_COMP_NAME_XVIDDEC	"OMX.Freescale.std.video_decoder.xvid.hw-based"
+#define VPU_COMP_NAME_RVDEC		"OMX.Freescale.std.video_decoder.rv.hw-based"
+#define VPU_COMP_NAME_MJPEGDEC	"OMX.Freescale.std.video_decoder.mjpeg.hw-based"
+#define VPU_COMP_NAME_AVS	"OMX.Freescale.std.video_decoder.avs.hw-based"
+#define VPU_COMP_NAME_VP8	"OMX.Freescale.std.video_decoder.vp8.hw-based"
+// Add the VPX component for StageFright.
+#define VPU_COMP_NAME_VPX	"OMX.Freescale.std.video_decoder.vpx.hw-based"
+#define VPU_COMP_NAME_MVC	"OMX.Freescale.std.video_decoder.mvc.hw-based"
+
+//#define VPU_COMP_POST_DEBUG
+#ifdef VPU_COMP_POST_DEBUG
+#include <sys/time.h>
+static struct timeval time_beg;
+static struct timeval time_end;
+static unsigned long long total_time;
+static unsigned long long total_cnt;
+static void time_init()
+{
+	total_time=0;
+	total_cnt=0;
+	return;
+}
+static void time_start()
+{
+	gettimeofday(&time_beg, 0);
+	return;
+}
+static void time_stop()
+{
+	unsigned int tm_1, tm_2;
+	gettimeofday(&time_end, 0);
+
+	tm_1 = time_beg.tv_sec * 1000000 + time_beg.tv_usec;
+	tm_2 = time_end.tv_sec * 1000000 + time_end.tv_usec;
+	total_cnt++;
+	total_time = total_time + (tm_2-tm_1);
+	printf("post-process time: %d (us) \r\n",(tm_2-tm_1));
+	return;
+}
+static void time_report()
+{
+	double avg;
+	if(total_cnt)
+	{
+		avg=total_time/total_cnt;
+		printf(" average post-process time: %f (ms)\r\n",avg/1000);
+	}
+	return;
+}
+#define TIMER_INIT	time_init()
+#define TIMER_START time_start()
+#define TIMER_STOP	time_stop()
+#define TIMER_REPORT	time_report()
+#define VPU_COMP_POST_LOG printf
+#else
+#define TIMER_INIT
+#define TIMER_START
+#define TIMER_STOP
+#define TIMER_REPORT
+#define VPU_COMP_POST_LOG
+#endif
+
+//#define USE_PROCESS_SEM		//for debug : use semaphore between process
+#ifdef USE_PROCESS_SEM
+#include <semaphore.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+sem_t* sharedmem_sem_open(fsl_osal_s32 pshared, fsl_osal_u32 value);
+efsl_osal_return_type_t fsl_osal_sem_init_process(fsl_osal_sem *sem_obj,fsl_osal_s32 pshared,fsl_osal_u32 value);
+sem_t* sharedmem_sem_open(fsl_osal_s32 pshared, fsl_osal_u32 value)
+{
+	int fd;
+	int ret;
+	sem_t *pSem = NULL;
+	char *shm_path, shm_file[256];
+	shm_path = getenv("CODEC_SHM_PATH");      /*the CODEC_SHM_PATH is on a memory map the fs */
+	
+	if (shm_path == NULL)
+		strcpy(shm_file, "/dev/shm");   /* default path */
+	else
+		strcpy(shm_file, shm_path);
+
+	strcat(shm_file, "/");
+	//strcat(shm_file, "codec.shm");
+	strcat(shm_file, "vpudec.shm");
+	fd = open(shm_file, O_RDWR, 0777);
+	if (fd < 0)
+	{
+		/* first thread/process need codec protection come here */
+		fd = open(shm_file, O_RDWR | O_CREAT | O_EXCL, 0777);
+		if(fd < 0)
+		{
+			return NULL;
+		}
+		ftruncate(fd, sizeof(sem_t));
+		/* map the semaphore variant in the file */
+		pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+		if((void *)(-1) == pSem)
+		{
+			return NULL;
+		}
+		/* do the semaphore initialization */
+		ret = sem_init(pSem, pshared, value);
+		if(-1 == ret)
+		{
+			return NULL;
+		}
+	}
+	else
+		pSem = (sem_t *)mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	close(fd);
+	return pSem;
+}
+efsl_osal_return_type_t fsl_osal_sem_init_process(fsl_osal_sem *psem_obj,fsl_osal_s32 pshared,fsl_osal_u32 value)
+{
+	ASSERT(1==pshared);
+	*psem_obj = (sem_t *)sharedmem_sem_open(pshared,value);
+	if(*psem_obj == NULL)
+	{
+		VPU_COMP_ERR_LOG("\n Creation of semaphore failed.");
+		return E_FSL_OSAL_UNAVAILABLE;
+	}
+	return E_FSL_OSAL_SUCCESS;
+}
+efsl_osal_return_type_t fsl_osal_sem_destroy_process(fsl_osal_sem sem_obj)
+{
+#ifdef ANDROID_BUILD
+	/* workaround for android semaphore usage */
+	fsl_osal_sem_post(sem_obj);
+#endif
+	if (sem_destroy((sem_t *)sem_obj) != 0)
+	{
+	VPU_COMP_ERR_LOG("\n Error in destroying semaphore.");
+	return E_FSL_OSAL_INVALIDPARAM ;
+	}
+	munmap((void *)sem_obj, sizeof(sem_t));
+	return E_FSL_OSAL_SUCCESS;
+}
+#endif
+
+#ifdef VPU_COMP_DEBUG
+void printf_memory(OMX_U8* addr, OMX_S32 width, OMX_S32 height, OMX_S32 stride)
+{
+	OMX_S32 i,j;
+	OMX_U8* ptr;
+
+	ptr=addr;
+	VPU_COMP_LOG("addr: 0x%X \r\n",(UINT32)addr);
+	for(i=0;i<height;i++)
+	{
+		for(j=0;j<width;j++)
+		{
+			VPU_COMP_LOG("%2X ",ptr[j]);         
+		}
+		VPU_COMP_LOG("\r\n");
+		ptr+=stride;
+	}
+	VPU_COMP_LOG("\r\n");	
+	return;
+}
+
+void FileDumpBitstrem(FILE** ppFp, OMX_U8* pBits, OMX_U32 nSize)
+{
+	if(nSize==0)
+	{
+		return;
+	}
+	
+	if(*ppFp==NULL)
+	{
+		*ppFp=fopen("temp.bit","wb");
+		if(*ppFp==NULL)
+		{
+			VPU_COMP_LOG("open temp.bit failure \r\n");
+			return;
+		}
+		VPU_COMP_LOG("open temp.bit OK \r\n");
+	}
+
+	fwrite(pBits,1,nSize,*ppFp);
+	return;
+}
+
+void FileDumpYUV(FILE** ppFp, OMX_U8*  pY,OMX_U8*  pU,OMX_U8*  pV, OMX_U32 nYSize,OMX_U32 nCSize,OMX_COLOR_FORMATTYPE colorFormat)
+{
+	static OMX_U32 cnt=0;
+	OMX_S32 nCScale=1;
+
+	switch (colorFormat)
+	{
+		case OMX_COLOR_FormatYUV420SemiPlanar:
+			VPU_COMP_ERR_LOG("interleave 420 color format : %d \r\n",colorFormat);
+		case OMX_COLOR_FormatYUV420Planar:
+			nCScale=1;
+			break;
+		case OMX_COLOR_FormatYUV422SemiPlanar:
+			VPU_COMP_ERR_LOG("interleave 422 color format : %d \r\n",colorFormat);
+		case OMX_COLOR_FormatYUV422Planar:
+			//hor ???
+			nCScale=2;
+			break;
+		//FIXME: add 4:0:0/4:4:4/...
+		default:
+			VPU_COMP_ERR_LOG("unsupported color format : %d \r\n",colorFormat);
+			break;
+	}	
+	
+	if(*ppFp==NULL)
+	{
+		*ppFp=fopen("temp.yuv","wb");
+		if(*ppFp==NULL)
+		{
+			VPU_COMP_LOG("open temp.yuv failure \r\n");
+			return;
+		}
+		VPU_COMP_LOG("open temp.yuv OK \r\n");
+	}
+
+	if(cnt<=MAX_YUV_FRAME)
+	{
+		fwrite(pY,1,nYSize,*ppFp);
+		fwrite(pU,1,nCSize*nCScale,*ppFp);
+		fwrite(pV,1,nCSize*nCScale,*ppFp);
+		cnt++;
+	}
+	
+	return;
+}
+#endif
+
+VpuDecRetCode VPU_DecGetMem_Wrapper(VpuMemDesc* pInOutMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	VpuDecRetCode ret;
+	if((pMemOp->pfMalloc==NULL) || (pMemOp->pfFree==NULL))
+	{
+		//use default method
+		ret=VPU_DecGetMem(pInOutMem);	
+	}
+	else
+	{
+		OMX_MEM_DESC sOmxMem;
+		sOmxMem.nSize=pInOutMem->nSize;
+		if(OMX_TRUE==pMemOp->pfMalloc(&sOmxMem))
+		{
+			pInOutMem->nPhyAddr=sOmxMem.nPhyAddr;
+			pInOutMem->nVirtAddr=sOmxMem.nVirtAddr;
+			pInOutMem->nCpuAddr=sOmxMem.nCpuAddr;
+			ret=VPU_DEC_RET_SUCCESS;
+		}
+		else
+		{
+			ret=VPU_DEC_RET_FAILURE;
+		}
+	}
+	return ret;
+}
+
+VpuDecRetCode VPU_DecFreeMem_Wrapper(VpuMemDesc* pInMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	VpuDecRetCode ret;
+	if((pMemOp->pfMalloc==NULL) || (pMemOp->pfFree==NULL))
+	{
+		//use default method
+		ret=VPU_DecFreeMem(pInMem);
+	}
+	else
+	{
+		OMX_MEM_DESC sOmxMem;
+		sOmxMem.nSize=pInMem->nSize;
+		sOmxMem.nPhyAddr=pInMem->nPhyAddr;
+		sOmxMem.nVirtAddr=pInMem->nVirtAddr;
+		sOmxMem.nCpuAddr=pInMem->nCpuAddr;
+		if(OMX_TRUE==pMemOp->pfFree(&sOmxMem))
+		{
+			ret=VPU_DEC_RET_SUCCESS;
+		}
+		else
+		{
+			ret=VPU_DEC_RET_FAILURE;
+		}
+	}
+	return ret;	
+}
+
+OMX_S32 MemFreeBlock(VpuDecoderMemInfo* pDecMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	OMX_S32 i;
+	VpuMemDesc vpuMem;
+	VpuDecRetCode vpuRet;
+	OMX_S32 retOk=1;
+
+	//free virtual mem
+	//for(i=0;i<pDecMem->nVirtNum;i++)
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		if(pDecMem->virtMem[i])
+		{
+			fsl_osal_ptr ptr=(fsl_osal_ptr)pDecMem->virtMem[i];
+			FSL_FREE(ptr);
+			pDecMem->virtMem[i]=NULL;
+		}
+	}
+
+	pDecMem->nVirtNum=0;
+
+	//free physical mem
+	//for(i=0;i<pDecMem->nPhyNum;i++)
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		if(pDecMem->phyMem_phyAddr[i])
+		{
+			vpuMem.nPhyAddr=pDecMem->phyMem_phyAddr[i];
+			vpuMem.nVirtAddr=pDecMem->phyMem_virtAddr[i];
+			vpuMem.nCpuAddr=pDecMem->phyMem_cpuAddr[i];
+			vpuMem.nSize=pDecMem->phyMem_size[i];
+			vpuRet=VPU_DecFreeMem_Wrapper(&vpuMem,pMemOp);
+			if(vpuRet!=VPU_DEC_RET_SUCCESS)
+			{
+				VPU_COMP_LOG("%s: free vpu memory failure : ret=0x%X \r\n",__FUNCTION__,vpuRet);
+				retOk=0;
+			}
+			pDecMem->phyMem_phyAddr[i]=NULL;
+			pDecMem->phyMem_virtAddr[i]=NULL;
+			pDecMem->phyMem_cpuAddr[i]=NULL;
+			pDecMem->phyMem_size[i]=0;
+		}
+	}
+	pDecMem->nPhyNum=0;
+	
+	return retOk;
+}
+
+
+OMX_S32 MemAddPhyBlock(VpuMemDesc* pInMemDesc,VpuDecoderMemInfo* pOutDecMem)
+{
+	OMX_S32 i;
+
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		// insert value into empty node
+		if(NULL==pOutDecMem->phyMem_phyAddr[i])
+		{
+			pOutDecMem->phyMem_phyAddr[i]=pInMemDesc->nPhyAddr;
+			pOutDecMem->phyMem_virtAddr[i]=pInMemDesc->nVirtAddr;
+			pOutDecMem->phyMem_cpuAddr[i]=pInMemDesc->nCpuAddr;
+			pOutDecMem->phyMem_size[i]=pInMemDesc->nSize;
+			pOutDecMem->nPhyNum++;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+OMX_S32 MemRemovePhyBlock(VpuMemDesc* pInMemDesc,VpuDecoderMemInfo* pOutDecMem)
+{
+	OMX_S32 i;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		// clear matched node
+		if(pInMemDesc->nPhyAddr==pOutDecMem->phyMem_phyAddr[i])
+		{
+			pOutDecMem->phyMem_phyAddr[i]=NULL;
+			pOutDecMem->phyMem_virtAddr[i]=NULL;
+			pOutDecMem->phyMem_cpuAddr[i]=NULL;
+			pOutDecMem->phyMem_size[i]=0;
+			pOutDecMem->nPhyNum--;
+			return 1;
+		}
+	}	
+	
+	return 0;
+}
+
+OMX_S32 MemQueryPhyBlock(OMX_PTR pInVirtAddr,VpuMemDesc* pOutMemDesc,VpuDecoderMemInfo* pInDecMem)
+{
+	OMX_S32 i;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		// find matched node
+		if((OMX_U32)pInVirtAddr==pInDecMem->phyMem_virtAddr[i])
+		{
+			pOutMemDesc->nPhyAddr=pInDecMem->phyMem_phyAddr[i];
+			pOutMemDesc->nVirtAddr=pInDecMem->phyMem_virtAddr[i];
+			pOutMemDesc->nCpuAddr=pInDecMem->phyMem_cpuAddr[i];
+			pOutMemDesc->nSize=pInDecMem->phyMem_size[i];
+			return 1;
+		}
+	}	
+	
+	return 0;
+}
+
+
+OMX_S32 MemMallocVpuBlock(VpuMemInfo* pMemBlock,VpuDecoderMemInfo* pVpuMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	OMX_S32 i;
+	OMX_U8 * ptr=NULL;
+	OMX_S32 size;
+	
+	for(i=0;i<pMemBlock->nSubBlockNum;i++)
+	{
+		size=pMemBlock->MemSubBlock[i].nAlignment+pMemBlock->MemSubBlock[i].nSize;
+		if(pMemBlock->MemSubBlock[i].MemType==VPU_MEM_VIRT)
+		{
+			ptr=(OMX_U8*)FSL_MALLOC(size);
+			if(ptr==NULL)
+			{
+				VPU_COMP_LOG("%s: get virtual memory failure, size=%d \r\n",__FUNCTION__,(INT32)size);
+				goto failure;
+			}		
+			pMemBlock->MemSubBlock[i].pVirtAddr=(OMX_U8*)Align(ptr,pMemBlock->MemSubBlock[i].nAlignment);
+
+			//record virtual base addr
+			pVpuMem->virtMem[pVpuMem->nVirtNum]=(OMX_U32)ptr;
+			pVpuMem->nVirtNum++;
+		}
+		else// if(memInfo.MemSubBlock[i].MemType==VPU_MEM_PHY)
+		{
+			VpuMemDesc vpuMem;
+			VpuDecRetCode ret;
+			vpuMem.nSize=size;
+			ret=VPU_DecGetMem_Wrapper(&vpuMem,pMemOp);
+			if(ret!=VPU_DEC_RET_SUCCESS)
+			{
+				VPU_COMP_LOG("%s: get vpu memory failure, size=%d, ret=0x%X \r\n",__FUNCTION__,(INT32)size,ret);
+				goto failure;
+			}		
+			pMemBlock->MemSubBlock[i].pVirtAddr=(OMX_U8*)Align(vpuMem.nVirtAddr,pMemBlock->MemSubBlock[i].nAlignment);
+			pMemBlock->MemSubBlock[i].pPhyAddr=(OMX_U8*)Align(vpuMem.nPhyAddr,pMemBlock->MemSubBlock[i].nAlignment);
+
+			//record physical base addr
+			pVpuMem->phyMem_phyAddr[pVpuMem->nPhyNum]=(OMX_U32)vpuMem.nPhyAddr;
+			pVpuMem->phyMem_virtAddr[pVpuMem->nPhyNum]=(OMX_U32)vpuMem.nVirtAddr;
+			pVpuMem->phyMem_cpuAddr[pVpuMem->nPhyNum]=(OMX_U32)vpuMem.nCpuAddr;
+			pVpuMem->phyMem_size[pVpuMem->nPhyNum]=size;
+			pVpuMem->nPhyNum++;			
+		}
+	}	
+
+	return 1;
+	
+failure:
+	MemFreeBlock(pVpuMem,pMemOp);
+	return 0;
+	
+}
+
+OMX_S32 FramePoolRegisterBuf(OMX_PTR pInVirtAddr,OMX_PTR pInPhyAddr,VpuDecoderFrmPoolInfo* pOutFrmPool)
+{
+	OMX_S32 i;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	
+	{
+		//insert into empty node
+		if(NULL==pOutFrmPool->nFrm_phyAddr[i])
+		{
+			pOutFrmPool->eFrmOwner[i]=VPU_COM_FRM_OWNER_NULL;
+			pOutFrmPool->eFrmState[i]=VPU_COM_FRM_STATE_FREE;
+			pOutFrmPool->nFrm_phyAddr[i]=(OMX_U32)pInPhyAddr;
+			pOutFrmPool->nFrm_virtAddr[i]=(OMX_U32)pInVirtAddr;
+			pOutFrmPool->nFrmNum++;
+			return pOutFrmPool->nFrmNum;
+		}
+	}	
+	return -1;
+}
+
+OMX_S32 FramePoolBufExist(OMX_PTR pInVirtAddr,VpuDecoderFrmPoolInfo* pInFrmPool,OMX_PTR* ppOutPhyAddr,OMX_S32* pOutIndx)
+{
+	OMX_S32 i;
+	OMX_PTR pPhyAddr;
+
+	//get physical info from resource manager
+	if(OMX_ErrorNone!=GetHwBuffer(pInVirtAddr,&pPhyAddr))
+	{
+		return -1;
+	}
+	if(pPhyAddr==NULL)
+	{
+		VPU_COMP_ERR_LOG("%s: physical addr is null !!!\r\n",__FUNCTION__);
+		return -1;
+	}
+	*ppOutPhyAddr=pPhyAddr;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	
+	{
+		//search matched node
+		if((OMX_U32)pPhyAddr==pInFrmPool->nFrm_phyAddr[i])
+		{
+			*pOutIndx=i;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+OMX_S32 FramePoolGetBufVirt(VpuDecoderFrmPoolInfo* pInFrmPool, OMX_S32 Index,OMX_PTR *ppOutVirtBuf)
+{
+	*ppOutVirtBuf=(OMX_PTR)pInFrmPool->nFrm_virtAddr[Index];
+	return 1;
+}
+
+OMX_S32 FramePoolGetBufProperty(VpuDecoderFrmPoolInfo* pInFrmPool, OMX_S32 Index,VpuDecoderFrmOwner* pOutOwner,VpuDecoderFrmState* pOutState,VpuDecOutFrameInfo** ppOutFrame)
+{
+	*pOutOwner=pInFrmPool->eFrmOwner[Index];
+	*pOutState=pInFrmPool->eFrmState[Index];
+	*ppOutFrame=&pInFrmPool->outFrameInfo[Index];
+	return 1;
+}
+
+OMX_S32 FramePoolSetBufState(VpuDecoderFrmPoolInfo* pInFrmPool, OMX_S32 Index,VpuDecoderFrmState eInState)
+{
+	pInFrmPool->eFrmState[Index]=eInState;
+	return 1;
+}
+
+OMX_S32 FramePoolBufNum(VpuDecoderFrmPoolInfo* pInFrmPool)
+{
+	return pInFrmPool->nFrmNum;
+}
+
+OMX_S32 FramePoolStolenDecoderBufNum(VpuDecoderFrmPoolInfo* pInFrmPool)
+{
+	OMX_S32 cnt=0;
+	OMX_S32 i;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	
+	{
+		if((pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_DEC)
+			&&(pInFrmPool->eFrmState[i]==VPU_COM_FRM_STATE_OUT))
+		{
+			if(NULL==pInFrmPool->outFrameInfo[i].pDisplayFrameBuf) 
+			{
+				cnt++;
+			}
+		}
+	}
+	return cnt;
+}
+
+OMX_S32 FramePoolCreateDecoderRegisterFrame(
+	VpuFrameBuffer* pOutRegisterFrame,VpuDecoderFrmPoolInfo* pInOutFrmPool, 
+	OMX_S32 nInRequiredCnt,OMX_S32 nPadW,OMX_S32 nPadH,
+	VpuDecoderMemInfo* pOutDecMemInfo, 
+	OMX_PARAM_MEM_OPERATOR* pMemOp,OMX_COLOR_FORMATTYPE colorFormat,OMX_U32 nInChromaAlign)
+{
+	VpuDecRetCode ret;
+	VpuMemDesc vpuMem;
+	OMX_S32 i;
+	OMX_S32 nCnt=0;
+	OMX_S32 yStride;
+	OMX_S32 uvStride;
+	OMX_S32 ySize;
+	OMX_S32 uvSize;
+	OMX_S32 mvSize;
+	OMX_S32 mvTotalSize;
+	OMX_U8* ptr;
+	OMX_U8* ptrVirt;
+
+	yStride=nPadW;
+	ySize=yStride*nPadH;
+
+	switch (colorFormat)
+	{
+		case OMX_COLOR_FormatYUV420Planar:
+		case OMX_COLOR_FormatYUV420SemiPlanar:
+			uvStride=yStride/2;
+			uvSize=ySize/4;
+			mvSize=ySize/4;
+			break;
+		case OMX_COLOR_FormatYUV422Planar:
+		case OMX_COLOR_FormatYUV422SemiPlanar:
+			//hor ???
+			uvStride=yStride/2;
+			uvSize=ySize/2;
+			mvSize=ySize/2;	//In fact, for MJPG, mv is useless
+			break;
+		//FIXME: add 4:0:0/4:4:4/...			
+		default:
+			VPU_COMP_ERR_LOG("unsupported color format : %d \r\n",colorFormat);
+			uvStride=yStride/2;
+			uvSize=ySize/4;
+			mvSize=ySize/4;
+			break;
+	}
+
+	//fill StrideY/StrideC/Y/Cb/Cr info
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		//search valid phy buff
+		if((pInOutFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_NULL)&&(pInOutFrmPool->nFrm_phyAddr[i]!=NULL))
+		{
+			ptr=(OMX_U8*)pInOutFrmPool->nFrm_phyAddr[i];
+			ptrVirt=(OMX_U8*)pInOutFrmPool->nFrm_virtAddr[i];
+			
+			/* fill stride info */
+			pOutRegisterFrame[nCnt].nStrideY=yStride;
+			pOutRegisterFrame[nCnt].nStrideC=uvStride;
+
+			/* fill phy addr*/
+			pOutRegisterFrame[nCnt].pbufY=(OMX_U8*)Align(ptr,nInChromaAlign);
+			pOutRegisterFrame[nCnt].pbufCb=(OMX_U8*)Align(pOutRegisterFrame[nCnt].pbufY+ySize,nInChromaAlign);
+			pOutRegisterFrame[nCnt].pbufCr=(OMX_U8*)Align(pOutRegisterFrame[nCnt].pbufCb+uvSize,nInChromaAlign);
+			//pOutRegisterFrame[nCnt].pbufMvCol=ptr+ySize+uvSize*2;
+
+			/* fill virt addr */
+			pOutRegisterFrame[nCnt].pbufVirtY=(OMX_U8*)Align(ptrVirt,nInChromaAlign);
+			pOutRegisterFrame[nCnt].pbufVirtCb=(OMX_U8*)Align(pOutRegisterFrame[nCnt].pbufVirtY+ySize,nInChromaAlign);
+			pOutRegisterFrame[nCnt].pbufVirtCr=(OMX_U8*)Align(pOutRegisterFrame[nCnt].pbufVirtCb+uvSize,nInChromaAlign);
+			//pOutRegisterFrame[nCnt].pbufVirtMvCol=ptrVirt+ySize+uvSize*2;	
+
+			if(pOutRegisterFrame[nCnt].pbufVirtY!=ptrVirt)
+			{
+				//FIXME: In this case, memory management will be out of order !!!!
+				VPU_COMP_ERR_LOG("%s: warning: buffer base address isn't aligned(%d bytes) correctly: 0x%X \r\n",__FUNCTION__,(UINT32)nInChromaAlign,(UINT32)ptrVirt);
+			}
+			//update frame owner/state
+			pInOutFrmPool->eFrmOwner[i]=VPU_COM_FRM_OWNER_DEC;
+			pInOutFrmPool->eFrmState[i]=VPU_COM_FRM_STATE_FREE;
+			nCnt++;
+			if(nCnt>=nInRequiredCnt)
+			{
+				break;
+			}
+		}
+		else
+		{
+			VPU_COMP_ERR_LOG("%s: warning: frame pool is not clean before register frame for vpu !!",__FUNCTION__);
+			//return -1;
+		}
+	}
+
+	ASSERT(nCnt==nInRequiredCnt);
+	//malloc phy memory for mv
+	mvTotalSize=mvSize*nInRequiredCnt;
+
+	vpuMem.nSize=mvTotalSize;
+	ret=VPU_DecGetMem_Wrapper(&vpuMem,pMemOp);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu malloc frame buf failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+		return -1;//OMX_ErrorInsufficientResources;
+	}
+
+	//record memory info for release
+	pOutDecMemInfo->phyMem_phyAddr[pOutDecMemInfo->nPhyNum]=vpuMem.nPhyAddr;
+	pOutDecMemInfo->phyMem_virtAddr[pOutDecMemInfo->nPhyNum]=vpuMem.nVirtAddr;
+	pOutDecMemInfo->phyMem_cpuAddr[pOutDecMemInfo->nPhyNum]=vpuMem.nCpuAddr;
+	pOutDecMemInfo->phyMem_size[pOutDecMemInfo->nPhyNum]=vpuMem.nSize;
+	pOutDecMemInfo->nPhyNum++;
+
+	//fill mv info
+	ptr=(OMX_U8*)vpuMem.nPhyAddr;
+	ptrVirt=(OMX_U8*)vpuMem.nVirtAddr;
+	for(i=0;i<nInRequiredCnt;i++)
+	{
+		pOutRegisterFrame[i].pbufMvCol=ptr;
+		pOutRegisterFrame[i].pbufVirtMvCol=ptrVirt;
+		ptr+=mvSize;
+		ptrVirt+=mvSize;
+	}
+
+	return nInRequiredCnt;
+}
+
+
+OMX_S32 FramePoolRegisterPostFrame(VpuDecoderFrmPoolInfo* pInOutFrmPool, OMX_S32 nInRequiredCnt,Queue* pQueue)
+{
+	OMX_S32 i;
+	OMX_S32 nCnt=0;	
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)
+	{
+		if((pInOutFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_NULL)&&(pInOutFrmPool->nFrm_phyAddr[i]!=NULL))
+		{
+			//update frame owner/state
+			pInOutFrmPool->eFrmOwner[i]=VPU_COM_FRM_OWNER_POST;
+			pInOutFrmPool->eFrmState[i]=VPU_COM_FRM_STATE_FREE;
+			//pInOutFrmPool->outFrameInfo[i].pDisplayFrameBuf->pbufVirtY=pInOutFrmPool->nFrm_virtAddr[i];
+			pQueue->Add(&i);
+			nCnt++;
+			if(nCnt>=nInRequiredCnt)
+			{
+				break;
+			}			
+		}
+	}
+	ASSERT(nCnt==nInRequiredCnt);
+	return nInRequiredCnt;
+}
+
+OMX_S32 FramePoolFindOneDecoderUnOutputed(OMX_PTR * ppOutVirtBuf,VpuDecoderFrmPoolInfo* pInFrmPool,VpuDecOutFrameInfo** ppOutFrame)
+{
+	OMX_S32 i;
+	//find one un-outputed frame
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	
+	{
+		if(pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_DEC)
+		{
+			if(pInFrmPool->eFrmState[i]!=VPU_COM_FRM_STATE_OUT)
+			{
+				*ppOutVirtBuf=(OMX_PTR)pInFrmPool->nFrm_virtAddr[i];
+				*ppOutFrame=&pInFrmPool->outFrameInfo[i];
+				return i;
+			}
+		}
+	}
+	*ppOutVirtBuf=NULL;
+	return -1;
+}
+
+OMX_S32 FramePoolFindOnePostUnOutputed(OMX_PTR * ppOutPhyBuf,OMX_PTR * ppOutVirtBuf,VpuDecoderFrmPoolInfo* pInFrmPool)
+{
+	OMX_S32 i;
+	//find one un-outputed frame
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	
+	{
+		if(pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_POST)
+		{
+			if(pInFrmPool->eFrmState[i]!=VPU_COM_FRM_STATE_OUT)
+			{
+				*ppOutPhyBuf=(OMX_PTR)pInFrmPool->nFrm_phyAddr[i];
+				*ppOutVirtBuf=(OMX_PTR)pInFrmPool->nFrm_virtAddr[i];
+				return i;
+			}
+		}
+	}
+	*ppOutPhyBuf=NULL;
+	*ppOutVirtBuf=NULL;
+	return -1;
+}
+
+OMX_S32 FramePoolRecordOutFrame(OMX_PTR pInVirtBuf,VpuDecoderFrmPoolInfo* pInFrmPool,VpuDecOutFrameInfo* pInFrameInfo,VpuDecoderFrmOwner eInOwner)
+{
+	OMX_S32 i;
+	//search matched node and restore output frame info
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	
+	{
+		if(pInFrmPool->eFrmOwner[i]==eInOwner)
+		{
+			if(pInFrmPool->nFrm_virtAddr[i]==(OMX_U32)pInVirtBuf)
+			{
+				pInFrmPool->outFrameInfo[i]=*pInFrameInfo;
+				return i;
+			}
+		}
+	}
+	return -1;
+}
+
+OMX_S32 FramePoolDecoderOutReset(VpuDecoderFrmPoolInfo* pInFrmPool,VpuFrameBuffer** pInFrameBufInfo,OMX_S32 nInFrameBufNum,OMX_S32 nInFlag)
+{
+	/*
+	nInFlag
+		0: iMX5: It should be OK whatever reset or clear to all buffers. since all buffers have been cleared automatically in internal wrapper.
+		1: iMX6: only clear NULL for those stolen buffers
+	*/
+	OMX_S32 i;
+	OMX_S32 nDecCnt=0;
+	OMX_S32 nClearedCnt=0;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	 
+	{
+		if(pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_DEC)
+		{
+			if(nInFlag==1)
+			{
+				if(pInFrmPool->eFrmState[i]!=VPU_COM_FRM_STATE_OUT)
+				{			
+					pInFrmPool->eFrmState[i]=VPU_COM_FRM_STATE_OUT;
+					pInFrmPool->outFrameInfo[i].pDisplayFrameBuf=NULL;
+					nClearedCnt++;
+				}
+			}
+			else
+			{
+				if(pInFrmPool->eFrmState[i]!=VPU_COM_FRM_STATE_OUT)
+				{			
+					pInFrmPool->eFrmState[i]=VPU_COM_FRM_STATE_OUT;
+					nClearedCnt++;
+				}
+				pInFrmPool->outFrameInfo[i].pDisplayFrameBuf=*pInFrameBufInfo++;
+				if((OMX_U32)(pInFrmPool->outFrameInfo[i].pDisplayFrameBuf->pbufVirtY)!=pInFrmPool->nFrm_virtAddr[i])
+				{
+					//FIXME: Now, we always reserve the first nOutBufferCntDec frames for vpu decoder
+					//So it should be match, otherwise, we need to search correct node based on virtual address.
+					VPU_COMP_ERR_LOG("%s: error: frame pool out of order !!!",__FUNCTION__);
+				}				
+			}
+			nDecCnt++;
+		}
+	}
+	ASSERT(nInFrameBufNum==nDecCnt);
+	return nClearedCnt;
+}
+
+OMX_S32 FramePoolPostOutReset(VpuDecoderFrmPoolInfo* pInFrmPool,OMX_S32 nInFrameBufNum)
+{
+	OMX_S32 i;
+	OMX_S32 nDecCnt=0;
+	OMX_S32 nClearedCnt=0;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++)	 
+	{
+		if(pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_POST)
+		{
+			if(pInFrmPool->eFrmState[i]!=VPU_COM_FRM_STATE_OUT)
+			{			
+				pInFrmPool->eFrmState[i]=VPU_COM_FRM_STATE_OUT;
+				nClearedCnt++;
+			}
+			//pInFrmPool->outFrameInfo[i].pDisplayFrameBuf=pInFrmPool->nFrm_virtAddr[i];
+			nDecCnt++;
+		}
+	}
+	ASSERT(nInFrameBufNum==nDecCnt);
+	return nClearedCnt;
+}
+
+OMX_S32 FramePoolClear(VpuDecoderFrmPoolInfo* pOutFrmPool)
+{
+	fsl_osal_memset(pOutFrmPool,0, sizeof(VpuDecoderFrmPoolInfo));
+	return 1;
+}
+
+VpuDecRetCode FramePoolReturnPostFrameToVpu(VpuDecoderFrmPoolInfo* pInFrmPool,VpuDecHandle InHandle,OMX_S32 index,VPUCompSemaphor psem)
+{
+	VpuDecRetCode ret=VPU_DEC_RET_SUCCESS;
+	if(index>=0)
+	{				
+		VPU_COMP_SEM_LOCK(psem);
+		ret=VPU_DecOutFrameDisplayed(InHandle,pInFrmPool->outFrameInfo[index].pDisplayFrameBuf);
+		VPU_COMP_SEM_UNLOCK(psem);
+	}
+	return ret;
+}
+
+OMX_S32 FramePoolClearPostIndexMapping(VpuDecoderFrmPoolInfo* pInFrmPool,OMX_S32 nPostIndx)
+{
+	pInFrmPool->nPostIndxMapping[nPostIndx]=0; // 0 mean invalid, align with memset(0).
+	return 1;
+}
+
+OMX_S32 FramePoolSetPostIndexMapping(VpuDecoderFrmPoolInfo* pInFrmPool,OMX_S32 nPostIndx,OMX_S32 nDecIndex)
+{
+	VPU_COMP_LOG("post thread: mapping: post index: %d,  dec index: %d \r\n",nPostIndx,nDecIndex);
+	pInFrmPool->nPostIndxMapping[nPostIndx]=nDecIndex+1;
+	pInFrmPool->outFrameInfo[nPostIndx]=pInFrmPool->outFrameInfo[nDecIndex]; // copy frame info
+	return 1;
+}
+
+OMX_S32 FramePoolSearchMappedDecBuffer(VpuDecoderFrmPoolInfo* pInFrmPool,OMX_PTR pPostBuf, OMX_PTR* ppDecBuf)
+{
+	OMX_S32 i,decIndx=-1;
+	for(i=0;i<VPU_DEC_MAX_NUM_MEM;i++){
+		if((OMX_U32)pPostBuf==pInFrmPool->nFrm_virtAddr[i]){
+			break;
+		}
+	}
+	if(i>=VPU_DEC_MAX_NUM_MEM){
+		VPU_COMP_ERR_LOG("%s: address is invalid : 0x%X \r\n",__FUNCTION__,pPostBuf);
+		return 0;
+	}
+	if(pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_POST){
+		decIndx=pInFrmPool->nPostIndxMapping[i]-1;
+		if(decIndx>=0){
+			*ppDecBuf=(OMX_PTR)pInFrmPool->nFrm_virtAddr[decIndx];
+			VPU_COMP_POST_LOG("%s: post: %d (0x%X), dec: %d (0x%X) \r\n",__FUNCTION__,i,pPostBuf,decIndx,*ppDecBuf);
+			return 1;
+		}
+		VPU_COMP_ERR_LOG("unmapped post buffer: 0x%X index: %d \r\n",pPostBuf,i);
+	}
+	else if(pInFrmPool->eFrmOwner[i]==VPU_COM_FRM_OWNER_DEC){
+		*ppDecBuf=pPostBuf;
+		VPU_COMP_POST_LOG("%s: no mapped: %d (0x%X), dec: %d (0x%X) \r\n",__FUNCTION__,i,pPostBuf,decIndx,*ppDecBuf);
+		return 1;
+	}
+	else{
+		VPU_COMP_ERR_LOG("invalid owner: buffer index: %d \r\n",i);
+	}
+	*ppDecBuf=NULL;
+	return 0;
+}
+
+#ifdef MX6X
+OMX_S32 PostProcessSetStrategy(VpuDecInitInfo* pInInitInfo,OMX_BOOL* pOutEnabled, OMX_U32* pOutBufNum,VpuCodStd InFormat,ipu_motion_sel* pOutMotion)
+{
+#define POST_PROCESS_MAX_FRM_PIXELS (1920*1088*12)
+	ipu_motion_sel motion=MED_MOTION;  //default
+	OMX_BOOL bClipEnable=OMX_FALSE;
+	OMX_BOOL bUserEnable=OMX_FALSE;
+#ifdef VPU_COMP_DIS_POST
+	//disable post-process since risk exist when CHROMA_ALIGN !=1 (gpu render limitation)
+#else
+	if(pInInitInfo->nInterlace!=0)
+	{
+		if(pInInitInfo->nPicWidth*pInInitInfo->nPicHeight*pInInitInfo->nMinFrameBufferCount < POST_PROCESS_MAX_FRM_PIXELS)
+		{
+			switch(InFormat)
+			{
+				case VPU_V_AVC:
+				case VPU_V_MPEG2:
+				case VPU_V_VC1:
+				case VPU_V_VC1_AP:
+					bClipEnable=OMX_TRUE;
+					break;
+				default:
+					break;
+			}
+		}
+	}
+	
+#if 1  //dynamic config
+	{
+#ifdef ANDROID_BUILD	
+		#define POST_CONFIGFILE "/data/omx_post_process"
+#else
+		#define POST_CONFIGFILE "/etc/omx_post_process"
+#endif
+		efsl_osal_return_type_t ret;
+		FILE* fpPost;
+		ret = fsl_osal_fopen(POST_CONFIGFILE, "r", (fsl_osal_file *)&fpPost);
+		if (ret != E_FSL_OSAL_SUCCESS)
+		{
+		       //printf("read post process config file: %s failed !!!!!!\r\n",POST_CONFIGFILE);
+			//bEnable=OMX_FALSE;
+		}	
+		else
+		{
+			fsl_osal_char symbol;
+			fsl_osal_s32 ReadLen = 0;
+			int level=0;
+			ret = fsl_osal_fread(&symbol, 1, fpPost, &ReadLen);
+			if (ret != E_FSL_OSAL_SUCCESS && ret != E_FSL_OSAL_EOF)
+			{
+				//bEnable=OMX_FALSE;
+			}
+			else
+			{
+				level=fsl_osal_atoi(&symbol);
+				if(level>0) bUserEnable=OMX_TRUE;
+				if(level==0) bUserEnable=OMX_FALSE;
+				else if(level==1) motion=LOW_MOTION;
+				else if (level==2) motion=MED_MOTION;
+				else if (level==3) motion=HIGH_MOTION;
+				else motion=MED_MOTION;
+
+				//printf("post process: enable: %d, mode: %d  \r\n",bEnable,motion);		
+			}
+			fsl_osal_fclose(fpPost);
+		}
+	}
+#endif	
+#endif
+
+	if((bUserEnable==OMX_FALSE) || (bClipEnable==OMX_FALSE))
+	{
+		*pOutEnabled=OMX_FALSE;
+		*pOutBufNum=DEFAULT_BUF_OUT_POST_ZEROCNT;
+		*pOutMotion=motion;
+	}
+	else
+	{
+		*pOutEnabled=OMX_TRUE;
+		*pOutBufNum=DEFAULT_BUF_OUT_POST_CNT;
+		*pOutMotion=motion;
+		//may crash if new post cnt is smaller than default cnt !
+		ASSERT(DEFAULT_BUF_OUT_POST_CNT>=DEFAULT_BUF_OUT_POST_ZEROCNT);
+	}
+	return 1;
+}
+
+OMX_S32 PostProcessIPUInit(VpuDecoderIpuHandle* pIpuHandle)
+{
+	pIpuHandle->nIpuFd=open("/dev/mxc_ipu", O_RDWR, 0);
+	if(pIpuHandle->nIpuFd<=0) 
+	{
+		VPU_COMP_ERR_LOG("Open /dev/mxc_ipu failed.\n");
+		return 0;
+	}
+	fsl_osal_memset(&pIpuHandle->sIpuTask, 0, sizeof(IpuTask));
+	TIMER_INIT;
+	return 1;
+}
+
+OMX_S32 PostProcessIPUSetDefault(VpuDecoderIpuHandle* pIpuHandle,OMX_VIDEO_PORTDEFINITIONTYPE* pOutFmt,OMX_CONFIG_RECTTYPE* pOutCrop,ipu_motion_sel InMotion)
+{
+	struct ipu_input* pIn=&pIpuHandle->sIpuTask.input;
+	struct ipu_output* pOut=&pIpuHandle->sIpuTask.output;
+	OMX_U32 color=IPU_FOURCC('I', '4', '2', '0');;
+	pIpuHandle->sIpuTask.overlay_en=0;
+
+	if(pOutFmt->eColorFormat == OMX_COLOR_FormatYUV420Planar)
+	{
+		color=IPU_FOURCC('I', '4', '2', '0');
+		VPU_COMP_LOG("Set post-process in format to YUVI420.\n");
+	}
+	else if(pOutFmt->eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+	{
+		color=IPU_FOURCC('N', 'V', '1', '2');
+		VPU_COMP_LOG("Set post-process in format to NV12.\n");
+	}
+	else
+	{
+		VPU_COMP_ERR_LOG("unsupported color format(%d) for deinterlace ! \r\n",pOutFmt->eColorFormat);
+	}
+	
+	pIn->width = pOutFmt->nFrameWidth;
+	pIn->height = pOutFmt->nFrameHeight;
+	pIn->crop.pos.x = Align(pOutCrop->nLeft,8);
+	if(pIn->crop.pos.x!=(OMX_U32)pOutCrop->nLeft)
+	{
+		VPU_COMP_ERR_LOG("warning: crop left(%d) isn't aligned with 8 bytes !!! \r\n",(INT32)pOutCrop->nLeft);
+	}
+	pIn->crop.pos.y = pOutCrop->nTop;
+	pIn->crop.w = pOutCrop->nWidth/8*8;
+	if(pIn->crop.w!=pOutCrop->nWidth)
+	{
+		VPU_COMP_ERR_LOG("warning: crop width(%d) isn't aligned with 8 bytes !!! \r\n",(INT32)pOutCrop->nWidth);
+	}
+	pIn->crop.h = pOutCrop->nHeight;
+	pIn->format = color;
+	VPU_COMP_LOG("IpulibRender sInParam width %d, height %d,crop x %d, y %d, w %d, h %d, color %d\n",
+		pIn->width, pIn->height,pIn->crop.pos.x, pIn->crop.pos.y,pIn->crop.w, pIn->crop.h,pIn->format);
+
+	pIn->deinterlace.enable=1;
+	pIn->deinterlace.motion=InMotion;
+	pIn->deinterlace.field_fmt=IPU_DEINTERLACE_FIELD_TOP;
+		
+	pOut->width = pIn->width;
+	pOut->height = pIn->height;
+	pOut->crop.pos.x = pIn->crop.pos.x;
+	pOut->crop.pos.y = pIn->crop.pos.y;
+	pOut->crop.w = pIn->crop.w;
+	pOut->crop.h = pIn->crop.h;
+	pOut->format = color;
+	pOut->rotate = ROTATE_NONE;
+	VPU_COMP_LOG("IpulibRender sOutParam width %d, height %d,crop x %d, y %d, rot: %d, color %d\n",
+		pOut->crop.w, pOut->crop.h ,pOut->crop.pos.x, pOut->crop.pos.y,pOut->rotate, pOut->format);
+
+	return 1;
+}
+
+OMX_S32 PostProcessIPUDeInterlace(OMX_PTR pInPhyBuf,VpuDecOutFrameInfo* pInFrmInfo,VpuDecOutFrameInfo* pInFutureFrmInfo,VpuDecoderIpuHandle* pIpuHandle)
+{
+	/*
+	(1) HIGH MOTION:
+		input.paddr : current frame
+	(2) LOW/MED MOTION:
+		input.paddr: current frame
+		input.paddr_n: next frame	
+	*/
+	OMX_S32 ret=0;
+	OMX_U8 motion_bak=(OMX_U8)LOW_MOTION;
+	OMX_BOOL bNeedChangeMotion=OMX_FALSE;
+	VPU_COMP_LOG("in De-interlaced: field type: %d \r\n",pInFrmInfo->eFieldType);
+	//FIXME: field_fmt should be same for previous and current frame ????
+	pIpuHandle->sIpuTask.input.deinterlace.field_fmt=(pInFrmInfo->eFieldType==VPU_FIELD_TB)?IPU_DEINTERLACE_FIELD_TOP:IPU_DEINTERLACE_FIELD_BOTTOM;
+	pIpuHandle->sIpuTask.input.paddr=(int)pInFrmInfo->pDisplayFrameBuf->pbufY;	
+	pIpuHandle->sIpuTask.output.paddr=(int)pInPhyBuf;
+	if(pInFrmInfo->eFieldType!=pInFutureFrmInfo->eFieldType){
+		//use the same frame if fieldtype are different
+		pIpuHandle->sIpuTask.input.paddr_n=(int)pInFrmInfo->pDisplayFrameBuf->pbufY;
+	}
+	else{
+		pIpuHandle->sIpuTask.input.paddr_n=(int)pInFutureFrmInfo->pDisplayFrameBuf->pbufY;	//needed for LOW_MOTION/MED_MOTION
+	}
+
+	//For LOW_MOTION/MED_MOTION case: if paddr and paddr_n point to the same frame, the effect isn't perfect. so we make temporary swith to high motion
+	if((pIpuHandle->sIpuTask.input.deinterlace.motion!=HIGH_MOTION)
+		&&(pIpuHandle->sIpuTask.input.paddr==pIpuHandle->sIpuTask.input.paddr_n)){
+		motion_bak=pIpuHandle->sIpuTask.input.deinterlace.motion;
+		VPU_COMP_POST_LOG("%s: temporary swith to high motion: from %d to %d \r\n",__FUNCTION__,(int)motion_bak,(int)HIGH_MOTION);
+		pIpuHandle->sIpuTask.input.deinterlace.motion=HIGH_MOTION;
+		bNeedChangeMotion=OMX_TRUE;
+	}
+
+	ret = IPU_CHECK_ERR_INPUT_CROP;
+	while(ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN) {
+		ret = ioctl(pIpuHandle->nIpuFd, IPU_CHECK_TASK, &pIpuHandle->sIpuTask);
+		switch(ret) {
+			case IPU_CHECK_OK:
+				break;
+			case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
+				pIpuHandle->sIpuTask.input.crop.w -= 8;
+				break;
+			case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
+				pIpuHandle->sIpuTask.input.crop.h -= 8;
+				break;
+			case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
+				pIpuHandle->sIpuTask.output.crop.w -= 8;
+				break;
+			case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
+				pIpuHandle->sIpuTask.output.crop.h -= 8;;
+				break;
+			default:
+				return 0;
+		}
+	}
+	
+	ret = ioctl(pIpuHandle->nIpuFd, IPU_QUEUE_TASK, &pIpuHandle->sIpuTask);
+	if(bNeedChangeMotion==OMX_TRUE){
+		pIpuHandle->sIpuTask.input.deinterlace.motion=motion_bak;
+	}
+	if (ret < 0) 
+	{
+		VPU_COMP_ERR_LOG("ioct IPU_QUEUE_TASK fail\n");
+		return 0;
+	}
+	return 1;
+}
+
+OMX_S32 PostProcessIPUDeinit(VpuDecoderIpuHandle* pIpuHandle)
+{
+	if(pIpuHandle->nIpuFd>0)
+	{
+		close(pIpuHandle->nIpuFd);
+		pIpuHandle->nIpuFd=0;
+	}
+	TIMER_REPORT;
+	return 1;
+}
+
+#else
+OMX_S32 PostProcessSetStrategy(VpuDecInitInfo* pInInitInfo,OMX_BOOL* pOutEnabled, OMX_U32* pOutBufNum,VpuCodStd InFormat,ipu_motion_sel* pOutMotion)
+{
+	VPU_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	*pOutEnabled=OMX_FALSE;
+	*pOutBufNum=DEFAULT_BUF_OUT_POST_ZEROCNT;
+	*pOutMotion=MED_MOTION;
+	return 1;
+}
+OMX_S32 PostProcessIPUInit(VpuDecoderIpuHandle* pIpuHandle)
+{
+	VPU_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	return 1;
+}
+OMX_S32 PostProcessIPUSetDefault(VpuDecoderIpuHandle* pIpuHandle,OMX_VIDEO_PORTDEFINITIONTYPE* pOutFmt,OMX_CONFIG_RECTTYPE* pOutCrop,ipu_motion_sel InMotion)
+{
+	VPU_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	return 1;
+}
+OMX_S32 PostProcessIPUDeInterlace(OMX_PTR pInPhyBuf,VpuDecOutFrameInfo* pInFrmInfo,VpuDecOutFrameInfo* pInFutureFrmInfo,VpuDecoderIpuHandle* pIpuHandle)
+{
+	VPU_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);	
+	return 1;
+}
+OMX_S32 PostProcessIPUDeinit(VpuDecoderIpuHandle* pIpuHandle)
+{
+	VPU_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	return 1;
+}
+#endif
+
+OMX_ERRORTYPE OpenVpu(VpuDecHandle* pOutHandle, VpuMemInfo* pInMemInfo,
+	VpuCodStd eCodeFormat, OMX_S32 nPicWidth,OMX_S32 nPicHeight,OMX_COLOR_FORMATTYPE eColorFormat,OMX_S32 enableFileMode,VPUCompSemaphor psem,OMX_BOOL bReorderDis)
+{
+	VpuDecOpenParam decOpenParam;	
+	VpuDecRetCode ret;
+	OMX_S32 para;
+
+	VPU_COMP_LOG("%s: codec format: %d \r\n",__FUNCTION__,eCodeFormat);
+	//clear 0
+	fsl_osal_memset(&decOpenParam, 0, sizeof(VpuDecOpenParam));
+	//set open params
+	decOpenParam.CodecFormat=eCodeFormat;
+
+	//FIXME: for MJPG, we need to add check for 4:4:4/4:2:2 ver/4:0:0  !!!
+	if((OMX_COLOR_FormatYUV420SemiPlanar==eColorFormat)
+		||(OMX_COLOR_FormatYUV422SemiPlanar==eColorFormat))
+	{
+		decOpenParam.nChromaInterleave=1;
+	}
+	else
+	{
+		decOpenParam.nChromaInterleave=0;
+	}
+	decOpenParam.nReorderEnable=(bReorderDis==OMX_TRUE)?0:1;	//for H264
+	switch(eCodeFormat)
+	{
+		case VPU_V_MPEG4:
+		case VPU_V_DIVX4:
+		case VPU_V_DIVX56:
+		case VPU_V_XVID:
+		case VPU_V_H263:
+			decOpenParam.nEnableFileMode=enableFileMode;	//FIXME: set 1 in future
+			break;			
+		case VPU_V_AVC:
+			decOpenParam.nEnableFileMode=enableFileMode; 	//FIXME: set 1 in future
+			break;
+		case VPU_V_MPEG2:
+			decOpenParam.nEnableFileMode=enableFileMode; 	//FIXME: set 1 in future
+			break;
+		case VPU_V_VC1:
+		case VPU_V_VC1_AP:
+		case VPU_V_DIVX3:
+		case VPU_V_RV:
+			//for VC1/RV/DivX3: we should use filemode, otherwise, some operations are unstable(such as seek...)
+			decOpenParam.nEnableFileMode=enableFileMode;
+			break;
+		case VPU_V_MJPG:
+			//must file mode ???
+			decOpenParam.nEnableFileMode=enableFileMode;
+			break;
+		default:
+			decOpenParam.nEnableFileMode=enableFileMode;
+			break;
+	}
+
+	//for special formats, such as package VC1 header,...
+	decOpenParam.nPicWidth=nPicWidth;
+	decOpenParam.nPicHeight=nPicHeight;
+
+	//open vpu
+	VPU_COMP_SEM_LOCK(psem);
+	ret=VPU_DecOpen(pOutHandle, &decOpenParam, pInMemInfo);
+	VPU_COMP_SEM_UNLOCK(psem);
+	if (ret!=VPU_DEC_RET_SUCCESS)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu open failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		return OMX_ErrorHardware;
+	}			
+
+	//set default config
+	VPU_COMP_SEM_LOCK(psem);
+	para=VPU_DEC_SKIPNONE;
+	ret=VPU_DecConfig(*pOutHandle, VPU_DEC_CONF_SKIPMODE, &para);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_DEC_CONF_SKIPMODE,ret);
+		VPU_DecClose(*pOutHandle);
+		VPU_COMP_SEM_UNLOCK(psem);
+		return OMX_ErrorHardware;
+	}
+	para=DEFAULT_BUF_DELAY;
+	ret=VPU_DecConfig(*pOutHandle, VPU_DEC_CONF_BUFDELAY, &para);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_DEC_CONF_SKIPMODE,ret);
+		VPU_DecClose(*pOutHandle);
+		VPU_COMP_SEM_UNLOCK(psem);
+		return OMX_ErrorHardware;
+	}	
+	VPU_COMP_SEM_UNLOCK(psem);
+	return OMX_ErrorNone;
+}
+
+#ifdef VPU_DEC_COMP_DROP_B
+OMX_ERRORTYPE ConfigVpu(VpuDecHandle InHandle,OMX_TICKS nTimeStamp,OMX_PTR pClock,VPUCompSemaphor psem)
+{
+	VpuDecRetCode ret;
+	OMX_TIME_CONFIG_TIMESTAMPTYPE sCur;
+        OMX_TIME_CONFIG_SCALETYPE sScale;
+	VpuDecConfig config;
+	OMX_S32 param;
+
+	if(pClock!=NULL)
+	{
+            OMX_INIT_STRUCT(&sScale, OMX_TIME_CONFIG_SCALETYPE);
+            OMX_GetConfig(pClock, OMX_IndexConfigTimeScale, &sScale);
+            if(!IS_NORMAL_PLAY(sScale.xScale)){
+                VPU_COMP_LOG("*** not normal playback for drop B, return");
+                return OMX_ErrorNone;
+            }
+		OMX_INIT_STRUCT(&sCur, OMX_TIME_CONFIG_TIMESTAMPTYPE);
+		OMX_GetConfig(pClock, OMX_IndexConfigTimeCurrentMediaTime, &sCur);
+		if(sCur.nTimestamp > (nTimeStamp - DROP_B_THRESHOLD))
+		{
+			VPU_COMP_LOG("drop B frame \r\n");
+			config=VPU_DEC_CONF_SKIPMODE;
+			param=VPU_DEC_SKIPB;
+		}
+		else
+		{
+			config=VPU_DEC_CONF_SKIPMODE;
+			param=VPU_DEC_SKIPNONE;
+		}
+		VPU_COMP_SEM_LOCK(psem);
+		ret=VPU_DecConfig(InHandle, config, (void*)(&param));
+		VPU_COMP_SEM_UNLOCK(psem);
+		if(VPU_DEC_RET_SUCCESS!=ret)
+		{
+			VPU_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,config,ret);
+			return OMX_ErrorHardware;
+		}	
+	}
+	
+	return OMX_ErrorNone;
+}
+#endif
+
+OMX_COLOR_FORMATTYPE ConvertMjpgColorFormat(OMX_S32 sourceFormat,OMX_COLOR_FORMATTYPE oriColorFmt)
+{
+	OMX_COLOR_FORMATTYPE	colorformat;
+	OMX_S32 interleave=0;
+
+	switch(oriColorFmt)
+	{
+		case OMX_COLOR_FormatYUV420SemiPlanar:
+		case OMX_COLOR_FormatYUV422SemiPlanar:	
+		//FIXME: add 4:0:0/4:4:4/...	
+			interleave=1;
+			break;
+		default:
+			break;
+	}
+	switch(sourceFormat)
+	{
+		case 0:	//4:2:0
+			colorformat=(1==interleave)?OMX_COLOR_FormatYUV420SemiPlanar:OMX_COLOR_FormatYUV420Planar;
+			break;
+		case 1:	//4:2:2 hor
+			colorformat=(1==interleave)?OMX_COLOR_FormatYUV422SemiPlanar:OMX_COLOR_FormatYUV422Planar;
+			break;
+#if 0	//FIXME
+		case 2:	//4:2:2 ver
+			VPU_COMP_ERR_LOG("unsupport mjpg 4:2:2 ver color format: %d \r\n",sourceFormat);
+			colorformat=OMX_COLOR_FormatYUV422Planar;
+			break;
+		case 3:	//4:4:4
+			VPU_COMP_ERR_LOG("unsupport mjpg 4:4:4 color format: %d \r\n",sourceFormat);
+			colorformat=OMX_COLOR_FormatYUV444Planar;
+			break;
+		case 4:	//4:0:0
+			VPU_COMP_ERR_LOG("unsupport mjpg 4:0:0 color format: %d \r\n",sourceFormat);
+			colorformat=OMX_COLOR_FormatYUV400Planar;
+			break;
+#endif			
+		default:	//unknow
+			VPU_COMP_ERR_LOG("unknown mjpg color format: %d \r\n",(INT32)sourceFormat);
+			colorformat=OMX_COLOR_FormatUnused;
+			break;			
+	}	
+	return colorformat;
+}
+
+OMX_S32 PostTransferQueue(Queue* pFromQueue,Queue* pToQueue,OMX_U32 nIndexFlag,OMX_U32 nInvalidExtFlag)
+{
+	//get all buffer from pFromQueue(except invalid index) and re-filled into pToQueue
+	OMX_S32 index;
+	OMX_S32 nCnt=0;
+	while(pFromQueue->Size()>0){
+		pFromQueue->Get(&index);
+		if(0==((index>>16)&nInvalidExtFlag)){
+			index=index&nIndexFlag;
+			pToQueue->Add(&index);
+			nCnt++;
+		}
+	}
+	return nCnt;
+}
+
+OMX_S32 PostWaitState(volatile PostProcessState * pState,PostProcessState eTargetState, fsl_osal_sem pSem)
+{
+	//decode thread wait post thread complete command
+	fsl_osal_sem_wait(pSem);
+	while(*pState!=eTargetState)
+	{
+		VPU_COMP_ERR_LOG("incorrect state: %d !!!, expected state: %d \r\n", *pState,eTargetState);
+	}
+	return 1;
+}
+
+OMX_S32 PostWakeUp(fsl_osal_mutex pMutex, pthread_cond_t* pCond, volatile OMX_BOOL * pWaiting)
+{
+	//decode thread notify post thread some tasks are received
+	fsl_osal_mutex_lock(pMutex);
+	if(*pWaiting==OMX_TRUE)
+	{
+		VPU_COMP_POST_LOG("%s: send tasks to post thread \r\n",__FUNCTION__);
+		pthread_cond_signal(pCond);
+	}
+	else
+	{
+		VPU_COMP_POST_LOG("%s: post thread is already in work state, needn't wakeup it \r\n",__FUNCTION__);
+	}
+	fsl_osal_mutex_unlock(pMutex);
+	return 1;
+}
+
+void *PostThread(void *arg) 
+{
+#define POST_THREAD_WAITTIMEOUT_US	(100000)
+	VpuDecoder *base = (VpuDecoder*)arg;
+	volatile PostProcessCmd * pCmd=&base->ePostCmd;
+	volatile PostProcessState* pState=&base->ePostState;
+	volatile OMX_BOOL* pPostWaitingTasks =&base->bPostWaitingTasks;
+	fsl_osal_sem pSem=base->pPostCmdSem;
+	VPU_COMP_POST_LOG("%s: Post Thread starting.\n",__FUNCTION__);
+
+	//set waiting firstly when post thread is actived.
+	*pPostWaitingTasks=OMX_TRUE;
+	//main loop
+	while(1){
+		VpuDecOutFrameInfo * pFrameInfo;
+		VpuDecOutFrameInfo * pPreFrameInfo;
+		OMX_S32 nVpuInIndex,nPostOutIndex;
+		static OMX_S32 nPreVpuInIndex=-1;
+		OMX_S32 nExtInfo=0;
+		struct timespec to;
+		struct timeval from;
+		int ret=0;
+		//wait decode thread send tasks(commands,data,...)
+		fsl_osal_mutex_lock(base->pPostMutex);
+		while(1){
+			if(*pCmd!=POST_PROCESS_CMD_NONE){
+				break;
+			}
+			if((base->pPostInQueue->Size()>0) && (base->pPostOutReturnQueue->Size()>0)){
+				break;
+			}
+			VPU_COMP_POST_LOG("%s: will wait tasks from decoder thread \r\n",__FUNCTION__);
+#if 0		//debug: using sleep method instead of wait 
+			#define POST_THREAD_SLEEP_US (1000)
+			fsl_osal_mutex_unlock(base->pPostMutex);
+			fsl_osal_sleep(POST_THREAD_SLEEP_US);
+			fsl_osal_mutex_lock(base->pPostMutex);
+#else
+			*pPostWaitingTasks=OMX_TRUE; //no any tasks, begin waiting
+			/*
+			gettimeofday(&from, NULL);
+			to.tv_sec=from.tv_sec;
+			to.tv_nsec=from.tv_usec * 1000;
+			to.tv_nsec+=(POST_THREAD_WAITTIMEOUT_US)*1000;
+			//here, we use timeout wait to avoid deadlock as possible
+			ret=pthread_cond_timedwait(&base->sPostCond, (pthread_mutex_t *)(base->pPostMutex), &to);
+			*/
+			ret=pthread_cond_wait(&base->sPostCond, (pthread_mutex_t *)base->pPostMutex);
+			if(0!=ret) {
+				VPU_COMP_POST_LOG("return from pthread_cond_*wait : %d \r\n",ret);
+			}
+#endif
+		}
+		if(ret!=0){//if(ret==ETIMEDOUT){
+			//in theory, if the sync logic is correct, shouldn't enter here
+			VPU_COMP_ERR_LOG("warning: the post thread isn't actived immediately ! error: %d \r\n",ret);
+		}
+		VPU_COMP_POST_LOG("%s: ready to work \r\n",__FUNCTION__);
+		*pPostWaitingTasks=OMX_FALSE;  //clear waiting
+		fsl_osal_mutex_unlock(base->pPostMutex);
+
+		//process command
+		if(*pCmd!=POST_PROCESS_CMD_NONE){
+			switch(*pCmd){
+				case POST_PROCESS_CMD_RUN:
+					*pState=POST_PROCESS_STATE_RUN;
+					break;
+				case POST_PROCESS_CMD_STOP:
+					*pState=POST_PROCESS_STATE_IDLE;
+					break;
+				case POST_PROCESS_CMD_FLUSH_OUT:
+					//get all buffer from pPostOutReturnQueue, and fill into pPostOutQueue directly
+					PostTransferQueue(base->pPostOutReturnQueue, base->pPostOutQueue, 0xFFFFFFFF,0x0);
+#if 0				//now, flush output cover flush input
+					break;
+#endif
+				case POST_PROCESS_CMD_FLUSH_IN:
+					//get all buffer from pPostInQueue except eos(invalid index), and fill into pPostInReturnQueue
+					PostTransferQueue(base->pPostInQueue, base->pPostInReturnQueue, 0xFFFF,POST_INDEX_EOS);
+					if(nPreVpuInIndex>=0){
+						//VPU_COMP_POST_LOG("%s: return vpu index: %d, ext info: %d \r\n",__FUNCTION__,nPreVpuInIndex&0xFFFF,nPreVpuInIndex>>16);
+						nPreVpuInIndex=nPreVpuInIndex&0xFFFF;
+						base->pPostInReturnQueue->Add(&nPreVpuInIndex);
+						nPreVpuInIndex=-1;
+					}					
+					break;
+				default:
+					VPU_COMP_POST_LOG("unknow command: %d, ignore it \r\n",*pCmd);
+					break;
+			}
+			VPU_COMP_POST_LOG("%s: command(%d) finished, will notify decoder thread \r\n",__FUNCTION__,*pCmd);
+			//clear command
+			*pCmd=POST_PROCESS_CMD_NONE;
+			//notify host command finished
+			fsl_osal_sem_post(pSem);
+		}
+
+		//check state
+		if((*pState)==POST_PROCESS_STATE_IDLE){
+			break; //exit main loop
+		}
+		else if((*pState)!=POST_PROCESS_STATE_RUN){
+			continue;
+		}
+
+		//check whether data is enough to do post-process
+		if((base->pPostInQueue->Size()<=0) || ((base->pPostOutReturnQueue->Size()<=0))){
+			continue;
+		}
+
+		base->pPostInQueue->Get(&nVpuInIndex);
+		//base->pPostOutReturnQueue->Get(&nPostOutIndex);
+		//VPU_COMP_POST_LOG("%s: get vpu index: %d(ext: %d), post output index: %d(ext: %d) \n",__FUNCTION__,nVpuInIndex&0xFFFF,nVpuInIndex>>16,nPostOutIndex&0xFFFF,nPostOutIndex>>16);
+
+		//check EOS event
+		if((nVpuInIndex>>16)&POST_INDEX_EOS){
+			//ASSERT(0==base->pPostInQueue->Size());
+			//clear previous index
+			if(nPreVpuInIndex>=0){
+				//VPU_COMP_POST_LOG("%s: return vpu index: %d, ext info: %d \r\n",__FUNCTION__,nPreVpuInIndex&0xFFFF,nPreVpuInIndex>>16);
+				nPreVpuInIndex=nPreVpuInIndex&0xFFFF;
+				base->pPostInReturnQueue->Add(&nPreVpuInIndex);
+				nPreVpuInIndex=-1;
+			}
+			//in this case, nVpuInIndex is unmeaningful, drop it.
+			//send eos output
+			base->pPostOutReturnQueue->Get(&nPostOutIndex);
+			nPostOutIndex=(POST_INDEX_EOS<<16)|nPostOutIndex;
+			VPU_COMP_POST_LOG("%s: output EOS index: %d, ext info: %d \r\n",__FUNCTION__,nPostOutIndex&0xFFFF,nPostOutIndex>>16);
+			base->pPostOutQueue->Add(&nPostOutIndex);
+			FramePoolClearPostIndexMapping(&base->sFramePoolInfo, nPostOutIndex&0xFFFF); //clear it since no valid map index for EOS
+			continue;
+		}
+
+		//get frame info
+		pFrameInfo=&base->sFramePoolInfo.outFrameInfo[nVpuInIndex&0xFFFF];
+
+		//equivalent: VPU_FIELD_TOP / VPU_FIELD_BOTTOM => VPU_FIELD_BT and VPU_FIELD_TB
+		if(pFrameInfo->eFieldType==VPU_FIELD_TOP){
+			pFrameInfo->eFieldType=VPU_FIELD_BT;
+		}
+		else if(pFrameInfo->eFieldType==VPU_FIELD_BOTTOM){
+			pFrameInfo->eFieldType=VPU_FIELD_TB;
+		}
+
+		//check frame or field
+#if 0	//debug: simulate frame+interlaced clips
+		if(1)
+#else
+		if(pFrameInfo->eFieldType==VPU_FIELD_NONE)	//frame type
+#endif
+		{
+			//clear previous index
+			if(nPreVpuInIndex>=0){
+				//VPU_COMP_POST_LOG("%s: return vpu index: %d, ext info: %d \r\n",__FUNCTION__,nPreVpuInIndex&0xFFFF,nPreVpuInIndex>>16);
+				nPreVpuInIndex=nPreVpuInIndex&0xFFFF;
+				base->pPostInReturnQueue->Add(&nPreVpuInIndex);
+				nPreVpuInIndex=-1;
+			}
+			//by pass vpu index to output
+			VPU_COMP_POST_LOG("%s: by pass vpu frame index: %d, ext info: %d \r\n",__FUNCTION__,nVpuInIndex&0xFFFF,nVpuInIndex>>16);
+			base->pPostOutQueue->Add(&nVpuInIndex);
+			FramePoolSetPostIndexMapping(&base->sFramePoolInfo, nVpuInIndex&0xFFFF, nVpuInIndex&0xFFFF); //mapping itself
+		}
+		else{	// field type
+
+			//do de-interlace
+			if(nPreVpuInIndex>=0){
+				pPreFrameInfo=&base->sFramePoolInfo.outFrameInfo[nPreVpuInIndex&0xFFFF];
+			}
+			else{
+				pPreFrameInfo=pFrameInfo;
+			}
+			base->pPostOutReturnQueue->Get(&nPostOutIndex);
+#if 0		//debug: copy directly
+			{
+				OMX_S32 nOutSize;
+				nOutSize=base->sOutFmt.nFrameWidth * base->sOutFmt.nFrameHeight*pxlfmt2bpp(base->sOutFmt.eColorFormat)/8;
+				fsl_osal_memcpy((OMX_PTR)(base->sFramePoolInfo.nFrm_virtAddr[nPostOutIndex]), pFrameInfo->pDisplayFrameBuf->pbufVirtY, nOutSize);
+			}
+#else
+			TIMER_START;
+			if(base->nPostMotion==HIGH_MOTION){
+				//only use current frame, pPreFrameInfo will be ignored by ipu
+				PostProcessIPUDeInterlace((OMX_PTR)(base->sFramePoolInfo.nFrm_phyAddr[nPostOutIndex]),pFrameInfo,pPreFrameInfo,&base->sIpuHandle);
+			}
+			else{
+				//IPU need to use current frame and future frame
+				//FIXME: Now, for simply implementation, we won't wait future frame. just make simple trick. e.g. using previous/current frame pair to simulate current/next pair
+				//as result, there will be one frame offset, like this:  1' 1 2 3 4.... N-1
+				PostProcessIPUDeInterlace((OMX_PTR)(base->sFramePoolInfo.nFrm_phyAddr[nPostOutIndex]),pPreFrameInfo,pFrameInfo,&base->sIpuHandle);
+			}
+			TIMER_STOP;
+#endif
+			//return previous index to vpu
+			if(nPreVpuInIndex>=0){
+				//VPU_COMP_POST_LOG("%s: return vpu index: %d, ext info: %d \r\n",__FUNCTION__,nPreVpuInIndex&0xFFFF,nPreVpuInIndex>>16);
+				nExtInfo=nPreVpuInIndex>>16;
+				nPreVpuInIndex=nPreVpuInIndex&0xFFFF;
+				base->pPostInReturnQueue->Add(&nPreVpuInIndex);
+			}
+			
+			nExtInfo=nExtInfo|(nVpuInIndex>>16); //the extension is decided by two frames
+
+#if 0		//FIXME: Now, we don't need these frame info
+			//copy frame info
+			base->sFramePoolInfo.outFrameInfo[nPostOutIndex]=base->sFramePoolInfo.outFrameInfo[nVpuInIndex&0xFFFF];
+			base->sFramePoolInfo.outFrameInfo[nPostOutIndex].pDisplayFrameBuf=NULL; //no meaning for post owner
+#endif
+			//send output 
+			nPostOutIndex=(nExtInfo<<16)|nPostOutIndex;  //set extension flag
+			VPU_COMP_POST_LOG("%s: output index: %d, ext info: %d, (vpu index: %d, ext info: %d, preIndx: %d) \r\n",__FUNCTION__,nPostOutIndex&0xFFFF,nPostOutIndex>>16,nVpuInIndex&0xFFFF,nVpuInIndex>>16,nPreVpuInIndex&0xFFFF);
+			base->pPostOutQueue->Add(&nPostOutIndex);
+			FramePoolSetPostIndexMapping(&base->sFramePoolInfo, nPostOutIndex&0xFFFF, nVpuInIndex&0xFFFF); //mapping decode index
+			nPreVpuInIndex=nVpuInIndex;		//update previous index
+		}
+	}
+	VPU_COMP_POST_LOG("%s: Post Thread Stopped.\n",__FUNCTION__);
+	return NULL;
+}
+
+OMX_ERRORTYPE VpuDecoder::ReleaseVpuSource()
+{
+	VpuDecRetCode ret;
+	OMX_ERRORTYPE omx_ret=OMX_ErrorNone;
+	//close vpu
+	if(NULL!=nHandle)
+	{
+		VPU_COMP_SEM_LOCK(psemaphore);
+		ret=VPU_DecClose(nHandle);
+		VPU_COMP_SEM_UNLOCK(psemaphore);
+		if (ret!=VPU_DEC_RET_SUCCESS)
+		{
+			VPU_COMP_ERR_LOG("%s: vpu close failure: ret=0x%X \r\n",__FUNCTION__,ret);
+			omx_ret=OMX_ErrorHardware;
+		}
+	}
+
+	//stop/release post-process thread
+	if(pPostThreadId != NULL) {
+		PostThreadStop();
+		fsl_osal_thread_destroy(pPostThreadId);
+	}
+	if(pPostInQueue){
+		pPostInQueue->Free();
+		FSL_DELETE(pPostInQueue);
+	}
+	if(pPostOutQueue){
+		pPostOutQueue->Free();
+		FSL_DELETE(pPostOutQueue);
+	}
+	if(pPostInReturnQueue){
+		pPostInReturnQueue->Free();
+		FSL_DELETE(pPostInReturnQueue);
+	}
+	if(pPostOutReturnQueue){
+		pPostOutReturnQueue->Free();
+		FSL_DELETE(pPostOutReturnQueue);
+	}
+	if(pPostCmdSem){
+		fsl_osal_sem_destroy(pPostCmdSem);
+	}
+	if(pPostMutex!= NULL){
+		fsl_osal_mutex_destroy(pPostMutex);
+		//fsl_osal_cond_destroy(sPostCond);
+		pthread_cond_destroy(&sPostCond);
+	}
+	if(bEnabledPostProcess)	{
+		PostProcessIPUDeinit(&sIpuHandle);
+	}
+
+	//release mem
+	if(0==MemFreeBlock(&sVpuMemInfo,&sMemOperator))
+	{
+		VPU_COMP_ERR_LOG("%s: free memory failure !  \r\n",__FUNCTION__);
+		omx_ret=OMX_ErrorHardware;
+	}
+
+	//avoid memory leak !!!
+	if(0==MemFreeBlock(&sAllocMemInfo,&sMemOperator))
+	{
+		VPU_COMP_ERR_LOG("%s: free memory failure !!!  \r\n",__FUNCTION__);
+		omx_ret=OMX_ErrorHardware;
+	}
+
+	//unload
+	VPU_COMP_SEM_LOCK(psemaphore);
+	ret=VPU_DecUnLoad();
+	VPU_COMP_SEM_UNLOCK(psemaphore);
+	if (ret!=VPU_DEC_RET_SUCCESS)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu unload failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		omx_ret=OMX_ErrorHardware;
+	}
+	return omx_ret;
+}
+
+OMX_ERRORTYPE VpuDecoder::SetDefaultSetting()
+{
+	fsl_osal_strcpy((fsl_osal_char*)name, "OMX.Freescale.std.video_decoder.mpeg4.hw-based");
+
+	fsl_osal_memset(&sInFmt, 0, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+	sInFmt.nFrameWidth = DEFAULT_FRM_WIDTH;
+	sInFmt.nFrameHeight = DEFAULT_FRM_HEIGHT;
+	sInFmt.xFramerate = DEFAULT_FRM_RATE;
+	sInFmt.eColorFormat = OMX_COLOR_FormatUnused;
+	sInFmt.eCompressionFormat = OMX_VIDEO_CodingMPEG4;
+
+	nInPortFormatCnt = 0;
+	nOutPortFormatCnt = 2;
+	eOutPortPormat[0] = OMX_COLOR_FormatYUV420Planar;
+	eOutPortPormat[1] = OMX_COLOR_FormatYUV420SemiPlanar;
+
+	fsl_osal_memset(&sOutFmt, 0, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+	sOutFmt.nFrameWidth = DEFAULT_FRM_WIDTH;
+	sOutFmt.nFrameHeight = DEFAULT_FRM_HEIGHT;
+	sOutFmt.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+	sOutFmt.eCompressionFormat = OMX_VIDEO_CodingUnused;
+
+	bFilterSupportPartilInput = OMX_TRUE;
+	nInBufferCnt = DEFAULT_BUF_IN_CNT;
+	nInBufferSize = DEFAULT_BUF_IN_SIZE;
+	nOutBufferCnt = DEFAULT_BUF_OUT_CNT;
+	nOutBufferSize = sOutFmt.nFrameWidth * sOutFmt.nFrameHeight * pxlfmt2bpp(sOutFmt.eColorFormat) / 8;
+
+	//clear internal variable 0
+	fsl_osal_memset(&sMemInfo,0,sizeof(VpuMemInfo));
+	fsl_osal_memset(&sVpuMemInfo,0,sizeof(VpuDecoderMemInfo));
+	fsl_osal_memset(&sAllocMemInfo,0,sizeof(VpuDecoderMemInfo));	
+	fsl_osal_memset(&sInitInfo,0,sizeof(VpuDecInitInfo));	
+	fsl_osal_memset(&sFramePoolInfo,0,sizeof(VpuDecoderFrmPoolInfo));
+	
+	nHandle=0;
+
+#if 0
+	// role info
+	role_cnt = 10;	//Mpeg2;Mpeg4;DivX3;DivX4;Divx56;XviD;H263;H264;RV;VC1
+	role_cnt = 8;
+	role[0] = "video_decoder.avc";
+	role[1] = "video_decoder.wmv9";
+	role[2] = "video_decoder.mpeg2";
+	role[3] = "video_decoder.mpeg4";
+	role[4] = "video_decoder.divx3";
+	role[5] = "video_decoder.divx4";
+	role[6] = "video_decoder.divx";
+	role[7] = "video_decoder.xvid";
+	role[8] = "video_decoder.h263";
+	role[9] = "video_decoder.rv";
+#endif
+
+	eFormat = VPU_V_MPEG2;//VPU_V_MPEG4;
+	nPadWidth=DEFAULT_FRM_WIDTH;
+	nPadHeight=DEFAULT_FRM_HEIGHT;
+	OMX_INIT_STRUCT(&sOutCrop, OMX_CONFIG_RECTTYPE);
+	//sOutCrop.nPortIndex = VPUDEC_OUT_PORT;
+	sOutCrop.nLeft = sOutCrop.nTop = 0;
+	sOutCrop.nWidth = sInFmt.nFrameWidth;
+	sOutCrop.nHeight = sInFmt.nFrameHeight;
+
+	nFrameWidthStride=-1;	//default: invalid
+	nFrameHeightStride=-1;
+	nFrameMaxCnt=-1;
+
+	pInBuffer=(OMX_PTR)INVALID;
+	nInSize=0;
+	bInEos=OMX_FALSE;
+
+	//pOutBuffer=NULL;
+	//bOutLast=OMX_FALSE;
+	
+	eVpuDecoderState=VPU_COM_STATE_NONE;
+
+	pLastOutVirtBuf=NULL;
+
+	nFreeOutBufCntDec=0;
+	nFreeOutBufCntPost=0;	
+
+	nNeedFlush=0;
+	nNeedSkip=0;
+
+	fsl_osal_memset(&sMemOperator,0,sizeof(OMX_PARAM_MEM_OPERATOR));
+
+	ePlayMode=DEC_FILE_MODE;
+	nChromaAddrAlign=CHROMA_ALIGN;	
+	pClock=NULL;
+	nCapability=0;
+
+	nMaxDurationMsThr=-1;
+	nMaxBufCntThr=-1;
+
+	nOutBufferCntPost=DEFAULT_BUF_OUT_POST_ZEROCNT;
+	nOutBufferCntDec=DEFAULT_BUF_OUT_DEC_CNT;
+	bEnabledPostProcess=OMX_FALSE;
+	nPostMotion=MED_MOTION;  //default
+	pPostThreadId=NULL;
+	pPostInQueue=NULL;
+	pPostOutQueue=NULL;
+	pPostInReturnQueue=NULL;
+	pPostOutReturnQueue=NULL;
+	pPostCmdSem=NULL;
+	pPostMutex=NULL;
+
+	bReorderDisabled=OMX_FALSE;
+	return OMX_ErrorNone;
+}
+
+VpuDecoder::VpuDecoder()
+{
+	VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	// version info
+	//fsl_osal_strcpy((fsl_osal_char*)name, "OMX.Freescale.std.video_decoder.vpu.v2");
+	ComponentVersion.s.nVersionMajor = 0x0;
+	ComponentVersion.s.nVersionMinor = 0x1;
+	ComponentVersion.s.nRevision = 0x0;
+	ComponentVersion.s.nStep = 0x0;
+	
+	//set default
+	SetDefaultSetting();
+	
+	//return OMX_ErrorNone;	
+}
+
+OMX_ERRORTYPE VpuDecoder::SetRoleFormat(OMX_STRING role)
+{
+	OMX_VIDEO_CODINGTYPE CodingType = OMX_VIDEO_CodingUnused;
+	//OMX_PARAM_PORTDEFINITIONTYPE sPortDef;	
+	
+	VPU_COMP_API_LOG("%s: role: %s \r\n",__FUNCTION__,role);
+
+	if(fsl_osal_strcmp(role, "video_decoder.mpeg2") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingMPEG2;
+		eFormat=VPU_V_MPEG2;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_MPEG2DEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.h263") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingH263;
+		eFormat=VPU_V_H263;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_H263DEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.sorenson") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_SORENSON263;//OMX_VIDEO_CodingH263;
+		eFormat=VPU_V_H263;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_SORENSONDEC);		
+	}		
+	else if(fsl_osal_strcmp(role, "video_decoder.mpeg4") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingMPEG4;
+		eFormat=VPU_V_MPEG4;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_MPEG4DEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.wmv9") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE )OMX_VIDEO_CodingWMV9;
+		//CodingType = OMX_VIDEO_CodingWMV; ???
+		//1 we need to use SetParameter() to set eFormat  !!!
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_WMVDEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.rv") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingRV;
+		eFormat=VPU_V_RV;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_RVDEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.avc") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingAVC;
+		eFormat=VPU_V_AVC;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_AVCDEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.divx") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIVX;
+		eFormat=VPU_V_DIVX56;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_DIVXDEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.div3") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIV3;
+		eFormat=VPU_V_DIVX3;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_DIV3DEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.div4") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIV4;
+		eFormat=VPU_V_DIVX4;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_DIV4DEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.xvid") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingXVID;
+		eFormat=VPU_V_XVID;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_XVIDDEC);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.mjpeg") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingMJPEG;
+		eFormat=VPU_V_MJPG;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_MJPEGDEC);
+	}	
+	else if(fsl_osal_strcmp(role, "video_decoder.avs") == 0)
+	{
+		//1 CodingType = (OMX_VIDEO_CODINGTYPE);
+		VPU_COMP_ERR_LOG("%s: failure: avs unsupported: %s \r\n",__FUNCTION__,role);
+		eFormat=VPU_V_AVS;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_AVS);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.vp8") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP8;
+		eFormat=VPU_V_VP8;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_VP8);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.vpx") == 0)
+	{
+		CodingType = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVPX;
+		eFormat=VPU_V_VP8;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_VPX);
+	}
+	else if(fsl_osal_strcmp(role, "video_decoder.mvc") == 0)
+	{
+		//1 CodingType = (OMX_VIDEO_CODINGTYPE);
+		VPU_COMP_ERR_LOG("%s: failure: mvc unsupported: %s \r\n",__FUNCTION__,role);
+		eFormat=VPU_V_AVC_MVC;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_COMP_NAME_MVC);
+	}
+	else
+	{
+		CodingType = OMX_VIDEO_CodingUnused;		
+		//eFormat=;
+		VPU_COMP_ERR_LOG("%s: failure: unknow role: %s \r\n",__FUNCTION__,role);
+		return OMX_ErrorUndefined;
+	}
+
+	//check input change
+	if(sInFmt.eCompressionFormat!=CodingType)
+	{
+		sInFmt.eCompressionFormat=CodingType;
+		InputFmtChanged();
+	}
+#if 0	
+	OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+	sPortDef.nPortIndex = VPUDEC_IN_PORT;
+	ports[VPUDEC_IN_PORT]->GetPortDefinition(&sPortDef);
+	sPortDef.format.video.eCompressionFormat = CodingType;
+	ports[VPUDEC_IN_PORT]->SetPortDefinition(&sPortDef);
+#endif
+	
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure) 
+{ 
+	VPU_COMP_API_LOG("%s: nParamIndex=0x%X, \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		default:
+			break;
+	}
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_COMP_ERR_LOG("%s: failure: param is null \r\n",__FUNCTION__);	
+		return OMX_ErrorBadParameter;
+	}
+	
+	if(nParamIndex==OMX_IndexParamStandardComponentRole)
+	{
+		fsl_osal_strcpy((OMX_STRING)((OMX_PARAM_COMPONENTROLETYPE*)pComponentParameterStructure)->cRole,(OMX_STRING)cRole);
+		return OMX_ErrorNone;
+	}
+	else if(nParamIndex ==  OMX_IndexParamVideoWmv)
+	{ 
+		OMX_VIDEO_PARAM_WMVTYPE  *pPara; 
+		pPara = (OMX_VIDEO_PARAM_WMVTYPE *)pComponentParameterStructure; 
+		switch(eFormat)
+		{ 
+			case VPU_V_VC1: 
+				pPara->eFormat = OMX_VIDEO_WMVFormat9; 
+				break; 
+			default:
+				pPara->eFormat = OMX_VIDEO_WMVFormatUnused;
+				break;
+		}
+		return OMX_ErrorNone;
+	}
+	else if(nParamIndex ==  OMX_IndexParamVideoProfileLevelQuerySupported)
+	{ 
+		struct CodecProfileLevel {
+			OMX_U32 mProfile;
+			OMX_U32 mLevel;
+		};
+
+		static const CodecProfileLevel kH263ProfileLevels[] = {
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level10 },
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level20 },
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level30 },
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level45 },
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level50 },
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level60 },
+			{ OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level70 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level10 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level20 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level30 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level45 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level50 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level60 },
+			{ OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level70 },
+		};
+
+		static const CodecProfileLevel kProfileLevels[] = {
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel1  },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel1b },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel11 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel12 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel13 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel2  },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel21 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel22 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel3  },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel31 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel32 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel4  },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel41 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel42 },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel5  },
+			{ OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel51 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel1  },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel1b },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel11 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel12 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel13 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel2  },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel21 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel22 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel3  },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel31 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel32 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel4  },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel41 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel42 },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel5  },
+			{ OMX_VIDEO_AVCProfileMain, OMX_VIDEO_AVCLevel51 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel1  },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel1b },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel11 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel12 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel13 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel2  },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel21 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel22 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel3  },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel31 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel32 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel4  },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel41 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel42 },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel5  },
+			{ OMX_VIDEO_AVCProfileHigh, OMX_VIDEO_AVCLevel51 },
+		};
+
+		static const CodecProfileLevel kM4VProfileLevels[] = {
+			{ OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level0 },
+			{ OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level0b },
+			{ OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level1 },
+			{ OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level2 },
+			{ OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level3 },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level0 },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level0b },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level1 },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level2 },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level3 },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level4 },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level4a },
+			{ OMX_VIDEO_MPEG4ProfileAdvancedSimple, OMX_VIDEO_MPEG4Level5 },
+		};
+
+		static const CodecProfileLevel kMpeg2ProfileLevels[] = {
+			{ OMX_VIDEO_MPEG2ProfileSimple, OMX_VIDEO_MPEG2LevelLL },
+			{ OMX_VIDEO_MPEG2ProfileSimple, OMX_VIDEO_MPEG2LevelML },
+			{ OMX_VIDEO_MPEG2ProfileSimple, OMX_VIDEO_MPEG2LevelH14},
+			{ OMX_VIDEO_MPEG2ProfileSimple, OMX_VIDEO_MPEG2LevelHL},
+			{ OMX_VIDEO_MPEG2ProfileMain, OMX_VIDEO_MPEG2LevelLL },
+			{ OMX_VIDEO_MPEG2ProfileMain, OMX_VIDEO_MPEG2LevelML },
+			{ OMX_VIDEO_MPEG2ProfileMain, OMX_VIDEO_MPEG2LevelH14},
+			{ OMX_VIDEO_MPEG2ProfileMain, OMX_VIDEO_MPEG2LevelHL},
+		};
+
+		OMX_VIDEO_PARAM_PROFILELEVELTYPE  *pPara; 
+		OMX_S32 index;
+		OMX_S32 nProfileLevels;
+
+		pPara = (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)pComponentParameterStructure; 
+		switch(eFormat)
+		{ 
+			case VPU_V_H263: 
+				index = pPara->nProfileIndex;
+
+				nProfileLevels =sizeof(kH263ProfileLevels) / sizeof(kH263ProfileLevels[0]);
+				if (index >= nProfileLevels) {
+					return OMX_ErrorNoMore;
+				}
+
+				pPara->eProfile = kH263ProfileLevels[index].mProfile;
+				pPara->eLevel = kH263ProfileLevels[index].mLevel;
+				break; 
+			case VPU_V_AVC: 
+				index = pPara->nProfileIndex;
+
+				nProfileLevels =sizeof(kProfileLevels) / sizeof(kProfileLevels[0]);
+				if (index >= nProfileLevels) {
+					return OMX_ErrorNoMore;
+				}
+
+				pPara->eProfile = kProfileLevels[index].mProfile;
+				pPara->eLevel = kProfileLevels[index].mLevel;
+				break; 
+			case VPU_V_MPEG4: 
+				index = pPara->nProfileIndex;
+
+				nProfileLevels =sizeof(kM4VProfileLevels) / sizeof(kM4VProfileLevels[0]);
+				if (index >= nProfileLevels) {
+					return OMX_ErrorNoMore;
+				}
+
+				pPara->eProfile = kM4VProfileLevels[index].mProfile;
+				pPara->eLevel = kM4VProfileLevels[index].mLevel;
+				break; 
+			case VPU_V_MPEG2: 
+				index = pPara->nProfileIndex;
+
+				nProfileLevels =sizeof(kMpeg2ProfileLevels) / sizeof(kMpeg2ProfileLevels[0]);
+				if (index >= nProfileLevels) {
+					return OMX_ErrorNoMore;
+				}
+
+				pPara->eProfile = kMpeg2ProfileLevels[index].mProfile;
+				pPara->eLevel = kMpeg2ProfileLevels[index].mLevel;
+				break; 				
+			default:
+				return OMX_ErrorUnsupportedIndex;
+				//break;
+		}
+		return OMX_ErrorNone;
+	}	
+	else
+	{
+		VPU_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);	
+		return OMX_ErrorUnsupportedIndex;
+	}
+} 
+
+OMX_ERRORTYPE VpuDecoder::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pComponentParameterStructure)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	VPU_COMP_API_LOG("%s: nParamIndex=0x%X \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_LOADED:
+			break;
+		case VPU_COM_STATE_OPENED:
+			if(nParamIndex ==  OMX_IndexParamVideoWmv)
+			{
+				break;
+			}			
+		default:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d, nParamIndex=0x%X, role=%s \r\n",__FUNCTION__,eVpuDecoderState,nParamIndex,(OMX_STRING)cRole);
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_COMP_ERR_LOG("%s: failure: param is null \r\n",__FUNCTION__);
+		return OMX_ErrorBadParameter;
+	}
+
+	if(nParamIndex==OMX_IndexParamStandardComponentRole)
+	{
+		fsl_osal_strcpy( (fsl_osal_char *)cRole,(fsl_osal_char *)((OMX_PARAM_COMPONENTROLETYPE*)pComponentParameterStructure)->cRole);
+		if(OMX_ErrorNone!=SetRoleFormat((OMX_STRING)cRole))
+		{
+			VPU_COMP_ERR_LOG("%s: set role format failure \r\n",__FUNCTION__);
+			return OMX_ErrorBadParameter;
+		}
+	}
+	else if(nParamIndex ==  OMX_IndexParamVideoWmv)
+	{
+		OMX_VIDEO_PARAM_WMVTYPE  *pPara;
+		pPara = (OMX_VIDEO_PARAM_WMVTYPE *)pComponentParameterStructure;
+
+		switch((int)(pPara->eFormat))
+		{
+			case OMX_VIDEO_WMVFormat7:
+			case OMX_VIDEO_WMVFormat8:
+			case OMX_VIDEO_WMVFormat9a:
+				ret = OMX_ErrorBadParameter;
+				break;	
+			case OMX_VIDEO_WMVFormat9:
+				eFormat = VPU_V_VC1;
+				VPU_COMP_LOG("%s: set OMX_VIDEO_WMVFormat9 \r\n",__FUNCTION__);
+				break;
+			case OMX_VIDEO_WMVFormatWVC1:
+				eFormat = VPU_V_VC1_AP;
+				VPU_COMP_LOG("%s: set OMX_VIDEO_WMVFormatWVC1 \r\n",__FUNCTION__);
+				break;
+			default:
+				//eFormat = ;
+				VPU_COMP_ERR_LOG("%s: failure: unsupported format: 0x%X \r\n",__FUNCTION__,pPara->eFormat);
+				ret = OMX_ErrorBadParameter;
+				break;
+		}
+	}
+	else if (nParamIndex==OMX_IndexParamMemOperator)
+	{
+		//should be set before open vpu(eg. malloc bitstream/frame buffers)
+		if(VPU_COM_STATE_LOADED!=eVpuDecoderState)
+		{
+			ret=OMX_ErrorInvalidState;
+		}		
+		else
+		{
+			OMX_PARAM_MEM_OPERATOR * pPara;
+			pPara=(OMX_PARAM_MEM_OPERATOR *)pComponentParameterStructure;
+			VPU_COMP_LOG("%s: set OMX_IndexParamMemOperator \r\n",__FUNCTION__);
+			sMemOperator=*pPara;
+		}
+	}
+	else if(nParamIndex==OMX_IndexParamDecoderPlayMode)
+	{
+		OMX_DECODE_MODE* pMode=(OMX_DECODE_MODE*)pComponentParameterStructure;
+		ePlayMode=*pMode;
+		VPU_COMP_LOG("%s: set OMX_IndexParamDecoderPlayMode: %d \r\n",__FUNCTION__,*pMode);
+	}	
+	else if(nParamIndex==OMX_IndexParamVideoDecChromaAlign)
+	{
+		OMX_U32* pAlignVal=(OMX_U32*)pComponentParameterStructure;
+		nChromaAddrAlign=*pAlignVal;
+		VPU_COMP_LOG("%s: set OMX_IndexParamVideoDecChromaAlign: %d \r\n",__FUNCTION__,nChromaAddrAlign);
+		if(nChromaAddrAlign==0) nChromaAddrAlign=1;
+	}
+	else if(nParamIndex==OMX_IndexParamDecoderCachedThreshold)
+	{
+		OMX_DECODER_CACHED_THR* pDecCachedInfo=(OMX_DECODER_CACHED_THR*)pComponentParameterStructure;
+		if(pDecCachedInfo->nPortIndex==IN_PORT)
+		{
+			nMaxDurationMsThr=pDecCachedInfo->nMaxDurationMsThreshold;
+			nMaxBufCntThr=pDecCachedInfo->nMaxBufCntThreshold;
+			VPU_COMP_LOG("%s: set OMX_IndexParamDecoderCachedThreshold: max duration(ms) threshold : %d, max buf cnt threshold: %d \r\n",__FUNCTION__,nMaxDurationMsThr,nMaxBufCntThr);
+		}
+	}
+	else if(nParamIndex==OMX_IndexParamVideoRegisterFrameExt){
+		OMX_VIDEO_REG_FRM_EXT_INFO* pExtInfo=(OMX_VIDEO_REG_FRM_EXT_INFO*)pComponentParameterStructure;
+		if(pExtInfo->nPortIndex==OUT_PORT){
+			nFrameWidthStride=pExtInfo->nWidthStride;
+			nFrameHeightStride=pExtInfo->nHeightStride;
+			nFrameMaxCnt=(pExtInfo->nMaxBufferCnt<=VPU_DEC_MAX_NUM_MEM)?pExtInfo->nMaxBufferCnt:VPU_DEC_MAX_NUM_MEM;
+			VPU_COMP_LOG("%s: set OMX_IndexParamVideoFrameStride: width stride : %d, height stride: %d, max count: %d \r\n",__FUNCTION__,nFrameWidthStride,nFrameHeightStride,nFrameMaxCnt);
+		}
+	}
+	else if(nParamIndex==OMX_IndexParamVideoDecReorderDisable){
+		OMX_DECODER_REORDER * pReorderInfo=(OMX_DECODER_REORDER *)pComponentParameterStructure;
+		bReorderDisabled=pReorderInfo->bDisable;
+		VPU_COMP_LOG("%s: set OMX_IndexParamVideoDecReorderDisable: disabled: %d \r\n",__FUNCTION__,bReorderDisabled);
+	}
+	else
+	{
+		VPU_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);	
+		ret = OMX_ErrorUnsupportedIndex;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE VpuDecoder::GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure)
+{
+	VPU_COMP_API_LOG("%s: nParamIndex=0x%X, \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+		case VPU_COM_STATE_LOADED:
+		case VPU_COM_STATE_OPENED:	//allow user get wrong value before opened ???
+			//forbidden
+			VPU_COMP_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_COMP_ERR_LOG("%s: failure: param is null  \r\n",__FUNCTION__);			
+		return OMX_ErrorBadParameter;
+	}
+
+	switch ((int)nParamIndex)
+	{
+		case OMX_IndexConfigCommonOutputCrop:
+			{
+				OMX_CONFIG_RECTTYPE *pRecConf = (OMX_CONFIG_RECTTYPE*)pComponentParameterStructure;
+				if(pRecConf->nPortIndex == VPUDEC_OUT_PORT)
+				{
+					pRecConf->nTop = sOutCrop.nTop;
+					pRecConf->nLeft = sOutCrop.nLeft;
+					pRecConf->nWidth = sOutCrop.nWidth;
+					pRecConf->nHeight = sOutCrop.nHeight;
+					VPU_COMP_LOG("%s: [top,left,width,height]=[%d,%d,%d,%d], \r\n",__FUNCTION__,(INT32)pRecConf->nTop,(INT32)pRecConf->nLeft,(INT32)pRecConf->nWidth,(INT32)pRecConf->nHeight);
+				}
+			}
+			break;
+		case OMX_IndexConfigCommonScale:
+			{
+				OMX_CONFIG_SCALEFACTORTYPE *pDispRatio = (OMX_CONFIG_SCALEFACTORTYPE *)pComponentParameterStructure;
+				if(pDispRatio->nPortIndex == VPUDEC_OUT_PORT)
+				{
+					pDispRatio->xWidth = sDispRatio.xWidth;
+					pDispRatio->xHeight = sDispRatio.xHeight;
+				}
+			}
+			break;
+		case OMX_IndexConfigVideoOutBufPhyAddr:
+			{
+				OMX_CONFIG_VIDEO_OUTBUFTYPE * param = (OMX_CONFIG_VIDEO_OUTBUFTYPE *)pComponentParameterStructure;
+				if(OMX_ErrorNone!=GetHwBuffer(param->pBufferHdr->pBuffer,&param->nPhysicalAddr))
+				{
+					return OMX_ErrorBadParameter;
+				}
+			}
+			break;
+		default:
+			VPU_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);			
+			return OMX_ErrorUnsupportedIndex;
+			//break;
+	}
+	
+	return OMX_ErrorNone;	
+}
+
+OMX_ERRORTYPE VpuDecoder::SetConfig(OMX_INDEXTYPE nIndex, OMX_PTR pComponentConfigStructure)
+{
+	OMX_ERRORTYPE eRetVal = OMX_ErrorNone;
+	OMX_CONFIG_CLOCK *pC;
+	
+	if(pComponentConfigStructure == NULL)
+	{
+		return OMX_ErrorBadParameter;
+
+	}
+	switch((int)nIndex)
+	{
+		case OMX_IndexConfigClock:
+			pC = (OMX_CONFIG_CLOCK*) pComponentConfigStructure;
+			pClock = pC->hClock;
+			break;
+		default:
+			return eRetVal;
+	}
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::GetInputDataDepthThreshold(OMX_S32* pDurationThr, OMX_S32* pBufCntThr)
+{
+    /*
+      for some application, such rtsp/http, we need to set some thresholds to avoid input data is consumed by decoder too fast.
+      -1: no threshold
+    */
+    *pDurationThr=nMaxDurationMsThr;
+    *pBufCntThr=nMaxBufCntThr;
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::InitFilterComponent()
+{
+	VpuDecRetCode ret;
+	//VpuVersionInfo ver;
+	//VpuMemInfo sMemInfo;
+	
+	VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+			break;
+		default:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+
+	}
+
+	// init semaphore
+#ifdef USE_PROCESS_SEM	
+	VPU_COMP_SEM_INIT_PROCESS(&psemaphore);
+#else
+	VPU_COMP_SEM_INIT(&psemaphore);
+#endif
+
+	//update state
+	eVpuDecoderState=VPU_COM_STATE_LOADED;
+	
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::DeInitFilterComponent()
+{
+	OMX_ERRORTYPE omx_ret=OMX_ErrorNone;
+	VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);	
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		case VPU_COM_STATE_LOADED:
+			break;
+		default:
+			//invalid state, DeInitFilter() is skipped : we need to close/unload vpu
+			VPU_COMP_ERR_LOG("invalid state: %d, close vpu manually \r\n",eVpuDecoderState);
+			ReleaseVpuSource();
+			break;
+	}
+
+#ifdef USE_PROCESS_SEM	
+	VPU_COMP_SEM_DESTROY_PROCESS(psemaphore);
+#else
+	VPU_COMP_SEM_DESTROY(psemaphore);
+#endif
+
+	//update state 
+	eVpuDecoderState=VPU_COM_STATE_NONE;
+
+	return omx_ret;
+}
+
+OMX_ERRORTYPE VpuDecoder::SetInputBuffer(OMX_PTR pBuffer, OMX_S32 nSize, OMX_BOOL bLast)
+{
+	pInBuffer=pBuffer;
+	nInSize=nSize;
+	bInEos=bLast;
+
+	VPU_COMP_API_LOG("%s: state: %d, size: %d, last: %d \r\n",__FUNCTION__,eVpuDecoderState,(UINT32)nInSize,(UINT32)bInEos);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		case VPU_COM_STATE_EOS:
+			//if user want to repeat play, user should call the last getoutput (to make state change from eos to decode)
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+	
+	//check data length, we don't allow zero-length-buf
+	if(0>=nInSize)
+	{
+		pInBuffer=NULL;
+	}
+
+	if(1==nNeedFlush)
+	{
+		VPU_COMP_LOG("flush internal !!!! \r\n");
+		if(OMX_ErrorNone!=FlushFilter())
+		{
+			VPU_COMP_ERR_LOG("internal flush filter failure \r\n");
+		}
+		if(bEnabledPostProcess)	{
+			//PostThreadFlushInput();
+			PostThreadFlushOutput();  //flush output cover flush input
+		}
+		//nNeedFlush=0;
+	}
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::SetOutputBuffer(OMX_PTR pBuffer)
+{
+	VpuDecRetCode ret;
+	VpuDecOutFrameInfo * pFrameInfo;
+	OMX_S32 nFrameNum;
+	OMX_S32 index;
+	OMX_PTR pPhyAddr;
+	OMX_S32 nBufExist;
+
+	VPU_COMP_API_LOG("%s: state: %d, buffer: 0x%X \r\n",__FUNCTION__,eVpuDecoderState,(UINT32)pBuffer);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);
+			return OMX_ErrorIncorrectStateTransition;
+		case VPU_COM_STATE_EOS:
+			//if user want to repeat play, user should call the last getoutput (to make state change from eos to decode)
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	//pOutBuffer=pBuffer;
+	nBufExist=FramePoolBufExist(pBuffer,&sFramePoolInfo,&pPhyAddr,&index);
+	if(nBufExist<0)
+	{
+		VPU_COMP_ERR_LOG("%s: failure: unvalid buffer: 0x%X \r\n",__FUNCTION__,(UINT32)pBuffer);
+		return OMX_ErrorInsufficientResources;
+	}
+	else if(nBufExist==0)
+	{
+		//register frame buffer
+		nFrameNum=FramePoolRegisterBuf(pBuffer,pPhyAddr,&sFramePoolInfo);
+		if(-1==nFrameNum)
+		{
+			VPU_COMP_ERR_LOG("%s: register frame failure: frame pool is full ! \r\n",__FUNCTION__);
+			return OMX_ErrorInsufficientResources;
+		}
+	}
+	else
+	{
+		VpuDecoderFrmOwner eOwner;
+		VpuDecoderFrmState eState;
+		FramePoolGetBufProperty(&sFramePoolInfo,index,&eOwner,&eState,&pFrameInfo);
+		switch(eOwner)
+		{
+			case VPU_COM_FRM_OWNER_DEC:
+				if (eState==VPU_COM_FRM_STATE_OUT)
+				{
+					if(NULL!=pFrameInfo->pDisplayFrameBuf)
+					{
+						//clear displayed frame
+						ret=FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+						if(VPU_DEC_RET_SUCCESS!=ret)
+						{
+							VPU_COMP_ERR_LOG("%s: vpu clear frame display failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+							return OMX_ErrorHardware;
+						}			
+					}
+					else
+					{
+						//this is fake output frame which is stolen at some special steps, include EOS, flush,...
+						VPU_COMP_LOG("application return one stolen buffer: 0x%X \r\n",pBuffer);
+					}
+					//update buffer state
+					nFreeOutBufCntDec++;
+					VPU_COMP_LOG("set output: 0x%X , nFreeOutBufCntDec: %d \r\n",(UINT32)pBuffer,(UINT32)nFreeOutBufCntDec);
+					FramePoolSetBufState(&sFramePoolInfo,index,VPU_COM_FRM_STATE_FREE);
+				}
+				else
+				{
+					VPU_COMP_ERR_LOG("%s: failure: repeat setting output buffer: 0x%X \r\n",__FUNCTION__,(UINT32)pBuffer);
+					return OMX_ErrorIncorrectStateOperation;					
+				}
+				break;
+			case VPU_COM_FRM_OWNER_POST:
+				if (eState==VPU_COM_FRM_STATE_OUT)
+				{
+					nFreeOutBufCntPost++;
+					VPU_COMP_LOG("set output: 0x%X , nFreeOutBufCntPost: %d \r\n",(UINT32)pBuffer,(UINT32)nFreeOutBufCntPost);
+					FramePoolSetBufState(&sFramePoolInfo,index,VPU_COM_FRM_STATE_FREE);
+					pPostOutReturnQueue->Add(&index);
+					PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+				}
+				else
+				{
+					VPU_COMP_ERR_LOG("%s: failure: repeat setting output buffer: 0x%X \r\n",__FUNCTION__,(UINT32)pBuffer);
+					return OMX_ErrorIncorrectStateOperation;					
+				}
+				break;
+			default:
+				VPU_COMP_ERR_LOG("%s: warning: find one isolated buffer: 0x%X, it will be discarded from pipeline !",__FUNCTION__,(UINT32)pBuffer);
+				break;
+		}
+	}
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::InitFilter()
+{
+	VpuDecRetCode ret;
+	VpuFrameBuffer frameBuf[MAX_FRAME_NUM];
+	OMX_S32 BufNum;
+	OMX_S32 nWidthStride,nHeightStride;
+
+	VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);	
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_DO_INIT:
+			break;
+		default:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+	}
+	
+	ASSERT(nOutBufferCnt<=MAX_FRAME_NUM);
+	//vpu register step: fill frameBuf[]
+	if(nFrameWidthStride<nPadWidth || nFrameHeightStride<nPadHeight){
+		nWidthStride=nPadWidth;
+		nHeightStride=nPadHeight;
+	}
+	else{
+		/*user will allocate enough frame memory, vpu needn't report resolution change which will lead to much overhead*/
+		nWidthStride=nFrameWidthStride;
+		nHeightStride=nFrameHeightStride;
+		VPU_DecDisCapability(nHandle,VPU_DEC_CAP_RESOLUTION_CHANGE);
+	}
+	BufNum=FramePoolCreateDecoderRegisterFrame(frameBuf, &sFramePoolInfo,nOutBufferCntDec,nWidthStride, nHeightStride, &sVpuMemInfo,&sMemOperator,sOutFmt.eColorFormat,nChromaAddrAlign);
+	if(-1==BufNum)
+	{
+		VPU_COMP_ERR_LOG("%s: create register frame failure \r\n",__FUNCTION__);	
+		return OMX_ErrorInsufficientResources;
+	}
+
+	//vpu register step: register frame buffs
+	VPU_COMP_SEM_LOCK(psemaphore);
+	ret=VPU_DecRegisterFrameBuffer(nHandle, frameBuf, BufNum);
+	VPU_COMP_SEM_UNLOCK(psemaphore);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu register frame failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+		return OMX_ErrorHardware;
+	}	
+
+	if(bEnabledPostProcess)
+	{
+		//post-process register step:
+		BufNum=FramePoolRegisterPostFrame(&sFramePoolInfo,nOutBufferCntPost,pPostOutReturnQueue);
+		if(-1==BufNum)
+		{
+			VPU_COMP_ERR_LOG("%s: register post frame failure \r\n",__FUNCTION__);	
+			return OMX_ErrorInsufficientResources;
+		}
+	}
+
+	//update state
+	eVpuDecoderState=VPU_COM_STATE_DO_DEC;
+
+	//update buffer state
+	nFreeOutBufCntDec=nOutBufferCntDec;
+	nFreeOutBufCntPost=nOutBufferCntPost;
+	
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::DeInitFilter()
+{
+	VpuDecRetCode ret;
+	OMX_ERRORTYPE omx_ret=OMX_ErrorNone;
+	VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+		case VPU_COM_STATE_LOADED:
+		//case VPU_COM_STATE_OPENED:
+		//case VPU_COM_STATE_WAIT_FRM:	
+		//case VPU_COM_STATE_DO_INIT:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	omx_ret=ReleaseVpuSource();
+
+	//clear handle
+	nHandle=0;
+
+	//restore default to support following switch from loaded to idle later.
+	SetDefaultSetting();
+
+	//update state 
+	eVpuDecoderState=VPU_COM_STATE_LOADED;
+
+	return omx_ret;
+}
+
+FilterBufRetCode VpuDecoder::FilterOneBuffer()
+{
+	VpuDecRetCode ret;
+	VpuBufferNode InData;
+	OMX_S32 bufRetCode;
+	FilterBufRetCode bufRet=FILTER_OK;	
+	
+	OMX_U8* pBitstream;
+	OMX_S32 readbytes;
+	OMX_U8  dummy;
+	OMX_S32 enableFileMode=0;
+	OMX_S32 capability=0;
+#ifdef VPU_COMP_DEBUG	
+	static OMX_U32 nNotUsedCnt=0;
+	static OMX_U32 nOutFrameCnt=0;
+	static FILE* fpBitstream=NULL;
+#endif
+
+	VPU_COMP_API_LOG("%s: state: %d, InBuf: 0x%X, data size: %d, bInEos: %d \r\n",__FUNCTION__,eVpuDecoderState,(UINT32)pInBuffer,(UINT32)nInSize,bInEos);
+
+	if(1==nNeedSkip)
+	{
+		VPU_COMP_LOG("skip directly: we need to get one time stamp \r\n");
+		nNeedSkip=0;
+		return FILTER_SKIP_OUTPUT;
+	}
+	
+RepeatPlay:
+	//check state
+	switch(eVpuDecoderState)
+	{
+		//forbidden state
+		case VPU_COM_STATE_NONE:
+		case VPU_COM_STATE_DO_INIT:	
+		case VPU_COM_STATE_DO_OUT:
+		case VPU_COM_STATE_EOS:
+			bufRet=FILTER_ERROR;
+			VPU_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return bufRet;
+		//allowed state	
+		case VPU_COM_STATE_WAIT_FRM:
+			if(FramePoolBufNum(&sFramePoolInfo)>=(OMX_S32)nOutBufferCnt)
+			{
+				//ready to call InitFilter()
+				eVpuDecoderState=VPU_COM_STATE_DO_INIT;
+				bufRet =FILTER_DO_INIT;
+			}
+			else
+			{
+				//do nothing, wait for more output buffer
+				bufRet=FILTER_NO_OUTPUT_BUFFER; 
+			}
+			VPU_COMP_LOG("%s: waiting frames ready, return and do nothing \r\n",__FUNCTION__);	
+			return bufRet;//OMX_ErrorNone;
+		case VPU_COM_STATE_LOADED:	
+			//load vpu
+			VPU_COMP_SEM_LOCK(psemaphore);
+			ret=VPU_DecLoad();
+			VPU_COMP_SEM_UNLOCK(psemaphore);
+			if (ret!=VPU_DEC_RET_SUCCESS)
+			{
+				VPU_COMP_ERR_LOG("%s: vpu load failure: ret=0x%X \r\n",__FUNCTION__,ret);
+				return FILTER_ERROR;//OMX_ErrorHardware;
+			}
+
+			//version info
+			VPU_COMP_SEM_LOCK(psemaphore);
+			ret=VPU_DecGetVersionInfo(&sVpuVer);
+			if (ret!=VPU_DEC_RET_SUCCESS)
+			{
+				VPU_COMP_ERR_LOG("%s: vpu get version failure: ret=0x%X \r\n",__FUNCTION__,ret);
+				VPU_DecUnLoad();
+				VPU_COMP_SEM_UNLOCK(psemaphore);
+				return FILTER_ERROR;//OMX_ErrorHardware;
+			}
+			VPU_COMP_SEM_UNLOCK(psemaphore);
+			VPU_COMP_LOG("vpu lib version : rel.major.minor=%d.%d.%d \r\n",sVpuVer.nLibRelease,sVpuVer.nLibMajor,sVpuVer.nLibMinor);
+			VPU_COMP_LOG("vpu fw version : rel.major.minor=%d.%d.%d \r\n",sVpuVer.nFwRelease,sVpuVer.nFwMajor,sVpuVer.nFwMinor);	
+
+			//query memory
+			VPU_COMP_SEM_LOCK(psemaphore);
+			ret=VPU_DecQueryMem(&sMemInfo);
+			VPU_COMP_SEM_UNLOCK(psemaphore);
+			if (ret!=VPU_DEC_RET_SUCCESS)
+			{
+				VPU_COMP_ERR_LOG("%s: vpu query memory failure: ret=0x%X \r\n",__FUNCTION__,ret);
+				return FILTER_ERROR;
+			}
+			//malloc memory for vpu wrapper
+			if(0==MemMallocVpuBlock(&sMemInfo,&sVpuMemInfo,&sMemOperator))
+			{
+				VPU_COMP_ERR_LOG("%s: malloc memory failure: \r\n",__FUNCTION__);
+				return FILTER_ERROR;
+			}
+			//open vpu
+			enableFileMode=(ePlayMode==DEC_FILE_MODE)?1:0;
+			if(OMX_ErrorNone!=OpenVpu(&nHandle, &sMemInfo, eFormat, sInFmt.nFrameWidth, sInFmt.nFrameHeight,sOutFmt.eColorFormat,enableFileMode,psemaphore,bReorderDisabled)) //1 sInFmt is valid ???
+			{
+				VPU_COMP_ERR_LOG("%s: open vpu failure \r\n",__FUNCTION__);
+				return FILTER_ERROR;
+			}
+			//check capability
+			VPU_COMP_SEM_LOCK(psemaphore);
+			ret=VPU_DecGetCapability(nHandle, VPU_DEC_CAP_FRAMESIZE, (INT32*)&capability);
+			if((ret==VPU_DEC_RET_SUCCESS)&&capability)
+			{
+				nCapability|=VPU_COM_CAPABILITY_FRMSIZE;
+				bFilterSupportFrmSizeRpt=OMX_TRUE;
+			}
+			VPU_COMP_SEM_UNLOCK(psemaphore);			
+			//update state
+			eVpuDecoderState=VPU_COM_STATE_OPENED;
+		case VPU_COM_STATE_OPENED:
+			break;
+		case VPU_COM_STATE_DO_DEC:
+			if(bEnabledPostProcess)
+			{
+				OMX_S32 index;
+				//return frame buffer to vpu as possible
+				while(pPostInReturnQueue->Size()>0){
+					pPostInReturnQueue->Get(&index);
+					VPU_COMP_LOG("post-process: return vpu index: %d \r\n",index);
+					FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+					nFreeOutBufCntDec++;
+				}
+				//notify user get output if output ready in post-process output port 
+				if(pPostOutQueue->Size()>0)
+				{
+					//printf("notify user get one post out : cnt: %d \r\n",pPostOutQueue->Size());
+					eVpuDecoderState=VPU_COM_STATE_DO_OUT;
+					return FILTER_HAS_OUTPUT;
+				}
+				//no enough output frame for post-process
+				if(nFreeOutBufCntPost<FRAME_POST_MIN_FREE_THD)
+				{
+					return FILTER_NO_OUTPUT_BUFFER;
+				}
+			}
+			else
+			{
+				//if(nFreeOutBufCntDec<=0)	//1 not enough, may hang up ???
+				if((OMX_S32)nFreeOutBufCntDec<=(OMX_S32)(Max((OMX_S32)FRAME_MIN_FREE_THD,0)))
+				{
+					//notify user release outputed buffer
+					//printf("%s: no output buffer, do nothing, current free buf numbers: %d \r\n",__FUNCTION__,(INT32)nFreeOutBufCntDec);	
+					return FILTER_NO_OUTPUT_BUFFER;
+				}
+			}
+			break;
+		case VPU_COM_STATE_RE_WAIT_FRM:
+			if(bEnabledPostProcess)
+			{
+				//no enough output frame for post-process
+				if(nFreeOutBufCntPost<FRAME_POST_MIN_FREE_THD)
+				{
+					return FILTER_NO_OUTPUT_BUFFER;
+				}				
+			}
+			//FIXME: for iMX6(now its major version==2), we needn't to return all frame buffers.
+			if((sVpuVer.nFwMajor!=2)&&(sVpuVer.nFwMajor!=3))
+			{			
+				//need to user SetOutputBuffer() for left buffers, otherwise vpu may return one buffer which is not set by user 
+				if((OMX_U32)(nFreeOutBufCntDec+nFreeOutBufCntPost)<nOutBufferCnt)
+				{
+					VPU_COMP_LOG("%s: no output buffer, do nothing, current free buf numbers: %d \r\n",__FUNCTION__,(INT32)nFreeOutBufCntDec);
+					return FILTER_NO_OUTPUT_BUFFER;
+				}		
+			}
+			else
+			{
+				//for  iMX6: needn't return all frame buffers except those who are stolen in flush/eos step.
+				OMX_S32 stolenNum;
+				stolenNum=FramePoolStolenDecoderBufNum(&sFramePoolInfo);
+				if(stolenNum>0)
+				{
+					VPU_COMP_LOG("stolen buffer cnt isn't zero: %d \r\n",stolenNum);
+					return FILTER_NO_OUTPUT_BUFFER;
+				}
+			}
+			eVpuDecoderState=VPU_COM_STATE_DO_DEC;
+			goto RepeatPlay;
+			break;
+		case VPU_COM_STATE_WAIT_POST_EOS:
+			if(bEnabledPostProcess)
+			{
+				OMX_S32 index;
+				//return frame buffer to vpu as possible
+				while(pPostInReturnQueue->Size()>0){
+					pPostInReturnQueue->Get(&index);
+					VPU_COMP_LOG("post-process: return vpu index: %d \r\n",index);
+					FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+					nFreeOutBufCntDec++;
+				}
+				//notify user get output if output ready in post-process output port 
+				if(pPostOutQueue->Size()>0)
+				{
+					//printf("notify user get one post out : cnt: %d \r\n",pPostOutQueue->Size());
+					pPostOutQueue->Access(&index, 0);
+					if((index>>16)&POST_INDEX_EOS)
+					{
+						eVpuDecoderState=VPU_COM_STATE_EOS;
+						return FILTER_LAST_OUTPUT;
+					}
+					return FILTER_HAS_OUTPUT;
+				}
+				//no enough output frame for post-process
+				if(nFreeOutBufCntPost<FRAME_POST_MIN_FREE_THD)
+				{
+					return FILTER_NO_OUTPUT_BUFFER;
+				}
+			}
+			return FILTER_OK;
+		//unknow state 
+		default:
+			VPU_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);
+			return FILTER_ERROR;
+	}
+
+	//for all codecs 
+	pBitstream=(pInBuffer==(OMX_PTR)INVALID)?NULL:(OMX_U8*)pInBuffer;
+	readbytes=nInSize;
+
+	//check eos or null data
+	if(pBitstream==NULL)
+	{
+		if(bInEos==OMX_TRUE)
+		{
+			//create and send EOS data (with length=0)
+			pBitstream=&dummy;
+			readbytes=0;
+			//bInEos=OMX_FALSE;
+		}
+		else
+		{
+			//no new input setting , return directly
+			//VPU_COMP_LOG("%s: pInBuffer==NULL, set consumed and return directly(do nothing)  \r\n",__FUNCTION__);
+			//bufRet=(FilterBufRetCode)(bufRet|FILTER_INPUT_CONSUMED);
+			//return FILTER_OK;//OMX_ErrorNone;
+		}
+	}
+
+	//EOS: 		0==readbytesp && Bitstream!=NULL
+	//non-EOS: 	0==readbytesp && Bitstream==NULL
+
+	//reset bOutLast for any non-zero data ??
+	//bOutLast=OMX_FALSE;
+	
+	//seq init
+	//decode bitstream buf
+	VPU_COMP_LOG("%s: pBitstream=0x%X, readbytes=%d  \r\n",__FUNCTION__,(UINT32)pBitstream,(INT32)readbytes);
+	InData.nSize=readbytes;
+	InData.pPhyAddr=NULL;
+	InData.pVirAddr=pBitstream;
+	InData.sCodecData.pData=(OMX_U8*)pCodecData;
+	InData.sCodecData.nSize=nCodecDataLen;
+
+#ifdef VPU_DEC_COMP_DROP_B
+#if 0  //FIXME: if disable drop B for some tough interlaced clips(1080p), it will impact the performance heavily
+        if((bEnabledPostProcess==OMX_FALSE)||(HIGH_MOTION==nPostMotion)) //post thread may detect frame/field type context, so shouldn't drop any fra
+#endif
+        {
+            OMX_TICKS nTimeStamp;
+            nTimeStamp=QueryStreamTs();
+            if(nTimeStamp >= 0) 
+            {
+                if(OMX_ErrorNone!=ConfigVpu(nHandle,nTimeStamp,pClock,psemaphore))
+                {
+                    return FILTER_ERROR;
+                }
+            }
+        }
+#endif
+
+	VPU_COMP_SEM_LOCK(psemaphore);
+	ret=VPU_DecDecodeBuf(nHandle, &InData,(INT32*)&bufRetCode);
+	//VPU_COMP_SEM_UNLOCK(&sSemaphore);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu dec buf failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+		if(VPU_DEC_RET_FAILURE_TIMEOUT==ret)
+		{
+			//VPU_COMP_SEM_LOCK(psemaphore);
+			VPU_DecReset(nHandle);
+			SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+		}
+		VPU_COMP_SEM_UNLOCK(psemaphore);
+		return FILTER_ERROR; //OMX_ErrorHardware;
+	}
+	VPU_COMP_SEM_UNLOCK(psemaphore);
+	VPU_COMP_LOG("%s: bufRetCode: 0x%X  \r\n",__FUNCTION__,bufRetCode);
+	//check input buff	
+	if(bufRetCode&VPU_DEC_INPUT_USED)
+	{
+#ifdef VPU_COMP_DEBUG
+		FileDumpBitstrem(&fpBitstream,pBitstream,readbytes);
+#endif
+
+		if(pInBuffer!=(OMX_PTR)INVALID)
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_INPUT_CONSUMED);
+			pInBuffer=(OMX_PTR)INVALID;  //clear input 
+			nInSize=0;
+		}
+	}
+	else
+	{
+		//not used
+		VPU_COMP_LOG("%s: not used  \r\n",__FUNCTION__);
+#ifdef VPU_COMP_DEBUG	
+		nNotUsedCnt++;
+		if(nNotUsedCnt>MAX_NULL_LOOP)
+		{
+			VPU_COMP_ERR_LOG("%s: too many(%d times) null loop: return failure \r\n",__FUNCTION__, (INT32)nNotUsedCnt);
+			return FILTER_ERROR;
+		}
+#endif		
+	}
+
+	//check init info
+	if(bufRetCode&VPU_DEC_INIT_OK)
+	{
+		FilterBufRetCode ret;
+		ret=ProcessVpuInitInfo();
+		bufRet=(FilterBufRetCode)((OMX_U32)bufRet|(OMX_U32)ret);
+		return bufRet;
+	}
+
+	//check resolution change
+	if(bufRetCode&VPU_DEC_RESOLUTION_CHANGED)
+	{
+		/*in such case:
+		   (1) the frames which haven't been output (in vpu or post-process) will be discard, So, video may be not complete continuous.
+		   (2) user need to re-allocate buffers, so buffer state will be meaningless.
+		   (3) the several frames dropped may affect timestamp if user don't use decoded handle to map frames between decoded and display ?
+		 */
+		FilterBufRetCode ret;
+		VPU_COMP_LOG("resolution changed \r\n");
+		//release post-process module
+		if(bEnabledPostProcess)
+		{
+			//stop/release post-process thread
+			if(pPostThreadId != NULL) {
+				PostThreadStop();
+				fsl_osal_thread_destroy(pPostThreadId); pPostThreadId=NULL;
+			}
+			if(pPostInQueue){
+				pPostInQueue->Free();
+				FSL_DELETE(pPostInQueue);
+			}
+			if(pPostOutQueue){
+				pPostOutQueue->Free();
+				FSL_DELETE(pPostOutQueue);
+			}
+			if(pPostInReturnQueue){
+				pPostInReturnQueue->Free();
+				FSL_DELETE(pPostInReturnQueue);
+			}
+			if(pPostOutReturnQueue){
+				pPostOutReturnQueue->Free();
+				FSL_DELETE(pPostOutReturnQueue);
+			}
+			if(pPostCmdSem){
+				fsl_osal_sem_destroy(pPostCmdSem); pPostCmdSem=NULL;
+			}
+			if(pPostMutex!= NULL){
+				fsl_osal_mutex_destroy(pPostMutex); pPostMutex=NULL;
+				//fsl_osal_cond_destroy(sPostCond);
+				pthread_cond_destroy(&sPostCond);
+			}
+			PostProcessIPUDeinit(&sIpuHandle);
+		}
+
+		//get new init info to re-set some variables
+		ret=ProcessVpuInitInfo();
+		bufRet=(FilterBufRetCode)((OMX_U32)bufRet|(OMX_U32)ret);
+		ASSERT(eVpuDecoderState==VPU_COM_STATE_WAIT_FRM);  //user need to re-register frames
+
+		//later, user will call port disable -> FlushOutputBuffer -> sFramePoolInfo will be cleared
+		return bufRet;
+	}
+
+	//check decoded info
+	if(nCapability&VPU_COM_CAPABILITY_FRMSIZE)
+	{
+		if(bufRetCode&VPU_DEC_ONE_FRM_CONSUMED)
+		{
+			VPU_COMP_LOG("%s: one frame is decoded \r\n");
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_ONE_FRM_DECODED);			
+		}
+	}
+
+	//check output buff
+	//VPU_COMP_LOG("%s: bufRetCode=0x%X \r\n",__FUNCTION__,bufRetCode);
+	if(bufRetCode&VPU_DEC_OUTPUT_DIS)
+	{
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_HAS_OUTPUT);
+		eVpuDecoderState=VPU_COM_STATE_DO_OUT;
+#ifdef VPU_COMP_DEBUG			
+		nOutFrameCnt++;
+		if(nOutFrameCnt>MAX_DEC_FRAME)
+		{
+			VPU_COMP_ERR_LOG("already output %d frames, return failure \r\n",(INT32)nOutFrameCnt);
+			return FILTER_ERROR;
+		}
+#endif
+		nOutBufferSize=sOutFmt.nFrameWidth * sOutFmt.nFrameHeight*pxlfmt2bpp(sOutFmt.eColorFormat)/8;
+	}
+	else if (bufRetCode&VPU_DEC_OUTPUT_MOSAIC_DIS)
+	{
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_HAS_OUTPUT);
+		eVpuDecoderState=VPU_COM_STATE_DO_OUT;	
+		//send out one frame with length=0
+		nOutBufferSize=0;
+	}
+	else if (bufRetCode&VPU_DEC_OUTPUT_EOS)
+	{
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_LAST_OUTPUT);
+		//bOutLast=OMX_TRUE;
+		eVpuDecoderState=VPU_COM_STATE_EOS;
+	}
+	//else if (bufRetCode&VPU_DEC_OUTPUT_NODIS)
+	//{
+	//	bufRet=(FilterBufRetCode)(bufRet|FILTER_SKIP_OUTPUT);
+	//}
+	else if (bufRetCode&VPU_DEC_OUTPUT_REPEAT)
+	{
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_SKIP_OUTPUT);
+	}
+	else if (bufRetCode&VPU_DEC_OUTPUT_DROPPED)
+	{
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_SKIP_OUTPUT);
+	}
+	else
+	{
+		//bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_OUTPUT);
+	}
+
+	//check "no enough buf"
+	if(bufRetCode&VPU_DEC_NO_ENOUGH_BUF)
+	{
+		//FIXME: if have one output , we ignore this "not enough buf" flag, since video filter may only check one bit among them
+		//only consider VPU_DEC_OUTPUT_MOSAIC_DIS/VPU_DEC_OUTPUT_DIS/VPU_DEC_OUTPUT_NODIS
+		if(bufRetCode&VPU_DEC_OUTPUT_NODIS)
+		{
+			if(bEnabledPostProcess)
+			{
+				//do nothing
+#if 0
+				OMX_S32 index;
+				//printf("vpu no frame !!!!!!!!!!!!post occupy cnt: %d , post out cnt: %d \r\n",pPostInReturnQueue->Size(),pPostOutQueue->Size());
+				//return frame buffer to vpu as possible
+				while(pPostInReturnQueue->Size()>0){
+					pPostInReturnQueue->Get(&index);
+					VPU_COMP_LOG("post-process: return vpu index: %d \r\n",index);
+					FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+					nFreeOutBufCntDec++;
+				}
+				//no enough output frame for post-process
+				if(nFreeOutBufCntPost<=FRAME_POST_MIN_FREE_THD)
+				{
+					bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_OUTPUT_BUFFER);
+				}
+#endif
+				if((0==pPostInReturnQueue->Size())&&(0==pPostInQueue->Size())){
+					//for frame+interlaced clips: we still need to notify user return related vpu index
+					bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_OUTPUT_BUFFER);
+				}
+			}
+			else
+			{
+				bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_OUTPUT_BUFFER);
+			}
+		}
+		else if(bufRetCode&VPU_DEC_OUTPUT_DIS)
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_HAS_OUTPUT);
+			eVpuDecoderState=VPU_COM_STATE_DO_OUT;
+			nOutBufferSize=sOutFmt.nFrameWidth * sOutFmt.nFrameHeight*pxlfmt2bpp(sOutFmt.eColorFormat)/8;		
+		}
+		else if(bufRetCode&VPU_DEC_OUTPUT_MOSAIC_DIS)
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_HAS_OUTPUT);
+			eVpuDecoderState=VPU_COM_STATE_DO_OUT;
+			nOutBufferSize=0;
+		}
+	}
+
+	if(bufRetCode&VPU_DEC_SKIP)
+	{
+		//notify user to get one time stamp.
+		ASSERT(bufRet&FILTER_HAS_OUTPUT);	//only for this case now !!
+		//bufRet=(FilterBufRetCode)(bufRet|FILTER_SKIP_TS);
+		nNeedSkip=1;
+	}
+
+	if((bufRetCode&VPU_DEC_NO_ENOUGH_INBUF)&&(OMX_FALSE==bInEos))
+	{
+		//in videofilter: these flags are exclusively, so we must be careful !!!
+		if(bufRet==(FILTER_OK|FILTER_INPUT_CONSUMED))
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_INPUT_BUFFER);
+		}
+		else if((bufRet==FILTER_OK)&&(pInBuffer==(OMX_PTR)INVALID))  //check this since we added one state for pInBuffer=INVALID
+		//else if((bufRet==FILTER_OK)&&(bufRetCode&VPU_DEC_INPUT_USED))  //check this since we added one state for pInBuffer=INVALID
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_INPUT_BUFFER);
+		}
+	}
+
+	if(bufRetCode&VPU_DEC_FLUSH)
+	{
+		//flush operation is recommended by vpu wrapper
+		//we call flush filter at setinput step to avoid missing getoutput
+		nNeedFlush=1;
+	}
+
+	VPU_COMP_LOG("%s: return OMX_ErrorNone \r\n",__FUNCTION__);
+
+	if(bEnabledPostProcess)
+	{
+		OMX_S32 index;
+		if(eVpuDecoderState==VPU_COM_STATE_DO_OUT)
+		{
+			VpuDecOutFrameInfo sFrameInfo;
+			VPU_COMP_SEM_LOCK(psemaphore);
+			ret=VPU_DecGetOutputFrame(nHandle, &sFrameInfo);
+			VPU_COMP_SEM_UNLOCK(psemaphore);
+			ASSERT(VPU_DEC_RET_SUCCESS==ret);
+			nFreeOutBufCntDec--;
+			//find the matched node in frame pool based on frame virtual address, and record output frame info
+			index=FramePoolRecordOutFrame(sFrameInfo.pDisplayFrameBuf->pbufVirtY, &sFramePoolInfo,&sFrameInfo,VPU_COM_FRM_OWNER_DEC);
+			ASSERT(-1!=index);
+			if(0==nOutBufferSize)
+			{
+				index=(POST_INDEX_MOSAIC<<16)|index;  // add extension flag info
+			}
+			VPU_COMP_LOG("post-process: add vpu index: %d, mosaic: %d \r\n",index&0xFFFF, index>>16);
+			pPostInQueue->Add(&index);
+			PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+			//clear output flag and enter decode state
+			OMX_U32 tmp=(OMX_U32)FILTER_HAS_OUTPUT;
+			bufRet=(FilterBufRetCode)(bufRet&(~tmp));
+			eVpuDecoderState=VPU_COM_STATE_DO_DEC;
+		}
+		if(eVpuDecoderState==VPU_COM_STATE_EOS)
+		{
+			index=POST_INDEX_EOS<<16;
+			VPU_COMP_LOG("post-process: add EOS:  index(invalid): %d, flag: %d \r\n",index&0xFFFF, index>>16);
+			pPostInQueue->Add(&index);
+			PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+			//clear last output flag and still enter wait post eos state
+			OMX_U32 tmp=(OMX_U32)FILTER_LAST_OUTPUT;
+			bufRet=(FilterBufRetCode)(bufRet&(~tmp));
+			eVpuDecoderState=VPU_COM_STATE_WAIT_POST_EOS;
+		}
+	}	
+	return bufRet;//OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder:: GetDecBuffer(OMX_PTR *ppBuffer,OMX_S32 * pOutStuffSize,OMX_S32* pOutFrmSize)
+{
+	VpuDecFrameLengthInfo sLengthInfo;
+	VpuDecRetCode ret;
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_DO_DEC:
+		case VPU_COM_STATE_DO_OUT:
+			break;
+		default:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);
+			//return OMX_ErrorIncorrectStateTransition;
+	}
+	VPU_COMP_SEM_LOCK(psemaphore);
+	ret=VPU_DecGetConsumedFrameInfo(nHandle, &sLengthInfo);
+	VPU_COMP_SEM_UNLOCK(psemaphore);	
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu get decoded frame info failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+		return OMX_ErrorHardware;
+	}		
+	*pOutStuffSize=sLengthInfo.nStuffLength;
+	*pOutFrmSize=sLengthInfo.nFrameLength;
+	if(sLengthInfo.pFrame==NULL)
+	{
+		*ppBuffer=NULL;	//the frame is skipped
+	}
+	else
+	{
+		*ppBuffer=(OMX_PTR)sLengthInfo.pFrame->pbufVirtY;
+	}
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::GetPostMappedDecBuffer(OMX_PTR pPostBuf, OMX_PTR *ppDecBuffer)
+{
+	OMX_S32 ret;
+	ret=FramePoolSearchMappedDecBuffer(&sFramePoolInfo, pPostBuf,ppDecBuffer);
+	if(ret==0){
+		return OMX_ErrorBadParameter;
+	}
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder:: GetOutputBuffer(OMX_PTR *ppOutVirtBuf,OMX_S32* pOutSize)	
+{
+	VpuDecRetCode ret;
+	OMX_S32 index;
+	OMX_BOOL bOutLast=OMX_FALSE;
+	OMX_PTR pPhyBuf=NULL;
+	OMX_BOOL bPostProcess=OMX_FALSE;
+	VpuDecoderFrmOwner eOwner=VPU_COM_FRM_OWNER_DEC;
+
+#ifdef VPU_COMP_DEBUG	
+	static FILE* fpYUV=NULL;
+#endif
+
+	VPU_COMP_API_LOG("%s: state: %d \r\n",__FUNCTION__,eVpuDecoderState);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_DO_OUT:
+			//update state
+			eVpuDecoderState=VPU_COM_STATE_DO_DEC;
+			break;
+		case VPU_COM_STATE_EOS:
+			bOutLast=OMX_TRUE;
+			//update to decode state for repeat play ??
+			//eVpuDecoderState=VPU_COM_STATE_DO_DEC; 
+			eVpuDecoderState=VPU_COM_STATE_RE_WAIT_FRM; 
+			break;
+		case VPU_COM_STATE_WAIT_POST_EOS:
+			break;
+		default:
+			//forbidden
+			VPU_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+	if(ppOutVirtBuf==NULL)
+	{
+		VPU_COMP_ERR_LOG("%s: failure: ppOutVirtBuf==NULL !!! \r\n",__FUNCTION__);		
+		return OMX_ErrorBadParameter;
+	}
+
+	//get output frame
+	if(OMX_TRUE==bOutLast)
+	{
+		VpuDecOutFrameInfo* pFrameInfo;	
+		if(bEnabledPostProcess)
+		{
+			OMX_S32 nOutSize;
+			pPostOutQueue->Get(&index);
+			ASSERT((index>>16)&POST_INDEX_EOS);
+			index=index&0xFFFF;  // remove flag info
+			FramePoolGetBufVirt(&sFramePoolInfo, index, ppOutVirtBuf);
+			//copy the last frame
+			if(pLastOutVirtBuf){
+				nOutSize=sOutFmt.nFrameWidth * sOutFmt.nFrameHeight*pxlfmt2bpp(sOutFmt.eColorFormat)/8;
+				fsl_osal_memcpy(*ppOutVirtBuf, pLastOutVirtBuf, nOutSize);
+				*pOutSize=nOutSize;
+			}
+			else{
+				*pOutSize=0;
+			}
+
+			VPU_COMP_LOG("%s:  reach EOS , repeat the last frame: 0x%X  \r\n",__FUNCTION__,*ppOutVirtBuf);
+			bPostProcess=OMX_TRUE;
+			//in this case, index owner should be VPU_COM_FRM_OWNER_POST
+			eOwner=VPU_COM_FRM_OWNER_POST;
+		}
+		else
+		{
+			//need to search one valid frame to output since vpu don't output one valid frame for EOS
+			index=FramePoolFindOneDecoderUnOutputed(ppOutVirtBuf,&sFramePoolInfo,&pFrameInfo);
+			if(-1==index)
+			{
+				VPU_COMP_ERR_LOG("%s: find unoutputed frame failure \r\n",__FUNCTION__);	
+				return OMX_ErrorInsufficientResources;
+			}
+			//set pDisplayFrameBuf to NULL to avoid clear operation in SetOutputBuffer()
+			pFrameInfo->pDisplayFrameBuf=NULL;
+			*pOutSize=0;
+			VPU_COMP_LOG("%s:  reach EOS , search one valid frame: 0x%X  \r\n",__FUNCTION__,*ppOutVirtBuf);
+		}
+	}
+	else
+	{
+		VpuDecOutFrameInfo sFrameInfo;
+		VpuDecOutFrameInfo * pFrameInfo;
+		if(bEnabledPostProcess)
+		{
+			VpuDecoderFrmState eState;
+			ASSERT(pPostOutQueue->Size()>0);
+			pPostOutQueue->Get(&index);
+			VPU_COMP_LOG("post-process: output index: %d, mosaic: %d \r\n",index&0xFFFF,(index>>16));
+			*pOutSize=sOutFmt.nFrameWidth * sOutFmt.nFrameHeight*pxlfmt2bpp(sOutFmt.eColorFormat)/8;
+			if((index>>16)&POST_INDEX_MOSAIC)
+			{
+				*pOutSize=0;
+			}
+			index=index&0xFFFF;  // remove flag info
+			FramePoolGetBufVirt(&sFramePoolInfo, index, ppOutVirtBuf);
+			FramePoolGetBufProperty(&sFramePoolInfo,index,&eOwner,&eState,&pFrameInfo);
+			bPostProcess=OMX_TRUE;
+		}
+		else
+		{
+			pFrameInfo=&sFrameInfo;
+			VPU_COMP_SEM_LOCK(psemaphore);
+			ret=VPU_DecGetOutputFrame(nHandle, pFrameInfo);
+			VPU_COMP_SEM_UNLOCK(psemaphore);
+			if(VPU_DEC_RET_SUCCESS!=ret)
+			{
+				VPU_COMP_ERR_LOG("%s: vpu get output frame failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+				return OMX_ErrorHardware;
+			}			
+			*ppOutVirtBuf=(OMX_PTR)sFrameInfo.pDisplayFrameBuf->pbufVirtY;
+			//find the matched node in frame pool based on frame virtual address, and record output frame info
+			index=FramePoolRecordOutFrame(*ppOutVirtBuf, &sFramePoolInfo,&sFrameInfo,VPU_COM_FRM_OWNER_DEC);
+			if(-1==index)
+			{
+				VPU_COMP_ERR_LOG("%s: can't find matched node in frame pool: 0x%X !!! \r\n",__FUNCTION__,(UINT32)(*ppOutVirtBuf));
+				return OMX_ErrorInsufficientResources;
+			}
+			*pOutSize=nOutBufferSize;
+			VPU_COMP_LOG("%s: return output: 0x%X, nFreeOutBufCntDec: %d \r\n",__FUNCTION__,(UINT32)(*ppOutVirtBuf),(UINT32)nFreeOutBufCntDec);
+		}
+		//update crop info for every output frame
+		sOutCrop.nLeft=pFrameInfo->pExtInfo->FrmCropRect.nLeft;
+		sOutCrop.nTop=pFrameInfo->pExtInfo->FrmCropRect.nTop;
+		sOutCrop.nWidth=pFrameInfo->pExtInfo->FrmCropRect.nRight-pFrameInfo->pExtInfo->FrmCropRect.nLeft;
+		sOutCrop.nHeight=pFrameInfo->pExtInfo->FrmCropRect.nBottom-pFrameInfo->pExtInfo->FrmCropRect.nTop;
+	}
+
+#ifdef VPU_COMP_DEBUG
+		FileDumpYUV(&fpYUV,sFramePoolInfo.outFrameInfo[index].pDisplayFrameBuf->pbufVirtY,sFramePoolInfo.outFrameInfo[index].pDisplayFrameBuf->pbufVirtCb,sFramePoolInfo.outFrameInfo[index].pDisplayFrameBuf->pbufVirtCr,
+			nPadWidth*nPadHeight,nPadWidth*nPadHeight/4,sOutFmt.eColorFormat);
+#endif
+
+	if(bPostProcess)
+	{
+		if(eOwner==VPU_COM_FRM_OWNER_POST)
+		{
+			nFreeOutBufCntPost--;
+			//FIXME: in future, we need to add one schema to mapping this output buffer(post) with decoded buffer(vpu)
+			//otherwise, it is difficulty to get accurate timestamp !!!
+		}
+		else
+		{
+			//nFreeOutBufCntDec--;	//it is already done before
+		}
+	}
+	else
+	{
+		nFreeOutBufCntDec--;
+	}
+	pLastOutVirtBuf=*ppOutVirtBuf;
+	FramePoolSetBufState(&sFramePoolInfo, index, VPU_COM_FRM_STATE_OUT);
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::FlushFilter()
+{
+	VpuDecRetCode ret;
+	VPU_COMP_LOG("%s: \r\n",__FUNCTION__);	
+
+	VPU_COMP_SEM_LOCK(psemaphore);
+	ret=VPU_DecFlushAll(nHandle);
+	//VPU_COMP_SEM_UNLOCK(psemaphore);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu flush failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		if(VPU_DEC_RET_FAILURE_TIMEOUT==ret)
+		{
+			VPU_DecReset(nHandle);
+			SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);			
+		}
+		VPU_COMP_SEM_UNLOCK(psemaphore);
+		return OMX_ErrorHardware;
+	}
+	VPU_COMP_SEM_UNLOCK(psemaphore);
+	//since vpu will auto clear all buffers(is equal to setoutput() operation), we need to add additional protection(set VPU_COM_STATE_WAIT_FRM).
+	//otherwise, vpu may return one buffer which is still not set by user.
+	eVpuDecoderState=VPU_COM_STATE_RE_WAIT_FRM;
+
+	nNeedFlush=0;
+	nNeedSkip=0;
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::FlushInputBuffer()
+{
+	OMX_ERRORTYPE ret=OMX_ErrorNone;
+
+	VPU_COMP_API_LOG("%s: state: %d \r\n",__FUNCTION__,eVpuDecoderState);
+
+	//clear input buffer
+	pInBuffer=(OMX_PTR)INVALID;
+	nInSize=0;
+
+	//need to clear bInEos
+	//fixed case: SetInputBuffer(,bInEos), and FlushInputBuffer(), then FilterOneBuffer() before SetInputBuffer(). 
+	//As result, user will get one output(EOS) without calling SetInputBuffer(). 
+	bInEos=OMX_FALSE;
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+		case VPU_COM_STATE_LOADED:
+		case VPU_COM_STATE_OPENED:			
+		case VPU_COM_STATE_WAIT_FRM:	// have not registered frames, so can not call flushfilter 
+		case VPU_COM_STATE_DO_INIT:
+		case VPU_COM_STATE_DO_OUT:	
+			//forbidden !!!
+			VPU_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorNone; //for conformance test: don't return OMX_ErrorIncorrectStateTransition;
+		case VPU_COM_STATE_DO_DEC:
+		case VPU_COM_STATE_EOS:	
+		case VPU_COM_STATE_RE_WAIT_FRM:
+		case VPU_COM_STATE_WAIT_POST_EOS:
+			break;
+		default:
+			VPU_COMP_ERR_LOG("%s: unknown state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);			
+			return OMX_ErrorNone; //for conformance test: don't return OMX_ErrorIncorrectStateTransition;
+	}	
+
+	//flush post-process
+	if(bEnabledPostProcess){
+		PostThreadFlushInput();
+	}
+	
+	//flush vpu input/output
+	ret=FlushFilter();
+
+	return ret;
+}
+
+OMX_ERRORTYPE VpuDecoder::FlushOutputBuffer()
+{
+	OMX_ERRORTYPE ret=OMX_ErrorNone;
+	OMX_S32 num;
+	VPU_COMP_API_LOG("%s: state: %d  \r\n",__FUNCTION__,eVpuDecoderState);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+		case VPU_COM_STATE_LOADED:	
+		case VPU_COM_STATE_OPENED:
+		case VPU_COM_STATE_WAIT_FRM:
+			break;
+#if 1			
+		case VPU_COM_STATE_DO_DEC:
+		case VPU_COM_STATE_EOS:	
+		case VPU_COM_STATE_RE_WAIT_FRM:
+		case VPU_COM_STATE_WAIT_POST_EOS:
+			//flush post-process
+			if(bEnabledPostProcess)
+			{
+				OMX_S32 index;
+				PostThreadFlushOutput();
+				ASSERT(0==pPostInQueue->Size());
+				ASSERT(0==pPostInReturnQueue->Size());
+				ASSERT(0==pPostOutQueue->Size());
+				ASSERT(0==pPostOutReturnQueue->Size());
+				//clear all frame state
+				num=FramePoolPostOutReset(&sFramePoolInfo,nOutBufferCntPost);
+				ASSERT(nFreeOutBufCntPost==num);
+			}
+			//flush vpu input/output
+			ret=FlushFilter();
+
+			//re set out map info: simulate: all frames have been returned from vpu and been recorded into outFrameInfo
+#if 0
+{
+			VpuFrameBuffer* vpuFrameBuffer[VPU_DEC_MAX_NUM_MEM];
+			VPU_COMP_SEM_LOCK(psemaphore);
+			VPU_DecAllRegFrameInfo(nHandle, vpuFrameBuffer, (INT32*)&num);
+			VPU_COMP_SEM_UNLOCK(psemaphore);	
+			if(num<=0)
+			{
+				//in theory, shouldn't enter here if all states are protected correctly.
+				VPU_COMP_ERR_LOG("%s: no buffers registered \r\n",__FUNCTION__);
+				return OMX_ErrorNone; 
+			}			
+			num=FramePoolDecoderOutReset(&sFramePoolInfo,vpuFrameBuffer, num,1);
+}
+#else
+			num=FramePoolDecoderOutReset(&sFramePoolInfo,NULL, nOutBufferCntDec,1);
+#endif
+			ASSERT(nFreeOutBufCntDec==num);
+
+			nFreeOutBufCntDec=0;
+			nFreeOutBufCntPost=0;
+			return ret;
+#endif
+		case VPU_COM_STATE_DO_INIT:
+		case VPU_COM_STATE_DO_OUT:
+			//forbidden !!!
+			VPU_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);
+			return OMX_ErrorNone; //for conformance test: don't return OMX_ErrorIncorrectStateTransition;
+		default: 
+			//forbidden !!!
+			VPU_COMP_ERR_LOG("%s: unknown state transition, current state=%d \r\n",__FUNCTION__,eVpuDecoderState);
+			return OMX_ErrorNone; //for conformance test: don't return OMX_ErrorIncorrectStateTransition;
+	}
+
+	//clear frame pool
+	FramePoolClear(&sFramePoolInfo);
+	
+	return ret;
+
+}
+
+OMX_PTR VpuDecoder::AllocateOutputBuffer(OMX_U32 nSize)
+{
+	VpuDecRetCode ret;
+	VpuMemDesc vpuMem;
+
+	VPU_COMP_API_LOG("%s: state: %d \r\n",__FUNCTION__,eVpuDecoderState);
+
+	//check state
+	switch(eVpuDecoderState)
+	{
+		case VPU_COM_STATE_NONE:
+		// case VPU_COM_STATE_LOADED:
+		//case VPU_COM_STATE_OPENED:
+			//1 how to avoid conflict memory operators
+			VPU_COMP_ERR_LOG("%s: error state: %d \r\n",__FUNCTION__,eVpuDecoderState);	
+			return (OMX_PTR)NULL;
+		default: 
+			break;
+	}
+
+	//malloc physical memory through vpu 
+	vpuMem.nSize=nSize;
+	ret=VPU_DecGetMem_Wrapper(&vpuMem,&sMemOperator);
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu malloc frame buf failure: size=%d, ret=0x%X \r\n",__FUNCTION__,(INT32)nSize,ret);	
+		return (OMX_PTR)NULL;//OMX_ErrorInsufficientResources;
+	}	
+
+	//record memory for release
+	if(0==MemAddPhyBlock(&vpuMem, &sAllocMemInfo))
+	{
+		VPU_DecFreeMem_Wrapper(&vpuMem,&sMemOperator);
+		VPU_COMP_ERR_LOG("%s:add phy block failure \r\n",__FUNCTION__);	
+		return (OMX_PTR)NULL;
+	}
+
+	//register memory info into resource manager
+	if(OMX_ErrorNone!=AddHwBuffer((OMX_PTR)vpuMem.nPhyAddr, (OMX_PTR)vpuMem.nVirtAddr))
+	{
+		MemRemovePhyBlock(&vpuMem, &sAllocMemInfo);
+		VPU_DecFreeMem_Wrapper(&vpuMem,&sMemOperator);
+		VPU_COMP_ERR_LOG("%s:add hw buffer failure \r\n",__FUNCTION__);	
+		return (OMX_PTR)NULL;
+	}
+
+	//return virtual address
+	return (OMX_PTR)vpuMem.nVirtAddr;//OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::FreeOutputBuffer(OMX_PTR pBuffer)
+{
+	VpuDecRetCode ret;
+	VpuMemDesc vpuMem;
+
+	VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//query related mem info for release
+	if(0==MemQueryPhyBlock(pBuffer,&vpuMem,&sAllocMemInfo))
+	{
+		VPU_COMP_ERR_LOG("%s: query phy block failure \r\n",__FUNCTION__);
+		return OMX_ErrorResourcesLost;
+	}
+
+	//release physical memory through vpu
+	ret=VPU_DecFreeMem_Wrapper(&vpuMem,&sMemOperator);
+	if(ret!=VPU_DEC_RET_SUCCESS)
+	{
+		VPU_COMP_ERR_LOG("%s: free vpu memory failure : ret=0x%X \r\n",__FUNCTION__,ret);
+		return OMX_ErrorHardware;
+	}
+
+	//remove mem info
+	if(0==MemRemovePhyBlock(&vpuMem, &sAllocMemInfo))
+	{
+		VPU_COMP_ERR_LOG("%s: remove phy block failure \r\n",__FUNCTION__);
+		return OMX_ErrorResourcesLost;	
+	}
+
+	//unregister memory info from resource manager
+	if(OMX_ErrorNone!=RemoveHwBuffer(pBuffer))
+	{
+		VPU_COMP_ERR_LOG("%s: remove hw buffer failure \r\n",__FUNCTION__);
+		return OMX_ErrorResourcesLost;
+	}
+		
+	return OMX_ErrorNone;
+}
+
+FilterBufRetCode VpuDecoder::ProcessVpuInitInfo()
+{
+	FilterBufRetCode bufRet=FILTER_OK;
+	VpuDecRetCode ret;	
+	OMX_S32 nChanged=0;
+	//process init info
+	VPU_COMP_SEM_LOCK(psemaphore);
+	ret=VPU_DecGetInitialInfo(nHandle, &sInitInfo);
+	VPU_COMP_SEM_UNLOCK(psemaphore);	
+	if(VPU_DEC_RET_SUCCESS!=ret)
+	{
+		VPU_COMP_ERR_LOG("%s: vpu get init info failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+		return FILTER_ERROR;//OMX_ErrorHardware;
+	}		
+
+	//set resolution info
+	sInFmt.nFrameWidth=sInitInfo.nPicWidth;
+	sInFmt.nFrameHeight=sInitInfo.nPicHeight;
+	nPadWidth = Align(sInFmt.nFrameWidth,FRAME_ALIGN);//(sInFmt.nFrameWidth +15)&(~15);
+	if(sInitInfo.nInterlace)
+	{
+		nPadHeight = Align(sInFmt.nFrameHeight ,2*FRAME_ALIGN);//(sInFmt.nFrameHeight +31)&(~31);
+	}
+	else
+	{
+		nPadHeight = Align(sInFmt.nFrameHeight ,FRAME_ALIGN);//(sInFmt.nFrameHeight +15)&(~15);
+	}
+
+	if((nFrameWidthStride>=nPadWidth) && (nFrameHeightStride>=nPadHeight)){
+		nPadWidth=nFrameWidthStride;
+		nPadHeight=nFrameHeightStride;
+	}
+
+	//check change for nFrameWidth/nFrameHeight
+	if(((OMX_S32)sOutFmt.nFrameWidth !=nPadWidth)||((OMX_S32)sOutFmt.nFrameHeight != nPadHeight))
+	{
+		sOutFmt.nFrameWidth = nPadWidth;
+		sOutFmt.nFrameHeight = nPadHeight;
+		sOutFmt.nStride=nPadWidth;
+		nChanged=1;
+	}
+
+	//check color format, only for mjpg : 4:2:0/4:2:2(ver/hor)/4:4:4/4:0:0
+	if(VPU_V_MJPG==eFormat)
+	{
+		OMX_COLOR_FORMATTYPE colorFormat;
+		colorFormat=ConvertMjpgColorFormat(sInitInfo.nMjpgSourceFormat,sOutFmt.eColorFormat);
+		if(colorFormat!=sOutFmt.eColorFormat)
+		{
+			sOutFmt.eColorFormat=colorFormat;
+			nChanged=1;
+		}
+	}
+
+	//TODO: check change for sOutCrop ?
+	//...
+
+	//set crop info
+	VPU_COMP_LOG("%s: original init info: [top,left,bottom,right]=[%d,%d,%d,%d], \r\n",__FUNCTION__,
+		(INT32)sInitInfo.PicCropRect.nTop,(INT32)sInitInfo.PicCropRect.nLeft,(INT32)sInitInfo.PicCropRect.nBottom,(INT32)sInitInfo.PicCropRect.nRight);
+
+	sOutCrop.nLeft = sInitInfo.PicCropRect.nLeft;
+	sOutCrop.nTop = sInitInfo.PicCropRect.nTop;
+	//here, we am not responsible to 8 pixels limitation at display end. !!!
+	sOutCrop.nWidth = sInitInfo.PicCropRect.nRight-sInitInfo.PicCropRect.nLeft;// & (~7);
+	sOutCrop.nHeight= sInitInfo.PicCropRect.nBottom-sInitInfo.PicCropRect.nTop;
+
+#if 1	//user need to know the non-pad width/height in portchange process ???
+	//it may have potential risk if crop info is not equal to non-pad info !!!
+	sInFmt.nFrameWidth=sOutCrop.nWidth;
+	sInFmt.nFrameHeight=sOutCrop.nHeight;
+	if(((nPadWidth-sOutCrop.nWidth)>=16)||((sInitInfo.nInterlace)&&(nPadHeight-sOutCrop.nHeight)>=32)||((0==sInitInfo.nInterlace)&&(nPadHeight-sOutCrop.nHeight)>=16))
+	{
+		VPU_COMP_LOG("potential risk for sInFmt [widthxheight]: [%dx%d] \r\n",(INT32)sOutCrop.nWidth,(INT32)sOutCrop.nHeight);
+	}
+#endif
+
+	//check change for nOutBufferCntDec
+	if((sInitInfo.nMinFrameBufferCount+FRAME_SURPLUS)!=(OMX_S32)nOutBufferCntDec)
+	{
+		nOutBufferCntDec=sInitInfo.nMinFrameBufferCount+FRAME_SURPLUS;
+		nChanged=1;
+	}
+#if 1	//workaround for ENGR00171878: we should make sure porting change event always be triggered
+	else
+	{
+		VPU_COMP_LOG("plus one buffer cnt manually: original cnt: %d, new cnt: %d \r\n",nOutBufferCntDec,nOutBufferCntDec+1);
+		nOutBufferCntDec++;
+		sInitInfo.nMinFrameBufferCount++;
+		nChanged=1;
+	}
+#endif
+
+	PostProcessSetStrategy(&sInitInfo,&bEnabledPostProcess,&nOutBufferCntPost,eFormat,&nPostMotion);
+	if(bEnabledPostProcess)
+	{
+		ASSERT(CHROMA_ALIGN==1);	//IPU don't support three address (Y/Cb/Cr)
+		if(PostProcessIPUInit(&sIpuHandle)==0)
+		{
+			//init failure, disable it
+			nOutBufferCntPost=DEFAULT_BUF_OUT_POST_ZEROCNT;
+			bEnabledPostProcess=OMX_FALSE;
+		}
+		else
+		{
+			//set ipu task in/out parameter
+			if(nFrameWidthStride<(OMX_S32)sOutFmt.nFrameWidth || nFrameHeightStride<(OMX_S32)sOutFmt.nFrameHeight){
+				PostProcessIPUSetDefault(&sIpuHandle,&sOutFmt,&sOutCrop,nPostMotion);
+			}
+			else{
+				//use stride value specified by user
+				OMX_VIDEO_PORTDEFINITIONTYPE outFmt;
+				outFmt=sOutFmt;
+				outFmt.nFrameWidth=nFrameWidthStride;
+				outFmt.nFrameHeight=nFrameHeightStride;
+				PostProcessIPUSetDefault(&sIpuHandle,&outFmt,&sOutCrop,nPostMotion);
+			}
+
+			//create post-process thread
+			pPostInQueue = FSL_NEW(Queue, ());
+			if(pPostInQueue == NULL) {
+				VPU_COMP_ERR_LOG("New post queue failed.\n");
+			}
+			if(pPostInQueue->Create(MAX_POST_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+				VPU_COMP_ERR_LOG("Init post queue failed.\n");
+			}
+			pPostOutQueue = FSL_NEW(Queue, ());
+			if(pPostOutQueue == NULL) {
+				VPU_COMP_ERR_LOG("New post queue failed.\n");
+			}
+			if(pPostOutQueue->Create(MAX_POST_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+				VPU_COMP_ERR_LOG("Init post queue failed.\n");
+			}
+			pPostInReturnQueue = FSL_NEW(Queue, ());
+			if(pPostInReturnQueue == NULL) {
+				VPU_COMP_ERR_LOG("New post queue failed.\n");
+			}
+			if(pPostInReturnQueue->Create(MAX_POST_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+				VPU_COMP_ERR_LOG("Init post queue failed.\n");
+			}
+			pPostOutReturnQueue = FSL_NEW(Queue, ());
+			if(pPostOutReturnQueue == NULL) {
+				VPU_COMP_ERR_LOG("New post queue failed.\n");
+			}
+			if(pPostOutReturnQueue->Create(MAX_POST_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+				VPU_COMP_ERR_LOG("Init post queue failed.\n");
+			}
+			if(E_FSL_OSAL_SUCCESS != fsl_osal_sem_init(&pPostCmdSem, 0, 0)){
+				VPU_COMP_ERR_LOG("Create pPostCmdSem Semphore failed.\n");
+			}
+			if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&pPostMutex, fsl_osal_mutex_normal)) {
+				VPU_COMP_ERR_LOG("Create mutext for post process failed.\n");
+			}
+			//if(E_FSL_OSAL_SUCCESS != fsl_osal_cond_create(&sPostCond)) {
+			if(0!= pthread_cond_init(&sPostCond, NULL)) {
+				VPU_COMP_ERR_LOG("Create condition variable for post process failed.\n");
+			}
+			ePostState=POST_PROCESS_STATE_NONE;
+			ePostCmd=POST_PROCESS_CMD_NONE;
+			bPostWaitingTasks=OMX_TRUE;
+			if(E_FSL_OSAL_SUCCESS != fsl_osal_thread_create(&pPostThreadId, NULL, PostThread, this)) {
+				VPU_COMP_ERR_LOG("Create post-process thread failed.\n");
+				//init failure, disable it
+				nOutBufferCntPost=DEFAULT_BUF_OUT_POST_ZEROCNT;
+				bEnabledPostProcess=OMX_FALSE;
+				pPostThreadId=NULL;
+				PostProcessIPUDeinit(&sIpuHandle);
+			}
+			PostThreadRun();
+			bNeedMapDecAndOutput=OMX_TRUE;
+		}
+	}
+	else{
+		bNeedMapDecAndOutput=OMX_FALSE;
+	}
+
+	nOutBufferCnt=nOutBufferCntDec+nOutBufferCntPost;
+
+	if(nFrameMaxCnt>0){
+		/*user specify the max buffer count*/
+		if(nFrameMaxCnt>(OMX_S32)nOutBufferCnt){
+			nOutBufferCntDec+=nFrameMaxCnt-nOutBufferCnt;
+			nOutBufferCnt=nOutBufferCntDec+nOutBufferCntPost;
+		}
+		else{
+			VPU_COMP_ERR_LOG("warning: buffer isn't enough,  nFrameMaxCnt: %d, vpu required cnt: %d, final required cnt: %d \r\n",nFrameMaxCnt,sInitInfo.nMinFrameBufferCount,nOutBufferCnt);
+		}
+	}
+
+	VPU_COMP_LOG("%s: Init OK, [width x height]=[%d x %d] \r\n",__FUNCTION__,sInitInfo.nPicWidth,sInitInfo.nPicHeight);
+	VPU_COMP_LOG("%s: [top,left,width,height]=[%d,%d,%d,%d], \r\n",__FUNCTION__,
+		(INT32)sOutCrop.nLeft,(INT32)sOutCrop.nTop,(INT32)sOutCrop.nWidth,(INT32)sOutCrop.nHeight);
+	VPU_COMP_LOG("nOutBufferCntDec:%d ,nPadWidth: %d, nPadHeight: %d \r\n",(INT32)nOutBufferCntDec, (INT32)nPadWidth, (INT32)nPadHeight);
+
+	//get aspect ratio info
+	sDispRatio.xWidth=sInitInfo.nQ16ShiftWidthDivHeightRatio;
+	sDispRatio.xHeight=Q16_SHIFT;
+	VPU_COMP_LOG("%s: ratio: width: 0x%X, height: 0x%X \r\n",__FUNCTION__,sDispRatio.xWidth,sDispRatio.xHeight);
+	
+	//update state
+	eVpuDecoderState=VPU_COM_STATE_WAIT_FRM;
+
+	if(nChanged)
+	{
+		nOutBufferSize=sOutFmt.nFrameWidth * sOutFmt.nFrameHeight*pxlfmt2bpp(sOutFmt.eColorFormat)/8;
+		OutputFmtChanged();
+	}
+
+	//bufRet|=FILTER_DO_INIT;
+	bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_OUTPUT_BUFFER); //request enough output buffer before do InitFilter() operation
+	
+	VPU_COMP_LOG("%s: enter wait frame state \r\n",__FUNCTION__);
+	return bufRet;	//OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::PostThreadRun()
+{
+	// non-run state => run state
+	if(ePostState==POST_PROCESS_STATE_RUN){
+		VPU_COMP_POST_LOG("%s: already in run state: %d \r\n",__FUNCTION__,ePostState);
+		return OMX_ErrorNone;
+	}
+
+	//send command
+	VPU_COMP_POST_LOG("decoder thread will send run command \r\n");
+	ePostCmd=POST_PROCESS_CMD_RUN;
+	PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+
+	//wait idle state
+	PostWaitState((volatile PostProcessState*)&ePostState,POST_PROCESS_STATE_RUN,pPostCmdSem);
+	VPU_COMP_POST_LOG("decoder thread receive run command finished\r\n");
+	return OMX_ErrorNone;
+}
+OMX_ERRORTYPE VpuDecoder::PostThreadStop()
+{
+	// run state => idle state
+	if(ePostState!=POST_PROCESS_STATE_RUN){
+		VPU_COMP_POST_LOG("%s: not run state: %d \r\n",__FUNCTION__,ePostState);
+		return OMX_ErrorNone;
+	}
+	//send command
+	VPU_COMP_POST_LOG("decoder thread will send stop command \r\n");
+	ePostCmd=POST_PROCESS_CMD_STOP;
+	PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+	
+	//wait idle state
+	PostWaitState((volatile PostProcessState*)&ePostState,POST_PROCESS_STATE_IDLE,pPostCmdSem);
+	VPU_COMP_POST_LOG("decoder thread receive stop command finished\r\n");
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::PostThreadFlushInput()
+{
+	// run -> (flush in) -> run state
+	OMX_S32 index;
+	VpuDecoderFrmState eState;
+	VpuDecOutFrameInfo * pFrameInfo;	
+	VpuDecoderFrmOwner eOwner=VPU_COM_FRM_OWNER_NULL;
+
+	if(ePostState!=POST_PROCESS_STATE_RUN){
+		VPU_COMP_POST_LOG("%s: not run state: %d \r\n",__FUNCTION__,ePostState);
+		return OMX_ErrorNone;
+	}
+
+	//send command
+	VPU_COMP_POST_LOG("decoder thread will send flushinput command \r\n");
+	ePostCmd=POST_PROCESS_CMD_FLUSH_IN;
+	PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+	
+	//wait finished
+	PostWaitState((volatile PostProcessState*)&ePostState,ePostState,pPostCmdSem);
+	VPU_COMP_POST_LOG("decoder thread receive flushinput command finished\r\n");
+
+	ASSERT(0==pPostInQueue->Size());
+	//return frame buffer to vpu as possible
+	while(pPostInReturnQueue->Size()>0){
+		pPostInReturnQueue->Get(&index);
+		//VPU_COMP_POST_LOG("post-process: return vpu index to vpu: %d \r\n",index);
+		FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+		nFreeOutBufCntDec++;
+	}
+
+	//popup all output frame, and refill into pPostOutReturnQueue or return to vpu
+	while(pPostOutQueue->Size()>0){
+		pPostOutQueue->Get(&index);
+		index=index&0xFFFF;	// remove extension flag
+		FramePoolGetBufProperty(&sFramePoolInfo,index,&eOwner,&eState,&pFrameInfo);
+		if(eOwner==VPU_COM_FRM_OWNER_POST){
+			//VPU_COMP_POST_LOG("%s: return index: %d to post \r\n",__FUNCTION__,index);
+			pPostOutReturnQueue->Add(&index);
+			//nFreeOutBufCntPost++;
+		}
+		else if (eOwner==VPU_COM_FRM_OWNER_DEC){
+			//VPU_COMP_POST_LOG("%s: return index: %d to vpu \r\n",__FUNCTION__,index);
+			FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+			nFreeOutBufCntDec++;
+		}
+		else{
+			VPU_COMP_POST_LOG("index: %d in incorrect owner: %d \r\n",index,eOwner);
+		}
+		ASSERT(VPU_COM_FRM_STATE_FREE==sFramePoolInfo.eFrmState[index]);
+	}
+
+	//finally, pPostInQueue/pPostInReturnQueue/pPostOutQueue are empty; pPostOutReturnQueue isn't empty
+
+	VPU_COMP_POST_LOG("%s: post flush input finised, nFreeOutBufCntDec: %d, nFreeOutBufCntPost: %d, pPostOutReturnQueue->Size(): %d \r\n",__FUNCTION__,nFreeOutBufCntDec,nFreeOutBufCntPost,pPostOutReturnQueue->Size());
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuDecoder::PostThreadFlushOutput()
+{
+	// run -> (flush out) -> run state
+	OMX_S32 index;
+	VpuDecoderFrmState eState;
+	VpuDecOutFrameInfo * pFrameInfo;	
+	VpuDecoderFrmOwner eOwner=VPU_COM_FRM_OWNER_NULL;	
+
+	if(ePostState!=POST_PROCESS_STATE_RUN){
+		VPU_COMP_POST_LOG("%s: not run state: %d \r\n",__FUNCTION__,ePostState);
+		return OMX_ErrorNone;
+	}
+
+	//send command
+	VPU_COMP_POST_LOG("decoder thread will send flushoutput command \r\n");
+	ePostCmd=POST_PROCESS_CMD_FLUSH_OUT;
+	PostWakeUp(pPostMutex, &sPostCond, (volatile OMX_BOOL*) &bPostWaitingTasks);
+		
+	//wait finished
+	PostWaitState((volatile PostProcessState*)&ePostState,ePostState,pPostCmdSem);
+	VPU_COMP_POST_LOG("decoder thread receive flushoutput command finished\r\n");
+
+	ASSERT(0==pPostInQueue->Size());
+	//return frame buffer to vpu as possible
+	while(pPostInReturnQueue->Size()>0){
+		pPostInReturnQueue->Get(&index);
+		//VPU_COMP_POST_LOG("post-process: return vpu index to vpu: %d \r\n",index);
+		FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+		nFreeOutBufCntDec++;
+	}
+
+	ASSERT(0==pPostOutReturnQueue->Size());
+	//popup all output frame
+	while(pPostOutQueue->Size()>0){
+		pPostOutQueue->Get(&index);
+		index=index&0xFFFF;	// remove extension flag
+		FramePoolGetBufProperty(&sFramePoolInfo,index,&eOwner,&eState,&pFrameInfo);
+		if(eOwner==VPU_COM_FRM_OWNER_POST){
+			nFreeOutBufCntPost--;
+		}
+		else if (eOwner==VPU_COM_FRM_OWNER_DEC){
+#if 0		//we can also return them to vpu
+			FramePoolReturnPostFrameToVpu(&sFramePoolInfo, nHandle, index, psemaphore);
+			nFreeOutBufCntDec++;
+#else
+			//nFreeOutBufCntDec--;
+#endif
+		}
+		else{
+			VPU_COMP_POST_LOG("index: %d in incorrect owner: %d \r\n",index,eOwner);
+		}
+		FramePoolSetBufState(&sFramePoolInfo, index, VPU_COM_FRM_STATE_OUT);
+	}
+	
+	//finally, pPostInQueue/pPostInReturnQueue/pPostOutQueue/pPostOutReturnQueue are all empty
+
+	VPU_COMP_POST_LOG("%s: post flush output finised, nFreeOutBufCntDec: %d, nFreeOutBufCntPost: %d \r\n",__FUNCTION__,nFreeOutBufCntDec,nFreeOutBufCntPost);
+	return OMX_ErrorNone;
+}
+
+/**< C style functions to expose entry point for the shared library */
+extern "C" 
+{
+	OMX_ERRORTYPE VpuDecoderInit(OMX_IN OMX_HANDLETYPE pHandle)
+	{
+		OMX_ERRORTYPE ret = OMX_ErrorNone;
+		VpuDecoder *obj = NULL;
+		ComponentBase *base = NULL;
+		VPU_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+		obj = FSL_NEW(VpuDecoder, ());
+		if(obj == NULL)
+		{
+			VPU_COMP_ERR_LOG("%s: vpu decoder new failure: ret=0x%X \r\n",__FUNCTION__,ret);
+			return OMX_ErrorInsufficientResources;
+		}
+
+		base = (ComponentBase*)obj;
+		ret = base->ConstructComponent(pHandle);
+		if(ret != OMX_ErrorNone)
+		{
+			VPU_COMP_ERR_LOG("%s: vpu decoder construct failure: ret=0x%X \r\n",__FUNCTION__,ret);
+			return ret;
+		}
+		return ret;
+	}	
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.h b/OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.h
new file mode 100755
index 0000000..4812eb6
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_dec_v2/VpuDecComponent.h
@@ -0,0 +1,247 @@
+/**
+ *  Copyright (c) 2010-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file VpuDecComponent.h
+ *  @brief Class definition of VpuDecoder Component
+ *  @ingroup VpuDecoder
+ */
+
+#ifndef VpuDecoder_h
+#define VpuDecoder_h
+
+#include "VideoFilter.h"
+#include "vpu_wrapper.h"
+
+#ifdef MX6X
+#include "linux/ipu.h"
+typedef struct ipu_task IpuTask;
+#else
+typedef enum {
+	MED_MOTION = 0,
+	LOW_MOTION = 1,
+	HIGH_MOTION = 2,
+} ipu_motion_sel;
+typedef OMX_S32 IpuTask;
+#endif  //ifdef MX6X
+
+#define VPU_DEC_MAX_NUM_MEM	(30)
+typedef fsl_osal_sem VPUCompSemaphor;
+#define VPU_COMP_SEM_INIT(ppsem)    fsl_osal_sem_init((ppsem), 0/*process shared*/,1/*number*/)
+#define VPU_COMP_SEM_INIT_PROCESS(ppsem)    fsl_osal_sem_init_process((ppsem), 1/*process shared*/,1/*number*/)
+#define VPU_COMP_SEM_DESTROY(psem)  fsl_osal_sem_destroy((psem))
+#define VPU_COMP_SEM_DESTROY_PROCESS(psem)  fsl_osal_sem_destroy_process((psem))
+#define VPU_COMP_SEM_LOCK(psem)     fsl_osal_sem_wait((psem))
+#define VPU_COMP_SEM_TRYLOCK(psem)     fsl_osal_sem_trywait((psem))
+#define VPU_COMP_SEM_UNLOCK(psem)   fsl_osal_sem_post((psem))
+
+typedef struct
+{
+	//virtual mem info
+	OMX_S32 nVirtNum;
+	OMX_U32 virtMem[VPU_DEC_MAX_NUM_MEM];
+
+	//phy mem info
+	OMX_S32 nPhyNum;
+	OMX_U32 phyMem_virtAddr[VPU_DEC_MAX_NUM_MEM];
+	OMX_U32 phyMem_phyAddr[VPU_DEC_MAX_NUM_MEM];
+	OMX_U32 phyMem_cpuAddr[VPU_DEC_MAX_NUM_MEM];
+	OMX_U32 phyMem_size[VPU_DEC_MAX_NUM_MEM];	
+}VpuDecoderMemInfo;
+
+typedef enum
+{
+	VPU_COM_FRM_OWNER_NULL=0,
+	VPU_COM_FRM_OWNER_DEC,
+	VPU_COM_FRM_OWNER_POST,
+}VpuDecoderFrmOwner;
+
+typedef enum
+{
+	VPU_COM_FRM_STATE_FREE=0,
+	VPU_COM_FRM_STATE_OUT,
+}VpuDecoderFrmState;
+
+typedef struct
+{
+	OMX_S32 nFrmNum;
+	VpuDecoderFrmOwner eFrmOwner[VPU_DEC_MAX_NUM_MEM];
+	VpuDecoderFrmState eFrmState[VPU_DEC_MAX_NUM_MEM];
+	OMX_U32 nFrm_virtAddr[VPU_DEC_MAX_NUM_MEM];
+	OMX_U32 nFrm_phyAddr[VPU_DEC_MAX_NUM_MEM];
+	//OMX_U32 nFrm_cpuAddr[VPU_DEC_MAX_NUM_MEM];
+	//OMX_U32 nFrm_size[VPU_DEC_MAX_NUM_MEM];
+	VpuDecOutFrameInfo outFrameInfo[VPU_DEC_MAX_NUM_MEM];
+	OMX_S32 nPostIndxMapping[VPU_DEC_MAX_NUM_MEM];  //mapping between decIndx and PostIndx: to align with memset(0),it store the decIndx+1
+}VpuDecoderFrmPoolInfo;
+
+typedef struct
+{
+	OMX_PTR pVirtAddr[VPU_DEC_MAX_NUM_MEM];
+	VpuDecOutFrameInfo outFrameInfo[VPU_DEC_MAX_NUM_MEM];
+}VpuDecoderOutMapInfo;
+
+typedef struct
+{
+	OMX_S32 nIpuFd;
+	IpuTask sIpuTask;
+}VpuDecoderIpuHandle;
+
+typedef enum
+{
+	VPU_COM_STATE_NONE=0,
+	VPU_COM_STATE_LOADED,
+	VPU_COM_STATE_OPENED,
+	VPU_COM_STATE_WAIT_FRM,
+	VPU_COM_STATE_DO_INIT,
+	VPU_COM_STATE_DO_DEC,
+	VPU_COM_STATE_DO_OUT,
+	VPU_COM_STATE_EOS,
+	VPU_COM_STATE_RE_WAIT_FRM,
+	VPU_COM_STATE_WAIT_POST_EOS,
+}VpuDecoderState;
+
+typedef enum
+{
+	POST_PROCESS_STATE_NONE=0,
+	POST_PROCESS_STATE_IDLE,
+	POST_PROCESS_STATE_RUN,
+}PostProcessState;
+
+typedef enum
+{
+	POST_PROCESS_CMD_NONE=0,
+	POST_PROCESS_CMD_RUN,
+	POST_PROCESS_CMD_FLUSH_IN,
+	POST_PROCESS_CMD_FLUSH_OUT,
+	POST_PROCESS_CMD_STOP,
+}PostProcessCmd;
+
+typedef enum
+{
+	VPU_COM_CAPABILITY_FILEMODE=0x1,
+	VPU_COM_CAPABILITY_TILE=0x2,
+	VPU_COM_CAPABILITY_FRMSIZE=0x4,
+}VpuDecoderCapability;
+
+class VpuDecoder : public VideoFilter {
+	public:
+		friend void *PostThread(void *arg);
+		VpuDecoder();
+		OMX_S32 DoGetBitstream(OMX_U32 nLen, OMX_U8 *pBuffer, OMX_S32 *pEndOfFrame);
+	private:
+		VPUCompSemaphor psemaphore;		//in fact, it is one ptr
+		VpuMemInfo sMemInfo;				// required by vpu wrapper
+		VpuDecoderMemInfo sVpuMemInfo;		// memory info for vpu wrapper itself
+		VpuDecoderMemInfo sAllocMemInfo;	// memory info for AllocateOutputBuffer()
+		VpuDecoderFrmPoolInfo sFramePoolInfo;// frame pool info for all output frames: decode + post-process		
+
+		VpuDecInitInfo sInitInfo;		// seqinit info
+		VpuDecHandle nHandle;		// pointer to vpu object
+
+		OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];
+		
+		//sWmv9DecObjectType sDecObj;
+		VpuCodStd eFormat;
+		OMX_S32 nPadWidth;
+		OMX_S32 nPadHeight;
+		//OMX_S32 nFrameSize;
+		//OMX_PTR pFrameBuffer;
+		OMX_CONFIG_RECTTYPE sOutCrop;
+		OMX_CONFIG_SCALEFACTORTYPE sDispRatio;
+
+		OMX_PTR pInBuffer;
+		OMX_S32 nInSize;
+		OMX_BOOL bInEos;
+		
+		//OMX_PTR pOutBuffer;
+		//OMX_BOOL bOutLast;
+		
+		//OMX_BOOL bFrameBufReady;
+		VpuDecoderState eVpuDecoderState;	
+
+		OMX_PTR pLastOutVirtBuf;		//record the last output frame
+
+		OMX_S32 nFreeOutBufCntDec;		//frame buffer numbers which can be used by vpu
+		OMX_S32 nFreeOutBufCntPost;		//frame buffer numbers which can be used by post-process
+
+		OMX_S32 nNeedFlush;		//flush automatically according return value from vpu wrapper
+		OMX_S32 nNeedSkip;			//output one skip to get one timestamp
+
+		OMX_PARAM_MEM_OPERATOR sMemOperator;
+		OMX_DECODE_MODE ePlayMode;
+		OMX_U32 nChromaAddrAlign;	//the address of Y,Cb,Cr may need to alignment.
+
+		OMX_PTR pClock;
+		VpuVersionInfo sVpuVer;		//vpu version info
+		OMX_U32 nCapability;			//vpu capability
+
+		OMX_S32 nMaxDurationMsThr;	// control the speed of data consumed by decoder: -1 -> no threshold
+		OMX_S32 nMaxBufCntThr;		// control the speed of data consumed by decoder: -1 -> no threshold		
+
+		OMX_U32 nOutBufferCntPost;	//used for post-porcess: <= nutBufferCnt-nOutBufferCntDec
+		OMX_U32 nOutBufferCntDec;	//used for vpu: <= nutBufferCnt-nOutBufferCntPost
+		OMX_BOOL bEnabledPostProcess;	//post-process is enalbed or not: mainly for deinterlace
+		ipu_motion_sel nPostMotion;     // post process motion: LOW/MED/HIGH 
+		VpuDecoderIpuHandle sIpuHandle;
+		fsl_osal_ptr pPostThreadId;
+		PostProcessState ePostState;	//post thread write, decoder thread read
+		PostProcessCmd ePostCmd;	//post thread read/clear, decoder thread write
+		Queue* pPostInQueue;		//vpu frame index(low 16bits): decode thread add, post thread get
+		Queue* pPostOutQueue;		//post/vpu frame index(low 16bits): decode thread get, post thread add
+		Queue* pPostInReturnQueue;  //vpu frame index: decode thread get, post thread add
+		Queue* pPostOutReturnQueue;//post frame index: decode thread add, post thread get
+		fsl_osal_sem pPostCmdSem;	//decode thread wait, post thread post
+		fsl_osal_mutex pPostMutex;       //sync mutex between post and decode thread
+		pthread_cond_t sPostCond;        //sync condition between post and decode thread
+		OMX_BOOL bPostWaitingTasks;//post thread are waiting tasks from decode thread
+
+		OMX_S32 nFrameWidthStride;	//user may register frames with specified width stride
+		OMX_S32 nFrameHeightStride;	//user may register frames with specified height stride
+		OMX_S32 nFrameMaxCnt;		//user may register frames with specified count
+		OMX_BOOL bReorderDisabled;
+		
+		OMX_ERRORTYPE SetRoleFormat(OMX_STRING role);
+		OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE GetInputDataDepthThreshold(OMX_S32* pDurationThr, OMX_S32* pBufCntThr);
+
+		/* virtual function implementation */
+		OMX_ERRORTYPE InitFilterComponent();
+		OMX_ERRORTYPE DeInitFilterComponent();
+		OMX_ERRORTYPE SetInputBuffer(OMX_PTR pBuffer, OMX_S32 nSize, OMX_BOOL bLast);
+		OMX_ERRORTYPE SetOutputBuffer(OMX_PTR pBuffer);
+		OMX_ERRORTYPE InitFilter();
+		OMX_ERRORTYPE DeInitFilter();
+		FilterBufRetCode FilterOneBuffer();
+		OMX_ERRORTYPE GetDecBuffer(OMX_PTR *ppBuffer,OMX_S32 * pOutStuffSize,OMX_S32* pOutFrmSize);
+		OMX_ERRORTYPE GetPostMappedDecBuffer(OMX_PTR pPostBuf,OMX_PTR *ppDecBuffer);
+		OMX_ERRORTYPE GetOutputBuffer(OMX_PTR *ppBuffer,OMX_S32 * pOutSize);
+		OMX_ERRORTYPE FlushFilter();
+		OMX_ERRORTYPE FlushInputBuffer();
+		OMX_ERRORTYPE FlushOutputBuffer();
+
+		//OMX_PTR AllocateInputBuffer(OMX_U32 nSize);
+		//OMX_ERRORTYPE FreeInputBuffer(OMX_PTR pBuffer);
+		OMX_PTR AllocateOutputBuffer(OMX_U32 nSize);
+		OMX_ERRORTYPE FreeOutputBuffer(OMX_PTR pBuffer);		
+
+		OMX_ERRORTYPE SetDefaultSetting();
+		FilterBufRetCode ProcessVpuInitInfo();
+		OMX_ERRORTYPE PostThreadRun();
+		OMX_ERRORTYPE PostThreadStop();
+		OMX_ERRORTYPE PostThreadFlushInput();
+		OMX_ERRORTYPE PostThreadFlushOutput();
+		OMX_ERRORTYPE ReleaseVpuSource();
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/component/vpu_enc/Android.mk b/OpenMAXIL/src/component/vpu_enc/Android.mk
new file mode 100755
index 0000000..926310b
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_enc/Android.mk
@@ -0,0 +1,28 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	VpuEncComponent.cpp
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+ 
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) -DDPB_FIX_APP -DDPB_FIX -Dbool $(LOCAL_PATH)/../vpu_wrapper
+
+LOCAL_SHARED_LIBRARIES := lib_omx_common_v2_arm11_elinux \
+                          lib_omx_osal_v2_arm11_elinux \
+                          lib_omx_utils_v2_arm11_elinux \
+			  lib_omx_res_mgr_v2_arm11_elinux \
+			  libvpu \
+			  lib_vpu_wrapper
+
+LOCAL_PRELINK_MODULE := false
+	
+LOCAL_MODULE:= lib_omx_vpu_enc_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/OpenMAXIL/src/component/vpu_enc/Makefile b/OpenMAXIL/src/component/vpu_enc/Makefile
new file mode 100755
index 0000000..a6e1ac5
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_enc/Makefile
@@ -0,0 +1,37 @@
+#####################################################################################
+#
+#   Copyright (c) 2011, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+#Set the root directory
+OMX_ROOT_DIR=../../../..
+
+#Set the component directory
+OMX_COMPONENT_DEFINE_DIR=..
+
+# Set the BUILD information 
+include $(OMX_COMPONENT_DEFINE_DIR)/Makefile_component.defines
+
+COMPONENT_NAME=vpu_enc
+COMPONENT_SO_NAME=lib_omx_$(COMPONENT_NAME)_v2_$(PROCESSOR)_$(OSTYPE).so
+
+SOURCE_FILES = $(SRC_DIR)/VpuEncComponent.cpp
+
+LFLAGS +=-l_vpu_wrapper -lvpu
+LFLAGS +=-L$(BSP_RELATED_LIB_DIR)               
+
+#Include rules Makefile
+include $(OMX_COMPONENT_DEFINE_DIR)/Makefile.rules	
+
+
+
diff --git a/OpenMAXIL/src/component/vpu_enc/VpuEncComponent.cpp b/OpenMAXIL/src/component/vpu_enc/VpuEncComponent.cpp
new file mode 100755
index 0000000..bd3f123
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_enc/VpuEncComponent.cpp
@@ -0,0 +1,3036 @@
+/**
+ *  Copyright (c) 2010-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+#include "VpuEncComponent.h"
+#include "Mem.h"
+#include "sys/ioctl.h"
+#include "fcntl.h"
+
+#define VPU_ENC_GUESS_OUTLENGTH	//no size in SetOutputBuffer(), so we guess one value
+//#define VPU_ENC_WORKAROUND_WIFI_INTRA_QUALITY //we need to set qp value for I frame manually to avoid dither in static video
+
+//#define VPU_ENC_COMP_API_DBGLOG
+#ifdef VPU_ENC_COMP_API_DBGLOG
+#define VPU_ENC_COMP_API_LOG	printf
+#define VPU_ENC_COMP_LOG(...)//	printf
+#define VPU_ENC_API(...)//	printf
+#define VPU_ENC_LOG(...)// printf
+typedef int INT32;				//avoid compiler warning in printf
+typedef unsigned int UINT32;		//avoid compiler warning in printf
+#else
+#define VPU_ENC_COMP_API_LOG(...)
+#define VPU_ENC_COMP_LOG(...)
+#define VPU_ENC_API(...)
+#define VPU_ENC_LOG(...)
+#endif
+
+//#define VPU_ENC_COMP_ERR_DBGLOG
+#ifdef VPU_ENC_COMP_ERR_DBGLOG
+#define VPU_ENC_COMP_ERR_LOG	printf
+//#define VPU_ENC_ERROR	printf
+typedef int INT32;				//avoid compiler warning in printf
+typedef unsigned int UINT32;		//avoid compiler warning in printf
+#define ASSERT(exp)	if(!(exp)) {printf("%s: %d : assert condition !!!\r\n",__FUNCTION__,__LINE__);}
+#else
+typedef int INT32;				//avoid compiler warning in printf
+typedef unsigned int UINT32;		//avoid compiler warning in printf
+#define VPU_ENC_COMP_ERR_LOG LOG_ERROR //(...)
+//#define VPU_ENC_ERROR(...)
+#define ASSERT(...)
+#endif
+
+#ifdef NULL
+#undef NULL
+#define NULL 0
+#endif
+
+#define Align(ptr,align)	(((OMX_U32)ptr+(align)-1)/(align)*(align))
+//#define MemAlign(mem,align)	((((OMX_U32)mem)%(align))==0)
+//#define MemNotAlign(mem,align)	((((OMX_U32)mem)%(align))!=0)
+
+#define ENC_MAX_FRAME_NUM		(VPU_ENC_MAX_NUM_MEM)
+//#define ENC_FRAME_SURPLUS	(1)
+
+#define DEFAULT_ENC_FRM_WIDTH		(320)
+#define DEFAULT_ENC_FRM_HEIGHT		(240)
+#define DEFAULT_ENC_FRM_RATE			(30 * Q16_SHIFT)
+#define DEFAULT_ENC_FRM_BITRATE		(256 * 1024)
+
+#define DEFAULT_ENC_BUF_IN_CNT		0x3
+#define DEFAULT_ENC_BUF_IN_SIZE		(DEFAULT_ENC_FRM_WIDTH*DEFAULT_ENC_FRM_HEIGHT*3/2)
+#define DEFAULT_ENC_BUF_OUT_CNT		0x3
+#define DEFAULT_ENC_BUF_OUT_SIZE		(1024*1024)	//FIXME: set one big enough value !!!
+
+#define VPU_ENC_COMP_NAME_AVCENC	"OMX.Freescale.std.video_encoder.avc.hw-based"
+#define VPU_ENC_COMP_NAME_MPEG4ENC	"OMX.Freescale.std.video_encoder.mpeg4.hw-based"
+#define VPU_ENC_COMP_NAME_H263ENC	"OMX.Freescale.std.video_encoder.h263.hw-based"
+
+//#define PRE_PROCESS_BY_PASS_TEST  //only for pipeline test
+#define PRE_FLAG_EOS			(0x1)
+#define PRE_MAX_QUEUE_SIZE	(VPU_ENC_MAX_NUM_MEM)
+#define PRE_OUT_BUF_NUM		(3)
+#define PRE_THRESHOLD_MIN_INPUT		(1)
+#define IPU_FOURCC(a,b,c,d) (((OMX_U32)(a)<<0)|((OMX_U32)(b)<<8)|((OMX_U32)(c)<<16)|((OMX_U32)(d)<<24))
+
+OMX_S32 MemMallocVpuBlock(VpuMemInfo* pMemBlock,VpuEncoderMemInfo* pVpuMem,OMX_PARAM_MEM_OPERATOR* pMemOp);
+
+//#define VPU_ENC_COMP_PRE_DEBUG
+#ifdef VPU_ENC_COMP_PRE_DEBUG
+#include <sys/time.h>
+static struct timeval time_beg;
+static struct timeval time_end;
+static unsigned long long total_time;
+static unsigned long long total_cnt;
+static void time_init()
+{
+	total_time=0;
+	total_cnt=0;
+	return;
+}
+static void time_start()
+{
+	gettimeofday(&time_beg, 0);
+	return;
+}
+static void time_stop()
+{
+	unsigned int tm_1, tm_2;
+	gettimeofday(&time_end, 0);
+
+	tm_1 = time_beg.tv_sec * 1000000 + time_beg.tv_usec;
+	tm_2 = time_end.tv_sec * 1000000 + time_end.tv_usec;
+	total_cnt++;
+	total_time = total_time + (tm_2-tm_1);
+	printf("pre-process time: %d (us) \r\n",(tm_2-tm_1));
+	return;
+}
+static void time_report()
+{
+	double avg;
+	if(total_cnt)
+	{
+		avg=total_time/total_cnt;
+		printf(" average pre-process time: %f (ms)\r\n",avg/1000);
+	}
+	return;
+}
+#define TIMER_INIT	time_init()
+#define TIMER_START time_start()
+#define TIMER_STOP	time_stop()
+#define TIMER_REPORT	time_report()
+#define VPU_ENC_COMP_PRE_LOG printf
+#else
+#define TIMER_INIT
+#define TIMER_START
+#define TIMER_STOP
+#define TIMER_REPORT
+#define VPU_ENC_COMP_PRE_LOG
+#endif
+
+VpuEncRetCode VPUCom_GetMem_Wrapper(VpuMemDesc* pInOutMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	VpuEncRetCode ret;
+	if((pMemOp->pfMalloc==NULL) || (pMemOp->pfFree==NULL))
+	{
+		//use default method
+		ret=VPU_EncGetMem(pInOutMem);	
+	}
+	else
+	{
+		OMX_MEM_DESC sOmxMem;
+		sOmxMem.nSize=pInOutMem->nSize;
+		if(OMX_TRUE==pMemOp->pfMalloc(&sOmxMem))
+		{
+			pInOutMem->nPhyAddr=sOmxMem.nPhyAddr;
+			pInOutMem->nVirtAddr=sOmxMem.nVirtAddr;
+			pInOutMem->nCpuAddr=sOmxMem.nCpuAddr;
+			ret=VPU_ENC_RET_SUCCESS;
+		}
+		else
+		{
+			ret=VPU_ENC_RET_FAILURE;
+		}
+	}
+	return ret;
+}
+
+VpuEncRetCode VPUCom_FreeMem_Wrapper(VpuMemDesc* pInMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	VpuEncRetCode ret;
+	if((pMemOp->pfMalloc==NULL) || (pMemOp->pfFree==NULL))
+	{
+		//use default method
+		ret=VPU_EncFreeMem(pInMem);
+	}
+	else
+	{
+		OMX_MEM_DESC sOmxMem;
+		sOmxMem.nSize=pInMem->nSize;
+		sOmxMem.nPhyAddr=pInMem->nPhyAddr;
+		sOmxMem.nVirtAddr=pInMem->nVirtAddr;
+		sOmxMem.nCpuAddr=pInMem->nCpuAddr;
+		if(OMX_TRUE==pMemOp->pfFree(&sOmxMem))
+		{
+			ret=VPU_ENC_RET_SUCCESS;
+		}
+		else
+		{
+			ret=VPU_ENC_RET_FAILURE;
+		}
+	}
+	return ret;	
+}
+
+VpuEncRetCode VPUCom_Init(VpuEncInputParam* pVpuEncInputPara,VpuEncoderMemInfo* pVpuMem,OMX_PARAM_MEM_OPERATOR* pMemOp,VpuEncHandle *pOutHandle, VpuEncInitInfo * pOutInitInfo)
+{
+	VpuEncRetCode ret;
+	VpuMemInfo sMemInfo;	
+	VpuEncOpenParamSimp sEncOpenParam;
+	//query memory
+	ret=VPU_EncQueryMem(&sMemInfo);
+	if (ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu query memory failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		return VPU_ENC_RET_FAILURE;
+	}
+	//malloc memory for vpu 
+	if(0==MemMallocVpuBlock(&sMemInfo,pVpuMem,pMemOp))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: malloc memory failure: \r\n",__FUNCTION__);
+		return VPU_ENC_RET_FAILURE;
+	}
+
+	//clear 0 firstly
+#if 0 //1 !!!!	
+	fsl_osal_memset(&sEncOpenParam,0,sizeof(VpuEncOpenParam));
+#else
+	fsl_osal_memset(&sEncOpenParam,0,sizeof(VpuEncOpenParamSimp));
+#endif
+	sEncOpenParam.eFormat=pVpuEncInputPara->eFormat;
+	sEncOpenParam.nPicWidth= pVpuEncInputPara->nPicWidth;
+	sEncOpenParam.nPicHeight=pVpuEncInputPara->nPicHeight;
+	sEncOpenParam.nRotAngle=pVpuEncInputPara->nRotAngle;
+	sEncOpenParam.nFrameRate=pVpuEncInputPara->nFrameRate;
+	sEncOpenParam.nBitRate=pVpuEncInputPara->nBitRate/1000;	// bps => kbps !!!
+	sEncOpenParam.nGOPSize=pVpuEncInputPara->nGOPSize;
+	sEncOpenParam.nIntraRefresh=pVpuEncInputPara->nIntraFreshNum;
+	sEncOpenParam.nIntraQP=pVpuEncInputPara->nRcIntraQP;
+	sEncOpenParam.nChromaInterleave=pVpuEncInputPara->nChromaInterleave;
+	sEncOpenParam.sMirror=pVpuEncInputPara->sMirror;
+
+	if(1==sEncOpenParam.nChromaInterleave){
+		//for reduce the bus loading, we set tile format for vpu internal frame buffers.
+		sEncOpenParam.nMapType=1;
+		sEncOpenParam.nLinear2TiledEnable=1;
+	}
+
+	//open vpu			
+	ret=VPU_EncOpenSimp(pOutHandle, &sMemInfo,&sEncOpenParam);
+	if (ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu open failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		return VPU_ENC_RET_FAILURE;
+	}			
+
+	//set default config
+	ret=VPU_EncConfig(*pOutHandle, VPU_ENC_CONF_NONE, NULL);
+	if(VPU_ENC_RET_SUCCESS!=ret)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_ENC_CONF_NONE,ret);
+		//VPU_EncClose(nHandle);
+		return VPU_ENC_RET_FAILURE;
+	}	
+
+	if(pVpuEncInputPara->nIntraFreshNum>0){
+		ret=VPU_EncConfig(*pOutHandle, VPU_ENC_CONF_INTRA_REFRESH, &pVpuEncInputPara->nIntraFreshNum);
+		if(VPU_ENC_RET_SUCCESS!=ret){
+			VPU_ENC_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_ENC_CONF_INTRA_REFRESH,ret);
+			return VPU_ENC_RET_FAILURE;
+		}
+	}
+
+	if(OMX_TRUE==pVpuEncInputPara->bEnabledSPSIDR){
+		ret=VPU_EncConfig(*pOutHandle, VPU_ENC_CONF_ENA_SPSPPS_IDR, NULL);
+		if(VPU_ENC_RET_SUCCESS!=ret){
+			VPU_ENC_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_ENC_CONF_ENA_SPSPPS_IDR,ret);
+			return VPU_ENC_RET_FAILURE;
+		}
+	}
+
+	if(pVpuEncInputPara->nRcIntraQP>0){
+		//fixme: this setting not work, so we still need to transfer intra qp in open operation
+		ret=VPU_EncConfig(*pOutHandle, VPU_ENC_CONF_RC_INTRA_QP, &pVpuEncInputPara->nRcIntraQP);
+		if(VPU_ENC_RET_SUCCESS!=ret){
+			VPU_ENC_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_ENC_CONF_RC_INTRA_QP,ret);
+			return VPU_ENC_RET_FAILURE;
+		}		
+	}
+
+	//get initinfo
+	ret=VPU_EncGetInitialInfo(*pOutHandle,pOutInitInfo);
+	if(VPU_ENC_RET_SUCCESS!=ret)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: init vpu failure \r\n",__FUNCTION__);
+		return VPU_ENC_RET_FAILURE;
+	}
+
+	return VPU_ENC_RET_SUCCESS;
+}
+
+OMX_S32 MemFreeBlock(VpuEncoderMemInfo* pEncMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	OMX_S32 i;
+	VpuMemDesc vpuMem;
+	VpuEncRetCode vpuRet;
+	OMX_S32 retOk=1;
+
+	//free virtual mem
+	//for(i=0;i<pEncMem->nVirtNum;i++)
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		if(pEncMem->virtMem[i])
+		{
+			fsl_osal_ptr ptr=(fsl_osal_ptr)pEncMem->virtMem[i];
+			FSL_FREE(ptr);
+			pEncMem->virtMem[i]=NULL;
+		}
+	}
+
+	pEncMem->nVirtNum=0;
+
+	//free physical mem
+	//for(i=0;i<pEncMem->nPhyNum;i++)
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		if(pEncMem->phyMem_phyAddr[i])
+		{
+			vpuMem.nPhyAddr=pEncMem->phyMem_phyAddr[i];
+			vpuMem.nVirtAddr=pEncMem->phyMem_virtAddr[i];
+			vpuMem.nCpuAddr=pEncMem->phyMem_cpuAddr[i];
+			vpuMem.nSize=pEncMem->phyMem_size[i];
+			vpuRet=VPUCom_FreeMem_Wrapper(&vpuMem,pMemOp);
+			if(vpuRet!=VPU_ENC_RET_SUCCESS)
+			{
+				VPU_ENC_COMP_LOG("%s: free vpu memory failure : ret=0x%X \r\n",__FUNCTION__,vpuRet);
+				retOk=0;
+			}
+			pEncMem->phyMem_phyAddr[i]=NULL;
+			pEncMem->phyMem_virtAddr[i]=NULL;
+			pEncMem->phyMem_cpuAddr[i]=NULL;
+			pEncMem->phyMem_size[i]=0;
+		}
+	}
+	pEncMem->nPhyNum=0;
+	
+	return retOk;
+}
+
+OMX_S32 MemAddPhyBlock(VpuMemDesc* pInMemDesc,VpuEncoderMemInfo* pOutEncMem)
+{
+	OMX_S32 i;
+
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		// insert value into empty node
+		if(NULL==pOutEncMem->phyMem_phyAddr[i])
+		{
+			pOutEncMem->phyMem_phyAddr[i]=pInMemDesc->nPhyAddr;
+			pOutEncMem->phyMem_virtAddr[i]=pInMemDesc->nVirtAddr;
+			pOutEncMem->phyMem_cpuAddr[i]=pInMemDesc->nCpuAddr;
+			pOutEncMem->phyMem_size[i]=pInMemDesc->nSize;
+			pOutEncMem->nPhyNum++;
+			return 1;
+		}
+	}
+	VPU_ENC_COMP_ERR_LOG("error: buffer items(%d) are full \r\n",VPU_ENC_MAX_NUM_MEM);
+	return 0;
+}
+
+OMX_S32 MemRemovePhyBlock(VpuMemDesc* pInMemDesc,VpuEncoderMemInfo* pOutEncMem)
+{
+	OMX_S32 i;
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		// clear matched node
+		if(pInMemDesc->nPhyAddr==pOutEncMem->phyMem_phyAddr[i])
+		{
+			pOutEncMem->phyMem_phyAddr[i]=NULL;
+			pOutEncMem->phyMem_virtAddr[i]=NULL;
+			pOutEncMem->phyMem_cpuAddr[i]=NULL;
+			pOutEncMem->phyMem_size[i]=0;
+			pOutEncMem->nPhyNum--;
+			return 1;
+		}
+	}	
+	
+	return 0;
+}
+
+OMX_S32 MemQueryPhyBlock(OMX_PTR pInVirtAddr,VpuMemDesc* pOutMemDesc,VpuEncoderMemInfo* pInEncMem)
+{
+	OMX_S32 i;
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		// find matched node
+		if((OMX_U32)pInVirtAddr==pInEncMem->phyMem_virtAddr[i])
+		{
+			pOutMemDesc->nPhyAddr=pInEncMem->phyMem_phyAddr[i];
+			pOutMemDesc->nVirtAddr=pInEncMem->phyMem_virtAddr[i];
+			pOutMemDesc->nCpuAddr=pInEncMem->phyMem_cpuAddr[i];
+			pOutMemDesc->nSize=pInEncMem->phyMem_size[i];
+			return 1;
+		}
+	}	
+	
+	return 0;
+}
+
+OMX_S32 MemMallocVpuBlock(VpuMemInfo* pMemBlock,VpuEncoderMemInfo* pVpuMem,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	OMX_S32 i;
+	OMX_U8 * ptr=NULL;
+	OMX_S32 size;
+	
+	for(i=0;i<pMemBlock->nSubBlockNum;i++)
+	{
+		size=pMemBlock->MemSubBlock[i].nAlignment+pMemBlock->MemSubBlock[i].nSize;
+		if(pMemBlock->MemSubBlock[i].MemType==VPU_MEM_VIRT)
+		{
+			ptr=(OMX_U8*)FSL_MALLOC(size);
+			if(ptr==NULL)
+			{
+				VPU_ENC_COMP_LOG("%s: get virtual memory failure, size=%d \r\n",__FUNCTION__,(INT32)size);
+				goto failure;
+			}		
+			pMemBlock->MemSubBlock[i].pVirtAddr=(OMX_U8*)Align(ptr,pMemBlock->MemSubBlock[i].nAlignment);
+
+			//record virtual base addr
+			pVpuMem->virtMem[pVpuMem->nVirtNum]=(OMX_U32)ptr;
+			pVpuMem->nVirtNum++;
+		}
+		else// if(memInfo.MemSubBlock[i].MemType==VPU_MEM_PHY)
+		{
+			VpuMemDesc vpuMem;
+			VpuEncRetCode ret;
+			vpuMem.nSize=size;
+			ret=VPUCom_GetMem_Wrapper(&vpuMem,pMemOp);
+			if(ret!=VPU_ENC_RET_SUCCESS)
+			{
+				VPU_ENC_COMP_LOG("%s: get vpu memory failure, size=%d, ret=0x%X \r\n",__FUNCTION__,(INT32)size,ret);
+				goto failure;
+			}		
+			pMemBlock->MemSubBlock[i].pVirtAddr=(OMX_U8*)Align(vpuMem.nVirtAddr,pMemBlock->MemSubBlock[i].nAlignment);
+			pMemBlock->MemSubBlock[i].pPhyAddr=(OMX_U8*)Align(vpuMem.nPhyAddr,pMemBlock->MemSubBlock[i].nAlignment);
+
+			//record physical base addr
+			pVpuMem->phyMem_phyAddr[pVpuMem->nPhyNum]=(OMX_U32)vpuMem.nPhyAddr;
+			pVpuMem->phyMem_virtAddr[pVpuMem->nPhyNum]=(OMX_U32)vpuMem.nVirtAddr;
+			pVpuMem->phyMem_cpuAddr[pVpuMem->nPhyNum]=(OMX_U32)vpuMem.nCpuAddr;
+			pVpuMem->phyMem_size[pVpuMem->nPhyNum]=size;
+			pVpuMem->nPhyNum++;			
+		}
+	}	
+
+	return 1;
+	
+failure:
+	MemFreeBlock(pVpuMem,pMemOp);
+	return 0;
+	
+}
+
+
+OMX_S32 OutFrameBufRegister(OMX_PTR pInVirtAddr,VpuEncoderMemInfo* pOutEncMem,OMX_S32* pOutIsPhy)
+{
+	OMX_S32 i;
+	OMX_PTR pPhyAddr;
+
+	//get physical info from resource manager
+	if(OMX_ErrorNone!=GetHwBuffer(pInVirtAddr,&pPhyAddr))
+	{
+		return -1;
+	}
+
+	if(pPhyAddr==NULL)
+	{
+		//1 virtual space ??
+		for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)	
+		{
+			//insert into empty node
+			if(NULL==pOutEncMem->virtMem[i])
+			{
+				pOutEncMem->virtMem[i]=(OMX_U32)pInVirtAddr;
+				pOutEncMem->nVirtNum++;
+				*pOutIsPhy=0;
+				return pOutEncMem->nPhyNum;
+			}
+		}
+	}
+	else
+	{
+		//physical space
+		for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)	
+		{
+			//insert into empty node
+			if(NULL==pOutEncMem->phyMem_phyAddr[i])
+			{
+				pOutEncMem->phyMem_phyAddr[i]=(OMX_U32)pPhyAddr;
+				pOutEncMem->phyMem_virtAddr[i]=(OMX_U32)pInVirtAddr;
+				//pOutEncMem->phyMem_cpuAddr[i]=
+				//pOutEncMem->phyMem_size[i]=	
+				pOutEncMem->nPhyNum++;
+				*pOutIsPhy=1;
+				return pOutEncMem->nPhyNum;
+			}
+		}
+	}
+	
+	return -1;
+}
+
+OMX_S32 OutFrameBufExist(OMX_PTR pInVirtAddr,VpuEncoderMemInfo* pInEncMem, OMX_S32* pOutIsPhy)
+{
+	OMX_S32 i;
+	OMX_PTR pPhyAddr;
+
+	//get physical info from resource manager
+	if(OMX_ErrorNone!=GetHwBuffer(pInVirtAddr,&pPhyAddr))
+	{
+		return 0;
+	}
+
+	if(pPhyAddr==NULL)
+	{
+		//1 virtual space ??
+		for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)	
+		{
+			//search matched node
+			if((OMX_U32)pInVirtAddr==pInEncMem->virtMem[i])
+			{
+				*pOutIsPhy=0;
+				return 1;
+			}
+		}
+	}
+	else
+	{
+		//physical space
+		for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)	
+		{
+			//search matched node
+			if((OMX_U32)pPhyAddr==pInEncMem->phyMem_phyAddr[i])
+			{
+				*pOutIsPhy=1;
+				return 1;
+			}
+		}
+	}	
+	return 0;
+}
+
+OMX_S32 OutFrameBufClear(VpuEncoderMemInfo* pOutEncMem)
+{
+	OMX_S32 i;
+	//clear all node
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)	 
+	{
+		pOutEncMem->phyMem_virtAddr[i]=NULL;
+	
+		pOutEncMem->phyMem_phyAddr[i]=NULL;
+		pOutEncMem->phyMem_virtAddr[i]=NULL;
+		pOutEncMem->phyMem_cpuAddr[i]=NULL;
+		pOutEncMem->phyMem_size[i]=0;
+	}
+	pOutEncMem->nVirtNum=0;
+	pOutEncMem->nPhyNum=0;	
+	return 1;
+}
+
+OMX_S32 OutFrameBufPhyFindValid(VpuEncoderMemInfo* pInMem, OMX_U32* pOutPhy,OMX_U32* pOutVirt,OMX_U32* pOutLen)
+{
+	OMX_S32 i;
+
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		//find one non-empty physical node
+		if(NULL!=pInMem->phyMem_phyAddr[i])
+		{
+			*pOutPhy=pInMem->phyMem_phyAddr[i];
+			*pOutVirt=pInMem->phyMem_virtAddr[i];
+			*pOutLen=pInMem->phyMem_size[i];
+#ifdef VPU_ENC_GUESS_OUTLENGTH	
+		//1 TODO: in fact, we do know the size value since only address is transfered through SetOutputBuffer()
+		//give one big enough value, Now, it is only used by assert checking in encode frame : header length <= output buffer size
+		*pOutLen=(64*1024);
+#endif
+			return i;
+		}
+	}
+	return -1;
+}
+
+OMX_S32 OutFrameBufVirtFindValidAndClear(VpuEncoderMemInfo* pInMem, OMX_U32* pOutVirt)
+{
+	OMX_S32 i;
+
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		//find one non-empty physical node and return its virtual address
+		if(NULL!=pInMem->phyMem_phyAddr[i])
+		{
+			*pOutVirt=pInMem->phyMem_virtAddr[i];
+			//clear the node
+			pInMem->phyMem_virtAddr[i]=NULL;
+			pInMem->phyMem_phyAddr[i]=NULL;
+			pInMem->phyMem_virtAddr[i]=NULL;
+			pInMem->phyMem_cpuAddr[i]=NULL;
+			pInMem->phyMem_size[i]=0;	
+			pInMem->nPhyNum--;	
+			return i;
+		}
+	}
+	return -1;
+}
+
+OMX_S32 OutFrameBufPhyClear(VpuEncoderMemInfo* pOutDecMem,OMX_PTR pInPhyAddr,OMX_PTR* ppOutVirtAddr)
+{
+	//find node according physical address and (1) return virtual address (2) clear node
+	OMX_S32 i;
+
+	for(i=0;i<VPU_ENC_MAX_NUM_MEM;i++)
+	{
+		if((OMX_U32)pInPhyAddr==pOutDecMem->phyMem_phyAddr[i])
+		{
+			//return virtual address
+			*ppOutVirtAddr=(OMX_PTR)(pOutDecMem->phyMem_virtAddr[i]);
+			//clear specified physical node
+			pOutDecMem->phyMem_virtAddr[i]=NULL;
+			pOutDecMem->phyMem_phyAddr[i]=NULL;
+			pOutDecMem->phyMem_virtAddr[i]=NULL;
+			pOutDecMem->phyMem_cpuAddr[i]=NULL;
+			pOutDecMem->phyMem_size[i]=0;
+
+			pOutDecMem->nPhyNum--;	
+			return 1;
+		}
+	}
+
+	return -1;
+}
+
+OMX_S32 OutFrameBufCreateRegisterFrame(
+	VpuFrameBuffer* pOutRegisterFrame,OMX_S32 nInCnt,OMX_S32 nWidth,OMX_S32 nHeight,
+	VpuEncoderMemInfo* pOutEncMemInfo, OMX_PARAM_MEM_OPERATOR* pMemOp,OMX_S32 nInRot,OMX_S32* pOutSrcStride,OMX_S32 nInAlign)
+{
+	OMX_S32 i;
+	VpuEncRetCode ret;	
+	OMX_S32 yStride;
+	OMX_S32 uvStride;	
+	OMX_S32 ySize;
+	OMX_S32 uvSize;
+	OMX_S32 mvSize;	
+	VpuMemDesc vpuMem;
+	OMX_U8* ptr;
+	OMX_U8* ptrVirt;
+	OMX_S32 nPadW;
+	OMX_S32 nPadH;
+
+	nPadW=Align(nWidth,16);
+	nPadH=Align(nHeight,16);
+	if((nInRot==90)||(nInRot==270))
+	{
+		yStride=nPadH;
+		ySize=yStride*nPadW;	
+	}
+	else
+	{
+		yStride=nPadW;
+		ySize=yStride*nPadH;
+	}
+	uvStride=yStride/2;
+
+	uvSize=ySize/4;
+	mvSize=0;//ySize/4;	//1 set 0 ??
+
+	//we need to align the Y/Cb/Cr address
+	if(nInAlign>1){
+		ySize=Align(ySize,nInAlign);
+		uvSize=Align(uvSize,nInAlign);
+	}
+
+	for(i=0;i<nInCnt;i++)
+	{
+		vpuMem.nSize=ySize+uvSize*2+mvSize+nInAlign;
+		ret=VPUCom_GetMem_Wrapper(&vpuMem,pMemOp);
+		if(VPU_ENC_RET_SUCCESS!=ret)
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: vpu malloc frame buf failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+			return -1;//OMX_ErrorInsufficientResources;
+		}
+
+		ptr=(OMX_U8*)vpuMem.nPhyAddr;
+		ptrVirt=(OMX_U8*)vpuMem.nVirtAddr;
+
+		/*align the base address*/
+		if(nInAlign>1){
+			ptr=(unsigned char*)Align(ptr,nInAlign);
+			ptrVirt=(unsigned char*)Align(ptrVirt,nInAlign);
+		}
+
+		/* fill stride info */
+		pOutRegisterFrame[i].nStrideY=yStride;
+		pOutRegisterFrame[i].nStrideC=uvStride;
+
+		/* fill phy addr*/
+		pOutRegisterFrame[i].pbufY=ptr;
+		pOutRegisterFrame[i].pbufCb=ptr+ySize;
+		pOutRegisterFrame[i].pbufCr=ptr+ySize+uvSize;
+		pOutRegisterFrame[i].pbufMvCol=ptr+ySize+uvSize*2;
+
+		/* fill virt addr */
+		pOutRegisterFrame[i].pbufVirtY=ptrVirt;
+		pOutRegisterFrame[i].pbufVirtCb=ptrVirt+ySize;
+		pOutRegisterFrame[i].pbufVirtCr=ptrVirt+ySize+uvSize;
+		pOutRegisterFrame[i].pbufVirtMvCol=ptrVirt+ySize+uvSize*2;	
+
+		/*now, only consider frame tile*/
+		pOutRegisterFrame[i].pbufY_tilebot=0;
+		pOutRegisterFrame[i].pbufCb_tilebot=0;
+		pOutRegisterFrame[i].pbufVirtY_tilebot=0;
+		pOutRegisterFrame[i].pbufVirtCb_tilebot=0;
+
+		//record memory info for release
+		pOutEncMemInfo->phyMem_phyAddr[pOutEncMemInfo->nPhyNum]=vpuMem.nPhyAddr;
+		pOutEncMemInfo->phyMem_virtAddr[pOutEncMemInfo->nPhyNum]=vpuMem.nVirtAddr;
+		pOutEncMemInfo->phyMem_cpuAddr[pOutEncMemInfo->nPhyNum]=vpuMem.nCpuAddr;
+		pOutEncMemInfo->phyMem_size[pOutEncMemInfo->nPhyNum]=vpuMem.nSize;
+		pOutEncMemInfo->nPhyNum++;		
+	}
+
+	*pOutSrcStride=nWidth;//nPadW;
+	return i;
+}
+
+OMX_PTR AllocateBuffer(OMX_U32 nSize,VpuEncoderMemInfo* pInMemInfo,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	VpuEncRetCode ret;
+	VpuMemDesc vpuMem;
+
+	//malloc physical memory through vpu 
+	vpuMem.nSize=nSize;
+	ret=VPUCom_GetMem_Wrapper(&vpuMem,pMemOp);
+	if(VPU_ENC_RET_SUCCESS!=ret)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu malloc frame buf failure: size=%d, ret=0x%X \r\n",__FUNCTION__,(INT32)nSize,ret);	
+		return (OMX_PTR)NULL;//OMX_ErrorInsufficientResources;
+	}	
+
+	//record memory for release
+	if(0==MemAddPhyBlock(&vpuMem, pInMemInfo))
+	{
+		VPUCom_FreeMem_Wrapper(&vpuMem,pMemOp);
+		VPU_ENC_COMP_ERR_LOG("%s:add phy block failure \r\n",__FUNCTION__);	
+		return (OMX_PTR)NULL;
+	}
+
+	//register memory info into resource manager
+	if(OMX_ErrorNone!=AddHwBuffer((OMX_PTR)vpuMem.nPhyAddr, (OMX_PTR)vpuMem.nVirtAddr))
+	{
+		MemRemovePhyBlock(&vpuMem, pInMemInfo);
+		VPUCom_FreeMem_Wrapper(&vpuMem,pMemOp);
+		VPU_ENC_COMP_ERR_LOG("%s:add hw buffer failure \r\n",__FUNCTION__);	
+		return (OMX_PTR)NULL;
+	}
+
+	//return virtual address
+	return (OMX_PTR)vpuMem.nVirtAddr;//OMX_ErrorNone;
+}
+
+OMX_S32 SetDefaultEncParam(VpuEncInputParam* pEncParam)
+{
+	//pEncParam->eFormat=VPU_V_AVC;
+	pEncParam->eFormat=VPU_V_MPEG4;
+	//pEncParam->eFormat=VPU_V_H263;
+	pEncParam->nPicWidth=DEFAULT_ENC_FRM_WIDTH;
+	pEncParam->nPicHeight=DEFAULT_ENC_FRM_HEIGHT;	
+	pEncParam->nWidthStride=pEncParam->nPicWidth;
+	pEncParam->nHeightStride=pEncParam->nPicHeight;		
+	pEncParam->nRotAngle=0;//90;
+	pEncParam->nFrameRate=30;	
+	ASSERT(0!=pEncParam->nFrameRate);
+	pEncParam->nBitRate=0;
+	pEncParam->nGOPSize=15;
+	pEncParam->nChromaInterleave=0;
+	pEncParam->sMirror=VPU_ENC_MIRDIR_NONE;
+	
+	/* "nQuantParam" is used for all quantization parameters in case of VBR (no rate control).
+	The range of value is 1-31 for MPEG-4 and 0-51 for H.264. When rate control is
+	enabled, this field is ignored*/
+	pEncParam->nQuantParam=10;
+
+	pEncParam->nEnableAutoSkip=1;
+
+	pEncParam->nIDRPeriod=pEncParam->nGOPSize;
+	pEncParam->nRefreshIntra=0;
+	pEncParam->nIntraFreshNum=0;
+	pEncParam->bEnabledSPSIDR=OMX_FALSE;
+	pEncParam->nRcIntraQP=0;
+	return 1;	
+}
+
+OMX_ERRORTYPE FreeBuffer(OMX_PTR pBuffer,VpuEncoderMemInfo* pInMemInfo,OMX_PARAM_MEM_OPERATOR* pMemOp)
+{
+	VpuEncRetCode ret;
+	VpuMemDesc vpuMem;
+
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//query related mem info for release
+	if(0==MemQueryPhyBlock(pBuffer,&vpuMem,pInMemInfo))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: query phy block failure \r\n",__FUNCTION__);
+		return OMX_ErrorResourcesLost;
+	}
+
+	//release physical memory through vpu
+	ret=VPUCom_FreeMem_Wrapper(&vpuMem,pMemOp);
+	if(ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: free vpu memory failure : ret=0x%X \r\n",__FUNCTION__,ret);
+		return OMX_ErrorHardware;
+	}
+
+	//remove mem info
+	if(0==MemRemovePhyBlock(&vpuMem, pInMemInfo))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: remove phy block failure \r\n",__FUNCTION__);
+		return OMX_ErrorResourcesLost;	
+	}
+
+	//unregister memory info from resource manager
+	if(OMX_ErrorNone!=RemoveHwBuffer(pBuffer))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: remove hw buffer failure \r\n",__FUNCTION__);
+		return OMX_ErrorResourcesLost;
+	}
+			
+	return OMX_ErrorNone;
+}
+
+#ifdef MX6X
+OMX_S32 PreProcessetSetStrategy(OMX_COLOR_FORMATTYPE colorfmt,OMX_BOOL* pOutEnabled)
+{
+	OMX_BOOL bEnable=OMX_FALSE;
+	switch((int)colorfmt){
+		case OMX_COLOR_Format16bitRGB565:
+		case OMX_COLOR_Format24bitRGB888:
+		case OMX_COLOR_Format24bitBGR888:
+		//case OMX_COLOR_Format32bitARGB8888:
+		case OMX_COLOR_Format32bitBGRA8888:
+		case OMX_COLOR_Format32bitRGBA8888:
+			bEnable=OMX_TRUE;
+			VPU_ENC_COMP_LOG("enable pre-process \r\n");
+			break;
+#ifdef PRE_PROCESS_BY_PASS_TEST	//for by pipeline test
+		case OMX_COLOR_FormatYUV420Planar:
+		case OMX_COLOR_FormatYUV420SemiPlanar:
+			bEnable=OMX_TRUE;
+			VPU_ENC_COMP_LOG("pre-process by pass test: color fmt: %d \r\n",colorfmt);
+			break;
+#endif
+		default:
+			break;
+	}
+	*pOutEnabled=bEnable;
+	return 1;
+}
+OMX_S32 PreProcessIPUInit(VpuEncoderIpuHandle* pIpuHandle)
+{
+	pIpuHandle->nIpuFd=open("/dev/mxc_ipu", O_RDWR, 0);
+	if(pIpuHandle->nIpuFd<=0){
+		VPU_ENC_COMP_ERR_LOG("Open /dev/mxc_ipu failed.\n");
+		return 0;
+	}
+	fsl_osal_memset(&pIpuHandle->sIpuTask, 0, sizeof(IpuTask));
+	TIMER_INIT;
+	return 1;
+}
+OMX_S32 PreProcessIPUSetDefault(VpuEncoderIpuHandle* pIpuHandle,OMX_VIDEO_PORTDEFINITIONTYPE* pInFmt,OMX_COLOR_FORMATTYPE eOutColor)
+{
+	struct ipu_input* pIn=&pIpuHandle->sIpuTask.input;
+	struct ipu_output* pOut=&pIpuHandle->sIpuTask.output;
+	OMX_U32 outcolor=IPU_FOURCC('N', 'V', '1', '2');;
+	OMX_U32 incolor=IPU_FOURCC('R', 'G', 'B', 'A');
+	OMX_U32 width=pInFmt->nFrameWidth;
+	OMX_U32 height=pInFmt->nFrameHeight;
+
+	pIpuHandle->sIpuTask.overlay_en=0;
+	pIn->deinterlace.enable=0;
+	switch ((int)pInFmt->eColorFormat){
+		case OMX_COLOR_Format16bitRGB565:
+			incolor=IPU_FOURCC('R', 'G', 'B', 'P');
+			break;
+		case OMX_COLOR_Format24bitRGB888:
+			incolor=IPU_FOURCC('R', 'G', 'B', '3');
+			break;
+		case OMX_COLOR_Format24bitBGR888:
+			incolor=IPU_FOURCC('B', 'G', 'R', '3');
+			break;
+		case OMX_COLOR_Format32bitBGRA8888:
+			incolor=IPU_FOURCC('B', 'G', 'R', 'A');
+			break;			
+		case OMX_COLOR_Format32bitRGBA8888:
+			incolor=IPU_FOURCC('R', 'G', 'B', 'A');
+			break;
+#ifdef PRE_PROCESS_BY_PASS_TEST
+		case OMX_COLOR_FormatYUV420Planar:
+			incolor=IPU_FOURCC('I', '4', '2', '0');
+			break;
+		case OMX_COLOR_FormatYUV420SemiPlanar:
+			incolor=IPU_FOURCC('N', 'V', '1', '2');
+			break;
+#endif
+		default:
+			VPU_ENC_COMP_ERR_LOG("unsupported input color format(%d) for pre-process ! \r\n",pInFmt->eColorFormat);
+			break;
+	}
+	switch(eOutColor){
+		case OMX_COLOR_FormatYUV420Planar:
+			outcolor=IPU_FOURCC('I', '4', '2', '0');
+			VPU_ENC_COMP_LOG("Set pre-process out format to YUVI420.\n");
+			break;
+		case OMX_COLOR_FormatYUV420SemiPlanar:
+			outcolor=IPU_FOURCC('N', 'V', '1', '2');
+			VPU_ENC_COMP_LOG("Set pre-process in format to NV12.\n");
+			break;
+		default:
+			VPU_ENC_COMP_ERR_LOG("unsupported output color format(%d) for pre-process ! \r\n",eOutColor);
+			break;
+	}
+	
+	if(width%8!=0){
+		VPU_ENC_COMP_ERR_LOG("warning: width(%d) isn't aligned with 8 bytes !!! \r\n",(INT32)width);
+	}
+	pIn->width = width;
+	pIn->height = height;
+	pIn->crop.pos.x = 0;
+	pIn->crop.pos.y = 0;
+	pIn->crop.w = width;
+	pIn->crop.h = height;
+	pIn->format = incolor;
+	VPU_ENC_COMP_LOG("IpulibRender sInParam width %d, height %d,crop x %d, y %d, w %d, h %d, color %d\n",
+		pIn->width, pIn->height,pIn->crop.pos.x, pIn->crop.pos.y,pIn->crop.w, pIn->crop.h,pIn->format);
+
+	pOut->width = pIn->width;
+	pOut->height = pIn->height;
+	pOut->crop.pos.x = pIn->crop.pos.x;
+	pOut->crop.pos.y = pIn->crop.pos.y;
+	pOut->crop.w = pIn->crop.w;
+	pOut->crop.h = pIn->crop.h;
+	pOut->format = outcolor;
+	pOut->rotate = ROTATE_NONE;
+	VPU_ENC_COMP_LOG("IpulibRender sOutParam width %d, height %d,crop x %d, y %d, rot: %d, color %d\n",
+		pOut->crop.w, pOut->crop.h ,pOut->crop.pos.x, pOut->crop.pos.y,pOut->rotate, pOut->format);
+	return 1;
+}
+OMX_S32 PreProcessIPUTask(VpuEncoderIpuHandle* pIpuHandle,OMX_PTR pInPhy, OMX_PTR pOutPhy)
+{
+	OMX_S32 ret=0;
+	pIpuHandle->sIpuTask.input.paddr=(int)pInPhy;	
+	pIpuHandle->sIpuTask.output.paddr=(int)pOutPhy;
+
+	ret = IPU_CHECK_ERR_INPUT_CROP;
+	while(ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN) {
+		ret = ioctl(pIpuHandle->nIpuFd, IPU_CHECK_TASK, &pIpuHandle->sIpuTask);
+		switch(ret) {
+			case IPU_CHECK_OK:
+				break;
+			case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
+				pIpuHandle->sIpuTask.input.crop.w -= 8;
+				break;
+			case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
+				pIpuHandle->sIpuTask.input.crop.h -= 8;
+				break;
+			case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
+				pIpuHandle->sIpuTask.output.crop.w -= 8;
+				break;
+			case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
+				pIpuHandle->sIpuTask.output.crop.h -= 8;
+				break;
+			default:
+				return 0;
+		}
+	}
+	
+	ret = ioctl(pIpuHandle->nIpuFd, IPU_QUEUE_TASK, &pIpuHandle->sIpuTask);
+	if (ret < 0){
+		VPU_ENC_COMP_ERR_LOG("ioct IPU_QUEUE_TASK fail\n");
+		return 0;
+	}
+	return 1;
+}
+OMX_S32 PreProcessIPUDeinit(VpuEncoderIpuHandle* pIpuHandle)
+{
+	if(pIpuHandle->nIpuFd>0){
+		close(pIpuHandle->nIpuFd);
+		pIpuHandle->nIpuFd=0;
+	}
+	TIMER_REPORT;
+	return 1;
+}
+
+#else
+OMX_S32 PreProcessetSetStrategy(OMX_COLOR_FORMATTYPE fmt,OMX_BOOL* pOutEnabled)
+{
+	VPU_ENC_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	*pOutEnabled=OMX_FALSE;
+	return 1;
+}
+OMX_S32 PreProcessIPUInit(VpuEncoderIpuHandle* pIpuHandle)
+{
+	VPU_ENC_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	return 1;
+}
+OMX_S32 PreProcessIPUSetDefault(VpuEncoderIpuHandle* pIpuHandle,OMX_VIDEO_PORTDEFINITIONTYPE* pInFmt,OMX_COLOR_FORMATTYPE eOutColor)
+{
+	VPU_ENC_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	return 1;
+}
+OMX_S32 PreProcessIPUTask(VpuEncoderIpuHandle* pIpuHandle,OMX_PTR pInPhy, OMX_PTR pOutPhy)
+{
+	VPU_ENC_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);	
+	return 1;
+}
+OMX_S32 PreProcessIPUDeinit(VpuEncoderIpuHandle* pIpuHandle)
+{
+	VPU_ENC_COMP_LOG("%s: not implemented \r\n",__FUNCTION__);
+	return 1;
+}
+#endif
+
+OMX_S32 PreFrameSet(VpuEncoderPreProcessMemInfo* pPreMem,OMX_U32 nPhy,OMX_U32 nVir,OMX_U32 nSize,OMX_U32 nFlag, OMX_S32* pIndex)
+{
+	OMX_S32 i;
+	for(i=0;i<=VPU_ENC_MAX_NUM_MEM;i++){
+		if(pPreMem->phyAddr[i]==NULL){
+			pPreMem->phyAddr[i]=nPhy;
+			pPreMem->virtAddr[i]=nVir;
+			pPreMem->size[i]=nSize;
+			pPreMem->flag[i]=nFlag;
+			*pIndex=i;
+			break;
+		}
+	}
+	if(i==VPU_ENC_MAX_NUM_MEM){
+		VPU_ENC_COMP_ERR_LOG("frame buffer is full ! \n");
+		*pIndex=-1;
+		return 0;
+	}
+	return 1;
+}
+
+OMX_S32 PreFrameClear(VpuEncoderPreProcessMemInfo* pPreMem,OMX_U32 nIndex)
+{
+	pPreMem->phyAddr[nIndex]=NULL;
+	pPreMem->virtAddr[nIndex]=NULL;
+	pPreMem->size[nIndex]=0;
+	pPreMem->flag[nIndex]=0;
+	return 1;
+}
+
+OMX_S32 PreFrameGetNode(VpuEncoderPreProcessMemInfo* pPreMem,OMX_U32 nIndex,OMX_U32* pPhy, OMX_U32* pVirt,OMX_S32* pSize,OMX_U32* pFlag)
+{
+	*pPhy=pPreMem->phyAddr[nIndex];
+	*pVirt=pPreMem->virtAddr[nIndex];
+	*pSize=(OMX_S32)pPreMem->size[nIndex];
+	*pFlag=pPreMem->flag[nIndex];
+	return 1;
+}
+
+OMX_U32 PreFrameGetVirt(VpuEncoderPreProcessMemInfo* pPreMem,OMX_U32 nIndex)
+{
+	return pPreMem->virtAddr[nIndex];
+}
+
+OMX_S32 PreFrameValid(VpuEncoderPreProcessMemInfo* pPreMem,OMX_U32 nIndex)
+{
+	if(pPreMem->phyAddr[nIndex]==NULL){
+		return 0;
+	}
+	else{
+		return 1;
+	}
+}
+
+OMX_S32 PreCreateOutFrame(VpuEncoderMemInfo* pMem,OMX_PARAM_MEM_OPERATOR* pMemOp,
+  VpuEncoderPreProcessMemInfo* pPreMem,Queue*pQueue,OMX_S32 nSize,OMX_S32 nNum)
+{
+	OMX_S32 index;
+	OMX_PTR pVirt;
+	OMX_PTR pPhy;
+	OMX_S32 i;
+	for (i=0;i<nNum;i++){
+		pVirt=AllocateBuffer(nSize, pMem, pMemOp);
+		if(pVirt==NULL){
+			VPU_ENC_COMP_ERR_LOG("allocate buffer(%d) failure ! \r\n",nSize);
+		}
+		GetHwBuffer(pVirt, &pPhy);
+		PreFrameSet(pPreMem, (OMX_U32)pPhy, (OMX_U32)pVirt, (OMX_U32)nSize, 0, &index);
+		pQueue->Add(&index);
+	}
+	return 1;
+}
+
+OMX_S32 PreTransferQueue(Queue* pFromQueue,Queue* pToQueue,VpuEncoderPreProcessMemInfo* pPreMem)
+{
+	//get all buffer from pFromQueue and re-filled into pToQueue
+	OMX_S32 index;
+	OMX_S32 nCnt=0;
+	while(pFromQueue->Size()>0){		
+		pFromQueue->Get(&index);
+		if(PreFrameValid(pPreMem,index)){
+			pToQueue->Add(&index);
+			nCnt++;
+		}
+	}
+	return nCnt;
+}
+
+OMX_S32 PreWaitState(volatile PreProcessState * pState,PreProcessState eTargetState, fsl_osal_sem pSem)
+{
+	//encoder thread wait pre thread complete command
+	fsl_osal_sem_wait(pSem);
+	while(*pState!=eTargetState)
+	{
+		VPU_ENC_COMP_ERR_LOG("incorrect state: %d !!!, expected state: %d \r\n", *pState,eTargetState);
+	}
+	return 1;
+}
+
+OMX_S32 PreWakeUp(fsl_osal_mutex pMutex, pthread_cond_t* pCond, volatile OMX_BOOL * pWaiting)
+{
+	//encode thread notify pre thread some tasks are received
+	fsl_osal_mutex_lock(pMutex);
+	if(*pWaiting==OMX_TRUE)
+	{
+		VPU_ENC_COMP_PRE_LOG("%s: send tasks to pre thread \r\n",__FUNCTION__);
+		pthread_cond_signal(pCond);
+	}
+	else
+	{
+		VPU_ENC_COMP_PRE_LOG("%s: pre thread is already in work state, needn't wakeup it \r\n",__FUNCTION__);
+	}
+	fsl_osal_mutex_unlock(pMutex);
+	return 1;
+}
+
+
+void *PreThread(void *arg) 
+{
+	/*
+	for invalid eos: (in such case, buffer is invalid)
+		pPreInQueue: 	   	index>=0, phy=virt=size=0;
+		pPreInReturnQueue:	index>=0, phy=virt=size=0;
+		pPreOutQueue:		index>=0, phy=virt=valid, size=0
+		pPreOutReturnQueue:	index>=0, phy=virt=valid, size=0
+	*/
+#define PRE_THREAD_WAITTIMEOUT_US	(100000)
+	VpuEncoder *base = (VpuEncoder*)arg;
+	volatile PreProcessCmd * pCmd=&base->ePreCmd;
+	volatile PreProcessState* pState=&base->ePreState;
+	volatile OMX_BOOL* pPreWaitingTasks =&base->bPreWaitingTasks;
+	fsl_osal_sem pSem=base->pPreCmdSem;
+	VpuEncoderPreProcessMemInfo * pPreInMem=&base->sEncPreProcessInFrameInfo;
+	VpuEncoderPreProcessMemInfo * pPreOutMem=&base->sEncPreProcessOutFrameInfo;
+	VPU_ENC_COMP_PRE_LOG("%s: Pre Thread starting.\n",__FUNCTION__);
+
+	//set waiting firstly when pre thread is actived.
+	*pPreWaitingTasks=OMX_TRUE;
+	//main loop
+	while(1){
+		OMX_S32 nPreInIndex,nPreOutIndex;
+		OMX_U32 nFlag;
+		struct timespec to;
+		struct timeval from;
+		OMX_S32 ret=0;
+		//wait encode thread send tasks(commands,data,...)
+		fsl_osal_mutex_lock(base->pPreMutex);
+		while(1){
+			if(*pCmd!=PRE_PROCESS_CMD_NONE){
+				break;
+			}
+			if((base->pPreInQueue->Size()>0) && (base->pPreOutReturnQueue->Size()>0)){
+				break;
+			}
+			VPU_ENC_COMP_PRE_LOG("%s: will wait tasks from encoder thread \r\n",__FUNCTION__);
+#if 0		//debug: using sleep method instead of wait 
+			#define PRE_THREAD_SLEEP_US (1000)
+			fsl_osal_mutex_unlock(base->pPreMutex);
+			fsl_osal_sleep(PRE_THREAD_SLEEP_US);
+			fsl_osal_mutex_lock(base->pPreMutex);
+#else
+			*pPreWaitingTasks=OMX_TRUE; //no any tasks, begin waiting
+			/*
+			gettimeofday(&from, NULL);
+			to.tv_sec=from.tv_sec;
+			to.tv_nsec=from.tv_usec * 1000;
+			to.tv_nsec+=(PRE_THREAD_WAITTIMEOUT_US)*1000;
+			//here, we use timeout wait to avoid deadlock as possible
+			ret=pthread_cond_timedwait(&base->sPreCond, (pthread_mutex_t *)(base->pPreMutex), &to);
+			*/
+			ret=pthread_cond_wait(&base->sPreCond, (pthread_mutex_t *)base->pPreMutex);
+			if(0!=ret) {
+				VPU_ENC_COMP_PRE_LOG("return from pthread_cond_*wait : %d \r\n",ret);
+			}
+#endif
+		}
+		if(ret!=0){//if(ret==ETIMEDOUT){
+			//in theory, if the sync logic is correct, shouldn't enter here
+			VPU_ENC_COMP_ERR_LOG("warning: the pre thread isn't actived immediately ! error: %d \r\n",ret);
+		}
+		VPU_ENC_COMP_PRE_LOG("%s: ready to work \r\n",__FUNCTION__);
+		*pPreWaitingTasks=OMX_FALSE;  //clear waiting
+		fsl_osal_mutex_unlock(base->pPreMutex);
+
+		//process command
+		if(*pCmd!=PRE_PROCESS_CMD_NONE){
+			switch(*pCmd){
+				case PRE_PROCESS_CMD_RUN:
+					*pState=PRE_PROCESS_STATE_RUN;
+					break;
+				case PRE_PROCESS_CMD_STOP:
+					*pState=PRE_PROCESS_STATE_IDLE;
+					break;
+				case PRE_PROCESS_CMD_FLUSH_OUT:
+					//get all buffers from pPreOutReturnQueue(except invalid eos), and fill into pPreOutQueue directly
+					PreTransferQueue(base->pPreOutReturnQueue, base->pPreOutQueue,pPreInMem);
+					break;
+				case PRE_PROCESS_CMD_FLUSH_IN:
+					//get all buffers from pPreInQueue(except invalid eos) and insert them into pPreInReturnQueue
+					PreTransferQueue(base->pPreInQueue, base->pPreInReturnQueue,pPreInMem);
+					break;
+				default:
+					VPU_ENC_COMP_PRE_LOG("unknow command: %d, ignore it \r\n",*pCmd);
+					break;
+			}
+			VPU_ENC_COMP_PRE_LOG("%s: command(%d) finished, will notify encoder thread \r\n",__FUNCTION__,*pCmd);
+			//clear command
+			*pCmd=PRE_PROCESS_CMD_NONE;
+			//notify host command finished
+			fsl_osal_sem_post(pSem);
+		}
+
+		//check state
+		if((*pState)==PRE_PROCESS_STATE_IDLE){
+			break; //exit main loop
+		}
+		else if((*pState)!=PRE_PROCESS_STATE_RUN){
+			continue;
+		}
+
+		//check whether data is enough to do pre-process
+		if((base->pPreInQueue->Size()<=0) || ((base->pPreOutReturnQueue->Size()<=0))){
+			continue;
+		}
+
+		base->pPreInQueue->Get(&nPreInIndex);
+		base->pPreOutReturnQueue->Get(&nPreOutIndex);
+
+		//check flag and other parameters
+		nFlag=pPreInMem->flag[nPreInIndex];
+		if((pPreInMem->phyAddr[nPreInIndex]==NULL)&&(nFlag!=PRE_FLAG_EOS)){
+			VPU_ENC_COMP_ERR_LOG("find one invalid input buffer \n");
+			continue;
+		}
+
+		if((pPreInMem->phyAddr[nPreInIndex]==NULL)&&(nFlag==PRE_FLAG_EOS)){
+			//invalid eos: skip pre-process
+			pPreOutMem->size[nPreOutIndex]=0;
+		}
+		else{
+			//pre-process
+#if 0		//debug: copy directly
+			{
+				OMX_S32 nOutSize;
+				nOutSize=base->sInFmt.nFrameWidth * base->sInFmt.nFrameHeight*pxlfmt2bpp(base->sInFmt.eColorFormat)/8;
+				fsl_osal_memcpy((OMX_PTR)pPreOutMem->virtAddr[nPreOutIndex],(OMX_PTR)pPreInMem->virtAddr[nPreInIndex], nOutSize);
+			}
+#else			
+			TIMER_START;
+			PreProcessIPUTask(&base->sIpuHandle,(OMX_PTR)pPreInMem->phyAddr[nPreInIndex],(OMX_PTR)pPreOutMem->phyAddr[nPreOutIndex]);
+			TIMER_STOP;
+#endif
+		}
+		VPU_ENC_COMP_PRE_LOG("%s: output index: %d, input Indx: %d, flag: %d \r\n",__FUNCTION__,nPreOutIndex,nPreInIndex,nFlag);
+		base->pPreInReturnQueue->Add(&nPreInIndex);
+		pPreOutMem->flag[nPreOutIndex]=nFlag;
+		base->pPreOutQueue->Add(&nPreOutIndex);
+	}
+	VPU_ENC_COMP_PRE_LOG("%s: Pre Thread Stopped.\n",__FUNCTION__);
+	return NULL;
+}
+
+VpuEncoder::VpuEncoder()
+{
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	// version info
+	ComponentVersion.s.nVersionMajor = 0x0;
+	ComponentVersion.s.nVersionMinor = 0x1;
+	ComponentVersion.s.nRevision = 0x0;
+	ComponentVersion.s.nStep = 0x0;
+	
+	//set default
+	fsl_osal_strcpy((fsl_osal_char*)name, "OMX.Freescale.std.video_encoder.mpeg4.hw-based");
+
+	fsl_osal_memset(&sInFmt, 0, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+	sInFmt.nFrameWidth = DEFAULT_ENC_FRM_WIDTH;
+	sInFmt.nFrameHeight = DEFAULT_ENC_FRM_HEIGHT;
+	sInFmt.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+	sInFmt.xFramerate = DEFAULT_ENC_FRM_RATE;
+	sInFmt.eCompressionFormat = OMX_VIDEO_CodingUnused;
+
+	nInPortFormatCnt = 3;
+	eInPortPormat[0] = OMX_COLOR_FormatYUV420Planar;
+	eInPortPormat[1] = OMX_COLOR_FormatYUV420SemiPlanar;
+	eInPortPormat[2] = (OMX_COLOR_FORMATTYPE)OMX_COLOR_FormatAndroidOpaque;
+	nOutPortFormatCnt = 0;
+
+	fsl_osal_memset(&sOutFmt, 0, sizeof(OMX_VIDEO_PORTDEFINITIONTYPE));
+	sOutFmt.nFrameWidth = DEFAULT_ENC_FRM_WIDTH;
+	sOutFmt.nFrameHeight = DEFAULT_ENC_FRM_HEIGHT;
+	sOutFmt.xFramerate = DEFAULT_ENC_FRM_RATE;
+	sOutFmt.nBitrate=DEFAULT_ENC_FRM_BITRATE;
+#if 0 //1 eagle : for component unit test
+	sOutFmt.eColorFormat = OMX_COLOR_FormatRawBayer8bitcompressed;
+#else
+	sOutFmt.eColorFormat = OMX_COLOR_FormatUnused;
+#endif
+	sOutFmt.eCompressionFormat = OMX_VIDEO_CodingMPEG4;
+
+	bFilterSupportPartilInput =OMX_TRUE;
+	nInBufferCnt = DEFAULT_ENC_BUF_IN_CNT;
+	nInBufferSize = DEFAULT_ENC_BUF_IN_SIZE;
+	nOutBufferCnt = DEFAULT_ENC_BUF_OUT_CNT;
+	nOutBufferSize = DEFAULT_ENC_BUF_OUT_SIZE;
+
+	//clear internal variable 0
+	fsl_osal_memset(&sEncInitInfo,0,sizeof(VpuEncInitInfo));	
+	fsl_osal_memset(&sVpuEncMemInfo,0,sizeof(VpuEncoderMemInfo));
+	fsl_osal_memset(&sEncAllocInMemInfo,0,sizeof(VpuEncoderMemInfo));		
+	fsl_osal_memset(&sEncAllocOutMemInfo,0,sizeof(VpuEncoderMemInfo));
+	fsl_osal_memset(&sEncPreProcessInFrameInfo,0,sizeof(VpuEncoderPreProcessMemInfo));
+	fsl_osal_memset(&sEncPreProcessOutFrameInfo,0,sizeof(VpuEncoderPreProcessMemInfo));
+	fsl_osal_memset(&sEncOutFrameInfo,0,sizeof(VpuEncoderMemInfo));	
+	fsl_osal_memset(&sMemOperator,0,sizeof(OMX_PARAM_MEM_OPERATOR));
+	fsl_osal_memset(&sVpuEncInputPara,0,sizeof(VpuEncInputParam));	
+	
+	nHandle=0;
+
+	//eFormat = VPU_V_MPEG4;
+	//nPadWidth=DEFAULT_ENC_FRM_WIDTH;
+	//nPadHeight=DEFAULT_ENC_FRM_HEIGHT;
+
+	pInBufferPhy=NULL;
+	pInBufferVirt=NULL;
+	nInSize=0;
+	bInEos=OMX_FALSE;
+	pOutBufferPhy=NULL;
+	nOutSize=0;
+	nOutGOPFrameCnt=1;
+    bStoreMetaData = OMX_FALSE;
+
+	bEnabledPreProcess=OMX_FALSE;
+	pPreThreadId=NULL;
+	pPreInQueue=NULL;
+	pPreOutQueue=NULL;
+	pPreInReturnQueue=NULL;
+	pPreOutReturnQueue=NULL;
+	pPreCmdSem=NULL;
+	pPreMutex=NULL;
+	pPreReturnedInput=NULL;
+	nPreOutIndex=-1;
+	bPreEos=OMX_FALSE;
+	eVpuEncoderState=VPU_ENC_COM_STATE_NONE;
+
+	SetDefaultEncParam(&sVpuEncInputPara);
+
+	return;
+}
+OMX_ERRORTYPE VpuEncoder::SetRoleFormat(OMX_STRING role)
+{
+	OMX_VIDEO_CODINGTYPE CodingType;
+	
+	VPU_ENC_COMP_API_LOG("%s: role: %s \r\n",__FUNCTION__,role);
+
+	if(fsl_osal_strcmp(role, "video_encoder.mpeg4") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingMPEG4;
+		sVpuEncInputPara.eFormat=VPU_V_MPEG4;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_ENC_COMP_NAME_MPEG4ENC);
+	}
+	else if(fsl_osal_strcmp(role, "video_encoder.avc") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingAVC;
+		sVpuEncInputPara.eFormat=VPU_V_AVC;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_ENC_COMP_NAME_AVCENC);
+	}
+	else if(fsl_osal_strcmp(role, "video_encoder.h263") == 0)
+	{
+		CodingType = OMX_VIDEO_CodingH263;
+		sVpuEncInputPara.eFormat=VPU_V_H263;
+		fsl_osal_strcpy((fsl_osal_char*)name, VPU_ENC_COMP_NAME_H263ENC);
+	}
+	else
+	{
+		CodingType = OMX_VIDEO_CodingUnused;		
+		//eFormat=;
+		VPU_ENC_COMP_ERR_LOG("%s: failure: unknow role: %s \r\n",__FUNCTION__,role);
+		return OMX_ErrorUndefined;
+	}
+
+	//check output format change
+	if(sOutFmt.eCompressionFormat!=CodingType)
+	{
+		sOutFmt.eCompressionFormat=CodingType;
+		OutputFmtChanged();
+		//FmtChanged(OUT_PORT,&sOutFmt);
+	}
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure)
+{
+	VPU_ENC_COMP_API_LOG("%s: nParamIndex=0x%X, \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		default:
+			break;
+	}
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: param is null \r\n",__FUNCTION__);	
+		return OMX_ErrorBadParameter;
+	}
+	
+	if(nParamIndex==OMX_IndexParamStandardComponentRole)
+	{
+		fsl_osal_strcpy((OMX_STRING)((OMX_PARAM_COMPONENTROLETYPE*)pComponentParameterStructure)->cRole,(OMX_STRING)cRole);
+		return OMX_ErrorNone;
+	}
+	else if (nParamIndex==OMX_IndexParamVideoBitrate)
+	{
+		OMX_VIDEO_PARAM_BITRATETYPE * pPara;
+		pPara=(OMX_VIDEO_PARAM_BITRATETYPE *)pComponentParameterStructure;
+		ASSERT(pPara->nPortIndex==IN_PORT);
+		//get bit rate 
+		if(0==sVpuEncInputPara.nBitRate)
+		{
+			//in this mode the encoder will ignore nTargetBitrate setting 
+			//and use the appropriate Qp (nQpI, nQpP, nQpB) values for encoding
+			pPara->eControlRate=OMX_Video_ControlRateDisable;
+			pPara->nTargetBitrate=0;
+		}
+		else
+		{
+			pPara->eControlRate=OMX_Video_ControlRateConstant;
+			pPara->nTargetBitrate=sVpuEncInputPara.nBitRate;			
+		}
+	}	
+	else if (nParamIndex==OMX_IndexParamVideoMpeg4)
+	{
+		OMX_VIDEO_PARAM_MPEG4TYPE* pPara;
+		pPara=(OMX_VIDEO_PARAM_MPEG4TYPE *)pComponentParameterStructure;
+		pPara->eProfile=OMX_VIDEO_MPEG4ProfileSimple;
+		pPara->eLevel=OMX_VIDEO_MPEG4Level0;
+		pPara->nPFrames=sVpuEncInputPara.nGOPSize-1;
+		pPara->nBFrames=0;
+		//...		
+	}
+	else if (nParamIndex==OMX_IndexParamVideoAvc)
+	{
+		OMX_VIDEO_PARAM_AVCTYPE* pPara;
+		pPara=(OMX_VIDEO_PARAM_AVCTYPE *)pComponentParameterStructure;
+		pPara->eProfile=OMX_VIDEO_AVCProfileBaseline;
+		pPara->eLevel=OMX_VIDEO_AVCLevel1;
+		pPara->nPFrames=sVpuEncInputPara.nGOPSize-1;
+		pPara->nBFrames=0;
+		//...
+	}
+	else if (nParamIndex==OMX_IndexParamVideoH263)
+	{
+		OMX_VIDEO_PARAM_H263TYPE* pPara;
+		pPara=(OMX_VIDEO_PARAM_H263TYPE *)pComponentParameterStructure;
+		pPara->eProfile=OMX_VIDEO_H263ProfileBaseline;
+		pPara->eLevel=OMX_VIDEO_H263Level10;
+		pPara->nPFrames=sVpuEncInputPara.nGOPSize-1;
+		pPara->nBFrames=0;
+		//...	
+	}	
+       else if(nParamIndex ==  OMX_IndexParamVideoProfileLevelQuerySupported)
+       { 
+               struct CodecProfileLevel {
+                       OMX_U32 mProfile;
+                       OMX_U32 mLevel;
+               };
+
+               static const CodecProfileLevel kH263ProfileLevels[] = {
+                       { OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level10 },
+                       { OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level20 },
+                       { OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level30 },
+                       { OMX_VIDEO_H263ProfileBaseline, OMX_VIDEO_H263Level45 },
+                       { OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level10 },
+                       { OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level20 },
+                       { OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level30 },
+                       { OMX_VIDEO_H263ProfileISWV2,    OMX_VIDEO_H263Level45 },
+               };
+
+               static const CodecProfileLevel kProfileLevels[] = {
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel1  },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel1b },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel11 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel12 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel13 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel2  },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel21 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel22 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel3  },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel31 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel32 },
+                       { OMX_VIDEO_AVCProfileBaseline, OMX_VIDEO_AVCLevel4  },
+                       /* For vpu encoder, the maxium bitrate set by driver is 32Mbps */
+               };
+                               
+               static const CodecProfileLevel kM4VProfileLevels[] = {
+                       { OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level0 },
+                       { OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level0b },
+                       { OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level1 },
+                       { OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level2 },
+                       { OMX_VIDEO_MPEG4ProfileSimple, OMX_VIDEO_MPEG4Level3 },
+               };
+
+               OMX_VIDEO_PARAM_PROFILELEVELTYPE  *pPara; 
+               OMX_S32 index;
+               OMX_S32 nProfileLevels;
+
+               pPara = (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)pComponentParameterStructure; 
+               switch(sVpuEncInputPara.eFormat)
+               { 
+                       case VPU_V_H263: 
+                               index = pPara->nProfileIndex;
+
+                               nProfileLevels =
+                                       sizeof(kH263ProfileLevels) / sizeof(kH263ProfileLevels[0]);
+                               if (index >= nProfileLevels) {
+                                       return OMX_ErrorNoMore;
+                               }
+
+                               pPara->eProfile = kH263ProfileLevels[index].mProfile;
+                               pPara->eLevel = kH263ProfileLevels[index].mLevel;
+                               break; 
+                       case VPU_V_AVC: 
+                               index = pPara->nProfileIndex;
+
+                               nProfileLevels =
+                                       sizeof(kProfileLevels) / sizeof(kProfileLevels[0]);
+                               if (index >= nProfileLevels) {
+                                       return OMX_ErrorNoMore;
+                               }
+
+                               pPara->eProfile = kProfileLevels[index].mProfile;
+                               pPara->eLevel = kProfileLevels[index].mLevel;
+                               break; 
+                       case VPU_V_MPEG4: 
+                               index = pPara->nProfileIndex;
+
+                               nProfileLevels =
+                                       sizeof(kM4VProfileLevels) / sizeof(kM4VProfileLevels[0]);
+                               if (index >= nProfileLevels) {
+                                       return OMX_ErrorNoMore;
+                               }
+
+                               pPara->eProfile = kM4VProfileLevels[index].mProfile;
+                               pPara->eLevel = kM4VProfileLevels[index].mLevel;
+                               break; 
+                       default:
+                               break;
+               }
+               return OMX_ErrorNone;
+       }       
+	else
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);	
+		return OMX_ErrorUnsupportedIndex;
+	}	
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	VPU_ENC_COMP_API_LOG("%s: nParamIndex=0x%X \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_LOADED:
+			break;
+		default:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d, nParamIndex=0x%X, role=%s \r\n",__FUNCTION__,eVpuEncoderState,nParamIndex,(OMX_STRING)cRole);
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: param is null \r\n",__FUNCTION__);
+		return OMX_ErrorBadParameter;
+	}
+
+	if(nParamIndex==OMX_IndexParamStandardComponentRole)
+	{
+		fsl_osal_strcpy( (fsl_osal_char *)cRole,(fsl_osal_char *)((OMX_PARAM_COMPONENTROLETYPE*)pComponentParameterStructure)->cRole);
+		if(OMX_ErrorNone!=SetRoleFormat((OMX_STRING)cRole))
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: set role format failure \r\n",__FUNCTION__);
+			return OMX_ErrorBadParameter;
+		}
+	}
+	else if (nParamIndex==OMX_IndexParamMemOperator)
+	{
+		//should be set before open vpu(eg. malloc bitstream/frame buffers)
+		if(VPU_ENC_COM_STATE_LOADED!=eVpuEncoderState)
+		{
+			ret=OMX_ErrorInvalidState;
+		}		
+		else
+		{
+			OMX_PARAM_MEM_OPERATOR * pPara;
+			pPara=(OMX_PARAM_MEM_OPERATOR *)pComponentParameterStructure;
+			VPU_ENC_COMP_LOG("%s: set OMX_IndexParamMemOperator \r\n",__FUNCTION__);
+			sMemOperator=*pPara;
+		}
+	}
+    else if (nParamIndex == OMX_IndexParamStoreMetaDataInBuffers)
+    {
+        OMX_CONFIG_BOOLEANTYPE *pParams = (OMX_CONFIG_BOOLEANTYPE*)pComponentParameterStructure;
+        bStoreMetaData = pParams->bEnabled;
+    }
+#if 1 //TODO : add related setting, including resolution/framerate/bitrate/... ???
+ 	else if (nParamIndex==OMX_IndexParamVideoPortFormat)
+	{
+			OMX_VIDEO_PARAM_PORTFORMATTYPE * pPara;
+			pPara=(OMX_VIDEO_PARAM_PORTFORMATTYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);	
+			//set port
+			if((sInFmt.eCompressionFormat!=pPara->eCompressionFormat)
+				||(sInFmt.eColorFormat!=pPara->eColorFormat))
+			{
+				sInFmt.eCompressionFormat=pPara->eCompressionFormat; 
+				sInFmt.eColorFormat=pPara->eColorFormat;
+				sVpuEncInputPara.nFrameRate=pPara->xFramerate/Q16_SHIFT;
+				//FmtChanged(IN_PORT, &sInFmt);
+				InputFmtChanged();
+			}		
+	}
+	else if (nParamIndex==OMX_IndexParamVideoAvc)
+	{
+			OMX_VIDEO_PARAM_AVCTYPE * pPara;
+			pPara=(OMX_VIDEO_PARAM_AVCTYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);	
+			//set AVC GOP size
+			sVpuEncInputPara.nGOPSize=pPara->nPFrames+pPara->nBFrames+1;
+	}
+	else if (nParamIndex==OMX_IndexParamVideoH263)
+	{
+			OMX_VIDEO_PARAM_H263TYPE * pPara;
+			pPara=(OMX_VIDEO_PARAM_H263TYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);	
+			//set H263 GOP size
+			sVpuEncInputPara.nGOPSize=pPara->nPFrames+pPara->nBFrames+1;
+	}
+	else if (nParamIndex==OMX_IndexParamVideoMpeg4)
+	{
+			OMX_VIDEO_PARAM_MPEG4TYPE * pPara;
+			pPara=(OMX_VIDEO_PARAM_MPEG4TYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);	
+			//set MPEG4 GOP size
+			sVpuEncInputPara.nGOPSize=pPara->nPFrames+pPara->nBFrames+1;
+	}
+	else if(nParamIndex==OMX_IndexParamCommonSensorMode)
+	{
+			OMX_PARAM_SENSORMODETYPE * pPara;
+			pPara=(OMX_PARAM_SENSORMODETYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			ASSERT(pPara->sFrameSize.nPortIndex==IN_PORT);
+			ASSERT(pPara->bOneShot==1);
+			//set frame rate
+			if(0!=pPara->nFrameRate)
+			{
+				sVpuEncInputPara.nFrameRate=pPara->nFrameRate/Q16_SHIFT;
+			}
+			//set input width/height
+			sVpuEncInputPara.nPicWidth=pPara->sFrameSize.nWidth;
+			sVpuEncInputPara.nPicHeight=pPara->sFrameSize.nHeight;
+			sVpuEncInputPara.nWidthStride=pPara->sFrameSize.nWidth;
+			sVpuEncInputPara.nHeightStride=pPara->sFrameSize.nHeight;
+			//need not call buffer change since user always allocate the buffer with correct size 
+			//BufferChanged(IN_PORT, &sInFmt, nInBufferCnt);
+	}		
+	else if (nParamIndex==OMX_IndexParamVideoIntraRefresh)
+	{
+			OMX_VIDEO_PARAM_INTRAREFRESHTYPE * pPara;
+			pPara=(OMX_VIDEO_PARAM_INTRAREFRESHTYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			VPU_ENC_COMP_LOG("%s: eRefreshMode: %d, nAirMBs: %d, nAirRef: %d, nCirMBs: %d \r\n",__FUNCTION__,pPara->eRefreshMode,pPara->nAirMBs,pPara->nAirRef,pPara->nCirMBs);
+			switch(pPara->eRefreshMode){
+				case OMX_VIDEO_IntraRefreshCyclic: /*it is used by wifi display*/
+					//in fact, vpu don't support this mode, we just map it to normal mode
+					sVpuEncInputPara.nIntraFreshNum=pPara->nCirMBs;
+					break;
+				case OMX_VIDEO_IntraRefreshAdaptive:
+					sVpuEncInputPara.nIntraFreshNum=pPara->nAirMBs;
+					break;
+				case OMX_VIDEO_IntraRefreshBoth:
+				case OMX_VIDEO_IntraRefreshMax:
+				default:
+					//do nothing, ignore it
+					VPU_ENC_COMP_ERR_LOG("unsupport refresh mode: %d \r\n",pPara->eRefreshMode);
+					break;
+			}
+	}
+	else if (nParamIndex==OMX_IndexParamUseAndroidPrependSPSPPStoIDRFrames){
+		OMX_PARAM_PREPEND_SPSPPS_TO_IDR * pPara;
+		pPara=(OMX_PARAM_PREPEND_SPSPPS_TO_IDR*)pComponentParameterStructure;
+		ASSERT(pPara->nPortIndex==IN_PORT);
+		VPU_ENC_COMP_LOG("%s: bEnableSPSToIDR: %d \r\n",__FUNCTION__,pPara->bEnableSPSToIDR);
+		sVpuEncInputPara.bEnabledSPSIDR=pPara->bEnableSPSToIDR;
+	}
+	else if (nParamIndex==OMX_IndexParamVideoBitrate)
+	{
+			OMX_VIDEO_PARAM_BITRATETYPE * pPara;
+			pPara=(OMX_VIDEO_PARAM_BITRATETYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			//set bit rate 
+			switch (pPara->eControlRate)
+			{
+				case OMX_Video_ControlRateDisable:
+					//in this mode the encoder will ignore nTargetBitrate setting 
+					//and use the appropriate Qp (nQpI, nQpP, nQpB) values for encoding
+					break;
+				case OMX_Video_ControlRateVariable:
+					sVpuEncInputPara.nBitRate=pPara->nTargetBitrate;
+					//Variable bit rate
+					break;
+				case OMX_Video_ControlRateConstant:
+					//the encoder can modify the Qp values to meet the nTargetBitrate target
+					sVpuEncInputPara.nBitRate=pPara->nTargetBitrate;
+					break;
+				case OMX_Video_ControlRateVariableSkipFrames:
+					//Variable bit rate with frame skipping
+					sVpuEncInputPara.nEnableAutoSkip=1;
+					break;
+				case OMX_Video_ControlRateConstantSkipFrames:
+					//Constant bit rate with frame skipping
+					//the encoder cannot modify the Qp values to meet the nTargetBitrate target. 
+					//Instead, the encoder can drop frames to achieve nTargetBitrate
+					sVpuEncInputPara.nEnableAutoSkip=1;
+					break;
+				case OMX_Video_ControlRateMax:
+					//Maximum value
+					if(sVpuEncInputPara.nBitRate>(OMX_S32)pPara->nTargetBitrate)
+					{
+						sVpuEncInputPara.nBitRate=pPara->nTargetBitrate;
+					}
+					break;
+				default:
+					//unknown
+					ret = OMX_ErrorUnsupportedIndex;
+					break;
+			}
+
+	}
+#endif
+	else
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);	
+		ret = OMX_ErrorUnsupportedIndex;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE VpuEncoder::GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure)
+{
+	VPU_ENC_COMP_API_LOG("%s: nParamIndex=0x%X, \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+		//case VPU_ENC_COM_STATE_LOADED:
+		//case VPU_ENC_COM_STATE_OPENED:	//allow user get wrong value before opened ???
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: param is null  \r\n",__FUNCTION__);			
+		return OMX_ErrorBadParameter;
+	}
+/*
+	if(nParamIndex == OMX_IndexConfigCommonOutputCrop) 
+	{
+		OMX_CONFIG_RECTTYPE *pRecConf = (OMX_CONFIG_RECTTYPE*)pComponentParameterStructure;
+		if(pRecConf->nPortIndex == VPUDEC_OUT_PORT)
+		{
+			pRecConf->nTop = sOutCrop.nTop;
+			pRecConf->nLeft = sOutCrop.nLeft;
+			pRecConf->nWidth = sOutCrop.nWidth;
+			pRecConf->nHeight = sOutCrop.nHeight;
+			VPU_ENC_COMP_LOG("%s: [top,left,width,height]=[%d,%d,%d,%d], \r\n",__FUNCTION__,(INT32)pRecConf->nTop,(INT32)pRecConf->nLeft,(INT32)pRecConf->nWidth,(INT32)pRecConf->nHeight);
+		}
+		return OMX_ErrorNone;
+	}
+	if (nParamIndex == OMX_IndexConfigCommonScale)
+	{
+		OMX_CONFIG_SCALEFACTORTYPE *pDispRatio = (OMX_CONFIG_SCALEFACTORTYPE *)pComponentParameterStructure;
+		if(pDispRatio->nPortIndex == VPUDEC_OUT_PORT)
+		{
+			pDispRatio->xWidth = sDispRatio.xWidth;
+			pDispRatio->xHeight = sDispRatio.xHeight;
+		}
+		return OMX_ErrorNone;
+	}
+*/	
+	else
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);			
+		return OMX_ErrorUnsupportedIndex;
+	}
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure)
+{
+	VPU_ENC_COMP_API_LOG("%s: nParamIndex=0x%X, \r\n",__FUNCTION__,nParamIndex);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+		//case VPU_ENC_COM_STATE_LOADED:
+		//case VPU_ENC_COM_STATE_OPENED:	//allow user get wrong value before opened ???
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	if(NULL==pComponentParameterStructure)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: param is null  \r\n",__FUNCTION__);			
+		return OMX_ErrorBadParameter;
+	}
+
+#if 1 //TODO : add related setting, including resolution/framerate/bitrate/... ???
+	if (nParamIndex==OMX_IndexConfigVideoFramerate)
+	{
+			OMX_CONFIG_FRAMERATETYPE * pPara;
+			pPara=(OMX_CONFIG_FRAMERATETYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);	
+			//set frame rate
+			sVpuEncInputPara.nFrameRate=pPara->xEncodeFramerate/Q16_SHIFT;
+	}
+	else if (nParamIndex==OMX_IndexConfigVideoBitrate)
+	{
+			OMX_VIDEO_CONFIG_BITRATETYPE * pPara;
+			VpuEncRetCode ret;
+			OMX_S32 kbps;
+			pPara=(OMX_VIDEO_CONFIG_BITRATETYPE *)pComponentParameterStructure;		
+			//set bit rate
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			sVpuEncInputPara.nBitRate=pPara->nEncodeBitrate;
+			kbps=sVpuEncInputPara.nBitRate/1000;
+			ret=VPU_EncConfig(nHandle, VPU_ENC_CONF_BIT_RATE, &kbps);
+			if(VPU_ENC_RET_SUCCESS!=ret){
+				VPU_ENC_COMP_ERR_LOG("%s: vpu config failure: config=0x%X, ret=%d \r\n",__FUNCTION__,(UINT32)VPU_ENC_CONF_BIT_RATE,ret);
+				return OMX_ErrorNotImplemented;
+			}
+	}		 
+	else if (nParamIndex==OMX_IndexConfigVideoAVCIntraPeriod)
+	{
+			OMX_VIDEO_CONFIG_AVCINTRAPERIOD * pPara;
+			pPara=(OMX_VIDEO_CONFIG_AVCINTRAPERIOD *)pComponentParameterStructure;		
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			//set GOP/IDRPeriod
+			sVpuEncInputPara.nGOPSize=pPara->nPFrames+1;	//???
+			sVpuEncInputPara.nIDRPeriod=pPara->nIDRPeriod*(pPara->nPFrames+1);	//???
+	}
+	else if (nParamIndex==OMX_IndexConfigVideoIntraVOPRefresh)
+	{
+			OMX_CONFIG_INTRAREFRESHVOPTYPE * pPara;
+			pPara=(OMX_CONFIG_INTRAREFRESHVOPTYPE *)pComponentParameterStructure;		
+			//set IDR refresh manually
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			sVpuEncInputPara.nRefreshIntra=1;
+	}
+	else if(nParamIndex==OMX_IndexConfigCommonRotate)
+	{
+			OMX_CONFIG_ROTATIONTYPE * pPara;
+			pPara=(OMX_CONFIG_ROTATIONTYPE *)pComponentParameterStructure;
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			//set rotation
+			sVpuEncInputPara.nRotAngle=pPara->nRotation;	//0, 90, 180 and 270
+			if (pPara->nRotation == 90)
+				sVpuEncInputPara.nRotAngle=270;
+			if (pPara->nRotation == 270)
+				sVpuEncInputPara.nRotAngle=90;
+			fsl_osal_memcpy(&Rotation, pPara, sizeof(OMX_CONFIG_ROTATIONTYPE));
+	}		
+	else if(nParamIndex==OMX_IndexConfigCommonInputCrop)
+	{
+			OMX_CONFIG_RECTTYPE * pPara;
+			pPara=(OMX_CONFIG_RECTTYPE *)pComponentParameterStructure;		
+			//set crop info 
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			return OMX_ErrorUnsupportedIndex;
+	}
+	else if(nParamIndex==OMX_IndexConfigGrallocBufferParameter)
+	{
+			GRALLOC_BUFFER_PARAMETER * pPara;
+			pPara=(GRALLOC_BUFFER_PARAMETER *)pComponentParameterStructure;		
+			ASSERT(pPara->nPortIndex==IN_PORT);
+			if(sInFmt.eColorFormat!=pPara->eColorFormat){
+				sInFmt.eColorFormat=pPara->eColorFormat;
+				InputFmtChanged();
+			}
+	}
+#endif
+	else
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: unsupported index: 0x%X \r\n",__FUNCTION__,nParamIndex);			
+		return OMX_ErrorUnsupportedIndex;
+	}
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::InitFilterComponent()
+{
+	VpuEncRetCode ret;
+	VpuVersionInfo ver;
+
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+			break;
+		default:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+
+	}
+	
+	//load vpu
+	ret=VPU_EncLoad();
+	if (ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu load failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		return OMX_ErrorHardware;
+	}
+
+	//version info
+	ret=VPU_EncGetVersionInfo(&ver);
+	if (ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu get version failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		VPU_EncUnLoad();
+		return OMX_ErrorHardware;
+	}
+	VPU_ENC_COMP_LOG("vpu lib version : rel.major.minor=%d.%d.%d \r\n",ver.nLibRelease,ver.nLibMajor,ver.nLibMinor);
+	VPU_ENC_COMP_LOG("vpu fw version : rel.major.minor=%d.%d.%d \r\n",ver.nFwRelease,ver.nFwMajor,ver.nFwMinor);	
+
+	//update state
+	eVpuEncoderState=VPU_ENC_COM_STATE_LOADED;	
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::DeInitFilterComponent()
+{
+	VpuEncRetCode ret;
+	OMX_ERRORTYPE omx_ret=OMX_ErrorNone;
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	//close vpu
+	ret=VPU_EncClose(nHandle);
+	if (ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu close failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		omx_ret=OMX_ErrorHardware;
+	}	
+
+	//stop/release pre-process thread
+	if(pPreThreadId != NULL) {
+		PreThreadStop();
+		fsl_osal_thread_destroy(pPreThreadId);
+	}
+	if(pPreInQueue){
+		pPreInQueue->Free();
+		FSL_DELETE(pPreInQueue);
+	}
+	if(pPreOutQueue){
+		pPreOutQueue->Free();
+		FSL_DELETE(pPreOutQueue);
+	}
+	if(pPreInReturnQueue){
+		pPreInReturnQueue->Free();
+		FSL_DELETE(pPreInReturnQueue);
+	}
+	if(pPreOutReturnQueue){
+		pPreOutReturnQueue->Free();
+		FSL_DELETE(pPreOutReturnQueue);
+	}
+	if(pPreCmdSem){
+		fsl_osal_sem_destroy(pPreCmdSem);
+	}
+	if(pPreMutex!= NULL){
+		fsl_osal_mutex_destroy(pPreMutex);
+		//fsl_osal_cond_destroy(sPreCond);
+		pthread_cond_destroy(&sPreCond);
+	}	
+	if(bEnabledPreProcess)	{
+		PreProcessIPUDeinit(&sIpuHandle);
+	}
+
+	// release mem
+	if(0==MemFreeBlock(&sVpuEncMemInfo,&sMemOperator))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: free memory failure !  \r\n",__FUNCTION__);
+		omx_ret=OMX_ErrorHardware;
+	}
+
+	//avoid memory leak !!!(user miss releasing them)
+	if(0==MemFreeBlock(&sEncAllocInMemInfo,&sMemOperator))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: free memory failure !!!  \r\n",__FUNCTION__);
+		omx_ret=OMX_ErrorHardware;
+	}	
+	if(0==MemFreeBlock(&sEncAllocOutMemInfo,&sMemOperator))
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: free memory failure !!!  \r\n",__FUNCTION__);
+		omx_ret=OMX_ErrorHardware;
+	}
+	
+	//clear handle
+	nHandle=0;
+
+	//unload
+	ret=VPU_EncUnLoad();
+	if (ret!=VPU_ENC_RET_SUCCESS)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu unload failure: ret=0x%X \r\n",__FUNCTION__,ret);
+		omx_ret=OMX_ErrorHardware;
+	}
+
+	//update state 
+	eVpuEncoderState=VPU_ENC_COM_STATE_NONE;
+	
+	return OMX_ErrorNone;
+}
+	
+OMX_ERRORTYPE VpuEncoder::SetInputBuffer(OMX_PTR pBufferVirt, OMX_S32 nSize, OMX_BOOL bLast)
+{
+	VPU_ENC_COMP_API_LOG("%s: state: %d, bufvirt: 0x%X, size: %d, last: %d \r\n",__FUNCTION__,eVpuEncoderState,(UINT32)pBufferVirt,(UINT32)nSize,(UINT32)bLast);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		//case VPU_ENC_COM_STATE_EOS:
+			//if user want to repeat play, user should call the last getoutput (to make state change from eos to decode)
+			//forbidden
+		//	VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+		//	return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+    if (bStoreMetaData == OMX_TRUE) {
+        pInBufferPhy = ((METADATA_BUFFER *)pBufferVirt)->pPhysicAddress;
+    } else {
+        if(OMX_ErrorNone!=GetHwBuffer(pBufferVirt,&pInBufferPhy))
+        {
+            VPU_ENC_COMP_ERR_LOG("%s: unvalid virtual buffer: 0x%X \r\n",__FUNCTION__,(UINT32)pBufferVirt);
+                return OMX_ErrorBadParameter;
+        }
+    }
+	pInBufferVirt=pBufferVirt;
+	ASSERT((OMX_U32)nSize==(sInFmt.nFrameWidth*sInFmt.nFrameHeight*3/2));
+	nInSize=nSize;
+	bInEos=bLast;
+	
+	//check data length, we don't allow zero-length-buf
+	if(0>=nInSize)
+	{
+		pInBufferPhy=NULL;
+		pInBufferVirt=NULL;
+	}
+	else{
+		
+	}
+	return OMX_ErrorNone;
+}
+	
+OMX_ERRORTYPE VpuEncoder::SetOutputBuffer(OMX_PTR pBuffer)
+{
+	OMX_S32 nPhyFrameNum;
+	OMX_S32 nIsPhy=0;
+
+	VPU_ENC_COMP_API_LOG("%s: state: %d, buffer: 0x%X \r\n",__FUNCTION__,eVpuEncoderState,(UINT32)pBuffer);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return OMX_ErrorIncorrectStateTransition;
+		//case VPU_ENC_COM_STATE_EOS:
+			//if user want to repeat play, user should call the last getoutput (to make state change from eos to decode)
+			//forbidden
+		//	VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+		//	return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	if(0==OutFrameBufExist(pBuffer,&sEncOutFrameInfo,&nIsPhy))
+	{
+		//register output frame buffer
+		nPhyFrameNum=OutFrameBufRegister(pBuffer,&sEncOutFrameInfo,&nIsPhy);
+		if(-1==nPhyFrameNum)
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: failure: unvalid buffer ! \r\n",__FUNCTION__);
+			//sFrameMemInfo is full
+			return OMX_ErrorInsufficientResources;
+		}
+	}
+	else
+	{
+		if(nIsPhy)
+		{
+			//set repeated !!!
+			VPU_ENC_COMP_ERR_LOG("%s: failure: output buffer is set repeatedly ! \r\n",__FUNCTION__);
+			return OMX_ErrorIncorrectStateOperation;
+		}
+		else
+		{
+			//clear frame node ...
+			//...
+		}
+	}
+
+	if(0==nIsPhy)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: virtual address is not supported ! \r\n",__FUNCTION__);
+		//TODO: Now, virtual address is not supported !!!!!, it will introduce more complex logic.
+		return OMX_ErrorUnsupportedSetting;
+	}
+
+	return OMX_ErrorNone;	
+}
+
+OMX_ERRORTYPE VpuEncoder::InitFilter()
+{
+	VpuEncRetCode ret;
+	VpuFrameBuffer frameBuf[ENC_MAX_FRAME_NUM];
+	OMX_S32 BufNum;
+	OMX_S32 nSrcStride;
+
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);	
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_DO_INIT:
+			break;
+		default:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+	//set mini buffer cnt
+	BufNum=sEncInitInfo.nMinFrameBufferCount;//+ENC_FRAME_SURPLUS;
+	ASSERT(BufNum==sEncInitInfo.nMinFrameBufferCount);
+	
+	//fill frameBuf[]
+	BufNum=OutFrameBufCreateRegisterFrame(frameBuf, BufNum,sVpuEncInputPara.nWidthStride, sVpuEncInputPara.nHeightStride, &sVpuEncMemInfo,&sMemOperator,sVpuEncInputPara.nRotAngle,&nSrcStride,sEncInitInfo.nAddressAlignment);
+	if(-1==BufNum)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: create register frame failure \r\n",__FUNCTION__);	
+		return OMX_ErrorInsufficientResources;
+	}
+	
+	//register frame buffs
+	ret=VPU_EncRegisterFrameBuffer(nHandle, frameBuf, BufNum,nSrcStride);
+	if(VPU_ENC_RET_SUCCESS!=ret)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: vpu register frame failure: ret=0x%X \r\n",__FUNCTION__,ret);	
+		return OMX_ErrorHardware;
+	}	
+
+	//update state
+	eVpuEncoderState=VPU_ENC_COM_STATE_DO_DEC;
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::DeInitFilter()
+{
+	OMX_ERRORTYPE omx_ret=OMX_ErrorNone;
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+		case VPU_ENC_COM_STATE_LOADED:
+		case VPU_ENC_COM_STATE_OPENED:
+		//case VPU_ENC_COM_STATE_WAIT_FRM:	
+		case VPU_ENC_COM_STATE_DO_INIT:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}
+
+	//update state 
+	//eVpuEncoderState=VPU_ENC_COM_STATE_OPENED; //???
+
+	return omx_ret;
+}
+
+FilterBufRetCode VpuEncoder::FilterOneBuffer()
+{
+	VpuEncRetCode ret;
+	FilterBufRetCode bufRet=FILTER_OK;	
+	OMX_S32 index;
+	OMX_U32 nOutPhy;
+	OMX_U32 nOutVirt;
+	OMX_U32 nOutLength;
+	VpuEncEncParam sEncEncParam;
+	OMX_S32 nValidInput=1;
+	OMX_U32 nInputPhy,nInputVirt;
+	OMX_S32 nInputSize;
+	OMX_COLOR_FORMATTYPE ePreColorFormat=OMX_COLOR_FormatYUV420Planar;
+	
+	VPU_ENC_COMP_API_LOG("%s:, state: %d \r\n",__FUNCTION__,eVpuEncoderState);
+
+//RepeatPlay:
+	//check state
+	switch(eVpuEncoderState)
+	{
+		//forbidden state
+		case VPU_ENC_COM_STATE_NONE:
+		case VPU_ENC_COM_STATE_DO_INIT:	
+		case VPU_ENC_COM_STATE_DO_OUT:
+		//case VPU_ENC_COM_STATE_EOS:
+			bufRet=FILTER_ERROR;
+			VPU_ENC_COMP_ERR_LOG("%s: failure: error state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return bufRet;
+		//allowed state	
+		//case VPU_ENC_COM_STATE_WAIT_FRM:
+		//	break;
+		case VPU_ENC_COM_STATE_LOADED:
+			PreProcessetSetStrategy(sInFmt.eColorFormat,&bEnabledPreProcess);
+			if(bEnabledPreProcess){
+				OMX_S32 nPreOutSize;
+				if(PreProcessIPUInit(&sIpuHandle)==0){
+					VPU_ENC_COMP_ERR_LOG("init pre-process failure ! \r\n");
+					bEnabledPreProcess=OMX_FALSE; //avoid PreProcessIPUDeinit() is called in DeInitFilterComponent()
+					return FILTER_ERROR;
+				}
+				else	{
+					//set ipu task in/out parameter
+					ePreColorFormat=OMX_COLOR_FormatYUV420SemiPlanar; //enable NV12
+#ifdef PRE_PROCESS_BY_PASS_TEST
+					ePreColorFormat=OMX_COLOR_FormatYUV420Planar;
+#endif
+					PreProcessIPUSetDefault(&sIpuHandle,&sInFmt,ePreColorFormat);
+
+					//create pre-process thread
+					pPreInQueue = FSL_NEW(Queue, ());
+					if(pPreInQueue == NULL) {
+						VPU_ENC_COMP_ERR_LOG("New pre queue failed.\n");
+					}
+					if(pPreInQueue->Create(PRE_MAX_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+						VPU_ENC_COMP_ERR_LOG("Init pre queue failed.\n");
+					}
+					pPreOutQueue = FSL_NEW(Queue, ());
+					if(pPreOutQueue == NULL) {
+						VPU_ENC_COMP_ERR_LOG("New pre queue failed.\n");
+					}
+					if(pPreOutQueue->Create(PRE_MAX_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+						VPU_ENC_COMP_ERR_LOG("Init pre queue failed.\n");
+					}
+					pPreInReturnQueue = FSL_NEW(Queue, ());
+					if(pPreInReturnQueue == NULL) {
+						VPU_ENC_COMP_ERR_LOG("New pre queue failed.\n");
+					}
+					if(pPreInReturnQueue->Create(PRE_MAX_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+						VPU_ENC_COMP_ERR_LOG("Init pre queue failed.\n");
+					}
+					pPreOutReturnQueue = FSL_NEW(Queue, ());
+					if(pPreOutReturnQueue == NULL) {
+						VPU_ENC_COMP_ERR_LOG("New pre queue failed.\n");
+					}
+					if(pPreOutReturnQueue->Create(PRE_MAX_QUEUE_SIZE, sizeof(OMX_BUFFERHEADERTYPE*), E_FSL_OSAL_TRUE)!= QUEUE_SUCCESS) {
+						VPU_ENC_COMP_ERR_LOG("Init pre queue failed.\n");
+					}
+					if(E_FSL_OSAL_SUCCESS != fsl_osal_sem_init(&pPreCmdSem, 0, 0)){
+						VPU_ENC_COMP_ERR_LOG("Create pPreCmdSem Semphore failed.\n");
+					}
+					if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&pPreMutex, fsl_osal_mutex_normal)) {
+						VPU_ENC_COMP_ERR_LOG("Create mutext for pre process failed.\n");
+					}
+					//if(E_FSL_OSAL_SUCCESS != fsl_osal_cond_create(&sPreCond)) {
+					if(0!= pthread_cond_init(&sPreCond, NULL)) {
+						VPU_ENC_COMP_ERR_LOG("Create condition variable for pre process failed.\n");
+					}
+					ePreState=PRE_PROCESS_STATE_NONE;
+					ePreCmd=PRE_PROCESS_CMD_NONE;
+					bPreWaitingTasks=OMX_TRUE;
+					if(E_FSL_OSAL_SUCCESS != fsl_osal_thread_create(&pPreThreadId, NULL, PreThread, this)) {
+						VPU_ENC_COMP_ERR_LOG("Create pre-process thread failed.\n");
+						//PreProcessIPUDeinit(&sIpuHandle); //will be called in DeInitFilterComponent()
+						return FILTER_ERROR;
+					}
+					nPreOutSize=sInFmt.nFrameWidth * sInFmt.nFrameHeight*pxlfmt2bpp(ePreColorFormat)/8;
+					PreCreateOutFrame(&sEncAllocOutMemInfo, &sMemOperator, &sEncPreProcessOutFrameInfo, pPreOutReturnQueue, nPreOutSize, PRE_OUT_BUF_NUM);
+					PreThreadRun();
+				}
+			}
+			
+			//1 we set width/height/stride here ???
+			sVpuEncInputPara.nPicWidth=sInFmt.nFrameWidth;
+			sVpuEncInputPara.nPicHeight=sInFmt.nFrameHeight;
+			sVpuEncInputPara.nWidthStride=sInFmt.nFrameWidth;
+			sVpuEncInputPara.nHeightStride=sInFmt.nFrameHeight;			
+			sVpuEncInputPara.nFrameRate=sInFmt.xFramerate/Q16_SHIFT;
+			if ((sVpuEncInputPara.nWidthStride%16!=0)||(sVpuEncInputPara.nHeightStride%16!=0))
+			{
+				VPU_ENC_COMP_ERR_LOG("%s: warning: stride is not 16 aligned \r\n",__FUNCTION__);
+				//return FILTER_ERROR;
+			}
+#if 0		//1 set nBitRate through OMX_IndexParamVideoBitrate ???
+			sVpuEncInputPara.nBitRate=sOutFmt.nBitrate; //sOutFmt.nBitrate is not updated ??
+#endif
+			if(bEnabledPreProcess){
+				if(ePreColorFormat==OMX_COLOR_FormatYUV420SemiPlanar){
+					sVpuEncInputPara.nChromaInterleave=1;
+				}
+#ifdef VPU_ENC_WORKAROUND_WIFI_INTRA_QUALITY
+				sVpuEncInputPara.nRcIntraQP=15;
+#endif
+			}
+			else if(sInFmt.eColorFormat==OMX_COLOR_FormatYUV420SemiPlanar)
+			{
+				sVpuEncInputPara.nChromaInterleave=1;
+			}
+			ret=VPUCom_Init(&sVpuEncInputPara, &sVpuEncMemInfo,&sMemOperator, &nHandle, &sEncInitInfo);
+			if (ret!=VPU_ENC_RET_SUCCESS)
+			{
+				VPU_ENC_COMP_ERR_LOG("%s: vpu init failure: ret=0x%X \r\n",__FUNCTION__,ret);
+				//PreProcessIPUDeinit(&sIpuHandle); //will be called in DeInitFilterComponent()
+				return FILTER_ERROR;
+			}
+
+			//update state
+			eVpuEncoderState=VPU_ENC_COM_STATE_DO_INIT;
+			return FILTER_DO_INIT;
+		//case VPU_ENC_COM_STATE_OPENED:		
+		case VPU_ENC_COM_STATE_DO_DEC:
+			break;
+		//case VPU_ENC_COM_STATE_RE_WAIT_FRM:
+		//	break;
+		//unknow state 
+		default:
+			VPU_ENC_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return FILTER_ERROR;
+	}
+
+	if((NULL==pInBufferPhy)||(0>=nInSize)){
+		nValidInput=0;
+		nInputPhy=0;
+		nInputVirt=0;
+		nInputSize=0;
+	}
+	else{
+		nInputPhy=(OMX_U32)pInBufferPhy;
+		nInputVirt=(OMX_U32)pInBufferVirt;
+		nInputSize=nInSize;
+	}
+	
+	if(bEnabledPreProcess){
+		OMX_U32 flag=0;
+		if(bInEos==OMX_TRUE){
+			flag|=PRE_FLAG_EOS;
+			bPreEos=OMX_TRUE;
+			bInEos=OMX_FALSE;	//we will re-enalbe eos when receive eos_flag from pre-process output
+			if(0==nValidInput){
+				VPU_ENC_COMP_LOG("warning: the last eos input is null \r\n");
+			}
+		}
+		//check input queue
+		if(nValidInput ||(flag&PRE_FLAG_EOS) ){
+			PreFrameSet(&sEncPreProcessInFrameInfo, nInputPhy, nInputVirt,nInputSize,flag, &index);
+			pPreInQueue->Add(&index);
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_INPUT_CONSUMED_EXT_READ);
+			PreWakeUp(pPreMutex, &sPreCond, (volatile OMX_BOOL*) &bPreWaitingTasks);
+			pInBufferPhy=NULL;  //clear input 
+			pInBufferVirt=NULL;
+			nInSize=0;
+		}
+		//check input return queue
+		if(pPreReturnedInput==NULL){
+			if(pPreInReturnQueue->Size()>0){
+				pPreInReturnQueue->Get(&index);
+				//if(PreFrameValid(&sEncPreProcessInFrameInfo, index)){
+				if(1){ //for invalid eos input, we still need to notify user to get it. in such case, pPreReturnedInput will be set NULL
+					pPreReturnedInput=(OMX_PTR)PreFrameGetVirt(&sEncPreProcessInFrameInfo,index);
+					PreFrameClear(&sEncPreProcessInFrameInfo, index);
+					bufRet=(FilterBufRetCode)(bufRet|FILTER_INPUT_CONSUMED_EXT_RETURN);
+				}
+			}
+		}
+#if 0 //disable it to decrease latency for wifi display
+		//check input buffer count to improve pipeline efficiency: avoid pre-process is idel as possible when vpu is decoding
+		if((pPreInQueue->Size()<PRE_THRESHOLD_MIN_INPUT)&&(pInBufferPhy==NULL)&&(OMX_FALSE==bPreEos)){
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_INPUT_BUFFER);
+			return bufRet;
+		}
+#endif	
+	}
+	
+	index=OutFrameBufPhyFindValid(&sEncOutFrameInfo,&nOutPhy,&nOutVirt,&nOutLength);
+	if(-1==index)
+	{
+		//not  output frame
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_OUTPUT_BUFFER);
+		return bufRet;
+	}
+
+	if(bEnabledPreProcess){
+		//check out queue
+		OMX_U32 flag=0;
+		if(nPreOutIndex!=-1){
+			PreFrameGetNode(&sEncPreProcessOutFrameInfo,nPreOutIndex, &nInputPhy, &nInputVirt, &nInputSize, &flag);
+		}
+		else if(pPreOutQueue->Size()>0){
+			pPreOutQueue->Get(&nPreOutIndex);
+			PreFrameGetNode(&sEncPreProcessOutFrameInfo,nPreOutIndex, &nInputPhy, &nInputVirt, &nInputSize, &flag);
+		}
+		else{
+			//no output from pre-process, now check whether need more input
+			if((NULL==pInBufferPhy) && (pPreInQueue->Size()==0)&&(OMX_FALSE==bPreEos)){
+				bufRet=(FilterBufRetCode)(bufRet|FILTER_NO_INPUT_BUFFER);
+			}
+			return bufRet;
+		}
+		if(flag&PRE_FLAG_EOS){
+			bInEos=OMX_TRUE;
+			if(nInputSize==0){
+				//no valid data for eos
+				eVpuEncoderState=VPU_ENC_COM_STATE_DO_OUT;	
+				pOutBufferPhy=NULL;
+				bufRet=(FilterBufRetCode)(bufRet|FILTER_LAST_OUTPUT);
+				return bufRet;				
+			}
+		}
+		if((NULL==nInputPhy)||(nInputSize==0)){
+			//shouldn't hit here !!
+			VPU_ENC_COMP_ERR_LOG("error: invalid data \r\n");
+			return FILTER_ERROR;
+		}
+	}
+	else{
+		if(0==nValidInput)	{
+			if(bInEos==OMX_TRUE)	{
+				//eos: and no output frame
+				eVpuEncoderState=VPU_ENC_COM_STATE_DO_OUT;	
+				pOutBufferPhy=NULL;//no real output frame
+				return (FilterBufRetCode)(FILTER_INPUT_CONSUMED|FILTER_LAST_OUTPUT);
+			}
+			else	{
+				//no input buffer
+				return FILTER_NO_INPUT_BUFFER;
+			}
+		}
+	}
+
+	//clear 0 firstly
+	fsl_osal_memset(&sEncEncParam,0,sizeof(VpuEncEncParam));
+	sEncEncParam.eFormat=sVpuEncInputPara.eFormat;
+	sEncEncParam.nPicWidth=sVpuEncInputPara.nWidthStride;//sVpuEncInputPara.nPicWidth;
+	sEncEncParam.nPicHeight=sVpuEncInputPara.nHeightStride;//sVpuEncInputPara.nPicHeight;	
+	sEncEncParam.nFrameRate=sVpuEncInputPara.nFrameRate;
+	sEncEncParam.nQuantParam=sVpuEncInputPara.nQuantParam;	
+	sEncEncParam.nInPhyInput=nInputPhy;
+	sEncEncParam.nInVirtInput=nInputVirt;
+	sEncEncParam.nInInputSize=nInputSize;
+	sEncEncParam.nInPhyOutput=nOutPhy;
+	sEncEncParam.nInVirtOutput=nOutVirt;
+	sEncEncParam.nInOutputBufLen=nOutLength;
+
+	//(1)check the frame count, for H.264
+	//In current design, we will set IDR frame for every I frame
+	//(2)check I refresh command by user
+	if((1==sVpuEncInputPara.nRefreshIntra) ||
+		((VPU_V_AVC==sEncEncParam.eFormat)&&(1==nOutGOPFrameCnt)))
+	{
+		sEncEncParam.nForceIPicture=1;
+		sVpuEncInputPara.nRefreshIntra=0; 	//clear it every time
+		nOutGOPFrameCnt=1;
+	}
+	else
+	{
+		sEncEncParam.nForceIPicture=0;
+	}
+	sEncEncParam.nSkipPicture=0;
+	sEncEncParam.nEnableAutoSkip=sVpuEncInputPara.nEnableAutoSkip;
+	
+	//encode frame
+	ret=VPU_EncEncodeFrame(nHandle, &sEncEncParam);
+
+	if(VPU_ENC_RET_SUCCESS!=ret)
+	{
+		if(VPU_ENC_RET_FAILURE_TIMEOUT==ret)
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: encode frame timeout \r\n",__FUNCTION__);
+			VPU_EncReset(nHandle);
+			//SendEvent(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
+		}
+		return FILTER_ERROR; 
+	}
+
+	//check input
+	if(sEncEncParam.eOutRetCode & VPU_ENC_INPUT_USED)
+	{
+		if(bEnabledPreProcess){
+			//buffer has been consumed by vpu , return back to pre-process.
+			pPreOutReturnQueue->Add(&nPreOutIndex);
+			nPreOutIndex=-1;
+			PreWakeUp(pPreMutex, &sPreCond, (volatile OMX_BOOL*) &bPreWaitingTasks);
+		}
+		else{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_INPUT_CONSUMED);
+			pInBufferPhy=NULL;  //clear input 
+			pInBufferVirt=NULL;
+			nInSize=0;		
+		}
+	}
+	else
+	{
+		//not used
+	}
+
+	//check output
+	if(sEncEncParam.eOutRetCode & VPU_ENC_OUTPUT_DIS)
+	{
+		//has output
+		if(bInEos==OMX_TRUE)
+		{
+			//last output
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_LAST_OUTPUT);
+		}
+		else
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_HAS_OUTPUT);
+		}
+		//set flags
+		if(1==nOutGOPFrameCnt)
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_FLAG_KEY_FRAME);
+		}
+		else
+		{
+			bufRet=(FilterBufRetCode)(bufRet|FILTER_FLAG_NONKEY_FRAME);
+		}
+		
+		eVpuEncoderState=VPU_ENC_COM_STATE_DO_OUT;	
+		//record output info
+		pOutBufferPhy=(OMX_PTR)nOutPhy;
+		nOutSize=sEncEncParam.nOutOutputSize;
+		ASSERT(nOutSize<=(OMX_S32)nOutBufferSize);
+		VPU_ENC_COMP_LOG("[%d]frame data: %d \r\n",nOutGOPFrameCnt,nOutSize);
+		//update count
+		nOutGOPFrameCnt++;
+		//if(nOutGOPFrameCnt>sVpuEncInputPara.nIDRPeriod)
+		if(nOutGOPFrameCnt>sVpuEncInputPara.nGOPSize)
+		{
+			nOutGOPFrameCnt=1;
+		}
+	}
+	else if(sEncEncParam.eOutRetCode & VPU_ENC_OUTPUT_SEQHEADER)
+	{
+		//has sequence header output
+		bufRet=(FilterBufRetCode)(bufRet|FILTER_HAS_OUTPUT|FILTER_FLAG_CODEC_DATA);
+
+		eVpuEncoderState=VPU_ENC_COM_STATE_DO_OUT;	
+		//record output info
+		pOutBufferPhy=(OMX_PTR)nOutPhy;
+		nOutSize=sEncEncParam.nOutOutputSize;
+		ASSERT(nOutSize<=(OMX_S32)nOutBufferSize);
+		VPU_ENC_COMP_LOG("sequence header: %d \r\n",nOutSize);
+	}
+	else
+	{
+		//no output
+	}
+
+	return bufRet;
+}
+
+OMX_ERRORTYPE VpuEncoder::GetReturnedInputDataPtr(OMX_PTR* ppInput)
+{
+	//if(pPreReturnedInput==NULL){
+	if(0){ //for invalid eos input, we need to return NULL pointer
+		VPU_ENC_COMP_ERR_LOG("%s: no input ptr is avaliable now \r\n",__FUNCTION__);
+		return OMX_ErrorIncorrectStateOperation;
+	}
+	*ppInput=pPreReturnedInput;
+	pPreReturnedInput=NULL;
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::GetOutputBuffer(OMX_PTR *ppOutVirtBuf)
+{
+	OMX_PTR pOutBufferVirt;
+
+	VPU_ENC_COMP_API_LOG("%s: state: %d  pOutBufferPhy: 0x%X \r\n",__FUNCTION__,eVpuEncoderState,(UINT32)pOutBufferPhy);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_DO_OUT:
+			//update state
+			eVpuEncoderState=VPU_ENC_COM_STATE_DO_DEC;
+			break;
+		default:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+	if(ppOutVirtBuf==NULL)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: ppOutVirtBuf==NULL !!! \r\n",__FUNCTION__);		
+		return OMX_ErrorBadParameter;
+	}
+	
+	//get output frame virtual address
+	if(NULL==pOutBufferPhy)
+	{
+		//no real output frame: for eos case
+		OMX_U32 virtAddr;
+		if(-1==OutFrameBufVirtFindValidAndClear(&sEncOutFrameInfo,&virtAddr)) 
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: failure: can not find one valid virtual address !!! \r\n",__FUNCTION__);	
+			return OMX_ErrorBadParameter;
+		}
+		*ppOutVirtBuf=(OMX_PTR)virtAddr;	//return one fake output frame
+		VPU_ENC_COMP_LOG("return last output frame: 0x%X \r\n",(UINT32)virtAddr);
+		//*pSize=0;
+	}
+	else
+	{
+		if(-1==OutFrameBufPhyClear(&sEncOutFrameInfo,pOutBufferPhy,&pOutBufferVirt))
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: failure: unvalid output physical address !!! \r\n",__FUNCTION__);	
+			return OMX_ErrorBadParameter;
+		}
+		*ppOutVirtBuf=pOutBufferVirt;
+		//*pSize=nOutSize;
+	}
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::GetOutputBuffer(OMX_PTR *ppOutVirtBuf,OMX_S32* pOutSize)
+{
+	OMX_PTR pOutBufferVirt;
+
+	VPU_ENC_COMP_API_LOG("%s: state: %d  pOutBufferPhy: 0x%X \r\n",__FUNCTION__,eVpuEncoderState,(UINT32)pOutBufferPhy);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_DO_OUT:
+			//update state
+			eVpuEncoderState=VPU_ENC_COM_STATE_DO_DEC;
+			break;
+		default:
+			//forbidden
+			VPU_ENC_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+	if(ppOutVirtBuf==NULL)
+	{
+		VPU_ENC_COMP_ERR_LOG("%s: failure: ppOutVirtBuf==NULL !!! \r\n",__FUNCTION__);		
+		return OMX_ErrorBadParameter;
+	}
+	
+	//get output frame virtual address
+	if(NULL==pOutBufferPhy)
+	{
+		//no real output frame: for eos case
+		OMX_U32 virtAddr;
+		if(-1==OutFrameBufVirtFindValidAndClear(&sEncOutFrameInfo,&virtAddr)) 
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: failure: can not find one valid virtual address !!! \r\n",__FUNCTION__);	
+			return OMX_ErrorBadParameter;
+		}
+		*ppOutVirtBuf=(OMX_PTR)virtAddr;	//return one fake output frame
+		VPU_ENC_COMP_LOG("return last output frame: 0x%X \r\n",(UINT32)virtAddr);
+		*pOutSize=0;
+	}
+	else
+	{
+		if(-1==OutFrameBufPhyClear(&sEncOutFrameInfo,pOutBufferPhy,&pOutBufferVirt))
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: failure: unvalid output physical address !!! \r\n",__FUNCTION__);	
+			return OMX_ErrorBadParameter;
+		}
+		*ppOutVirtBuf=pOutBufferVirt;
+		*pOutSize=(OMX_U32)nOutSize;
+	}
+
+	return OMX_ErrorNone;
+}
+
+/*
+OMX_ERRORTYPE VpuEncoder::GetOutputBufferSize(OMX_S32* pOutBufSize)
+{
+	VPU_ENC_COMP_API_LOG("%s: state: %d  \r\n",__FUNCTION__,eVpuEncoderState);
+
+	if(NULL==pOutBufferPhy)
+	{
+		*pOutBufSize=0;
+	}
+	else
+	{
+		*pOutBufSize=nOutSize;
+	}
+	return OMX_ErrorNone;
+}
+*/
+
+OMX_ERRORTYPE VpuEncoder::FlushInputBuffer()
+{
+	VPU_ENC_COMP_API_LOG("%s: state: %d \r\n",__FUNCTION__,eVpuEncoderState);
+
+	//clear input buffer
+	pInBufferPhy=NULL;
+	pInBufferVirt=NULL;
+	nInSize=0;
+	bInEos=OMX_FALSE;
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+		case VPU_ENC_COM_STATE_LOADED:
+			VPU_ENC_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);			
+			return OMX_ErrorIncorrectStateTransition;
+		default:
+			break;
+	}		
+
+	if(bEnabledPreProcess){
+		PreThreadFlushInput();
+		PreThreadFlushOutput();
+	}
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::FlushOutputBuffer()
+{
+	VPU_ENC_COMP_API_LOG("%s: state: %d  \r\n",__FUNCTION__,eVpuEncoderState);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_OPENED:
+		case VPU_ENC_COM_STATE_DO_DEC:
+			break;
+		default: 
+			//forbidden !!!
+			VPU_ENC_COMP_ERR_LOG("%s: failure state transition, current state=%d \r\n",__FUNCTION__,eVpuEncoderState);
+			return OMX_ErrorIncorrectStateTransition;
+	}
+
+#if 0 //needn't
+	if(bEnabledPreProcess){
+		PreThreadFlushOutput();
+	}
+#endif
+	//clear out frame info
+	OutFrameBufClear(&sEncOutFrameInfo);	
+	return OMX_ErrorNone;
+}
+
+OMX_PTR VpuEncoder::AllocateInputBuffer(OMX_U32 nSize)
+{
+	OMX_PTR ptr;
+
+	VPU_ENC_COMP_API_LOG("%s: state: %d, size: %d \r\n",__FUNCTION__,eVpuEncoderState, (UINT32)nSize);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+		// case VPU_ENC_COM_STATE_LOADED:
+		//case VPU_ENC_COM_STATE_OPENED:
+			//1 how to avoid conflict memory operators
+			VPU_ENC_COMP_ERR_LOG("%s: error state: %d \r\n",__FUNCTION__,eVpuEncoderState);	
+			return (OMX_PTR)NULL;
+		default: 
+			break;
+	}
+
+	ptr=AllocateBuffer(nSize, &sEncAllocInMemInfo, &sMemOperator);
+	return ptr;  //virtual address
+
+}
+
+OMX_ERRORTYPE VpuEncoder::FreeInputBuffer(OMX_PTR pBuffer)
+{
+	OMX_ERRORTYPE ret;
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	ret=FreeBuffer(pBuffer,&sEncAllocInMemInfo, &sMemOperator);
+	return ret;
+}
+
+OMX_PTR VpuEncoder::AllocateOutputBuffer(OMX_U32 nSize)
+{
+	OMX_PTR ptr;
+
+	VPU_ENC_COMP_API_LOG("%s: state: %d , size: %d \r\n",__FUNCTION__,eVpuEncoderState,(UINT32)nSize);
+
+	//check state
+	switch(eVpuEncoderState)
+	{
+		case VPU_ENC_COM_STATE_NONE:
+		// case VPU_ENC_COM_STATE_LOADED:
+		//case VPU_ENC_COM_STATE_OPENED:
+			//1 how to avoid conflict memory operators
+			VPU_ENC_COMP_ERR_LOG("%s: error state: %d \r\n",__FUNCTION__,eVpuEncoderState);	
+			return (OMX_PTR)NULL;
+		default: 
+			break;
+	}
+
+	ptr=AllocateBuffer(nSize, &sEncAllocOutMemInfo, &sMemOperator);
+	return ptr;  //virtual address
+}
+
+OMX_ERRORTYPE VpuEncoder::FreeOutputBuffer(OMX_PTR pBuffer)
+{
+	OMX_ERRORTYPE ret;
+	VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+	ret=FreeBuffer(pBuffer,&sEncAllocOutMemInfo, &sMemOperator);
+	return ret;
+}
+
+OMX_ERRORTYPE VpuEncoder::PreThreadRun()
+{
+	// non-run state => run state
+	if(ePreState==PRE_PROCESS_STATE_RUN){
+		VPU_ENC_COMP_PRE_LOG("%s: already in run state: %d \r\n",__FUNCTION__,ePreState);
+		return OMX_ErrorNone;
+	}
+
+	//send command
+	VPU_ENC_COMP_PRE_LOG("encoder thread will send run command \r\n");
+	ePreCmd=PRE_PROCESS_CMD_RUN;
+	PreWakeUp(pPreMutex, &sPreCond, (volatile OMX_BOOL*) &bPreWaitingTasks);
+
+	//wait run state
+	PreWaitState((volatile PreProcessState*)&ePreState,PRE_PROCESS_STATE_RUN,pPreCmdSem);
+	VPU_ENC_COMP_PRE_LOG("encoder thread receive run command finished\r\n");
+	return OMX_ErrorNone;
+}
+OMX_ERRORTYPE VpuEncoder::PreThreadStop()
+{
+	// run state => idle state
+	if(ePreState!=PRE_PROCESS_STATE_RUN){
+		VPU_ENC_COMP_PRE_LOG("%s: not run state: %d \r\n",__FUNCTION__,ePreState);
+		return OMX_ErrorNone;
+	}
+	//send command
+	VPU_ENC_COMP_PRE_LOG("encoder thread will send stop command \r\n");
+	ePreCmd=PRE_PROCESS_CMD_STOP;
+	PreWakeUp(pPreMutex, &sPreCond, (volatile OMX_BOOL*) &bPreWaitingTasks);
+	
+	//wait idle state
+	PreWaitState((volatile PreProcessState*)&ePreState,PRE_PROCESS_STATE_IDLE,pPreCmdSem);
+	VPU_ENC_COMP_PRE_LOG("encoder thread receive stop command finished\r\n");
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::PreThreadFlushInput()
+{
+	// run -> (flush in) -> run state
+	OMX_S32 index;
+
+	if(ePreState!=PRE_PROCESS_STATE_RUN){
+		VPU_ENC_COMP_PRE_LOG("%s: not run state: %d \r\n",__FUNCTION__,ePreState);
+		return OMX_ErrorNone;
+	}
+
+	//send command
+	VPU_ENC_COMP_PRE_LOG("encoder thread will send flushinput command \r\n");
+	ePreCmd=PRE_PROCESS_CMD_FLUSH_IN;
+	PreWakeUp(pPreMutex, &sPreCond, (volatile OMX_BOOL*) &bPreWaitingTasks);
+	
+	//wait finished
+	PreWaitState((volatile PreProcessState*)&ePreState,ePreState,pPreCmdSem);
+	VPU_ENC_COMP_PRE_LOG("encoder thread receive flushinput command finished\r\n");
+
+	ASSERT(0==pPreInQueue->Size());
+	//clear all input buffer
+	while(pPreInReturnQueue->Size()>0){
+		pPreInReturnQueue->Get(&index);
+		//VPU_ENC_COMP_PRE_LOG("pre-process: clear input index %d \r\n",index);
+		PreFrameClear(&sEncPreProcessInFrameInfo,index);
+	}
+	pPreReturnedInput=NULL;
+	bPreEos=OMX_FALSE; //clear eos flag
+	//finally, pPreInQueue/pPreInReturnQueue are empty
+#if 0
+	//popup all output frame, and refill into pPreOutReturnQueue
+	while(pPreOutQueue->Size()>0){
+		pPreOutQueue->Get(&index);
+		index=index;
+		pPreOutReturnQueue->Add(&index);
+	}
+	//finally, pPreOutQueue are empty; pPreOutReturnQueue isn't empty
+	VPU_ENC_COMP_PRE_LOG("%s: pre flush input finised, pPreOutReturnQueue->Size(): %d \r\n",__FUNCTION__,pPreOutReturnQueue->Size());
+#else
+	VPU_ENC_COMP_PRE_LOG("%s: pre flush input finised \r\n",__FUNCTION__);
+#endif
+
+	return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE VpuEncoder::PreThreadFlushOutput()
+{
+	// run -> (flush out) -> run state
+	OMX_S32 index;
+
+	if(ePreState!=PRE_PROCESS_STATE_RUN){
+		VPU_ENC_COMP_PRE_LOG("%s: not run state: %d \r\n",__FUNCTION__,ePreState);
+		return OMX_ErrorNone;
+	}
+
+	//send command
+	VPU_ENC_COMP_PRE_LOG("encoder thread will send flushoutput command \r\n");
+	ePreCmd=PRE_PROCESS_CMD_FLUSH_OUT;
+	PreWakeUp(pPreMutex, &sPreCond, (volatile OMX_BOOL*) &bPreWaitingTasks);
+		
+	//wait finished
+	PreWaitState((volatile PreProcessState*)&ePreState,ePreState,pPreCmdSem);
+	VPU_ENC_COMP_PRE_LOG("encoder thread receive flushoutput command finished\r\n");
+
+#if 0
+	ASSERT(0==pPreInQueue->Size());
+	//clear all input buffer
+	while(pPreInReturnQueue->Size()>0){
+		pPreInReturnQueue->Get(&index);
+		//VPU_ENC_COMP_PRE_LOG("pre-process: clear input index %d \r\n",index);
+		PreFrameClear(&sEncPreProcessInFrameInfo,index);
+	}
+	pPreReturnedInput=NULL;
+	// finally, pPreInQueue/pPreInReturnQueue are empty
+#endif
+
+	//popup all output frame, and refill into pPreOutReturnQueue
+	while(pPreOutQueue->Size()>0){
+		pPreOutQueue->Get(&index);
+		index=index;
+		pPreOutReturnQueue->Add(&index);
+	}
+	nPreOutIndex=-1;
+	//finally, pPreOutQueue are empty; pPreOutReturnQueue isn't empty
+
+	VPU_ENC_COMP_PRE_LOG("%s: pre flush output finised  \r\n",__FUNCTION__);
+	return OMX_ErrorNone;
+}
+
+/**< C style functions to expose entry point for the shared library */
+extern "C" 
+{
+	OMX_ERRORTYPE VpuEncoderInit(OMX_IN OMX_HANDLETYPE pHandle)
+	{
+		OMX_ERRORTYPE ret = OMX_ErrorNone;
+		VpuEncoder *obj = NULL;
+		ComponentBase *base = NULL;
+		VPU_ENC_COMP_API_LOG("%s: \r\n",__FUNCTION__);
+
+		obj = FSL_NEW(VpuEncoder, ());
+		if(obj == NULL)
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: vpu encoder new failure: ret=0x%X \r\n",__FUNCTION__,ret);
+			return OMX_ErrorInsufficientResources;
+		}
+
+		base = (ComponentBase*)obj;
+		ret = base->ConstructComponent(pHandle);
+		if(ret != OMX_ErrorNone)
+		{
+			VPU_ENC_COMP_ERR_LOG("%s: vpu encoder construct failure: ret=0x%X \r\n",__FUNCTION__,ret);
+			return ret;
+		}
+		return ret;
+	}	
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/component/vpu_enc/VpuEncComponent.h b/OpenMAXIL/src/component/vpu_enc/VpuEncComponent.h
new file mode 100755
index 0000000..40e38c9
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_enc/VpuEncComponent.h
@@ -0,0 +1,200 @@
+/**
+ *  Copyright (c) 2010-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file VpuEncComponent.h
+ *  @brief Class definition of VpuEncoder Component
+ *  @ingroup VpuEncoder
+ */
+
+#ifndef VpuEncoder_h
+#define VpuEncoder_h
+
+#include "vpu_wrapper.h"
+#include "VideoFilter.h"
+
+#ifdef MX6X
+#include "linux/ipu.h"
+typedef struct ipu_task IpuTask;
+#else
+typedef OMX_S32 IpuTask;
+#endif  //ifdef MX6X
+
+typedef unsigned int VpuEncHandle;
+
+typedef struct {
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nWidthStride;
+	int nHeightStride;
+	int nRotAngle;
+	int nFrameRate;
+	int nBitRate;			/*unit: bps*/
+	int nGOPSize;
+	int nChromaInterleave;
+	VpuEncMirrorDirection sMirror;
+	int nQuantParam;
+
+	int nEnableAutoSkip;
+	int nIDRPeriod;		//for H.264
+	int nRefreshIntra;	//IDR for H.264
+	int nIntraFreshNum;
+	OMX_BOOL bEnabledSPSIDR; //SPS/PPS is added for every IDR frame
+	int nRcIntraQP;		//0: auto; >0: qp value
+} VpuEncInputParam;
+
+typedef struct
+{
+	OMX_S32 nIpuFd;
+	IpuTask sIpuTask;
+}VpuEncoderIpuHandle;
+
+typedef enum
+{
+	VPU_ENC_COM_STATE_NONE=0,
+	VPU_ENC_COM_STATE_LOADED,
+	VPU_ENC_COM_STATE_OPENED,
+	//VPU_ENC_COM_STATE_WAIT_FRM,
+	VPU_ENC_COM_STATE_DO_INIT,
+	VPU_ENC_COM_STATE_DO_DEC,
+	VPU_ENC_COM_STATE_DO_OUT,
+	//VPU_ENC_COM_STATE_EOS,
+	//VPU_ENC_COM_STATE_RE_WAIT_FRM,
+}VpuEncoderState;
+
+typedef enum
+{
+	PRE_PROCESS_STATE_NONE=0,
+	PRE_PROCESS_STATE_IDLE,
+	PRE_PROCESS_STATE_RUN,
+}PreProcessState;
+
+typedef enum
+{
+	PRE_PROCESS_CMD_NONE=0,
+	PRE_PROCESS_CMD_RUN,
+	PRE_PROCESS_CMD_FLUSH_IN,
+	PRE_PROCESS_CMD_FLUSH_OUT,
+	PRE_PROCESS_CMD_STOP,
+}PreProcessCmd;
+
+#define VPU_ENC_MAX_NUM_MEM	(36)
+typedef struct
+{
+	//virtual mem info
+	OMX_S32 nVirtNum;
+	OMX_U32 virtMem[VPU_ENC_MAX_NUM_MEM];
+
+	//phy mem info
+	OMX_S32 nPhyNum;
+	OMX_U32 phyMem_virtAddr[VPU_ENC_MAX_NUM_MEM];
+	OMX_U32 phyMem_phyAddr[VPU_ENC_MAX_NUM_MEM];
+	OMX_U32 phyMem_cpuAddr[VPU_ENC_MAX_NUM_MEM];
+	OMX_U32 phyMem_size[VPU_ENC_MAX_NUM_MEM];	
+}VpuEncoderMemInfo;
+
+typedef struct
+{
+	OMX_S32 nNum;
+	OMX_U32 virtAddr[VPU_ENC_MAX_NUM_MEM];
+	OMX_U32 phyAddr[VPU_ENC_MAX_NUM_MEM];
+	OMX_U32 size[VPU_ENC_MAX_NUM_MEM];
+	OMX_U32 flag[VPU_ENC_MAX_NUM_MEM];
+}VpuEncoderPreProcessMemInfo;
+
+class VpuEncoder : public VideoFilter {
+	public:
+		friend void *PreThread(void *arg);
+		VpuEncoder();
+		//OMX_S32 DoGetBitstream(OMX_U32 nLen, OMX_U8 *pBuffer, OMX_S32 *pEndOfFrame);
+	private:
+		VpuEncoderMemInfo sVpuEncMemInfo;		// memory info for vpu : component internal structure/vpu_EncRegisterFrameBuffer()
+		VpuEncoderMemInfo sEncAllocInMemInfo;	// memory info for AllocateInputBuffer()
+		VpuEncoderMemInfo sEncAllocOutMemInfo;	// memory info for AllocateOutputBuffer() and output of pre-process
+		VpuEncoderMemInfo sEncOutFrameInfo;		// memory info for output frames: it may be overlapped with sEncAllocOutMemInfo
+		VpuEncoderPreProcessMemInfo sEncPreProcessInFrameInfo;	// memory info for pre-process input
+		VpuEncoderPreProcessMemInfo sEncPreProcessOutFrameInfo;	// memory info for pre-process output, it is released through sEncAllocOutMemInfo
+		OMX_PARAM_MEM_OPERATOR sMemOperator;
+
+		VpuEncInitInfo sEncInitInfo;	// seqinit info
+		VpuEncHandle nHandle;		// pointer to vpu object
+
+		OMX_U8 cRole[OMX_MAX_STRINGNAME_SIZE];
+		
+		//VpuCodStd eFormat;
+		//OMX_S32 nPadWidth;
+		//OMX_S32 nPadHeight;
+
+		OMX_PTR pInBufferPhy;
+		OMX_PTR pInBufferVirt;
+		OMX_S32 nInSize;
+		OMX_BOOL bInEos;
+		OMX_PTR pOutBufferPhy;
+		OMX_S32 nOutSize;	
+		OMX_S32 nOutGOPFrameCnt;	// used for H.264: [1,2,...,GOPSize]
+        OMX_BOOL bStoreMetaData;    // indicate store meta data in buffer.
+
+		VpuEncoderState eVpuEncoderState;	
+
+		VpuEncInputParam sVpuEncInputPara;
+
+		OMX_BOOL bEnabledPreProcess;	//pre-process is enalbed or not: mainly for RGBA - YUV
+		VpuEncoderIpuHandle sIpuHandle;
+		fsl_osal_ptr pPreThreadId;
+		PreProcessState ePreState;	//pre thread write, encode thread read
+		PreProcessCmd ePreCmd;	//pre thread read/clear, encode thread write
+		Queue* pPreInQueue;		//rgb frame index: encode thread add, pre thread get
+		Queue* pPreOutQueue;		//yuv frame index: encode thread get, pre thread add
+		Queue* pPreInReturnQueue;  //rgb frame index: encode thread get, pre thread add
+		Queue* pPreOutReturnQueue;//yuv frame index: encode thread add, pre thread get
+		fsl_osal_sem pPreCmdSem;	//encode thread wait, pre thread pre
+		fsl_osal_mutex pPreMutex;       //sync mutex between pre and encode thread
+		pthread_cond_t sPreCond;        //sync condition between pre and encode thread
+		OMX_BOOL bPreWaitingTasks;//pre thread are waiting tasks from encode thread
+		OMX_PTR pPreReturnedInput; //record the last buffer addr (in pPreInReturnQueue)
+		OMX_S32 nPreOutIndex;	      //record the last out index (in pPreOutQueue)
+		OMX_BOOL bPreEos;			//pre-process has received eos
+		
+		OMX_ERRORTYPE SetRoleFormat(OMX_STRING role);
+		OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+		OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure);
+
+		/* virtual function implementation */
+		OMX_ERRORTYPE InitFilterComponent();
+		OMX_ERRORTYPE DeInitFilterComponent();
+		OMX_ERRORTYPE SetInputBuffer(OMX_PTR pBuffer, OMX_S32 nSize, OMX_BOOL bLast);
+		OMX_ERRORTYPE SetOutputBuffer(OMX_PTR pBuffer);
+		OMX_ERRORTYPE InitFilter();
+		OMX_ERRORTYPE DeInitFilter();
+		FilterBufRetCode FilterOneBuffer();
+		OMX_ERRORTYPE GetReturnedInputDataPtr(OMX_PTR* ppInput);
+		OMX_ERRORTYPE GetOutputBuffer(OMX_PTR *ppBuffer);
+		OMX_ERRORTYPE GetOutputBuffer(OMX_PTR *ppBuffer,OMX_S32* pOutSize);
+		OMX_ERRORTYPE FlushInputBuffer();
+		OMX_ERRORTYPE FlushOutputBuffer();
+
+		OMX_PTR AllocateInputBuffer(OMX_U32 nSize);	//implement this api to support direct input
+		OMX_ERRORTYPE FreeInputBuffer(OMX_PTR pBuffer);
+		OMX_PTR AllocateOutputBuffer(OMX_U32 nSize);
+		OMX_ERRORTYPE FreeOutputBuffer(OMX_PTR pBuffer);		
+
+		//OMX_ERRORTYPE GetOutputBufferSize(OMX_S32 *pOutSize);
+
+		OMX_ERRORTYPE PreThreadRun();
+		OMX_ERRORTYPE PreThreadStop();
+		OMX_ERRORTYPE PreThreadFlushInput();
+		OMX_ERRORTYPE PreThreadFlushOutput();
+};
+
+#endif	// #ifdef VpuEncoder_h
+/* File EOF */
+
diff --git a/OpenMAXIL/src/component/vpu_wrapper/Android.mk b/OpenMAXIL/src/component/vpu_wrapper/Android.mk
new file mode 100755
index 0000000..feda8fe
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_wrapper/Android.mk
@@ -0,0 +1,29 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+## ifeq ($(TARGET_BOARD_PLATFORM), imx6)
+## LOCAL_SRC_FILES := vpu_wrapper_imx6.c
+## else
+LOCAL_SRC_FILES := vpu_wrapper.c
+## endif
+
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) \
+
+LOCAL_MODULE:= lib_vpu_wrapper
+
+
+LOCAL_SHARED_LIBRARIES := libutils libc libm libstdc++ libvpu \
+    			  lib_omx_osal_v2_arm11_elinux
+
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+
+endif
diff --git a/OpenMAXIL/src/component/vpu_wrapper/makefile b/OpenMAXIL/src/component/vpu_wrapper/makefile
new file mode 100755
index 0000000..0de3dc1
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_wrapper/makefile
@@ -0,0 +1,102 @@
+
+PROGRAM=test_dec_arm_elinux
+ENC_PROGRAM=test_enc_arm_elinux
+ENC_AUTO_TEST=enc_auto_test
+LIB=lib_vpu_wrapper
+LIBRARY=../../release/lib/$(LIB)
+SQLITE_LIBRARY=./sqlite/libsqlite3
+
+VERSION = .1.0
+
+ifeq ($(BUILD),CROSSBUILD)
+
+TOOLS_DIR=/opt/freescale/usr/local/gcc-4.4.4-glibc-2.11.1-multilib-1.0/arm-fsl-linux-gnueabi
+CC=$(TOOLS_DIR)/bin/arm-none-linux-gnueabi-gcc
+LN=$(TOOLS_DIR)/bin/arm-none-linux-gnueabi-gcc
+
+CFLAGS=-mcpu=arm1136j-s
+CFLAGS+=-O2 -Wall
+#CFLAGS+=-g
+AFLAGS=
+
+LFLAGS=-L$(TOOLS_DIR)/lib/gcc/arm-fsl-linux-gnueabi/4.4.4 -lpthread -lm -ldl
+LFLAGS+=-L../../../bsp_51/lib -lvpu -lipu
+LFLAGS_LIB=-L../../../bsp_51/lib -lvpu
+
+else
+
+CC=gcc
+LN=gcc
+AS=as
+AR=ar
+
+CFLAGS= -O2 -Wall
+#CFLAGS+=-g
+AFLAGS=
+
+LFLAGS=-L/usr/lib -lvpu -lipu -lpthread -lm -ldl
+LFLAGS_LIB=-L/usr/lib -lvpu
+
+endif
+
+INCLUDES= -I. -I../../ghdr -I../../../bsp_51/include -I/usr/include -I./sqlite
+
+
+#CFLAGS+=-DUSE_VPU_WRAPPER_TIMER
+#CFLAGS+=-DVPU_WRAPPER_DEBUG
+CFLAGS+=-DDEC_STREAM_DEBUG
+CFLAGS+=-DENC_STREAM_DEBUG
+CFLAGS+=-DAPP_DEBUG
+CFLAGS+=-DFB_RENDER_DEBUG
+
+#CFLAGS+=-DUSER_SPECIFY_BINARY_VER -DSTR_USER_SPECIFY_BINARY_VER=\"binary version specified by user\"
+
+LIB_OBJS=vpu_wrapper_timer.o
+#ifeq ($(PLATFORM),IMX6)
+#LIB_OBJS+=vpu_wrapper_imx6.o
+#else
+LIB_OBJS+=vpu_wrapper.o
+#endif
+
+APP_OBJS=test_dec_arm_elinux.o decode_stream.o
+#APP_OBJS+=vpu_general_lib.o
+APP_OBJS+=fb_render.o
+
+ENC_APP_OBJS=test_enc_arm_elinux.o encode_stream.o
+ENC_AUTO_OBJS=enc_auto_test.o encode_stream.o decode_stream.o fb_render.o sqlite_wrapper.o
+
+all: EXE ENC_EXE ENC_AUTO_TEST
+	@echo "--- Build-all done for vpu wrapper ---"
+
+LIBRARY: $(LIB_OBJS)
+	$(AR) -r $(LIBRARY).a $(LIB_OBJS)
+	$(LN) -o $(LIBRARY).so $(LFLAGS_LIB) --shared -Wl,-soname,$(LIB).so$(VERSION) -fpic $(LIB_OBJS)
+
+EXE: $(APP_OBJS) LIBRARY
+	$(LN) -o $(PROGRAM) $(LFLAGS) $(APP_OBJS) $(LIBRARY).a
+
+ENC_EXE: $(ENC_APP_OBJS) LIBRARY
+	$(LN) -o $(ENC_PROGRAM) $(LFLAGS) $(ENC_APP_OBJS) $(LIBRARY).a
+
+ENC_AUTO_TEST: $(ENC_AUTO_OBJS) LIBRARY
+	$(LN) -o $(ENC_AUTO_TEST) $(LFLAGS) $(ENC_AUTO_OBJS) $(LIBRARY).a $(SQLITE_LIBRARY).a
+
+%.o: %.c
+	$(CC) $(CFLAGS) $(INCLUDES)  -c  -o $@ $<
+
+#%.o: %.s
+#	$(AS) $(AFLAGS) -o $@ $<
+
+
+clean:
+	rm -rf $(LIB_OBJS)
+	rm -rf $(APP_OBJS)	
+	rm -rf $(ENC_APP_OBJS)
+	rm -rf $(ENC_AUTO_OBJS)
+	rm -rf $(LIBRARY).a
+	rm -rf $(LIBRARY).so
+	rm -rf $(PROGRAM)
+	rm -rf $(ENC_PROGRAM)	
+	rm -rf $(ENC_AUTO_TEST)
+
+	
diff --git a/OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.c b/OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.c
new file mode 100755
index 0000000..c62a000
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.c
@@ -0,0 +1,8707 @@
+/*
+ *  Copyright (c) 2010-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ *	Vpu_wrapper.c
+ *	vpu wrapper file contain all related vpu api exposed to application
+ *	History :
+ *	Date	(y.m.d)		Author			Version			Description
+ *	2010-09-07		eagle zhou		0.1				Created
+ *	2011-12-22		eagle zhou		1.0				refine
+ */
+
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+
+#include "vpu_lib.h"
+#include "vpu_io.h"
+#include "vpu_wrapper.h"
+
+#define DIVX_WARNING_LOG	//always prompt warning info when find divx format !!!!
+#ifdef DIVX_WARNING_LOG
+#ifdef ANDROID_BUILD
+#include "Log.h"
+#define LOG_DIVX_WARNING LogOutput
+#else
+#define LOG_DIVX_WARNING printf
+#endif
+#else
+#define LOG_DIVX_WARNING(...)
+#endif
+
+#ifdef USE_VPU_WRAPPER_TIMER
+#include "vpu_wrapper_timer.h"
+#define TIMER_INIT				timer_init()
+#define TIMER_MARK(id)			timer_mark(id)
+#define TIMER_START(id)			timer_start(id)
+#define TIMER_STOP(id)			timer_stop(id)
+#define TIMER_MARK_REPORT(id)	timer_mark_report(id)
+#define TIMER_REPORT(id)			timer_report(id)
+#else
+#define TIMER_INIT				
+#define TIMER_MARK(id)			
+#define TIMER_START(id)			
+#define TIMER_STOP(id)			
+#define TIMER_MARK_REPORT(id)	
+#define TIMER_REPORT(id)			
+#endif
+
+#define TIMER_MARK_GETOUTPUT_ID		(0)
+#define TIMER_CLEARDISP_ID				(0)
+
+
+//#define VPU_DEC_PIPELINE
+#define VPU_DEC_CHECK_INIT_LENGTH		//VPU limitation of minimum size 512 before seq init ?
+#define VPU_ONE_EOS
+#define VPU_SUPPORT_UNCLOSED_GOP		// for unclosed gop case:(1) drop B frames whose reference are missing (2) drop non-I frame after flushing
+#define VPU_PROTECT_MULTI_INSTANCE	// for stream mode, we need to add protection for (startoneframe()--check busy/wait interrupt--getoutput()) to avoid hangup
+//#define VPU_DEBUG_BS
+//#define VPU_DEC_FILE_MODE				// default, using file mode for all codecs
+#define VPU_IFRAME_SEARCH				// for file mode, we need to enable iframesearch to clear buffer: to implement seek(flush) feature: (3) skipping decoding until key frame
+										//In fact, (2)=(1)+(3)
+#define VPU_FILEMODE_QUICK_EXIT		// for vc1 complexity, vpu_DecSetEscSeqInit() will cost some time, so we return error directly for file mode, but not check the loop count
+										//for example: wmv9_CP_240x180_26fps_263kbps_vc1.cmplx.wmv
+#define VPU_AVOID_DEAD_LOOP			// avoid dead loop, cover: seqinit step; decode step
+										//for example: mp4v_mp3_mp3audio_4567_50_100_10_20.mp4
+#define VPU_FILEMODE_WORKAROUND		//add some work around for file mode: H.264/H.263/Mpeg2/Mpeg4/DivX456/XVID
+#define VPU_SUPPORT_NO_ENOUGH_FRAME	//avoid hang when no enough frame buffer
+#define VPU_VC1_AP_SKIP_WORKAROUND	//work around for skip frame(VC1), vpu may output one frame which has not been released, now, we simply drop this frame; clip: Test_1440x576_WVC1_6Mbps.wmv
+#define VPU_INIT_FREE_SIZE_LIMITATION	//after the first init step, rd may exceed wr (can no occur at decode state), for example, WR+8, but RD+512, As result, free size is not enough when try the second init. But in fact, we can ignore the info
+										//for example: Divx5_640x480_23.976_1013_a_mp3_48_158_2_1st-key-frame-is-the-2nd-frame_11.Search-for-the-Full-Moon-02.avi
+#define VPU_FILEMODE_INTERLACE_WORKAROUND		//for interlaced clips: If user feed two fields seperately, and vpu action is: return valid for the first field, and return invalid for the second field. So we need to drop the second field and notify user get one timestamp
+#define VPU_FILEMODE_CORRUPT_WORKAROUND	//for some corrupt clips(h264_P_B1.3_25.0fps_730k_320x240_aac_48KHz_128Kbps_c2_3min3s_Tomsk_iPod.mp4)
+											//vpu return dexindex=-2, dispindex=-3 even data length !=0
+#define VPU_SUPPORT_NO_INBUF		//no enough input buffer: to avoid null run
+#define VPU_FAKE_FLUSH				//for debug flush mode
+#define VPU_FILEMODE_PBCHUNK_FLUSH_WORKAROUND	//if flush is called between PB chunk(need to feed to vpu twice), the pb state is not cleared by vpu.
+													//as result, the following key frame will be regarded as B frame and the output is wrong until next key frame.
+													//video may be freeze after seek when VPU_SUPPORT_UNCLOSED_GOP is enabled:Xvid_SP1_640x480_23.98_655_aaclc_44_2_test.mkv(the first interval of key frame is about 6s)
+#define VPU_FLUSH_BEFORE_DEC_WORKAROUND		//for vpu, below case need to be avoided, eg. should not update 0 after register frame immediately
+													//register frame -> update 0 -> get EOS -> update non-0 -> always return EOS even data is valid
+//#define VPU_SEEK_ANYPOINT_WORKAROUND	//unrecoverable mosaic may be introduced by random seek point(mainly for H.264??), so we need to call some related flush operation.
+//#define VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE	//for interlaced clips: we should make sure the skipmode for two field are the same, to avoid mosaic and hangup issues
+											//it is mainly for skip B  strategy (performance issue): so we only consider skipframeMode
+//#define VPU_FILEMODE_MERGE_INTERLACE_DEBUG		//in file mode, it is unstable that feeding two fields seperately. So we make some effort to merge two fields into one frame
+#define VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE	//for field decoding: move "pop of timestampe" from decode order to display order
+													//for some interlaced clips with deep dpb, original design may introduce much bigger timestamp(about 0.5 seconds): technicolor/332_dec.ts
+#define VPU_NOT_RETURN_ALLBUF_AFTER_FLUSH	//we don't want to return all frame buffers after flush operation
+#define VPU_IMX6_VC1AP_RANGEMAP_BUF_WORKAROUND  //some buffers ared used for rangmap, and the buffer numbers will be accumulated for every flush operation. so we need to clear them explicitly after every flush operation
+#define VPU_IMX6_MULTIINSTANCE_FRAMESTART_WORKAROUND //for multi-instance, frame start may point to memory space in another instance.
+
+#define VPU_ENC_OUTFRAME_ALIGN	//vpu limitation: 4(or 8?) bytes alignment for output frame address
+#define VPU_ENC_GUESS_OUTLENGTH	//no size in SetOutputBuffer(), so we guess one value
+//#define VPU_ENC_ALIGN_LIMITATION	//vpu encoder has 16 pixels alignment limitation: vpu will cut down to 16-aligned pixels automatically
+#define VPU_ENC_SEQ_DATA_SEPERATE	//output sequence header and data seperately, otherwise, only our vpu decoder can play it
+
+#define VPU_FILEMODE_MERGE_FLAG	1
+
+//#define VPU_USE_UNSPECIFIED_RATIO  //added for special case
+
+//#define VPU_BACKDOOR	//use some special backdoor
+#ifdef VPU_BACKDOOR
+#define IMX6Q	//only for compiler vpu_reg.h
+#include "vpu_util.h"
+#endif
+
+static int nVpuLogLevel=0;		//bit 0: api log; bit 1: raw dump; bit 2: yuv dump 
+#ifdef ANDROID_BUILD
+#include "Log.h"
+#define LOG_PRINTF LogOutput
+#define VPU_LOG_LEVELFILE "/data/vpu_log_level"
+#define VPU_DUMP_RAWFILE "/data/temp_wrapper.bit"
+#define VPU_DUMP_YUVFILE "/data/temp_wrapper.yuv"
+#else
+#define LOG_PRINTF printf
+#define VPU_LOG_LEVELFILE "/etc/vpu_log_level"
+#define VPU_DUMP_RAWFILE "temp_wrapper.bit"
+#define VPU_DUMP_YUVFILE "temp_wrapper.yuv"
+#endif
+typedef unsigned int UINT32;
+
+#define MAX_YUV_FRAME  (1000)
+#define DUMP_ALL_DATA		1
+static int g_seek_dump=DUMP_ALL_DATA;	/*0: only dump data after seeking; otherwise: dump all data*/
+
+//#define VPU_WRAPPER_DEBUG
+
+#define VPU_LOG(...)
+#define VPU_TRACE
+#define VPU_API(...) if(nVpuLogLevel&0x1) {LOG_PRINTF(__VA_ARGS__);}
+#define VPU_ERROR(...) if(nVpuLogLevel&0x1) {LOG_PRINTF(__VA_ARGS__);}
+#define VPU_ENC_API(...) if(nVpuLogLevel&0x1) {LOG_PRINTF(__VA_ARGS__);}
+#define VPU_ENC_LOG(...)
+#define VPU_ENC_ERROR(...) if(nVpuLogLevel&0x1) {LOG_PRINTF(__VA_ARGS__);}
+#define ASSERT(exp) if((!(exp))&&(nVpuLogLevel&0x1)) {LOG_PRINTF("%s: %d : assert condition !!!\r\n",__FUNCTION__,__LINE__);}
+
+#define VPU_DUMP_RAW  (nVpuLogLevel&0x2)
+#define VPU_DUMP_YUV  (nVpuLogLevel&0x4)
+
+//#define VPU_RESET_TEST		//avoid reset board for every changing to FW
+
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+#define MIN_REF_CNT			1			// ref number before B frame: it is display order, but not decode order !!!
+#define MAX_DROPB_CNT		5			// maxium continuous dropping B frames number: avoid freeze for closed gop (I B B B B B B B B... B EOS) 
+#define MIN_KEY_CNT			1			// key number before the first non-I frame: display order
+#define DIS_DROP_FRAME					// to avoid seek timeout , decoder need to output one valid buffer, but not drop frame automaticaly
+#endif
+
+#define vpu_memset	memset
+#define vpu_memcpy	memcpy
+#define vpu_malloc	malloc
+#define vpu_free		free
+
+#ifdef NULL
+#undef NULL
+#define NULL 0
+#endif
+
+#define USE_NEW_VPU_API	//api change for vp8
+
+#if 1	//for iMX6 
+//#define IMX6_MULTI_FORMATS_WORKAROUND	//need to reset to decoder different formats: such VC1 followed by Mpeg2
+//#define IMX6_SKIPMODE_WORKAROUND_FILL_DUMMY
+#define IMX6_RANGEMAP_WORKAROUND_IGNORE
+//#define IMX6_LD_BUG_WORKAROUND	 //1 for iMX6 compiler : ld (2.20.1-system.20100303) bug ??	
+//#define IMX6_PIC_ORDER_WORKAROUND	//fixed for 6_Gee_HD.avi
+//#define IMX6_BUFNOTENOUGH_WORKAROUND	//when buffer is not enough, vpu may return dispIndex=-1(EOS) directly, but not decIndex=-1
+//#define IMX6_INTER_DEBUG_RD_WR	//internal debug: rd wr register
+//#define IMX6_INTER_DEBUG	//internal debug
+//#define IMX6_BITBUFSPACE_WORKAROUND	//the free sapce may be not correct for FW version 2.1.3 or later
+#define IMX6_WRONG_EOS_WORKAROUND //for mpeg4, vpu may report disIndx=-1(EOS) in the middle of clip after seeking
+#define IMX6_VP8_SHOWFRAME_WORKAROUND //for special frame(show_frame=0) in vpu8, buffer may be decoded repeatedly, as a result, timestamp will be accumulated
+#define IMX6_AVC_NOFRAME_WORKAROUND //for h.264 clips, vpu may report no frame buffer before decoding the first frame(frames are just registered to vpu)
+#endif
+/****************************** cpu version ***************************************/
+#define CPU_IS_MX5X  cpu_is_mx5x
+#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,4,0))
+#define CPU_IS_MX6X cpu_is_mx6x
+#else
+#define CPU_IS_MX6X  cpu_is_mx6q
+#endif
+/****************************** binary version info *********************************/
+#define SEPARATOR " "
+#define BASELINE_SHORT_NAME "VPUWRAPPER_ARM"
+#define OS_NAME "_LINUX"
+ 
+#define VPUWRAPPER_BINARY_VERSION_STR \
+    (BASELINE_SHORT_NAME OS_NAME \
+     SEPARATOR "Build on" \
+     SEPARATOR __DATE__ SEPARATOR __TIME__)
+/****************************** decoder part **************************************/
+
+#define VPU_MEM_ALIGN			0x8
+#define VPU_TILE_ALIGN			(4096)	//tile format: Y(or CbCr) address alignment limitation: bytes
+#if 1 //for iMX6 stream mode
+#define VPU_BITS_BUF_SIZE		(3*1024*1024)		//bitstream buffer size : big enough contain two big frames
+#else
+#define VPU_BITS_BUF_SIZE		(1024*1024)
+#endif
+#define VPU_SLICE_SAVE_SIZE	0x17E800		//worst slice buffer size: 1920*1088*1.5/2= 1.5MB
+#define VPU_PS_SAVE_SIZE		0x80000
+#define VPU_VP8_MBPARA_SIZE	0x87780			//68 * (1920 * 1088 / 256)=0x87780;
+
+#define VPU_MIN_INIT_SIZE		(512)			//min required data size for seq init
+#define VPU_MIN_DEC_SIZE		(64*1024)		//min required data size for decode
+
+#ifdef VPU_AVOID_DEAD_LOOP
+#define VPU_MAX_INIT_SIZE		(VPU_BITS_BUF_SIZE-256*1024)		//avoid dead loop for unsupported clips
+#define VPU_MAX_INIT_LOOP		(500)				//avoid dead loop for crashed files, including null file
+
+#define VPU_MAX_DEC_SIZE		(200*1024*1024)//(8*1024*1024)	//avoid dead loop in decode state for corrupted clips
+#define VPU_MAX_DEC_LOOP		(4000)			//avoid dead loop in decode state for corrupted clips
+#endif
+
+#define VPU_TIME_OUT			(200)			//used for flush operation: wait time
+#define VPU_MAX_TIME_OUT_CNT	(10)				//used for flush operation: max counts
+#define VPU_MAX_EOS_DEAD_LOOP_CNT	(20)			//used for flush operation
+#define VPU_MAX_FRAME_INDEX	30
+
+#define VPU_MIN_UINT_SIZE		(512)			//min required data size for vpu_DecStartOneFrame()
+
+#define VIRT_INDEX	0
+#define PHY_INDEX	1
+
+#define VPU_POLLING_TIME_OUT			(10)		//used for normal decode
+#define VPU_POLLING_MIN_TIME_OUT		(1)		//used for normal decode: use it when vpu is not busy
+#define VPU_MAX_POLLING_BUSY_CNT		(200)	//used for normal decode: max counts 
+
+#define VPU_POLLING_PRESCAN_TIME_OUT			(500)	//used for prescan mode
+#define VPU_MAX_POLLING_PRESCAN_BUSY_CNT	(4)		//used for prescan mode: max counts 
+
+#define VPU_OUT_DEC_INDEX_NOMEANING	-4	//unmeaning value: it is not defined by vpu
+#define VPU_OUT_DEC_INDEX_UNDEFINE	-3
+#define VPU_OUT_DEC_INDEX_UNDEC		-2
+#define VPU_OUT_DEC_INDEX_EOS			-1
+#define VPU_OUT_DIS_INDEX_NODIS		-3
+#define VPU_OUT_DIS_INDEX_NODIS_SKIP	-2
+#define VPU_OUT_DIS_INDEX_EOS			-1
+
+#define VPU_FRAME_STATE_FREE			0	//clear them by memset() at init step
+#define VPU_FRAME_STATE_DEC			1	//decoded by vpu, but not send out
+#define VPU_FRAME_STATE_DISP			2	//send out by vpu for display
+
+#define MemAlign(mem,align)	((((unsigned int)mem)%(align))==0)
+#define MemNotAlign(mem,align)	((((unsigned int)mem)%(align))!=0)
+
+#define NotEnoughInitData(free)	(((VPU_BITS_BUF_SIZE)-(free))<(VPU_MIN_INIT_SIZE))
+#define NotEnoughDecData(free,min_validsize)	(((VPU_BITS_BUF_SIZE)-(free))<(min_validsize))
+
+#define VC1_MAX_SEQ_HEADER_SIZE	256		//for clip: WVC1_stress_a0_stress06.wmv, its header length = 176 (>128)
+#define VC1_MAX_FRM_HEADER_SIZE	32
+#define VP8_SEQ_HEADER_SIZE	32
+#define VP8_FRM_HEADER_SIZE	12
+#define DIV3_SEQ_HEADER_SIZE	32
+#define DIV3_FRM_HEADER_SIZE	12
+#define RCV_HEADER_LEN			24
+#define RCV_CODEC_VERSION		(0x5 << 24) //FOURCC_WMV3_WMV
+#define RCV_NUM_FRAMES			0xFFFFFF
+#define RCV_SET_HDR_EXT		0x80000000
+#define VC1_IS_NOT_NAL(id)		(( id & 0x00FFFFFF) != 0x00010000)
+
+#define AVC_IS_IDR(type)		(0==((type)&0x1))	//bit[0]==0
+#define AVC_IS_ISLICE(type)	((1==((type)&0x1))&&(0==((type)&0x6))) //bit[0]==1 && bit[2:1]==0
+#define AVC_IS_PSLICE(type)	((1==((type)&0x1))&&(2==((type)&0x6))) //bit[0]==1 && bit[2:1]==1
+#define AVC_IS_BSLICE(type)	((1==((type)&0x1))&&((4==((type)&0x6))||(6==((type)&0x6)))) //bit[0]==1 && bit[2:1]==2 or 3
+
+#define FRAME_IS_REF(type)	((type==VPU_IDR_PIC)||(type==VPU_I_PIC)||(type==VPU_P_PIC)||(type==VPU_UNKNOWN_PIC))
+#define FRAME_IS_B(type)	((type==VPU_B_PIC))
+#define FRAME_IS_KEY(type)	((type==VPU_IDR_PIC)||(type==VPU_I_PIC))
+#define FRAME_ISNOT_KEY(type)	((type!=VPU_IDR_PIC)&&(type!=VPU_I_PIC))
+
+#if 1
+#define FRAME_START_OFFSET	0	//start regiter point to : frame start
+#define FRAME_END_OFFSET		1	//end register point to : frame end + 1 
+#else
+#define FRAME_START_OFFSET	1	//start regiter point to : frame start -1
+#define FRAME_END_OFFSET		0	//end register point to : frame end
+#endif
+
+/*
+for stream: WVC1_stress_NoAudio_intensitycomp.wmv, the first frame(two fields) is defined as I/P
+here, we loose the rule and regard the frame as I frame for those P/I and I/P.
+VC1-AP frame type:(it is not totally defined by specifiction, refer to table 105)
+	Bot	0	1	2	3	4	5	6	7
+Top		I	P	BI	B	SKIP	*	*	*
+0	I	I	I	*	*	*	*	*	*
+1	P	I	P	*	*	*	*	*	*
+2	BI	*	*	BI	B	*	*	*	*
+3	B	*	*	B	B	*	*	*	*
+4	SKIP*	*	*	*	SKIP*	*	*
+5	*	*	*	*	*	*	*	*	*
+6	*	*	*	*	*	*	*	*	*
+7	*	*	*	*	*	*	*	*	*
+*/
+
+static VpuPicType g_VC1APPicType[8][8]={
+{VPU_I_PIC,VPU_I_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+{VPU_I_PIC,VPU_P_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+{VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_BI_PIC,VPU_B_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+{VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_B_PIC,VPU_BI_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+
+{VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_SKIP_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+{VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+{VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC},
+{VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC,VPU_UNKNOWN_PIC}
+};
+
+typedef enum
+{
+	VPU_DEC_STATE_OPEN=0,
+	VPU_DEC_STATE_INITOK,
+	VPU_DEC_STATE_REGFRMOK,
+	VPU_DEC_STATE_DEC,
+	VPU_DEC_STATE_STARTFRAMEOK,	/*it is used for non-block mode*/
+	VPU_DEC_STATE_OUTOK,
+	VPU_DEC_STATE_EOS,
+	VPU_DEC_STATE_RESOLUTION_CHANGE,
+	VPU_DEC_STATE_CORRUPT,
+}VpuDecState;
+
+typedef struct
+{
+	int picType;
+	int idrFlag;				/*for iMX6X*/
+	int topFieldFirst;
+	int repeatFirstField;
+	int pFrameInPBPacket;	/*P frame in [P,B] chunk*/
+	int consumedBytes;	/*record frame length*/
+	VpuFieldType	eFieldType;
+	int viewID;	/*MVC: view id*/
+	int width;
+	int height;
+	VpuRect frameCrop;
+	unsigned int Q16ShiftWidthDivHeightRatio;
+}VpuFrameBufInfo;
+
+typedef struct
+{
+	/* open parameters */
+	VpuCodStd CodecFormat;
+	//int blockmode;
+
+	/* decode parameters */
+	int streamBufDelaySize;	/*unit: bytes. used in stream mode:  valid data size should reach the threshold before decoding*/
+	int iframeSearchEnable;
+	int skipFrameMode;
+	int skipFrameNum;
+	int inputType;			/*normal, kick, drain(EOS)*/
+
+	/* init info */
+	VpuDecInitInfo initInfo;
+	
+	/* out frame info */
+	VpuDecOutFrameInfo frameInfo;
+
+	/* frame buffer management */
+	int frameNum;
+	VpuFrameBuffer frameBuf[VPU_MAX_FRAME_INDEX];	 /*buffer node*/
+	VpuFrameBufInfo   frameBufInfo[VPU_MAX_FRAME_INDEX];  /*info required by user*/
+	int frameBufState[VPU_MAX_FRAME_INDEX];  /*record frame state for clearing display frame(if user forgot to clear them)*/
+
+	/* bitstream buffer pointer info */
+	unsigned char* pBsBufVirtStart;
+	unsigned char* pBsBufPhyStart;
+	unsigned char* pBsBufPhyEnd;
+	//unsigned char* pBsBufPhyWritePtr;
+
+	/* avc slice/ps buffer*/
+	unsigned char* pAvcSlicePhyBuf;
+	unsigned char* pAvcSPSPhyBuf;	/*vpu may write sps/pps info into this buffer */
+
+	/* */
+
+	/* state */
+	VpuDecState state;
+
+	/* historical info */
+	VpuFrameBuffer * pPreDisplayFrameBuf;
+	//VpuFrameBuffer * pPreDecodedFrameBuf;
+
+	int nPrivateSeqHeaderInserted;
+
+	/*resolution for some special formats, such as package VC1 header,...*/
+	int picWidth;
+	int picHeight;
+
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+	//(1) drop B frame
+	int refCnt;	//IDR/I/P
+	int dropBCnt;
+	//(2) drop non-I frame
+	int keyCnt;	//IDR/I
+#endif
+//#ifdef VPU_IFRAME_SEARCH
+	int keyDecCnt;	//IDR/I: it is in decode order, not like keyCnt
+	int iframesearch_allowed;    //iMX6: enable, iMX5: disable
+//#endif
+	int fake_flush;	//iMX6: enable, iMX5: disable
+
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+	int seekKeyLoc;	/*I/IDR location: it is decode order, similar with keyDecCnt*/
+	int recommendFlush;	/*recommend user call flush to clear some related internal state in vpu*/
+#endif
+
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+	int dataUsedInFileMode;	//in file mode, avoid copy data repeatedly
+	int lastDatLenInFileMode;	//record the last data length
+	int lastConfigMode;		//protection for PB: use same skipmode for PB chunk
+#endif
+	int filemode;	/*now, for DivX3, VC1, RV*/
+	int firstData;	/*for file mode: we need to send the first data to seqinit and startoneframe seperately */
+	int firstDataSize; /*data length for the first data*/
+#ifdef VPU_PROTECT_MULTI_INSTANCE
+	int filledEOS;	/* have vpu_DecUpdateBitstreamBuffer(handle,0) */
+#endif	
+	int pbPacket;/*divx PB chunk*/
+	int pbClips;	/*for PB clips, skipmode will introduce problem*/
+
+#ifdef VPU_FLUSH_BEFORE_DEC_WORKAROUND
+	int realWork;	/*will be set 1 if only vpu_DecGetOutputInfo() is called*/
+#endif
+
+#ifdef VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE
+	int firstFrameMode;	/*record the skip frame mode for first field*/
+	int fieldCnt;			/*first field decoded: 1; second field decoded: 0;*/						
+#endif
+
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+	int needMergeFields;	/*1: need merge; 0: needn't merge*/
+	int lastFieldOffset;	/*record the length of first field*/
+#endif
+
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+	int fieldDecoding;	/*two fields are feed to vpu seperately*/
+	int oweFieldTS;		/*the number of fields whose timestamp still not be popped*/
+#endif
+
+	int mjpg_frmidx;	/*for mjpg output frame*/
+	FrameBuffer vpu_regframebuf[VPU_MAX_FRAME_INDEX];	/*we need to record it for mjpg's frame management*/
+	int mjpg_linebuffmode;  /*for iMX6: 1: line buffer mode; 0: non-line buffer mode*/
+
+	/*tile setting*/
+	int nMapType;
+	int nTiled2LinearEnable;
+
+	/*used to store extended frame info*/
+	VpuFrameExtInfo frmExtInfo;
+
+	/*management of consumed bytes: used to sync with frame boundary*/
+	int nDecFrameRptEnabled;			/*1:support frame reported; 0: not support*/
+	int nAccumulatedConsumedStufferBytes;/*stuffer size between frames: if it <0, indicate that some frames are contained in config data*/
+	int nAccumulatedConsumedFrmBytes;	/*frame size: >=0*/
+	int nAccumulatedConsumedBytes;		/*it should match with the input data size == nAccumulatedConsumedStufferBytes+nAccumulatedConsumedFrmBytes*/	
+	VpuFrameBuffer* pLastDecodedFrm;	/*the nearest decoded frame*/
+	int nAdditionalSeqBytes;				/*seq header inserted by wrapper itself , or config data */
+	int nAdditionalFrmHeaderBytes; 		/*frame header inserted by wrapper itself */
+	unsigned int nLastFrameEndPosPhy;	/*point to the previous frame tail: used to compute the stuff data length between frames*/
+
+	/*profile/level info*/
+	int nProfile;
+	int nLevel;
+
+	/*resolution change*/
+	int nDecResolutionChangeEnabled;		/*1: support resolution change notification; 0: not support*/
+	int nOriWidth;	/*set in seqinit stage*/
+	int nOriHeight;	/*set in seqinit stage*/
+	int nResolutionChanged;	/*resolution change happen: checked in decoded stage*/
+	unsigned char* pSeqBak;	/*backup the sequence data*/
+	int nSeqBakLen;
+	DecOpenParam sDecOpenParam; /*backup the open parameters*/
+
+	int initDataCountThd;
+	VpuDecErrInfo nLastErrorInfo;  /*it record the last error info*/
+
+	int nIsAvcc;	/*only for H.264 format*/
+	int nNalSizeLen;
+}VpuDecObj;
+
+typedef struct 
+{
+	DecHandle handle;
+	VpuDecObj obj;
+}VpuDecHandleInternal;
+
+#ifdef VPU_BACKDOOR
+int VpuLogClearFlag(DecHandle nInHandle)
+{
+	int val,reg;
+	CodecInst *pCodecInst;
+	pCodecInst = nInHandle;
+	reg=VpuReadReg(BIT_FRM_DIS_FLG);
+	val=pCodecInst->ctxRegs[CTX_BIT_FRM_DIS_FLG];
+	printf("vpu frame buffer clear flag: 0x%X, clear reg: 0x%X \r\n",val,reg);
+	return 1;
+}
+int VpuVerifyClearFlag(DecHandle nInHandle,VpuDecObj* pObj)
+{
+	CodecInst *pCodecInst;
+	int val;
+	int i,state;
+	pCodecInst = nInHandle;
+	val=pCodecInst->ctxRegs[CTX_BIT_FRM_DIS_FLG];
+	VPU_LOG("vpu frame buffer clear flag: 0x%X \r\n",val);
+	for(i=0;i<pObj->frameNum;i++)
+	{
+		/*
+		0: is cleared
+		1: is decoded(may already output to user or not)
+		*/
+		state=(1 << i) &val;
+		state=(state==0)?VPU_FRAME_STATE_FREE:(VPU_FRAME_STATE_DEC|VPU_FRAME_STATE_DISP);
+		if((VPU_FRAME_STATE_FREE==pObj->frameBufState[i])&&(state!=VPU_FRAME_STATE_FREE))
+		{
+			//user has clear it, but vpu hasn't clear it
+			VPU_ERROR("the state for buffer %d is not correct!!!, should be cleared \r\n",i);
+		}
+		else if((VPU_FRAME_STATE_FREE!=pObj->frameBufState[i])&&(state==VPU_FRAME_STATE_FREE))
+		{
+			//user hasn't clear it, but vpu has cleared it.
+			VPU_ERROR("the state for buffer %d is not correct!!!, shouldn't be cleared \r\n",i);
+		}
+	}	
+	return 1;
+}
+int VpuSetClearFlag(DecHandle nInHandle,VpuDecObj* pObj,int nIndex)
+{
+	CodecInst *pCodecInst;
+	int val;
+	pCodecInst = nInHandle;
+	printf("reset flag: bufer index: %d \r\n",nIndex);
+	val=pCodecInst->ctxRegs[CTX_BIT_FRM_DIS_FLG];	
+	pCodecInst->ctxRegs[CTX_BIT_FRM_DIS_FLG]=(1<<nIndex)|val;
+	return 1;
+}
+#endif
+
+#ifdef VPU_WRAPPER_DEBUG
+void printf_memory(unsigned char* addr, int width, int height, int stride)
+{
+	int i,j;
+	unsigned char* ptr;
+
+	ptr=addr;
+	VPU_LOG("addr: 0x%X \r\n",(unsigned int)addr);
+	for(i=0;i<height;i++)
+	{
+		for(j=0;j<width;j++)
+		{
+			VPU_LOG("%2X ",ptr[j]);         
+		}
+		VPU_LOG("\r\n");
+		ptr+=stride;
+	}
+	VPU_LOG("\r\n");	
+	return;
+}
+#endif
+
+void WrapperFileDumpBitstrem(FILE** ppFp, unsigned char* pBits, unsigned int nSize)
+{
+	int nWriteSize=0;
+	if(nSize==0)
+	{
+		return;
+	}
+
+	if (0==g_seek_dump) return;
+	
+	if(*ppFp==NULL)
+	{
+		*ppFp=fopen(VPU_DUMP_RAWFILE,"wb");
+		if(*ppFp==NULL)
+		{
+			VPU_LOG("open %s failure \r\n",VPU_DUMP_RAWFILE);
+			return;
+		}
+		VPU_LOG("open %s OK \r\n",VPU_DUMP_RAWFILE);
+	}
+
+	nWriteSize=fwrite(pBits,1,nSize,*ppFp);
+	fflush(*ppFp);
+	return;
+}
+
+void WrapperFileDumpYUV(FILE** ppFp, unsigned char*  pY,unsigned char*  pU,unsigned char*  pV, unsigned int nYSize,unsigned int nCSize,int nColorfmt)
+{
+	static int cnt=0;
+	int nCScale=1;
+	int nWriteSize=0;
+	
+	switch(nColorfmt)
+	{
+		case 0:	//4:2:0
+			nCScale=1;
+			break;
+		case 1:	//4:2:2 hor
+		case 2:	//4:2:2 ver
+			nCScale=2;
+			break;
+		case 3:	//4:4:4
+			nCScale=4;
+			break;
+		case 4:	//4:0:0
+			nCScale=0;
+			break;
+		default:	//4:2:0
+			break;			
+	}	
+
+	if (0==g_seek_dump) return;
+	
+	if(*ppFp==NULL)
+	{
+		*ppFp=fopen(VPU_DUMP_YUVFILE,"wb");
+		if(*ppFp==NULL)
+		{
+			VPU_LOG("open %s failure \r\n",VPU_DUMP_YUVFILE);
+			return;
+		}
+		VPU_LOG("open %s OK \r\n",VPU_DUMP_YUVFILE);
+	}
+
+	if(cnt<MAX_YUV_FRAME)
+	{
+		nWriteSize=fwrite(pY,1,nYSize,*ppFp);
+		nWriteSize=fwrite(pU,1,nCSize*nCScale,*ppFp);
+		nWriteSize=fwrite(pV,1,nCSize*nCScale,*ppFp);
+		fflush(*ppFp);
+		cnt++;
+	}
+	
+	return;
+}
+
+int VpuLogLevelParse(int * pLogLevel)
+{
+	int level=0;
+	FILE* fpVpuLog;
+	fpVpuLog=fopen(VPU_LOG_LEVELFILE,"r");
+	if (NULL==fpVpuLog){
+		//LOG_PRINTF("no vpu log level file: %s \r\n",VPU_LOG_LEVELFILE);
+	}	
+	else	{
+		char symbol;
+		int readLen = 0;
+
+		readLen = fread(&symbol,1,1,fpVpuLog);
+		if(feof(fpVpuLog) != 0){
+			//LOG_PRINTF("\n End of file reached.");
+		}
+		else	{
+			level=atoi(&symbol);
+			//LOG_PRINTF("vpu log level: %d \r\n",level);
+			if((level<0) || (level>255)){
+				level=0;
+			}
+		}
+		fclose(fpVpuLog);
+	}
+	nVpuLogLevel=level;
+	//*pLogLevel=level;	
+	return 1;
+}
+
+
+int VpuTiledAddressMapping(int nInMapType,unsigned int nInYTop,unsigned int nInYBot,unsigned int nInCbTop,unsigned int nInCbBot,
+			unsigned int* pOutY, unsigned int* pOutCb,unsigned int* pOutCr)
+{
+	unsigned int lum_top_20bits,chr_top_20bits;
+	unsigned int lum_bot_20bits,chr_bot_20bits;
+	/*
+	* In tiled map format the construction of the buffer pointers is as follows:
+	* addrY [31:12]: lum_top_20bits
+	* addrY [11: 0], addrCb[31:24]: chr_top_20bits
+	* addrCb[23: 4]: lum_bot_20bits
+	* addrCb[ 3: 0], addrCr[31:16]: chr_bot_20bits
+	*/
+	lum_top_20bits=nInYTop>>12;
+	chr_top_20bits=nInCbTop>>12;
+
+	if(1==nInMapType)
+	{
+		//frame tile
+		ASSERT(nInYBot==0);
+		lum_bot_20bits=0;
+		chr_bot_20bits=0;
+	}
+	else
+	{
+		//field tile
+		ASSERT(nInYBot!=0);
+		ASSERT(0==(nInYBot&0xFFF));	//aligned with 4K(VPU_DEC_TILE_ALIGN)
+		lum_bot_20bits=nInYBot>>12;
+		chr_bot_20bits=nInCbBot>>12;
+	}
+	*pOutY=(lum_top_20bits<< 12) + (chr_top_20bits >> 8);
+	*pOutCb=(chr_top_20bits << 24) + (lum_bot_20bits << 4) + (chr_bot_20bits >> 16);
+	*pOutCr=chr_bot_20bits << 16;
+	return 1;
+}
+
+
+int VC1CreateNALSeqHeader(unsigned char* pHeader, int* pHeaderLen, 
+	unsigned char* pCodecPri,int nCodecSize, unsigned int* pData, int nMaxHeader)
+{
+	int nHeaderLen;
+	unsigned char temp[4]={0x00,0x00,0x01,0x0D};
+	nHeaderLen =nCodecSize -1;
+	if((4+nHeaderLen)>nMaxHeader)
+	{
+		//for case: WVC1_stress_a0_stress06.wmv: header size is 176, In fact, it is also OK if we only copy 128 bytes
+		nHeaderLen=nMaxHeader-4;
+		VPU_ERROR("error: header length %d overrun !!! \r\n",nCodecSize);
+	}
+	vpu_memcpy(pHeader, pCodecPri+1, nHeaderLen);
+
+	if(VC1_IS_NOT_NAL(pData[0]))
+	{
+		//insert 0x0000010D at the end of header 
+		vpu_memcpy(pHeader+nHeaderLen, temp, 4);
+		nHeaderLen += 4;
+	}
+
+	*pHeaderLen=nHeaderLen;
+
+	return 1;
+}
+
+int VC1CreateRCVSeqHeader(unsigned char* pHeader, int* pHeaderLen, 
+	unsigned char* pCodecPri,unsigned int nFrameSize,int nWidth,int nHeight)
+{
+	int nHeaderLen;
+
+	unsigned int nValue;
+	unsigned int HdrExtDataLen;
+	int i=0;
+	int profile;
+
+	nHeaderLen = RCV_HEADER_LEN;
+
+	//Number of Frames, Header Extension Bit, Codec Version
+	nValue = RCV_NUM_FRAMES | RCV_SET_HDR_EXT | RCV_CODEC_VERSION;
+	pHeader[i++] = (unsigned char)nValue;
+	pHeader[i++] = (unsigned char)(nValue >> 8);
+	pHeader[i++] = (unsigned char)(nValue >> 16);
+#if 0 //1 ???	
+	pHeader[i++] = 0xC5;
+#else
+	pHeader[i++] = (unsigned char)(nValue >> 24);
+#endif
+
+	//Header Extension Size
+	//ASF Parser gives 5 bytes whereas the VPU expects only 4 bytes, so limiting it
+	HdrExtDataLen = 4;
+	pHeader[i++] = (unsigned char)HdrExtDataLen;
+	pHeader[i++] = (unsigned char)(HdrExtDataLen >> 8);
+	pHeader[i++] = (unsigned char)(HdrExtDataLen >> 16);
+	pHeader[i++] = (unsigned char)(HdrExtDataLen >> 24);
+
+	profile=(*pCodecPri)>>4;
+	if((profile!=0)&&(profile!=4)&&(profile!=12))
+	{
+		VPU_ERROR("unsuport profile: %d, private: 0x%X \r\n",profile,*((unsigned int*)pCodecPri));
+	}
+	vpu_memcpy(pHeader+i, pCodecPri, HdrExtDataLen);
+	i += HdrExtDataLen;
+
+	//Height
+	pHeader[i++] = (unsigned char)nHeight;
+	pHeader[i++] = (unsigned char)(((nHeight >> 8) & 0xff));
+	pHeader[i++] = (unsigned char)(((nHeight >> 16) & 0xff));
+	pHeader[i++] = (unsigned char)(((nHeight >> 24) & 0xff));
+	//Width
+	pHeader[i++] = (unsigned char)nWidth;
+	pHeader[i++] = (unsigned char)(((nWidth >> 8) & 0xff));
+	pHeader[i++] = (unsigned char)(((nWidth >> 16) & 0xff)); 
+	pHeader[i++] = (unsigned char)(((nWidth >> 24) & 0xff));
+
+	//RCV2 ???
+	//nHeaderLen+=16;
+	//...
+	
+	//Frame Size
+	pHeader[i++] = (unsigned char)nFrameSize;
+	pHeader[i++] = (unsigned char)(nFrameSize >> 8);
+	pHeader[i++] = (unsigned char)(nFrameSize >> 16);
+#if 0	//1 ???
+	pHeader[i++] = (unsigned char)((nFrameSize >> 24));
+#else
+	pHeader[i++] = (unsigned char)((nFrameSize >> 24) | 0x80);
+#endif
+
+	*pHeaderLen=nHeaderLen;
+
+	return 1;
+}
+
+
+int VC1CreateNalFrameHeader(unsigned char* pHeader, int* pHeaderLen,unsigned int*pInData )
+{
+	unsigned int VC1Id;
+	VC1Id=*pInData;
+	if(VC1_IS_NOT_NAL(VC1Id))	
+	{
+		//need insert header : special ID
+		pHeader[0]=0x0;
+		pHeader[1]=0x0;
+		pHeader[2]=0x01;
+		pHeader[3]=0x0D;
+		*pHeaderLen=4;	
+	}
+	else
+	{
+		//need not insert header
+		//do nothing
+		*pHeaderLen=0;
+	}
+
+	return 1;
+}
+
+
+int VC1CreateRCVFrameHeader(unsigned char* pHeader, int* pHeaderLen,unsigned int nInSize )
+{
+	pHeader[0] = (unsigned char)nInSize;
+	pHeader[1] = (unsigned char)(nInSize >> 8);
+	pHeader[2] = (unsigned char)(nInSize >> 16);
+	pHeader[3] = (unsigned char)(nInSize >> 24);
+	*pHeaderLen=4;
+
+	return 1;
+}
+
+int VP8CreateSeqHeader(unsigned char* pHeader, int* pHeaderLen, 
+	unsigned int nTimeBaseDen,unsigned int nTimeBaseNum,unsigned int nFrameCnt,int nWidth,int nHeight)
+{
+	int i=0;
+
+	pHeader[i++] = 'D';
+	pHeader[i++] = 'K';
+	pHeader[i++] = 'I';
+	pHeader[i++] = 'F';
+	/*version*/
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+	/*headersize*/
+	pHeader[i++]=VP8_SEQ_HEADER_SIZE;
+	pHeader[i++]=0;
+	/*fourcc*/
+	pHeader[i++]='V';
+	pHeader[i++]='P';
+	pHeader[i++]='8';
+	pHeader[i++]='0';
+	/*width*/
+	pHeader[i++]=(unsigned char)nWidth;
+	pHeader[i++]=(unsigned char)(((nWidth >> 8) & 0xff));
+	/*height*/
+	pHeader[i++]=(unsigned char)nHeight;
+	pHeader[i++]=(unsigned char)(((nHeight >> 8) & 0xff));
+	/*rate*/
+	pHeader[i++] = (unsigned char)nTimeBaseDen;
+	pHeader[i++] = (unsigned char)(((nTimeBaseDen >> 8) & 0xff));
+	pHeader[i++] = (unsigned char)(((nTimeBaseDen >> 16) & 0xff));
+	pHeader[i++] = (unsigned char)(((nTimeBaseDen >> 24) & 0xff));
+	/*scale*/
+	pHeader[i++] = (unsigned char)nTimeBaseNum;
+	pHeader[i++] = (unsigned char)(((nTimeBaseNum >> 8) & 0xff));
+	pHeader[i++] = (unsigned char)(((nTimeBaseNum >> 16) & 0xff));
+	pHeader[i++] = (unsigned char)(((nTimeBaseNum >> 24) & 0xff));
+	/*frame cnt*/
+	pHeader[i++] = (unsigned char)nFrameCnt;
+	pHeader[i++] = (unsigned char)(((nFrameCnt >> 8) & 0xff));
+	pHeader[i++] = (unsigned char)(((nFrameCnt >> 16) & 0xff));
+	pHeader[i++] = (unsigned char)(((nFrameCnt >> 24) & 0xff));
+	/*unused*/
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+
+	ASSERT(i==VP8_SEQ_HEADER_SIZE);
+	*pHeaderLen=VP8_SEQ_HEADER_SIZE;
+
+	return 1;
+}
+
+int VP8CreateFrameHeader(unsigned char* pHeader, int* pHeaderLen,unsigned int nInSize,unsigned nPTSLow32,unsigned int nPTSHig32)
+{
+	int i=0;
+	/*frame size*/
+	pHeader[i++] = (unsigned char)nInSize;
+	pHeader[i++] = (unsigned char)(nInSize >> 8);
+	pHeader[i++] = (unsigned char)(nInSize >> 16);
+	pHeader[i++] = (unsigned char)(nInSize >> 24);
+	/*PTS[31:0]*/
+	pHeader[i++] = (unsigned char)nPTSLow32;
+	pHeader[i++] = (unsigned char)(nPTSLow32 >> 8);
+	pHeader[i++] = (unsigned char)(nPTSLow32 >> 16);
+	pHeader[i++] = (unsigned char)(nPTSLow32 >> 24);
+	/*PTS[63:32]*/
+	pHeader[i++] = (unsigned char)nPTSHig32;
+	pHeader[i++] = (unsigned char)(nPTSHig32 >> 8);
+	pHeader[i++] = (unsigned char)(nPTSHig32 >> 16);
+	pHeader[i++] = (unsigned char)(nPTSHig32 >> 24);
+
+	ASSERT(i==VP8_FRM_HEADER_SIZE);
+	*pHeaderLen=VP8_FRM_HEADER_SIZE;
+
+	return 1;
+}
+
+int DIV3CreateSeqHeader(unsigned char* pHeader, int* pHeaderLen, 
+	unsigned int nTimeBaseDen,unsigned int nTimeBaseNum,unsigned int nFrameCnt,int nWidth,int nHeight)
+{
+	int i=0;
+
+	pHeader[i++] = 'C';
+	pHeader[i++] = 'N';
+	pHeader[i++] = 'M';
+	pHeader[i++] = 'V';
+	/*version*/
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+	/*headersize*/
+	pHeader[i++]=DIV3_SEQ_HEADER_SIZE;
+	pHeader[i++]=0;
+	/*fourcc*/
+	pHeader[i++]='D';
+	pHeader[i++]='I';
+	pHeader[i++]='V';
+	pHeader[i++]='3';
+	/*width*/
+	pHeader[i++]=(unsigned char)(nWidth&0xFF);
+	pHeader[i++]=(unsigned char)(((nWidth >> 8) & 0xFF));
+	/*height*/
+	pHeader[i++]=(unsigned char)(nHeight&0xFF);
+	pHeader[i++]=(unsigned char)(((nHeight >> 8) & 0xFF));
+	/*rate*/
+	pHeader[i++] = (unsigned char)nTimeBaseDen;
+	pHeader[i++] = (unsigned char)(((nTimeBaseDen >> 8) & 0xFF));
+	pHeader[i++] = (unsigned char)(((nTimeBaseDen >> 16) & 0xFF));
+	pHeader[i++] = (unsigned char)(((nTimeBaseDen >> 24) & 0xFF));
+	/*scale*/
+	pHeader[i++] = (unsigned char)(nTimeBaseNum&0xFF);
+	pHeader[i++] = (unsigned char)(((nTimeBaseNum >> 8) & 0xFF));
+	pHeader[i++] = (unsigned char)(((nTimeBaseNum >> 16) & 0xFF));
+	pHeader[i++] = (unsigned char)(((nTimeBaseNum >> 24) & 0xFF));
+	/*frame cnt*/
+	pHeader[i++] = (unsigned char)(nFrameCnt&0xFF);
+	pHeader[i++] = (unsigned char)(((nFrameCnt >> 8) & 0xFF));
+	pHeader[i++] = (unsigned char)(((nFrameCnt >> 16) & 0xFF));
+	pHeader[i++] = (unsigned char)(((nFrameCnt >> 24) & 0xFF));
+	/*unused*/
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+	pHeader[i++]=0;
+
+	ASSERT(i==DIV3_SEQ_HEADER_SIZE);
+	*pHeaderLen=DIV3_SEQ_HEADER_SIZE;
+
+	return 1;
+}
+
+int DIV3CreateFrameHeader(unsigned char* pHeader, int* pHeaderLen,unsigned int nInSize,unsigned nPTSLow32,unsigned int nPTSHig32)
+{
+	int i=0;
+	/*frame size*/
+	pHeader[i++] = (unsigned char)nInSize;
+	pHeader[i++] = (unsigned char)(nInSize >> 8);
+	pHeader[i++] = (unsigned char)(nInSize >> 16);
+	pHeader[i++] = (unsigned char)(nInSize >> 24);
+	/*PTS[31:0]*/
+	pHeader[i++] = (unsigned char)nPTSLow32;
+	pHeader[i++] = (unsigned char)(nPTSLow32 >> 8);
+	pHeader[i++] = (unsigned char)(nPTSLow32 >> 16);
+	pHeader[i++] = (unsigned char)(nPTSLow32 >> 24);
+	/*PTS[63:32]*/
+	pHeader[i++] = (unsigned char)nPTSHig32;
+	pHeader[i++] = (unsigned char)(nPTSHig32 >> 8);
+	pHeader[i++] = (unsigned char)(nPTSHig32 >> 16);
+	pHeader[i++] = (unsigned char)(nPTSHig32 >> 24);
+
+	ASSERT(i==DIV3_FRM_HEADER_SIZE);
+	*pHeaderLen=DIV3_FRM_HEADER_SIZE;
+
+	return 1;
+}
+
+unsigned int VpuConvertAspectRatio(VpuCodStd eInFormat,unsigned int InRatio,int InWidth,int InHeight, int profile, int level)
+{
+#define FIXED_POINTED_1	(0x10000)	//(Q16_SHIFT)
+	unsigned int tmp;
+	//set default value: no scale
+	unsigned int OutWidth=FIXED_POINTED_1;	
+	unsigned int OutHeight=FIXED_POINTED_1;
+	unsigned int Q16Ratio=FIXED_POINTED_1;
+	VPU_LOG("aspect ratio: format: %d, ratio: 0x%X, InWidth: %d, InHeight: %d \r\n",eInFormat,InRatio,InWidth,InHeight);
+	switch(eInFormat)
+	{
+		case VPU_V_MPEG2:
+			//FIXME: we have no other better info to identify mpeg1 or mpeg2 except profile/level
+			if((profile==0)&&(level==0))
+			{
+				//Mpeg1
+/*
+CODE	HEIGHT/WIDTH	COMMENT
+0000	undefined		Forbidden
+0001	1.0				square pels
+0010	0.6735	
+0011	0.7031			16:9 625-line
+0100	0.7615	
+0101	0.8055	
+0110	0.8437			16:9 525-line
+0111	0.8935	
+1000	0.9157			702x575 at 4:3 = 0.9157
+1001	0.9815	
+1010	1.0255	
+1011	1.0695	
+1100	1.0950			711x487 at 4:3 = 1.0950
+1101	1.1575	
+1110	1.2015	
+1111	undefined		reserved
+*/				switch(InRatio)
+				{
+					case 0x1:	// 1.0 (SAR)
+						//no scale(use default value)
+						break;
+					case 0x2:	// 1:0.6735 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*6735;
+						break;						
+					case 0x3:	// 1:0.7031 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*7031;
+						break;	
+					case 0x4:	// 1:0.7615 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*7615;
+						break;	
+					case 0x5:	// 1:0.8055 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*8055;
+						break;	
+					case 0x6:	// 1:0.8437 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*8437;
+						break;	
+					case 0x7:	// 1:0.8935 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*8935;
+						break;	
+					case 0x8:	// 1:0.9157 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*9157;
+						break;	
+					case 0x9:	// 1:0.9815 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*9815;
+						break;	
+					case 0xA:	// 1:1.0255 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*10255;
+						break;	
+					case 0xB:	// 1:1.0695 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*10695;
+						break;	
+					case 0xC:	// 1:1.0950 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*10950;
+						break;		
+					case 0xD:	// 1:1.1575 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*11575;
+						break;	
+					case 0xE:	// 1:1.2015 (SAR)
+						OutWidth=(double)FIXED_POINTED_1*10000;
+						OutHeight=FIXED_POINTED_1*12015;
+						break;				
+					default:
+						VPU_ERROR("unsupported ration: 0x%X \r\n",InRatio);
+						break;
+				}
+			}
+			else
+			{
+				//Mpeg2
+/*	
+		aspect_ratio_information 	Sample Aspect Ratio 		DAR
+		0000 					Forbidden 				Forbidden			
+		0001					1.0 (Square Sample) 		C
+		0010 					C 						3  4
+		0011 					C 						9  16
+		0100 					C 						1  2.21		
+		0101 					C 						Reserved
+		 												
+		1111 					C 						Reserved		
+*/
+				switch(InRatio)
+				{
+					case 0x1:	// 1.0 (SAR)
+						//no scale(use default value)
+						break;
+					case 0x2:	// 4:3 (DAR)
+						OutWidth=(double)FIXED_POINTED_1*InHeight*4/(3*InWidth);
+						OutHeight=FIXED_POINTED_1;
+						break;
+					case 0x3:	// 16:9 (DAR)
+						OutWidth=(double)FIXED_POINTED_1*InHeight*16/(9*InWidth);
+						OutHeight=FIXED_POINTED_1;
+						break;
+					case 0x4:	// 2.21 : 1 (DAR)
+						OutWidth=(double)FIXED_POINTED_1*InHeight*221/(100*InWidth);
+						OutHeight=FIXED_POINTED_1;
+						break;
+					default:
+						VPU_ERROR("unsupported ration: 0x%X \r\n",InRatio);
+						break;
+				}	
+			}
+			break;
+		case VPU_V_AVC:
+/*
+	if aspectRateInfo [31:16] is 0, aspectRateInfo [7:0] means
+	aspect_ratio_idc. Otherwise, AspectRatio means Extended_SAR.
+	sar_width = aspectRateInfo [31:16],
+	sar_height = aspectRateInfo [15:0]
+		aspect_ratio_idc 	Sample aspect ratio 		(informative)Examples of use
+		0 				Unspecified
+		1 				1:1(square)		1280x720 16:9 frame without overscan
+												1920x1080 16:9 frame without overscan (cropped from 1920x1088)
+												640x480 4:3 frame without overscan
+		2 				12:11 					720x576 4:3 frame with horizontal overscan
+												352x288 4:3 frame without overscan
+		3 				10:11 					720x480 4:3 frame with horizontal overscan
+												352x240 4:3 frame without overscan
+		4 				16:11 					720x576 16:9 frame with horizontal overscan
+												540x576 4:3 frame with horizontal overscan
+		5 				40:33 					720x480 16:9 frame with horizontal overscan
+												540x480 4:3 frame with horizontal overscan
+		6 				24:11 					352x576 4:3 frame without overscan
+												480x576 16:9 frame with horizontal overscan
+		7 				20:11 					352x480 4:3 frame without overscan
+												480x480 16:9 frame with horizontal overscan
+		8 				32:11 					352x576 16:9 frame without overscan
+		9 				80:33 					352x480 	16:9 frame without overscan
+		10 				18:11 					480x576 4:3 frame with horizontal overscan
+		11 				15:11 					480x480 4:3 frame with horizontal overscan
+		12 				64:33 					540x576 16:9 frame with horizontal overscan
+		13 				160:99 					540x480 16:9 frame with horizontal overscan
+		14 				4:3 						1440x1080 16:9 frame without horizontal overscan
+		15 				3:2 						1280x1080 16:9 frame without horizontal overscan                  
+		16 				2:1 						960x1080 16:9 frame without horizontal overscan
+		17..254 			Reserved		
+		255 				Extended_SAR	
+*/			
+			tmp=(InRatio>>16)&0xFFFF;	//[31:16]
+			if(tmp==0)
+			{
+				tmp=InRatio&0xFF;		//[7:0]
+				switch(tmp)
+				{
+					case 0x1:	// 1:1
+						//no scale(use default value)
+						break;
+					case 0x2:	// 12:11
+						OutWidth=FIXED_POINTED_1*12;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0x3:	// 10:11
+						OutWidth=FIXED_POINTED_1*10;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0x4:	// 16:11
+						OutWidth=FIXED_POINTED_1*16;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0x5:	// 40:33
+						OutWidth=FIXED_POINTED_1*40;
+						OutHeight=FIXED_POINTED_1*33;	
+						break;
+					case 0x6:	// 24:11
+						OutWidth=FIXED_POINTED_1*24;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0x7:	// 20:11
+						OutWidth=FIXED_POINTED_1*20;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0x8:	// 32:11
+						OutWidth=FIXED_POINTED_1*32;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0x9:	// 80:33
+						OutWidth=FIXED_POINTED_1*80;
+						OutHeight=FIXED_POINTED_1*33;	
+						break;
+
+					case 0xA:	// 18:11
+						OutWidth=FIXED_POINTED_1*18;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0xB:	// 15:11
+						OutWidth=FIXED_POINTED_1*15;
+						OutHeight=FIXED_POINTED_1*11;	
+						break;
+					case 0xC:	// 64:33
+						OutWidth=FIXED_POINTED_1*64;
+						OutHeight=FIXED_POINTED_1*33;	
+						break;
+					case 0xD:	// 160:99
+						OutWidth=FIXED_POINTED_1*160;
+						OutHeight=FIXED_POINTED_1*99;	
+						break;
+					case 0xE:	// 4:3
+						OutWidth=FIXED_POINTED_1*4;
+						OutHeight=FIXED_POINTED_1*3;
+						break;
+					case 0xF:	// 3:2
+						OutWidth=FIXED_POINTED_1*3;
+						OutHeight=FIXED_POINTED_1*2;
+						break;
+					case 0x10:	// 2:1
+						OutWidth=FIXED_POINTED_1*2;
+						OutHeight=FIXED_POINTED_1*1;
+						break;	
+					default:
+						VPU_ERROR("unsupported ration: 0x%X \r\n",InRatio);
+						break;
+				}
+			}
+#ifdef VPU_USE_UNSPECIFIED_RATIO  //added for special case
+			else if(0xFFFFFFFF==InRatio){
+				//unspecified
+				return 0xFFFFFFFF;
+			}
+#endif
+			else
+			{
+				//extended SAR: => sar_width: sar_height ??
+				//sar_width = aspectRateInfo [31:16],
+				//sar_height = aspectRateInfo [15:0]	
+				tmp=(InRatio>>16)&0xFFFF;	//width=[31:16]
+				//OutWidth=FIXED_POINTED_1*tmp/InWidth;
+				OutWidth=FIXED_POINTED_1*tmp;
+				tmp=InRatio&0xFFFF;			//height=[15:0]
+				//OutHeight=FIXED_POINTED_1*tmp/InHeight;
+				OutHeight=FIXED_POINTED_1*tmp;
+			}
+			break;
+		case VPU_V_DIVX3:	//??
+		case VPU_V_DIVX4:
+		case VPU_V_DIVX56:
+		case VPU_V_XVID:
+		case VPU_V_MPEG4:
+/*
+		aspect_ratio_info 	pixel aspect ratios
+		0000 									Forbidden
+		0001 									1:1 (Square)
+		0010 									12:11 (625-type for 4:3 picture)
+		0011 									10:11 (525-type for 4:3 picture)
+		0100 									16:11 (625-type stretched for 16:9 picture)
+		0101 									40:33 (525-type stretched for 16:9 picture)
+		0110-1110 								Reserved
+		1111 									extended PAR
+*/			
+			switch(InRatio)
+			{
+				case 0x1:	// 1:1 (SAR)
+					OutWidth=FIXED_POINTED_1;
+					OutHeight=FIXED_POINTED_1;
+					break;
+				case 0x2:	// 12:11 (SAR)
+					OutWidth=FIXED_POINTED_1*12;
+					OutHeight=FIXED_POINTED_1*11;
+					break;
+				case 0x3:	// 10:11 (SAR)
+					OutWidth=FIXED_POINTED_1*10;
+					OutHeight=FIXED_POINTED_1*11;				
+					break;
+				case 0x4:	// 16:11 (SAR)
+					OutWidth=FIXED_POINTED_1*16;
+					OutHeight=FIXED_POINTED_1*11;
+					break;
+				case 0x5:	// 40:33 (SAR)
+					OutWidth=FIXED_POINTED_1*40;
+					OutHeight=FIXED_POINTED_1*33;
+					break;
+				default:
+					if((InRatio&0xF)==0xF)		// [3:0]: '1111' : extended_PAR
+					{
+						tmp=(InRatio>>4)&0xFF;	//width=[11:4]
+						OutWidth=FIXED_POINTED_1*tmp;
+						tmp=(InRatio>>12)&0xFF;	//height=[19:12]
+						OutHeight=FIXED_POINTED_1*tmp;
+					}
+					else
+					{
+						VPU_ERROR("unsupported ration: 0x%X \r\n",InRatio);
+					}
+					break;
+			}
+			break;
+		case VPU_V_VC1:
+		case VPU_V_VC1_AP:	
+			//Aspect Width = aspectRateInfo [31:16],
+			//Aspect Height = aspectRateInfo [15:0]
+			tmp=(InRatio>>16)&0xFFFF;	//width=[31:16]
+			//OutWidth=FIXED_POINTED_1*tmp/InWidth;
+			OutWidth=FIXED_POINTED_1*tmp;
+			tmp=InRatio&0xFFFF;			//height=[15:0]
+			//OutHeight=FIXED_POINTED_1*tmp/InHeight;
+			OutHeight=FIXED_POINTED_1*tmp;
+			break;
+		case VPU_V_MJPG:
+		case VPU_V_AVC_MVC:
+		case VPU_V_AVS:
+		case VPU_V_VP8:
+			//ignore ratio
+			break;
+		default:
+			//ignore ratio
+			VPU_ERROR("unsupported ration: 0x%X \r\n",InRatio);
+			break;
+	}
+
+	if((OutWidth==0)||(OutHeight==0))
+	{
+		Q16Ratio=FIXED_POINTED_1; //no valid ratio
+	}
+	else
+	{
+		Q16Ratio=(double)OutWidth*FIXED_POINTED_1/OutHeight;
+	}
+	VPU_LOG("return Q16Ratio: 0x%X, [OutWidth,OutHeight]=[%d, %d]  \r\n",Q16Ratio,OutWidth,OutHeight);
+	return Q16Ratio;
+}
+
+VpuPicType VpuConvertPicType(VpuCodStd InCodec,int InPicType,int InIdrFlag)
+{
+	VpuPicType eOutPicType=VPU_UNKNOWN_PIC;
+
+	/*
+	InPicType:
+	interlaced: top field: [5:3]; bot field: [2:0]
+	progressive: [2:0]
+	now, we only check the bot field(or frame) bits [2:0]
+	*/
+	switch (InCodec)
+	{
+		case VPU_V_AVC:
+			if(CPU_IS_MX6X())
+			{
+				/*
+				InIdrFlag:
+				[0]: second field or frame
+				[1]: first field
+				now, we only check the second field bit [0]
+				*/
+				if((InIdrFlag)&0x1)
+				{
+					eOutPicType=VPU_IDR_PIC;
+					VPU_LOG("frame : (IDR) \r\n");
+				}
+				else
+				{
+					switch(InPicType)
+					{
+						case 0:
+							eOutPicType=VPU_I_PIC;
+							VPU_LOG("frame : (I) \r\n");
+							break;
+						case 1:
+							eOutPicType=VPU_P_PIC;
+							VPU_LOG("frame : (P) \r\n");
+							break;
+						case 2:
+							eOutPicType=VPU_B_PIC;
+							VPU_LOG("frame : (B) \r\n");
+							break;			
+						default:
+							VPU_LOG("frame : (*) \r\n");
+							break;
+					}
+				}
+			}
+			else
+			{
+				if(AVC_IS_IDR(InPicType))
+				{
+					eOutPicType=VPU_IDR_PIC;
+					VPU_LOG("frame : (I) \r\n");
+				}
+				else if(AVC_IS_ISLICE(InPicType))
+				{
+					eOutPicType=VPU_I_PIC;
+					VPU_LOG("frame : (IS) \r\n");
+				}
+				else if(AVC_IS_PSLICE(InPicType))
+				{
+					eOutPicType=VPU_P_PIC;		
+					VPU_LOG("frame : (PS) \r\n");
+				}
+				else if(AVC_IS_BSLICE(InPicType))
+				{
+					eOutPicType=VPU_B_PIC;		
+					VPU_LOG("frame : (BS) \r\n");
+				}
+				else
+				{
+					VPU_LOG("frame :  (*) \r\n");
+				}					
+			}
+			break;			
+		case VPU_V_VC1:
+			/*
+			0 - I picture
+			1 - P picture
+			2 - BI picture
+			3 - B picture
+			4 - P_SKIP picture
+			*/
+			switch(InPicType&0x7)
+			{
+				case 0:
+					eOutPicType=VPU_I_PIC;
+					VPU_LOG("frame : (I) \r\n");
+					break;
+				case 1:
+					eOutPicType=VPU_P_PIC;
+					VPU_LOG("frame : (P) \r\n");
+					break;
+				case 2:	
+					eOutPicType=VPU_BI_PIC;
+					VPU_LOG("frame : (BI) \r\n");
+					break;
+				case 3:	
+					eOutPicType=VPU_B_PIC;
+					VPU_LOG("frame : (B) \r\n");
+					break;
+				case 4:	
+					eOutPicType=VPU_SKIP_PIC;
+					VPU_LOG("frame : (SKIP) \r\n");
+					break;
+				default:
+					VPU_LOG("frame : (*) \r\n");
+					break;
+			}
+			break;
+		case VPU_V_VC1_AP:
+			//need to check [2:0](second field) and [5:3](first field)
+			eOutPicType=g_VC1APPicType[(InPicType>>3)&0x7][InPicType&0x7];
+			VPU_LOG("VC1-AP: pictype: %d \r\n",eOutPicType);
+			break;
+		default:	
+			/*
+			0 - I picture
+			1 - P picture
+			2 - B picture
+			3 - D picture in MPEG2, S picture in MPEG4		
+			*/
+			switch(InPicType)
+			{
+				case 0:
+					eOutPicType=VPU_I_PIC;
+					VPU_LOG("frame : (I) \r\n");
+					break;
+				case 1:
+					eOutPicType=VPU_P_PIC;
+					VPU_LOG("frame : (P) \r\n");
+					break;
+				case 2:
+					eOutPicType=VPU_B_PIC;
+					VPU_LOG("frame : (B) \r\n");
+					break;			
+				default:
+					VPU_LOG("frame : (*) \r\n");
+					break;
+			}
+			break;			
+	}	
+	return eOutPicType;
+}
+
+VpuFieldType VpuConvertFieldType(VpuCodStd InCodec,DecOutputInfo * pCurDecFrameInfo)
+{
+	VpuFieldType eField=VPU_FIELD_NONE;
+
+	switch (InCodec)
+	{
+		case VPU_V_AVC:
+			if(pCurDecFrameInfo->interlacedFrame)
+			{
+				if (pCurDecFrameInfo->topFieldFirst) eField = VPU_FIELD_TB;
+				else eField = VPU_FIELD_BT;
+			}
+			break;
+		case VPU_V_VC1:
+		case VPU_V_VC1_AP:
+			if (pCurDecFrameInfo->pictureStructure==2)
+			{
+				VPU_LOG("frame interlaced \r\n");
+			}
+			else if (pCurDecFrameInfo->pictureStructure==3)
+			{
+				if (pCurDecFrameInfo->topFieldFirst) eField = VPU_FIELD_TB;
+				else 	eField= VPU_FIELD_BT;
+			}			
+			break;
+		case VPU_V_MPEG2:
+		case VPU_V_H263:
+		case VPU_V_DIVX3:
+			if (pCurDecFrameInfo->interlacedFrame
+				|| !pCurDecFrameInfo->progressiveFrame)
+			{
+				/* pictureStructure: 1 => current struct represent the top info, the bottom info has been written. e.g. decode order: bottom  + top
+				     pictureStructure: 2 => current struct represent the bottom info, the top info has been written. e.g. decode order: top + bottom
+				*/
+				if (pCurDecFrameInfo->pictureStructure == 1) eField=VPU_FIELD_BT ;//VPU_FIELD_TOP;
+				else if (pCurDecFrameInfo->pictureStructure == 2) eField= VPU_FIELD_TB;//VPU_FIELD_BOTTOM;
+				else if (pCurDecFrameInfo->pictureStructure == 3)
+				{
+					if (pCurDecFrameInfo->topFieldFirst) eField = VPU_FIELD_TB;
+					else eField = VPU_FIELD_BT;
+				}
+			}
+			break;
+		case VPU_V_MPEG4:
+		case VPU_V_DIVX4:
+		case VPU_V_DIVX56:
+		case VPU_V_XVID:
+		case VPU_V_RV:
+		case VPU_V_MJPG:
+			//none ??
+			break;
+		default:	
+			break;			
+	}
+	
+	return eField;
+}
+
+unsigned int VpuCopyValidSizeInRingBuf(unsigned char* pDst,unsigned int nStart,unsigned int nEnd,unsigned int nBufStart,unsigned int nBufEnd)
+{
+	if((nStart<nBufStart)||((nStart-FRAME_END_OFFSET)>=nBufEnd)||
+		(nEnd<nBufStart)||(nEnd>=nBufEnd))
+	{
+		VPU_ERROR("%s: address: [0x%X, 0x%X] out of range [0x%X, 0x%X] \r\n",__FUNCTION__,nStart,nEnd,nBufStart,nBufEnd);
+		//return 0;  //vpu register BIT_BYTE_POS_FRAME_START/BIT_BYTE_POS_FRAME_END may point to far away from correct buffer range
+	}
+	if(nStart<=nEnd)
+	{
+		vpu_memcpy(pDst,(void*)nStart,(nEnd-nStart+1));
+		return (nEnd-nStart+1);
+	}
+	else
+	{
+		vpu_memcpy(pDst,(void*)nStart,(nBufEnd-nStart));
+		vpu_memcpy(pDst+(nBufEnd-nStart),(void*)nBufStart,(nEnd-nBufStart+1));
+		return ((nBufEnd-nStart)+(nEnd-nBufStart+1));
+	}
+}
+
+unsigned int VpuComputeValidSizeInRingBuf(unsigned int nStart,unsigned int nEnd,unsigned int nBufStart,unsigned int nBufEnd)
+{
+	if((nStart<nBufStart)||((nStart-FRAME_END_OFFSET)>=nBufEnd)||
+		(nEnd<nBufStart)||(nEnd>=nBufEnd))
+	{
+		VPU_ERROR("%s: address: [0x%X, 0x%X] out of range [0x%X, 0x%X] \r\n",__FUNCTION__,nStart,nEnd,nBufStart,nBufEnd);
+		//return 0;  //vpu register BIT_BYTE_POS_FRAME_START/BIT_BYTE_POS_FRAME_END may point to far away from correct buffer range
+	}
+	if(nStart<=nEnd)
+	{
+		return (nEnd-nStart+1);
+	}
+	else
+	{
+		return ((nBufEnd-nStart)+(nEnd-nBufStart+1));
+	}
+}
+
+int VpuAccumulateConsumedBytes(VpuDecObj* pObj, int nInSize, int type, unsigned int nFrmStartPhy, unsigned int nFrmEndPhy)
+{
+#define MAX_CONSUMED_BYTES	1000000000
+	/* 	type: 
+			0: sequence header inserted by vpu wrapper(VC1/VP8/DivX3), may include the first frame header
+			0: config data set by user
+			1: additional frame header inserted by vpu wrapper(VC1/VP8/DivX3)
+			2: frame length reported by vpu
+		nFrm*Phy:
+			type=0: invalid
+			type=1: invalid
+			type=2; indicate the range of the frame[beg,end] in the bitstream buffer
+	*/
+	int nStuffSize=0;
+	if(pObj->nDecFrameRptEnabled==0)
+	{
+		return 0;
+	}
+	VPU_LOG("%s: size: %d, type: %d \r\n",__FUNCTION__,nInSize,type);
+
+	switch(type)
+	{
+		case 0:	//It should be called only once !!!
+			if(0==pObj->nAdditionalSeqBytes)
+			{
+				pObj->nAdditionalSeqBytes=nInSize;
+			}
+			//We suppose, the size is constant !!!
+			ASSERT(pObj->nAdditionalSeqBytes==nInSize);
+			VPU_LOG("additional sequence size: %d \r\n", nInSize);
+			break;
+		case 1:
+			if(0==pObj->nAdditionalFrmHeaderBytes)
+			{
+				pObj->nAdditionalFrmHeaderBytes=nInSize;
+			}
+			//We suppose, the size is constant !!!(for DivX3/VP8/VC1RCV, the header size is fixed; but for VC1NAL, is it fixed ??)
+			ASSERT(pObj->nAdditionalFrmHeaderBytes==nInSize);			
+			VPU_LOG("additional frame header size: %d \r\n", nInSize);
+			break;
+		case 2:
+			/*accumulate stuffer data size between two frames*/
+			if(1)//if(nFrmStartPhy!=(pObj->nLastFrameEndPosPhy+1))
+			{
+				//two frames are not continuous, stuffer data is exist	
+				//ASSERT(nFrmStartPhy!=pObj->nLastFrameEndPosPhy);	// empty or full ??
+				nStuffSize=VpuComputeValidSizeInRingBuf(pObj->nLastFrameEndPosPhy, nFrmStartPhy,(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd);
+				nStuffSize-=2;	//reduce start and end themselves
+				nStuffSize+=FRAME_END_OFFSET+FRAME_START_OFFSET;
+				VPU_LOG("last end: 0x%X, start: 0x%X, buf start: 0x%X, buf end: 0x%X, stuff size: %d \r\n",pObj->nLastFrameEndPosPhy, nFrmStartPhy,(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd,nStuffSize);
+				pObj->nAccumulatedConsumedStufferBytes+=nStuffSize;
+			}
+			/*adjust stuffer size: reduce the sequence/config size inserted by vpu wrapper itself */
+			if(pObj->nAdditionalSeqBytes)
+			{
+				pObj->nAccumulatedConsumedStufferBytes-=pObj->nAdditionalSeqBytes;
+				pObj->nAdditionalSeqBytes=0; //clear 0 !!!
+				if(pObj->nAccumulatedConsumedStufferBytes<0)
+				{
+					VPU_LOG("warning: some frames are packaged in the config data.\r\n");
+				}
+			}
+
+#if 0	//debug code
+			{
+				unsigned int nFrmSize;
+				nFrmSize=VpuComputeValidSizeInRingBuf(nFrmStartPhy,nFrmEndPhy,(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd);
+				ASSERT(nInSize==nFrmSize);
+				if(nInSize!=nFrmSize)
+				{
+					VPU_LOG("error: size not matched!!!!:  frame size: %d, vpu reported frame size: %d \r\n",nFrmSize,nInSize);
+					nInSize=nFrmSize;
+				}
+			}
+#endif
+
+			/*accumulate the frame size*/
+			pObj->nAccumulatedConsumedFrmBytes+=nInSize;
+			/*adjust frame size: reduce the frame header inserted by vpu wrapper itself*/
+			pObj->nAccumulatedConsumedFrmBytes-=pObj->nAdditionalFrmHeaderBytes;
+			ASSERT(nInSize>pObj->nAdditionalFrmHeaderBytes);
+
+			/*total consumed bytes= stuffer size + frame size*/
+			pObj->nAccumulatedConsumedBytes=pObj->nAccumulatedConsumedStufferBytes+pObj->nAccumulatedConsumedFrmBytes;
+
+			/*update last frame end location*/
+			pObj->nLastFrameEndPosPhy=nFrmEndPhy;
+			break;
+		default:
+			break;
+	}
+
+	/*If user don't get the info, we need to clear it to avoid overflow */
+	if(pObj->nAccumulatedConsumedBytes >MAX_CONSUMED_BYTES)
+	{
+		ASSERT(pObj->nAccumulatedConsumedStufferBytes+pObj->nAccumulatedConsumedFrmBytes==pObj->nAccumulatedConsumedBytes);
+		pObj->nAccumulatedConsumedStufferBytes =0;
+		pObj->nAccumulatedConsumedFrmBytes =0;
+		pObj->nAccumulatedConsumedBytes =0;
+	}
+	return 1;
+}
+
+int VpuCheckIllegalMemoryAccess(unsigned char*  pY,unsigned char*  pU,unsigned char*  pV, unsigned int nYStride,int nHeight)
+{
+#define ILLEGAL_MEMORY_MARK	(0)
+#define ILLEGAL_MEMORY_CHECK_LEN	(32)
+	unsigned int nYSize,nCSize;
+	unsigned char* pYEnd,*pUEnd,*pVEnd;
+	int i;
+	nYSize=nYStride*nHeight;
+	nCSize=nYSize/4;
+	pYEnd=pY+nYSize;
+	pUEnd=pU+nCSize;
+	pVEnd=pV+nCSize;
+	for(i=0;i<ILLEGAL_MEMORY_CHECK_LEN;i++){
+		if((pYEnd[i]!=ILLEGAL_MEMORY_MARK)
+			&&(pUEnd[i]!=ILLEGAL_MEMORY_MARK)
+			&&(pVEnd[i]!=ILLEGAL_MEMORY_MARK)){
+			VPU_ERROR("error: illegal memory(off: %d) access detected ! stride: %d, height: %d \r\n",i,nYStride,nHeight);
+			return 0;
+		}
+	}
+	VPU_LOG("memory check is ok !!\r\n");
+	return 1;
+}
+
+
+int VpuSaveDecodedFrameInfo(VpuDecObj* pObj, int index,DecOutputInfo * pCurDecFrameInfo,VpuFrameBuffer* pInFrameDecode)
+{
+	VpuFrameBufInfo * pDstInfo;
+	
+	if(index>=pObj->frameNum)
+	{
+		//overflow !!!		
+		return 0;
+	}	
+
+#ifdef VPU_IMX6_MULTIINSTANCE_FRAMESTART_WORKAROUND
+	/*
+	for single instance: start/end pointer may point illegal memory space
+					in such case, start and end have the same offset, and the frame size is correct, so we needn't rectify it
+	for multi-instance: start pointer may point illegal memory space(belong to another instance).
+					in such case, we need to rectify it with last frame end.
+	*/
+	if(pObj->nDecFrameRptEnabled){
+		if(((unsigned int)pCurDecFrameInfo->frameEndPos > (unsigned int)pObj->pBsBufPhyEnd)||((unsigned int)pCurDecFrameInfo->frameEndPos < (unsigned int)pObj->pBsBufPhyStart)){
+			VPU_ERROR("warning: frame end (0x%X) is out of range: [0x%X, 0x%X] \r\n",pCurDecFrameInfo->frameEndPos,(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd);
+		}
+		if((((unsigned int)pCurDecFrameInfo->frameStartPos > (unsigned int)pObj->pBsBufPhyEnd)||((unsigned int)pCurDecFrameInfo->frameStartPos < (unsigned int)pObj->pBsBufPhyStart))
+			&& ((unsigned int)pCurDecFrameInfo->frameStartPos!=pObj->nLastFrameEndPosPhy)
+			&& (pObj->nLastFrameEndPosPhy!=(unsigned int)pObj->pBsBufPhyEnd-1+FRAME_END_OFFSET)){
+			unsigned int nFrmSize;
+			nFrmSize=VpuComputeValidSizeInRingBuf(pObj->nLastFrameEndPosPhy,pCurDecFrameInfo->frameEndPos,(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd);
+			nFrmSize-=1;
+			VPU_ERROR("error: frame start is out of range[0x%X, 0x%X], rectify frame info [consumed, start, end] from [%d, 0x%X, 0x%X] to [%d, 0x%X, 0x%X] !\r\n",(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd,
+				pCurDecFrameInfo->consumedByte,pCurDecFrameInfo->frameStartPos,pCurDecFrameInfo->frameEndPos,
+				nFrmSize,pObj->nLastFrameEndPosPhy,pCurDecFrameInfo->frameEndPos);
+			pCurDecFrameInfo->frameStartPos=pObj->nLastFrameEndPosPhy;
+			pCurDecFrameInfo->consumedByte=nFrmSize;
+		}
+	}
+#endif
+
+	if(index>=0)	//valid decoded frame
+	{
+		int cropWidth,cropHeight;
+		//VPU_LOG("save index %d: pictype = %d \r\n",index,pCurDecFrameInfo->picType);
+		pDstInfo=&pObj->frameBufInfo[index];
+		pDstInfo->picType=pCurDecFrameInfo->picType;
+		pDstInfo->idrFlag=pCurDecFrameInfo->idrFlg;
+		//pDstInfo->topFieldFirst=pCurDecFrameInfo->topFieldFirst;
+		//pDstInfo->repeatFirstField=pCurDecFrameInfo->repeatFirstField;
+		pDstInfo->pFrameInPBPacket=pObj->pbPacket;
+		pDstInfo->consumedBytes=pCurDecFrameInfo->consumedByte;
+		pDstInfo->eFieldType=VpuConvertFieldType(pObj->CodecFormat,pCurDecFrameInfo);
+		pDstInfo->viewID=pCurDecFrameInfo->mvcPicInfo.viewIdxDecoded;
+
+		/*dynamic resolution and ratio*/
+		pDstInfo->width=pCurDecFrameInfo->decPicWidth;
+		pDstInfo->height=pCurDecFrameInfo->decPicHeight;
+		if(((0==pCurDecFrameInfo->decPicCrop.bottom)&&(0==pCurDecFrameInfo->decPicCrop.right))
+			||(pCurDecFrameInfo->decPicCrop.right<=pCurDecFrameInfo->decPicCrop.left)
+			||(pCurDecFrameInfo->decPicCrop.bottom<=pCurDecFrameInfo->decPicCrop.top))
+		{
+			//crop info is invalid
+			pDstInfo->frameCrop.nLeft= 0;
+			pDstInfo->frameCrop.nTop = 0;
+			pDstInfo->frameCrop.nRight=pCurDecFrameInfo->decPicWidth;
+			pDstInfo->frameCrop.nBottom=pCurDecFrameInfo->decPicHeight;
+		}
+		else
+		{	
+			pDstInfo->frameCrop.nLeft=pCurDecFrameInfo->decPicCrop.left;
+			pDstInfo->frameCrop.nTop=pCurDecFrameInfo->decPicCrop.top;
+			pDstInfo->frameCrop.nRight=pCurDecFrameInfo->decPicCrop.right;
+			pDstInfo->frameCrop.nBottom=pCurDecFrameInfo->decPicCrop.bottom;
+		}
+		cropWidth=pDstInfo->frameCrop.nRight-pDstInfo->frameCrop.nLeft;
+		cropHeight=pDstInfo->frameCrop.nBottom-pDstInfo->frameCrop.nTop;		
+		pDstInfo->Q16ShiftWidthDivHeightRatio=VpuConvertAspectRatio(pObj->CodecFormat,(unsigned int)pCurDecFrameInfo->aspectRateInfo,cropWidth,cropHeight, pObj->nProfile,pObj->nLevel);
+
+#ifdef ILLEGAL_MEMORY_DEBUG
+		VpuCheckIllegalMemoryAccess(pInFrameDecode->pbufVirtY, pInFrameDecode->pbufVirtCb, pInFrameDecode->pbufVirtCr,pInFrameDecode->nStrideY,pObj->nOriHeight);
+#endif
+		/*resolution change*/
+		if(pObj->nDecResolutionChangeEnabled!=0){
+			if((pCurDecFrameInfo->decPicWidth!=pObj->nOriWidth)||((pCurDecFrameInfo->decPicHeight!=pObj->nOriHeight))){
+				pObj->nResolutionChanged=1;
+				//in such case, needn't record/accumulate frame info
+				VPU_LOG("resolution change: original: [%d x %d], new: [%d x %d]!\r\n",pObj->nOriWidth,pObj->nOriHeight,pCurDecFrameInfo->decPicWidth,pCurDecFrameInfo->decPicHeight);
+				return 1;
+			}
+		}
+	}
+
+	/*record the nearest decoded frame and accumulate the frame size reported by vpu*/
+	pObj->pLastDecodedFrm=pInFrameDecode;
+	VPU_LOG("one decoded frame: start: 0x%X, end: 0x%X \r\n",pCurDecFrameInfo->frameStartPos,pCurDecFrameInfo->frameEndPos);
+	VpuAccumulateConsumedBytes(pObj,pCurDecFrameInfo->consumedByte,2,pCurDecFrameInfo->frameStartPos,pCurDecFrameInfo->frameEndPos);
+	
+	return 1;
+}
+
+int VpuLoadDispFrameInfo(VpuDecObj* pObj, int index,VpuDecOutFrameInfo* pDispFrameInfo,DecOutputInfo * pCurDisFrameInfo)
+{
+	VpuFrameBufInfo * pSrcInfo;
+	
+	if(index>=pObj->frameNum)
+	{
+		//overflow !!!		
+		return 0;
+	}		
+
+	pSrcInfo=&pObj->frameBufInfo[index];
+	//pDispFrameInfo->ePicType=pSrcInfo->picType;
+	pDispFrameInfo->ePicType=VpuConvertPicType(pObj->CodecFormat,pSrcInfo->picType,pSrcInfo->idrFlag);
+	//pDispFrameInfo->nTopFieldFirst=pSrcInfo->topFieldFirst;
+	//pDispFrameInfo->nRepeatFirstField=pSrcInfo->repeatFirstField;
+	//pDispFrameInfo->nConsumedByte=pSrcInfo->consumedBytes;
+	pDispFrameInfo->eFieldType=pSrcInfo->eFieldType;
+	if((pObj->CodecFormat==VPU_V_AVC)&&(pDispFrameInfo->eFieldType!=VPU_FIELD_NONE)){
+		/*	h264Npf: Field information based on display frame index
+			0 - paired field
+			1 - bottom (top-field missing)
+			2 - top (bottom-field missing)
+			3 - none (top-bottom missing)
+		*/
+		switch(pCurDisFrameInfo->h264Npf){
+			case 0: //ignore
+				break;
+			case 1:
+				pDispFrameInfo->eFieldType=VPU_FIELD_BOTTOM;
+				break;
+			case 2:
+				pDispFrameInfo->eFieldType=VPU_FIELD_TOP;
+				break;
+			case 3:  //ignore
+			default:
+				break;
+		}
+	}
+	pDispFrameInfo->nMVCViewID=pSrcInfo->viewID;	
+
+	/*dynamic resolution and ratio*/
+	pDispFrameInfo->pExtInfo=&pObj->frmExtInfo;
+	pDispFrameInfo->pExtInfo->nFrmWidth=pSrcInfo->width;
+	pDispFrameInfo->pExtInfo->nFrmHeight=pSrcInfo->height;
+	pDispFrameInfo->pExtInfo->FrmCropRect=pSrcInfo->frameCrop;
+	pDispFrameInfo->pExtInfo->nQ16ShiftWidthDivHeightRatio=pSrcInfo->Q16ShiftWidthDivHeightRatio;
+	
+	//VPU_LOG("load index %d: pictype = %d \r\n",index,pSrcInfo->picType);	
+	return 1;
+}
+
+int VpuSearchFrameIndex(VpuDecObj* pObj,VpuFrameBuffer * pInFrameBuf)
+{
+	int index;
+	int i;
+
+	for(i=0;i<pObj->frameNum;i++)
+	{
+		if((&pObj->frameBuf[i]) == pInFrameBuf)
+		{
+			index=i;
+			break;
+		}
+	}
+	
+	if (i>=pObj->frameNum)
+	{
+		//not find !!
+		VPU_LOG("%s: error: can not find frame index \r\n",__FUNCTION__);
+		index=-1;
+	}
+	return index;
+}
+
+int  VpuSearchFrameBuf(VpuDecObj* pObj,int index,VpuFrameBuffer ** ppOutFrameBuf)
+{
+	if((index>=pObj->frameNum)||(index<0))
+	{
+		//overflow !!!
+		*ppOutFrameBuf=NULL;
+		return 0;
+	}
+	else
+	{
+		*ppOutFrameBuf=&pObj->frameBuf[index];
+		return 1;
+	}
+}
+
+int  VpuSearchFreeFrameBuf(VpuDecObj* pObj,int* pIndex)
+{
+	int i;
+
+	for(i=0;i<pObj->frameNum;i++)
+	{
+		if(pObj->frameBufState[i] == VPU_FRAME_STATE_FREE)
+		{			
+			break;
+		}
+	}
+	
+	if (i>=pObj->frameNum)
+	{
+		//not find !!
+		VPU_LOG("%s: can not find frame index \r\n",__FUNCTION__);
+		*pIndex=-1;
+		return 0;
+	}
+	*pIndex=i;
+	return 1;
+}
+
+int VpuSetDispFrameState(int index, int* pFrameState,int state)
+{
+	pFrameState[index]=state;
+	return 1;
+}
+
+int VpuGetDispFrameState(int index, int* pFrameState)
+{
+	return pFrameState[index];
+}
+
+int VpuClearDispFrame(int index, int* pFrameState)
+{
+	pFrameState[index]=VPU_FRAME_STATE_FREE;
+	return 1;
+}
+
+int VpuDispFrameIsNotCleared(int index, int* pFrameState)
+{
+	if(pFrameState[index]!=VPU_FRAME_STATE_FREE)
+	{
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+
+int VpuFreeAllDispFrame(DecHandle InVpuHandle,int Num,int* pFrameState)
+{
+	//TODO: it is already useless !!!
+	int i;
+	RetCode ret=RETCODE_SUCCESS;
+	for(i=0;i<Num;i++)
+	{
+		if (VpuDispFrameIsNotCleared(i, pFrameState))
+		{
+			VpuClearDispFrame(i, pFrameState);
+			VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,i);
+			ret=vpu_DecClrDispFlag(InVpuHandle,i);
+			if(RETCODE_SUCCESS!=ret)
+			{
+				VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,i,ret);
+			}
+		}
+	}
+	return ((ret==RETCODE_SUCCESS)?1:0);
+}
+
+int VpuClearAllDispFrame(int Num,int* pFrameState)
+{
+	int i;
+	for(i=0;i<Num;i++)
+	{
+		VpuClearDispFrame(i, pFrameState);
+	}
+	return 1;
+}
+
+int VpuClearAllDispFrameFlag(DecHandle InVpuHandle,int Num)
+{
+	int i;
+	RetCode ret=RETCODE_SUCCESS;
+	for(i=0;i<Num;i++)
+	{
+		VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,i);
+		ret=vpu_DecClrDispFlag(InVpuHandle,i);
+		if(RETCODE_SUCCESS!=ret)
+		{
+			VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,i,ret);
+		}
+	}
+	return ((ret==RETCODE_SUCCESS)?1:0);
+}
+
+int VpuQueryVpuHoldBufNum(VpuDecObj* pObj)
+{
+	//occupied by vpu: state = free or dec
+	int i;
+	int num=0;
+	for(i=0;i<pObj->frameNum;i++)
+	{
+		if((pObj->frameBufState[i] == VPU_FRAME_STATE_DEC) ||(pObj->frameBufState[i] == VPU_FRAME_STATE_FREE))
+		{			
+			num++;
+		}
+	}
+	return num;
+}
+	
+int VpuBitsBufIsEnough(DecHandle InVpuHandle,unsigned int nFillSize)
+{
+	PhysicalAddress Rd;
+	PhysicalAddress Wr;
+	unsigned long nSpace;
+	RetCode ret;
+
+	VPU_TRACE;
+	VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+	ret=vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+	VPU_TRACE;
+
+	//check ret ??
+	
+	//check free space
+#ifdef IMX6_BITBUFSPACE_WORKAROUND	
+	if(nSpace<nFillSize+512)
+#else
+	if(nSpace<nFillSize)
+#endif
+	{
+		//VPU_LOG("vpu bistream is too full, free=%d, required=%d \r\n",(unsigned int)nSpace,nFillSize);
+		return 0;
+	}
+	else
+	{
+		return 1;
+	}
+}
+
+int VpuBitsBufValidDataLength(DecHandle InVpuHandle,VpuDecObj* pObj,unsigned int* pOutValidSize,unsigned int* pOutFreeSize)
+{
+	PhysicalAddress Rd;
+	PhysicalAddress Wr;
+	unsigned long nSpace;
+	RetCode ret;
+
+	VPU_TRACE;
+	VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+	ret=vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+	VPU_TRACE;
+
+	//check ret ??
+
+	*pOutValidSize=((unsigned int)Wr-(unsigned int)pObj->pBsBufPhyStart);
+	*pOutFreeSize=nSpace;
+	return 1;
+}
+
+int VpuDetectAvcc(unsigned char* pCodecData, unsigned int nSize, int * pIsAvcc, int * pNalSizeLength)
+{
+	*pIsAvcc=0;
+	if(pCodecData[0]==1){
+		int nalsizelen=(pCodecData[4]&0x3)+1;
+		if(nalsizelen<3){
+			/*Now, we only support nal_size_length == 3 or 4, 
+			   otherwise, the implementation is complex.
+			*/
+			VPU_ERROR("error: only 3 or 4 bytes nal_size_length are supported ! \r\n");
+			return 0;
+		}
+		VPU_LOG("avcc format is detected, nal_size_length % d \r\n",nalsizelen);
+		*pIsAvcc=1;
+		*pNalSizeLength=nalsizelen;
+	}
+	return 1;
+}
+
+int VpuConvertAvccHeader(unsigned char* pCodecData, unsigned int nSize, unsigned char** ppOut, unsigned int * pOutSize)
+{
+	/*will allocate and return one new buffer, caller is responsible to free it  */
+	unsigned char* p=pCodecData;
+	unsigned char* pDes;
+	unsigned char* pSPS, *pPPS;
+	int spsSize,ppsSize;
+	int numPPS, outSize=0;
+	unsigned char* pTemp;
+	int tempBufSize=0;
+	/* [0]: version */
+	/* [1]: profile */
+	/* [2]: profile compat */
+	/* [3]: level */
+	/* [4]: 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+	/* [5]: 3 bits reserved (111) + 5 bits number of sps (00001) */
+	/*[6,7]: 16bits: sps_size*/
+	/*sps data*/
+	/*number of pps*/
+	/*16bits: pps_size*/
+	/*pps data */
+	if(nSize<8){
+		goto corrupt_header;
+	}
+	spsSize=(p[6]<<8)|p[7];
+	p+=8;
+	pSPS=p;
+	p+=spsSize;
+	if(p>=pCodecData+nSize){
+		goto corrupt_header;
+	}
+	numPPS=*p++;
+
+	VPU_LOG("spsSize: %d , num of PPS: %d \r\n",spsSize, numPPS);
+	tempBufSize=nSize+2*numPPS; //need to allocate more bytes since startcode occupy 4 bytes, while pps size is 2 bytes.
+	pTemp=vpu_malloc(tempBufSize); 
+	if(pTemp==NULL){
+		VPU_ERROR("error: malloc %d bytes fail !\r\n", tempBufSize);
+		//do nothing, return
+		*ppOut=pCodecData;
+		*pOutSize=nSize;
+		return 0;
+	}
+	pDes=pTemp;
+	pDes[0]=pDes[1]=pDes[2]=0; /*fill start code*/
+	pDes[3]=0x1;
+	pDes+=4;
+	vpu_memcpy(pDes,pSPS,spsSize); /*fill sps*/
+	pDes+=spsSize;
+	outSize+=4+spsSize;
+	while(numPPS>0){
+		if((p+2) > (pCodecData+nSize)){
+			goto corrupt_header;
+		}
+		ppsSize=(p[0]<<8)|p[1];
+		p+=2;
+		pPPS=p;
+		outSize+=4+ppsSize;
+		if(outSize>tempBufSize){
+			VPU_ERROR("error: convert avcc header overflow ! \r\n");
+			//discard left pps data and return
+			*ppOut=pTemp;
+			*pOutSize=(outSize-4-ppsSize);
+			return 0;
+		}
+		VPU_LOG("fill one pps: %d bytes \r\n", ppsSize);
+		pDes[0]=pDes[1]=pDes[2]=0; /*fill start code*/
+		pDes[3]=0x1;
+		pDes+=4;
+		vpu_memcpy(pDes,pPPS,ppsSize); /*fill pps*/
+		pDes+=ppsSize;
+		numPPS--;
+		p+=ppsSize;
+	}
+	*ppOut=pTemp;
+	*pOutSize=outSize;
+	return 1;
+
+corrupt_header:
+	//do nothing, return
+	VPU_ERROR("error: codec data corrupted ! \r\n");
+	*ppOut=pCodecData;
+	*pOutSize=nSize;
+	return 0;
+}
+
+int VpuConvertAvccFrame(unsigned char* pData, unsigned int nSize, int nNalSizeLength)
+{
+	/*will change the nalsize with start code (3 or 4 bytes), the buffer size won't be changed*/
+	int leftSize=nSize;
+	unsigned char * p=pData;
+
+	if((nNalSizeLength!=3)&&(nNalSizeLength!=4)){
+		return 0; //not supported
+	}
+
+	while(leftSize>0){
+		unsigned int dataSize;
+		if(((p+nNalSizeLength) > (pData+nSize))
+			|| (p < pData)){
+			goto corrupt_data;
+		}
+		if(nNalSizeLength==3){
+			dataSize=(p[0]<<16)|(p[1]<<8)|p[2];
+			p[0]=p[1]=0;
+			p[2]=0x1;  /*fill 3 bytes of startcode*/
+		}
+		else{
+			dataSize=(p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
+			p[0]=p[1]=p[2]=0;
+			p[3]=0x1; /*fill 4 bytes of startcode*/
+		}
+		VPU_LOG("fill one %d bytes of start code for nal data(%d bytes) \r\n", nNalSizeLength,dataSize);
+		leftSize-=dataSize+4;
+		p+=dataSize+4;
+	}
+	if(leftSize!=0){
+		goto corrupt_data;
+	}
+	return 1;
+
+corrupt_data:
+	VPU_ERROR("error: the nal data corrupted ! \r\n");
+	return 0;
+}
+
+int VpuFillData(DecHandle InVpuHandle,VpuDecObj* pObj,unsigned char* pInVirt,unsigned int nSize, int InIsEnough,int nFileModeOffset)
+{
+
+#ifdef VPU_ONE_EOS
+	static int eos_flag=0;
+#endif
+
+	PhysicalAddress Rd;
+	PhysicalAddress Wr;
+	unsigned long nSpace;
+	unsigned int nFillSize,nFillUnit;	
+	RetCode ret;
+	unsigned char* pFill;
+	unsigned char* pSrc;
+
+#ifdef VPU_DEBUG_BS
+	static int totalSize=0;
+#endif
+
+//#ifdef VPU_WRAPPER_DUMP
+	static FILE* fpBitstream=NULL;
+	//static int nDumpSize=0;
+//#endif
+
+	//EOS:  pInVirt!=NULL && nSize==0
+	if(pInVirt==NULL)
+	{
+		return 1; //0
+	}
+
+#ifdef VPU_ONE_EOS
+	if((1==eos_flag))		
+	{
+		if (0==nSize)
+		{
+			// avoid repeated send EOS flag
+			return 1; 
+		}
+		else
+		{
+			//reset for repeat playing
+			eos_flag=0;
+		}
+	}
+#endif
+	
+
+	nFillSize=nSize;
+	pSrc=pInVirt;
+
+	//get bits buff info
+	VPU_TRACE;
+	VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+	ret=vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+	VPU_API("Wr: 0x%X, Rd: 0x%X, space: %d \r\n",(unsigned int)Wr,(unsigned int)Rd,(unsigned int)nSpace);
+	VPU_TRACE;
+
+#ifdef IMX6_INTER_DEBUG_RD_WR
+{
+	unsigned int rd,wr;
+//#define BIT_RD_PTR_0			0x120
+//#define BIT_WR_PTR_0			0x124
+	IOClkGateSet(1);
+	rd=VpuReadReg(0x120);
+	wr=VpuReadReg(0x124);
+	IOClkGateSet(0);
+	printf("vpu register: wr: 0x%X, rd: 0x%X \r\n", wr, rd);
+}
+#endif
+
+	if(0==InIsEnough)		//TODO: should remove it after wrapper is stable
+	{
+		//check free space
+		if(nSpace<nFillSize)
+		{
+			//VPU_LOG("vpu bistream is too full, free=%d, required=%d \r\n",(unsigned int)nSpace,nFillSize);
+			//1 need to check and update pObj->state from DEC to FRAMEOK ????
+			return 0;
+		}
+	}
+
+#ifdef VPU_DEBUG_BS
+	totalSize+=nFillSize;
+	VPU_LOG("total filled data size = %d \r\n",totalSize);
+#endif
+
+	//in file mode, we may not get correct value from vpu_DecGetBitstreamBuffer(), so we need to add different branch for filemode.
+	if(0==pObj->filemode)
+	{
+		//check ring buffer's bottom
+		if((unsigned int)pObj->pBsBufPhyEnd < (unsigned int)Wr + nFillSize)
+		{
+			//need to split data into two segments
+			ASSERT((unsigned int)(pObj->pBsBufPhyEnd) != (unsigned int)Wr);
+			nFillUnit=(unsigned int)pObj->pBsBufPhyEnd-(unsigned int)Wr;
+			pFill=pObj->pBsBufVirtStart+((unsigned int)Wr-(unsigned int)pObj->pBsBufPhyStart);
+			vpu_memcpy(pFill,pSrc,nFillUnit);
+			VPU_API("calling vpu_DecUpdateBitstreamBuffer(): %d \r\n",nFillUnit);
+			ret = vpu_DecUpdateBitstreamBuffer(InVpuHandle, nFillUnit);
+
+			//update nFillUnit for next writing
+			pSrc+=nFillUnit;
+			nFillUnit=nFillSize- nFillUnit;
+			VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+			ret = vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+			VPU_LOG("nSpace: %d \r\n", nSpace);
+		}
+		else
+		{
+			nFillUnit=nFillSize;
+		}
+
+		//write the left data
+		pFill=pObj->pBsBufVirtStart+((unsigned int)Wr-(unsigned int)pObj->pBsBufPhyStart);
+		vpu_memcpy(pFill,pSrc,nFillUnit);
+		VPU_TRACE;
+		VPU_API("calling vpu_DecUpdateBitstreamBuffer(): %d \r\n",nFillUnit);
+		ret = vpu_DecUpdateBitstreamBuffer(InVpuHandle, nFillUnit);
+		VPU_TRACE;
+
+		//VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+		//ret = vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+		//VPU_LOG("nSpace: %d \r\n", nSpace);		
+	}
+	else
+	{
+		//file mode: always write data from start address+offset.
+		nFillUnit=nFillSize;
+		ASSERT(nFillUnit<(unsigned int)(pObj->pBsBufPhyEnd-pObj->pBsBufPhyStart-nFileModeOffset));
+		pFill=pObj->pBsBufVirtStart+nFileModeOffset;
+		vpu_memcpy(pFill,pSrc,nFillUnit);
+		VPU_API("calling vpu_DecUpdateBitstreamBuffer(): %d \r\n",nFillUnit);
+		ret = vpu_DecUpdateBitstreamBuffer(InVpuHandle, nFillUnit);
+	}
+
+	//check ret ??
+
+#ifdef VPU_ONE_EOS
+	//update eos flag
+	if(nFillUnit==0)
+	{
+		eos_flag=1;
+	}
+	else
+	{
+		eos_flag=0;
+	}
+#endif
+
+#ifdef VPU_PROTECT_MULTI_INSTANCE
+	//TODO: In fact, we can merge two variables (eos_flag and filledEOS) into one 
+	if(nFillUnit==0)
+	{
+		pObj->filledEOS=1;
+	}
+	else
+	{
+		pObj->filledEOS=0;
+	}
+#endif
+
+	if(VPU_DUMP_RAW){
+		WrapperFileDumpBitstrem(&fpBitstream,pInVirt,nSize);
+		//nDumpSize+=nSize;
+		//LOG_PRINTF("dump size: %d \r\n",nDumpSize);
+	}
+	
+	return 1;
+}
+
+int VpuUpdateErrInfo(VpuDecObj* pObj,DecInitialInfo * pInitInfo)
+{
+	unsigned int nMask_NotSupported=0;
+	unsigned int nMask_Corrupt=0xFFFFFFFF;
+	if(pInitInfo->errorcode==0){
+		return 1; //no error
+	}
+	
+	//now, only mapping errcode for iMX6
+	if(CPU_IS_MX6X()){
+		switch(pObj->CodecFormat){
+		case VPU_V_MPEG4:
+		case VPU_V_DIVX3:
+		case VPU_V_DIVX4:
+		case VPU_V_DIVX56:
+		case VPU_V_XVID:
+		case VPU_V_H263:
+			/*
+			bit[0..31]:
+			Mpeg4: short header
+				3	MP4ERR_MP4ERR_ANNEXD
+				4	MP4ERR_MP4ERR _ANNEXEFG
+				7	MP4ERR_ANNEXD_PLUSPTYPE
+				8	MP4ERR_ANNEXEF_PLUSPTYPE
+				9	MP4ERR_ANNEXNRS_PLUSPTYPE
+				11	MP4ERR_ANNEXPQ_MPPTYPE
+			Mpeg4:VOL VOS
+				1	MP4ERR_VIDEO_OBJECT_LAYER_VERID
+				4	MP4ERR_CHROMA_FORMAT
+				6	MP4ERR_VIDEO_OBJECT_LAYER_SHAPE
+				9	MP4ERR_OBMC_DISABLE
+				10	MP4ERR_SPRITE_ENABLE
+				11	MP4ERR_NOT_8_BIT
+				12	MP4ERR_COMPLEXITY_EST_DISABLE
+				13	MP4ERR_SCALABILITY
+			*/
+#if 0		//vpu may not set 'mp4_shortVideoHeader' correctly when returning error
+			if(pInitInfo->mp4_shortVideoHeader){
+#else
+			if((VPU_V_H263==pObj->CodecFormat) ||pInitInfo->mp4_shortVideoHeader){
+#endif
+				nMask_NotSupported=(1<<3)|(1<<4)|(1<<7)|(1<<8)|(1<<9)|(1<<11);
+			}
+			else{
+				nMask_NotSupported=(1<<1)|(1<<4)|(1<<6)|(1<<9)|(1<<10)|(1<<11)|(1<<12)|(1<<13);
+			}
+			break;
+		case VPU_V_AVC:
+		case VPU_V_AVC_MVC:
+			/*
+			bit[0..31]:
+				5	AVCERR_BIT_DEPTH_LUMA_MINUS8
+				6	AVCERR_BIT_DEPTH_CHROMA_MINUS8
+				17	AVCERR_OVER_MAX_MB_SIZE
+				18	AVCERR_NOT_SUPPORT_PROFILEIDC
+				19	AVCERR_NOT_SUPPORT_LEVELIDC
+			*/
+			nMask_NotSupported=(1<<5)|(1<<6)|(1<<17)|(1<<18)|(1<<19);
+			break;
+		case VPU_V_VC1:
+		case VPU_V_VC1_AP:
+			/*
+			bit[0..31]:
+				3	VC1ERR_COMPLEX_PROFILE
+				4	VC1ERR_YUV411
+				5	VC1ERR_SPRITE
+			*/
+			nMask_NotSupported=(1<<3)|(1<<4)|(1<<5);
+			break;
+		case VPU_V_MPEG2:
+			/*
+			bit[0..31]:
+				8	MP2ERR_CHROMA_FORMAT.
+				16	MP2ERR_NOT_SUPPORTED_PROFILE
+			*/
+			nMask_NotSupported=(1<<8)|(1<<16);
+			break;
+		case VPU_V_AVS:
+			/*
+			bit[0..31]:
+				1	AVSERR_PROFILE
+			*/
+			nMask_NotSupported=(1<<1);
+			break;
+		case VPU_V_RV:
+		case VPU_V_MJPG:
+		case VPU_V_VP8:
+		default:
+			VPU_LOG("ignore error info for format: %d \r\n",pObj->CodecFormat);
+			break;
+		}
+	}
+	else{
+		VPU_LOG("ignore error info for non-IMX6 platform \r\n");
+	}
+
+	if(pInitInfo->errorcode & nMask_NotSupported){
+		pObj->nLastErrorInfo=VPU_DEC_ERR_NOT_SUPPORTED;
+		VPU_ERROR("not supported : errorcode: 0x%X \r\n",(unsigned int)pInitInfo->errorcode);
+	}
+	else if(pInitInfo->errorcode & nMask_Corrupt){
+		pObj->nLastErrorInfo=VPU_DEC_ERR_CORRUPT;
+		VPU_ERROR("corrupt : errorcode: 0x%X \r\n",(unsigned int)pInitInfo->errorcode);
+	}
+	else{
+		//nothing
+	}
+	
+	return 1;
+}
+
+int VpuSeqInit(DecHandle InVpuHandle, VpuDecObj* pObj ,VpuBufferNode* pInData,int* pOutRetCode,int * pNoErr) 
+{
+	RetCode ret;
+	DecInitialInfo initInfo;
+
+	unsigned char* pHeader=NULL;
+	unsigned int headerLen=0;
+
+	unsigned char aVC1Header[VC1_MAX_SEQ_HEADER_SIZE];
+	unsigned char aVP8Header[VP8_SEQ_HEADER_SIZE+VP8_FRM_HEADER_SIZE];
+	unsigned char aDIV3Header[DIV3_SEQ_HEADER_SIZE+DIV3_FRM_HEADER_SIZE];	
+	int bufIsEnough=1;
+
+	//FIXME: total_* is only for internal debug now after we adding macro VPU_AVOID_DEAD_LOOP 
+	static int total_size=0;		// avoid dead loop for unsupported clips
+	static int total_loop=0;		// avoid dead loop for crashed file
+	*pNoErr=1;	//set default: no error
+
+	//for special formats, we need to re-organize data
+	switch(pObj->CodecFormat)
+	{
+		case VPU_V_VC1:
+		case VPU_V_VC1_AP:
+			pHeader=aVC1Header;
+			if ((0==pInData->sCodecData.nSize)||(0xFFFFFFFF==pInData->sCodecData.nSize))
+			{
+				//raw file: .rcv/.vc1
+				//do nothing
+				//1 for identify raw data ( .rcv/.vc1), user should not clear sCodecData.nSize before seqinit finished !!!
+			}
+			else if(pInData->nSize==0){
+				//do nothing for invalid data
+			}
+			else if(pObj->nPrivateSeqHeaderInserted==0)
+			{
+				//insert private data
+				if((pObj->CodecFormat==VPU_V_VC1_AP))
+				{
+					if((pInData->pVirAddr==NULL) ||(pInData->nSize<4))
+					{
+						//we need pInData->pVirAddr to create correct VC1 header
+						//TODO: or define one default value when pInData->pVirAddr is NULL
+						VPU_LOG("%s: no input buffer, return and do nothing \r\n",__FUNCTION__);	
+						*pOutRetCode=VPU_DEC_INPUT_NOT_USED;
+						return 0;
+					}
+					VC1CreateNALSeqHeader(pHeader, (int*)(&headerLen),pInData->sCodecData.pData, (int)pInData->sCodecData.nSize, (unsigned int*)pInData->pVirAddr,VC1_MAX_SEQ_HEADER_SIZE);
+				}
+				else
+				{
+					//1 nSize must == frame size ??? 
+					VPU_LOG("%s: [width x height]=[%d x %d] , frame size =%d \r\n",__FUNCTION__,pObj->picWidth,pObj->picHeight,pInData->nSize);
+					VC1CreateRCVSeqHeader(pHeader, (int*)(&headerLen),pInData->sCodecData.pData, pInData->nSize,pObj->picWidth,pObj->picHeight);
+				}
+
+#ifdef VPU_WRAPPER_DEBUG
+				printf_memory(pHeader, headerLen, 1, headerLen);
+#endif				
+
+			}
+			else
+			{
+				//private data have already been inserted before
+				//so we need to insert frame header !!! when we enable macro VPU_DEC_CHECK_INIT_LENGTH
+
+				if((pInData->pVirAddr==NULL)/* ||(pInData->nSize<4)*/)
+				{
+					VPU_LOG("%s: no input buffer, return and do nothing \r\n",__FUNCTION__);	
+					*pOutRetCode=VPU_DEC_INPUT_NOT_USED;
+					return 0;
+				}
+
+				if((pObj->CodecFormat==VPU_V_VC1_AP))
+				{
+					ASSERT(pInData->nSize>=4);
+					VC1CreateNalFrameHeader(pHeader,(int*)(&headerLen),(unsigned int*)(pInData->pVirAddr));
+				}
+				else
+				{
+					//need to insert header : frame size
+					VC1CreateRCVFrameHeader(pHeader,(int*)(&headerLen),pInData->nSize);
+				}					
+			}	
+			break;
+		case VPU_V_VP8:
+			pHeader=aVP8Header;
+			if (pInData->sCodecData.nSize==0xFFFFFFFF)	
+			{
+				//raw data
+				//do nothing
+				//1 for identify raw data , user should set 0xFFFFFFF to sCodecData.nSize before seqinit finished !!!
+			}
+			else if(pInData->nSize==0){
+				//do nothing for invalid data
+			}
+			else
+			{
+				if(pObj->nPrivateSeqHeaderInserted==0)
+				{
+					unsigned int frmHdrLen=0;
+					if(pInData->sCodecData.nSize!=0)
+					{
+						VPU_ERROR("Warning: VP8 CodecData is not NULL, and it will be ignored by wrapper !\r\n");
+					}
+					//insert private data: seq+frm header
+					VPU_LOG("%s: [width x height]=[%d x %d] , frame size =%d \r\n",__FUNCTION__,pObj->picWidth,pObj->picHeight,pInData->nSize);
+					VP8CreateSeqHeader(pHeader, (int*)(&headerLen),1,1,0,pObj->picWidth,pObj->picHeight);
+					VP8CreateFrameHeader(pHeader+headerLen,(int*)(&frmHdrLen),pInData->nSize,0,0);
+					headerLen+=frmHdrLen;
+#ifdef VPU_WRAPPER_DEBUG
+					printf_memory(pHeader, headerLen, 1, headerLen);
+#endif
+				}
+				else
+				{
+					//seq header have already been inserted before
+					//so we need to insert frame header !!! when we enable macro VPU_DEC_CHECK_INIT_LENGTH
+					if((pInData->pVirAddr==NULL)/* ||(pInData->nSize<4)*/)
+					{
+						VPU_LOG("%s: no input buffer, return and do nothing \r\n",__FUNCTION__);	
+						*pOutRetCode=VPU_DEC_INPUT_NOT_USED;
+						return 0;
+					}
+					//need to insert header : frame size
+					VP8CreateFrameHeader(pHeader,(int*)(&headerLen),pInData->nSize,0,0);
+				}	
+			}
+			break;
+		default:
+			if((CPU_IS_MX6X())&&(pObj->CodecFormat==VPU_V_DIVX3))
+			{
+				//for iMX6: DivX3
+				pHeader=aDIV3Header;
+				if (pInData->sCodecData.nSize==0xFFFFFFFF)	
+				{
+					//raw data ??
+					//do nothing
+					//1 for identify raw data , user should set 0xFFFFFFF to sCodecData.nSize before seqinit finished !!!
+				}
+				else if(pInData->nSize==0){
+					//do nothing for invalid data
+				}
+				else
+				{
+					if(pObj->nPrivateSeqHeaderInserted==0)
+					{
+						unsigned int frmHdrLen=0;
+						if(pInData->sCodecData.nSize!=0)
+						{
+							VPU_ERROR("Warning: DIV3 CodecData is not NULL, and it will be ignored by wrapper !\r\n");
+						}
+						//insert private data: seq+frm header
+						VPU_LOG("%s: [width x height]=[%d x %d] , frame size =%d \r\n",__FUNCTION__,pObj->picWidth,pObj->picHeight,pInData->nSize);
+						DIV3CreateSeqHeader(pHeader, (int*)(&headerLen),1,1,0,pObj->picWidth,pObj->picHeight);
+						DIV3CreateFrameHeader(pHeader+headerLen,(int*)(&frmHdrLen),pInData->nSize,0,0);
+						headerLen+=frmHdrLen;
+#ifdef VPU_WRAPPER_DEBUG
+						printf_memory(pHeader, headerLen, 1, headerLen);
+#endif
+					}
+					else
+					{
+						//seq header have already been inserted before
+						//so we need to insert frame header !!! when we enable macro VPU_DEC_CHECK_INIT_LENGTH
+						if((pInData->pVirAddr==NULL)/* ||(pInData->nSize<4)*/)
+						{
+							VPU_LOG("%s: no input buffer, return and do nothing \r\n",__FUNCTION__);	
+							*pOutRetCode=VPU_DEC_INPUT_NOT_USED;
+							return 0;
+						}
+						//need to insert header : frame size
+						DIV3CreateFrameHeader(pHeader,(int*)(&headerLen),pInData->nSize,0,0);
+					}	
+				}
+			}
+			else
+			{
+				//other formats
+				if ((0==pInData->sCodecData.nSize)||(0xFFFFFFFF==pInData->sCodecData.nSize))
+				{
+					//raw data
+					//do nothing
+				}
+				else if(pObj->nPrivateSeqHeaderInserted==0)
+				{
+					//insert private data
+					if((pObj->CodecFormat==VPU_V_AVC)&&(0==pObj->nIsAvcc)){
+						VpuDetectAvcc(pInData->sCodecData.pData,pInData->sCodecData.nSize,&pObj->nIsAvcc,&pObj->nNalSizeLen);
+					}
+					if(pObj->nIsAvcc){
+						VpuConvertAvccHeader(pInData->sCodecData.pData,pInData->sCodecData.nSize, &pHeader,&headerLen);
+					}
+					else{
+						pHeader=pInData->sCodecData.pData;
+						headerLen=pInData->sCodecData.nSize;
+					}
+				}			
+				else
+				{
+					//private data have already been inserted before
+					//do nothing
+				}
+			}
+			break;
+	}
+
+
+	//check free space and fill data into vpu
+	bufIsEnough=VpuBitsBufIsEnough(InVpuHandle,headerLen+pInData->nSize);
+
+#ifdef VPU_INIT_FREE_SIZE_LIMITATION
+	{
+		#define VPU_INIT_UNIT_SIZE	512
+		unsigned int validSize;
+		unsigned int freeSize;
+		VpuBitsBufValidDataLength(InVpuHandle, pObj, &validSize,&freeSize);
+		//if(1==pObj->filemode) //only in file mode ???, not sure
+		if((freeSize<VPU_INIT_UNIT_SIZE)&&(validSize<(VPU_BITS_BUF_SIZE/2)))
+		{
+			VPU_LOG("fake info: freeSize: %d, validSize: %d, we should continue feed data \r\n",freeSize,validSize);
+			bufIsEnough=1;
+		}
+	}
+#endif
+
+	if(0==bufIsEnough)
+	{
+		//write failure: buffer is full
+		*pOutRetCode=VPU_DEC_INPUT_NOT_USED;
+		//TODO: add flush bitstream buffer to avoid dead loop in application ??
+		//Here: we think the clip can not be identified by vpu if bitstream buffer is full
+		VPU_ERROR("seq init failure: buffer is full: total_size: %d, total_loop: %d \r\n",total_size,total_loop);
+		*pNoErr=0;
+		total_size=0;	//clear 0
+		total_loop=0;
+		return 0;
+	}
+	else
+	{
+		//it is enough to fill
+		int fill_ret;
+		if(0!=headerLen)
+		{
+			fill_ret=VpuFillData(InVpuHandle,pObj,pHeader,headerLen,1,0);
+			if(pObj->nIsAvcc && (pInData->sCodecData.pData != pHeader)){
+				vpu_free(pHeader); //the logic should make sure it won't be freed repeatedly
+			}
+			if(0==pObj->nPrivateSeqHeaderInserted)
+			{
+				VpuAccumulateConsumedBytes(pObj, headerLen, 0,NULL,NULL);	//seq/config 
+			}
+			else
+			{
+				VpuAccumulateConsumedBytes(pObj, headerLen, 1,NULL,NULL);	//frame header
+			}
+			
+			if(0!=pInData->sCodecData.nSize)
+			{
+				//not raw data : .rcv/.vc1
+				pObj->nPrivateSeqHeaderInserted=1; // we need to re-open vpu wrapper if user want to re-seqinit
+			}
+			else if((pObj->CodecFormat==VPU_V_VP8)||
+				((CPU_IS_MX6X())&&(pObj->CodecFormat==VPU_V_DIVX3)))
+			{
+				//for VP8/DivX3(iMX6), regard it as non-raw data as long as headerLen!=0
+				pObj->nPrivateSeqHeaderInserted=1; 
+			}
+		}
+		//allow pInData->nSize==0 ???
+		if(pObj->nIsAvcc){
+			VpuConvertAvccFrame(pInData->pVirAddr,pInData->nSize,pObj->nNalSizeLen);
+		}
+		fill_ret=VpuFillData(InVpuHandle,pObj,pInData->pVirAddr,pInData->nSize,1,headerLen);
+		ASSERT(fill_ret==1);
+		total_size+=headerLen+pInData->nSize;
+		total_loop++;
+	}
+
+	if(0==pObj->filemode)
+	{
+#ifdef VPU_DEC_CHECK_INIT_LENGTH
+		PhysicalAddress Rd;
+		PhysicalAddress Wr;
+		unsigned long nSpace;
+		//check init size only for stream mode
+		VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+		vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+		if(NotEnoughInitData(nSpace))
+		{
+			//not inited
+			*pOutRetCode=VPU_DEC_INPUT_USED;
+			return 0;
+		}
+		VPU_LOG("have collect %d bytes data to start seq init \r\n",VPU_MIN_INIT_SIZE);
+#endif	
+	}
+	else
+	{
+		//here, we need to consider header length
+		//ASSERT(headerLen==0);
+		pObj->firstDataSize=headerLen+pInData->nSize;
+	}
+	VPU_LOG("===================seqinit : length: %d \r\n",pObj->firstDataSize);
+
+	VPU_TRACE;
+	VPU_API("calling vpu_DecSetEscSeqInit(): 1 \r\n");
+	vpu_DecSetEscSeqInit(InVpuHandle, 1);
+	VPU_TRACE;	
+	VPU_API("calling vpu_DecGetInitialInfo() \r\n");
+	vpu_memset(&initInfo, 0, sizeof(DecInitialInfo));
+	ret = vpu_DecGetInitialInfo(InVpuHandle, &initInfo);
+	VPU_TRACE;
+	VPU_API("calling vpu_DecSetEscSeqInit(): 0, interlace: %d , errcode: 0x%X \r\n",initInfo.interlace,(unsigned int)initInfo.errorcode);
+	vpu_DecSetEscSeqInit(InVpuHandle, 0);
+	VPU_TRACE;
+	if (ret != RETCODE_SUCCESS)
+	{
+		*pOutRetCode=VPU_DEC_INPUT_USED;
+
+		if(1==pObj->filemode)
+		{
+			//if((0!=headerLen)&&(0==pInData->nSize)&&(NULL==pInData->pVirAddr))
+			{
+				VPU_LOG("header is valid, but data is unvalid ! \r\n");
+				//FIX case: user has not set input before decoding; (clip: 720P10M30FPS.mpg, command(p s p))
+				//shouldn't return error
+				pObj->nPrivateSeqHeaderInserted=0; //need to re-fill the header next round
+			}
+		}
+		VpuUpdateErrInfo(pObj,&initInfo);
+		//check some special case: and report error to let application exist directly
+		if(ret==RETCODE_NOT_SUPPORTED){
+			*pNoErr=0;
+			pObj->nLastErrorInfo=VPU_DEC_ERR_NOT_SUPPORTED;
+		}
+		return 0;
+	}
+	else
+	{
+		int cropWidth,cropHeight;
+		*pOutRetCode=VPU_DEC_INIT_OK|VPU_DEC_INPUT_USED;
+
+		//update state
+		pObj->state=VPU_DEC_STATE_INITOK;
+#ifdef IMX6_PIC_ORDER_WORKAROUND
+		if(CPU_IS_MX6X())
+		{
+			VPU_API("codec: %d(AVC=6),profile: %d,  minum bufcount: %d, buf delay: %d \r\n",pObj->CodecFormat,initInfo.profile,initInfo.minFrameBufferCount, initInfo.frameBufDelay);
+			if((3==initInfo.minFrameBufferCount)/*&&(0==initInfo.frameBufDelay)*/)
+			{
+				initInfo.minFrameBufferCount=10;
+			}
+		}
+#endif
+		//record init output info
+		pObj->initInfo.nMinFrameBufferCount=initInfo.minFrameBufferCount;
+		pObj->initInfo.nPicHeight=initInfo.picHeight;
+		pObj->initInfo.nPicWidth=initInfo.picWidth;
+		pObj->initInfo.nInterlace=initInfo.interlace;
+		if(VPU_V_MJPG==pObj->CodecFormat)
+		{
+			pObj->initInfo.nMjpgSourceFormat=initInfo.mjpg_sourceFormat;
+		}
+		
+		if(CPU_IS_MX6X())
+		{
+			pObj->initInfo.nFrameRateRes=(int)initInfo.frameRateRes;
+			pObj->initInfo.nFrameRateDiv=(int)initInfo.frameRateDiv;
+		}
+		else
+		{
+			pObj->initInfo.nFrameRateRes=initInfo.frameRateInfo&0xFFFF;	//[15:0]
+			pObj->initInfo.nFrameRateDiv=((initInfo.frameRateInfo>>16)&0xFFFF)+1;	//[31:16];
+			if(pObj->initInfo.nFrameRateRes==0)
+			{
+				pObj->initInfo.nFrameRateRes=-1;
+				pObj->initInfo.nFrameRateDiv=-1;
+			}
+		}
+		
+		//1 FIXME: set correct nConsumedByte value
+		pObj->initInfo.nConsumedByte=-1;	//unknow
+
+		//alignment for Y,Cb,Cr pointer
+		if(pObj->nMapType==0)
+		{
+			pObj->initInfo.nAddressAlignment=1;
+		}
+		else
+		{
+			pObj->initInfo.nAddressAlignment=VPU_TILE_ALIGN;
+		}
+		
+		//record crop info
+		if(((0==initInfo.picCropRect.bottom)&&(0==initInfo.picCropRect.right))
+			||(initInfo.picCropRect.right<=initInfo.picCropRect.left)
+			||(initInfo.picCropRect.bottom<=initInfo.picCropRect.top))
+		{
+			//Init info is invalid
+			pObj->initInfo.PicCropRect.nLeft= 0;
+			pObj->initInfo.PicCropRect.nRight=initInfo.picWidth;
+			pObj->initInfo.PicCropRect.nTop = 0;
+			pObj->initInfo.PicCropRect.nBottom=initInfo.picHeight;
+		}
+		else
+		{
+			pObj->initInfo.PicCropRect.nLeft = initInfo.picCropRect.left;
+			pObj->initInfo.PicCropRect.nRight=initInfo.picCropRect.right;
+			pObj->initInfo.PicCropRect.nTop = initInfo.picCropRect.top;
+			pObj->initInfo.PicCropRect.nBottom=initInfo.picCropRect.bottom;
+		}
+
+		//record profile/level info
+		pObj->nProfile=initInfo.profile;
+		pObj->nLevel=initInfo.level;
+		//convert aspect ratio info
+		cropWidth=pObj->initInfo.PicCropRect.nRight-pObj->initInfo.PicCropRect.nLeft;
+		cropHeight=pObj->initInfo.PicCropRect.nBottom-pObj->initInfo.PicCropRect.nTop;
+		pObj->initInfo.nQ16ShiftWidthDivHeightRatio=VpuConvertAspectRatio(pObj->CodecFormat,(unsigned int)initInfo.aspectRateInfo,cropWidth,cropHeight, pObj->nProfile,pObj->nLevel);
+
+		//clear 0
+		total_size=0;
+		total_loop=0;
+
+		VPU_API("%s:vpu init OK: [width x heigh]=[%d x %d] , mini count: %d \r\n",__FUNCTION__,initInfo.picWidth,initInfo.picHeight,initInfo.minFrameBufferCount);
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+		if((1==pObj->filemode)&&(1==initInfo.interlace)&&(VPU_V_AVC==pObj->CodecFormat))	//FIXME: now only process for H.264 ???
+		{
+			pObj->fieldDecoding=1;
+		}
+#endif
+		pObj->nOriHeight=pObj->initInfo.nPicHeight;
+		pObj->nOriWidth=pObj->initInfo.nPicWidth;
+		return 1;
+	}
+
+}
+
+int VpuGetOutput(DecHandle InVpuHandle, VpuDecObj* pObj,int* pOutRetCode,int InSkipMode,int* pOutInStreamModeEnough,int InFilemodeChunkSize,int* pOutDecoded)
+{
+	RetCode ret;
+	DecOutputInfo outInfo;
+	VpuFrameBuffer * pFrameDisp;
+	VpuFrameBuffer * pFrameDecode=NULL;	
+//#ifdef VPU_WRAPPER_DUMP
+	static FILE* fpYUV=NULL;
+//#endif
+#ifdef VPU_FILEMODE_WORKAROUND
+	int disOrderOutput=0;		// the state of output buffer is error
+#endif
+
+#ifdef VPU_BACKDOOR		
+	VpuLogClearFlag(InVpuHandle);
+#endif
+
+	*pOutDecoded=0;	//default: no frame is decoded
+
+	vpu_memset(&outInfo,0,sizeof(DecOutputInfo));	//clear 0: it is useful for some error case debug
+	VPU_TRACE;
+	VPU_API("calling vpu_DecGetOutputInfo() \r\n");
+	ret = vpu_DecGetOutputInfo(InVpuHandle, &outInfo);
+	VPU_API("calling vpu_DecGetOutputInfo(), indexFrmDec: %d, return indexFrmDis: %d, type: %d, success: 0x%X, errMB: %d, consumed: %d \r\n",outInfo.indexFrameDecoded,outInfo.indexFrameDisplay,outInfo.picType,outInfo.decodingSuccess,outInfo.numOfErrMBs,outInfo.consumedByte);
+	VPU_LOG("fieldSequence: %d, vc1_repeatFrame: %d,interlacedFrame: %d, indexFrameRangemap: %d, progressiveFrame: %d, topFieldFirst: %d \r\n",outInfo.fieldSequence,outInfo.vc1_repeatFrame,outInfo.interlacedFrame,outInfo.indexFrameRangemap,outInfo.progressiveFrame,outInfo.topFieldFirst);
+#ifdef VPU_BACKDOOR		
+	VpuLogClearFlag(InVpuHandle);
+#endif
+
+#if 0//def IMX6_INTER_DEBUG_RD_WR
+{
+	unsigned int rd,wr;
+	unsigned int start,end;
+//#define BIT_RD_PTR_0			0x120
+//#define BIT_WR_PTR_0			0x124
+	IOClkGateSet(1);
+	rd=VpuReadReg(0x120);
+	wr=VpuReadReg(0x124);
+	start=VpuReadReg(0x144);
+	end=VpuReadReg(0x148);	
+	IOClkGateSet(0);
+	printf("vpu register: wr: 0x%X, rd: 0x%X, start: 0x%X, end: 0x%X \r\n", wr, rd,start,end);
+}
+#endif
+
+	if((CPU_IS_MX6X()) &&(outInfo.indexFrameDisplay>=pObj->frameNum))
+	{
+		//FIXME: iMX6X workaround to fix the display index overflow
+		VPU_ERROR("%s: indexFrameDisplay overflow: %d, will rectify it maunally !!! \r\n",__FUNCTION__,outInfo.indexFrameDisplay);
+		outInfo.decodingSuccess=0x10;
+		outInfo.indexFrameDecoded=VPU_OUT_DEC_INDEX_NOMEANING;		
+		outInfo.indexFrameDisplay=VPU_OUT_DIS_INDEX_NODIS;
+	}
+
+	if((VPU_V_VP8==pObj->CodecFormat)&&(CPU_IS_MX6X()))
+	{
+		//FIXME: iMX6X workaround to fix the decIndx/disIndx issue for VP8: indexFrameDisplay==indexFrameDecoded==-1
+		if((VPU_OUT_DEC_INDEX_EOS==outInfo.indexFrameDecoded) &&(VPU_OUT_DIS_INDEX_EOS==outInfo.indexFrameDisplay))
+		{
+			VPU_ERROR("%s: warning: conflict index meaning, indexFrameDecoded: %d, indexFrameDisplay: %d, decodingSuccess: %dwill rectify it maunally !!! \r\n",__FUNCTION__,outInfo.indexFrameDecoded,outInfo.indexFrameDisplay,outInfo.decodingSuccess);
+			if(0==outInfo.decodingSuccess)
+			{
+				//no frame buffer: -1,-1 => -1,-3
+				//outInfo.indexFrameDecoded=VPU_OUT_DEC_INDEX_EOS;
+				outInfo.indexFrameDisplay=VPU_OUT_DIS_INDEX_NODIS;
+			}
+			else
+			{
+				//eos: -1,-1 => -2,-1
+				outInfo.indexFrameDecoded=VPU_OUT_DEC_INDEX_UNDEC;
+				//outInfo.indexFrameDisplay=VPU_OUT_DIS_INDEX_NODIS;
+			}
+			outInfo.decodingSuccess=0x1;
+		}
+#ifdef IMX6_VP8_SHOWFRAME_WORKAROUND
+		if((outInfo.indexFrameDecoded>=0) &&(VPU_OUT_DIS_INDEX_NODIS==outInfo.indexFrameDisplay)){			
+			//change (>0,-3) => (-2,-3) manually since no I frame (e.g no delay) for vp8
+			VPU_ERROR("find one invisible frame, skip it manually(need to notify user pop one time stamp) \r\n");
+			outInfo.indexFrameDecoded=VPU_OUT_DEC_INDEX_UNDEC;
+			InSkipMode=1;
+		}
+#endif
+	}
+
+#ifdef IMX6_AVC_NOFRAME_WORKAROUND
+	//workaround: check the illegal decIndx and rectify it. (-1,-3 => -2,-3)			
+	if((CPU_IS_MX6X())&&(VPU_V_AVC==pObj->CodecFormat)&&((outInfo.decodingSuccess & 0x10)==0)
+		&&(outInfo.indexFrameDecoded==VPU_OUT_DEC_INDEX_EOS)&&(outInfo.indexFrameDisplay==VPU_OUT_DIS_INDEX_NODIS)){
+		int hold_num=0;
+		hold_num=VpuQueryVpuHoldBufNum(pObj);
+		if(hold_num==pObj->frameNum){
+			VPU_ERROR("illegal decIndex: %d , rectify decIndx to -2 \r\n",outInfo.indexFrameDecoded);
+			outInfo.indexFrameDecoded=VPU_OUT_DEC_INDEX_UNDEC;
+		}
+	}
+#endif
+	
+	if(!CPU_IS_MX6X())
+	{	
+		//enhance for iMX5
+		if((ret==RETCODE_SUCCESS)&&(outInfo.indexFrameDecoded>=0)&&
+			(((outInfo.prescanresult==1)&&(pObj->filemode==0))||(pObj->filemode==1)))
+			/*
+				ret ok
+				decoded frame is valid
+				stream mode prescan ok
+			*/
+		{
+			if((VPU_V_AVC==pObj->CodecFormat)&&
+				((outInfo.decPicWidth!=pObj->initInfo.nPicWidth)||(outInfo.decPicHeight!=pObj->initInfo.nPicHeight)
+				||((outInfo.numOfErrMBs==-1)&&(outInfo.decodingSuccess==0))))
+			{
+				/*for some avc corrupted clips: often occur unrecoverable display issue even if inserting sps/pps header again after seeking
+					-resolution change
+					-decode serious fail: errMB=-1 && success=0 && decIndex>=0
+				*/
+				VPU_ERROR("%s:resolution changed: original[%dx%d], new[%dx%d] \r\n",__FUNCTION__,pObj->initInfo.nPicWidth,pObj->initInfo.nPicHeight,outInfo.decPicWidth,outInfo.decPicHeight);
+				return 0;
+			}
+		}
+	}
+#ifdef IMX6_INTER_DEBUG
+{
+	static int valid_deccnt=0;
+	static int valid_discnt=0;
+	if(outInfo.indexFrameDisplay>=0)
+	{
+		valid_discnt++;
+	}
+	if(outInfo.indexFrameDecoded>=0)	
+	{
+		valid_deccnt++;
+	}	
+	printf("dec cnt: %d , dis cnt: %d \r\n",valid_deccnt,valid_discnt);
+}
+#endif
+
+#ifdef IMX6_RANGEMAP_WORKAROUND_IGNORE //for iMX6
+	if(CPU_IS_MX6X())
+	{
+//if(0==outInfo.indexFrameRangemap) 	//for WVC1_APL1_720x480_30fps_1000kbps_NoAudio_MA10055.WMV: always is zero
+		outInfo.indexFrameRangemap=-1;
+	}
+#endif
+
+	pObj->pbPacket=outInfo.mp4PackedPBframe;
+	if((pObj->pbClips==0) && (0!=pObj->pbPacket)) 
+	{
+		pObj->pbClips=1;
+	}
+#ifdef VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE	
+#if 0	// it is difficult to check since "skipframeMode!=0" will affect the result of "interlacedFrame" and "topFieldFirst"
+	if((VPU_V_AVC==pObj->CodecFormat)&&(0!=pObj->initInfo.nInterlace))
+	{
+		if((1==outInfo.interlacedFrame)&&(0==outInfo.topFieldFirst) &&(outInfo.indexFrameDecoded>=0))
+		{
+			pObj->mediumFrame=1; //the first field is decoded
+		}
+		else if ((1==outInfo.interlacedFrame)&&(1==outInfo.topFieldFirst) &&(VPU_OUT_DEC_INDEX_UNDEC==outInfo.indexFrameDecoded))
+		{
+			pObj->mediumFrame=0; //the second field is decoded
+		}
+		else
+		{
+			pObj->mediumFrame=0; //???
+		}
+	}
+#endif
+	//FIXME: Now, only support H.264 interlaced in file mode
+	if((VPU_V_AVC==pObj->CodecFormat)&&(0!=pObj->initInfo.nInterlace)&&(1==pObj->filemode))		
+	{
+		if((outInfo.indexFrameDecoded!=VPU_OUT_DEC_INDEX_EOS)&&(0!=InFilemodeChunkSize))
+		{
+			//one valid field is decoded
+			pObj->fieldCnt=(pObj->fieldCnt==0)?1:0;
+		}
+	}
+#endif
+	VPU_TRACE;
+	*pOutInStreamModeEnough=1;
+	if (ret != RETCODE_SUCCESS)
+	{
+		VPU_LOG("%s:vpu get output info failure: ret=%d \r\n",__FUNCTION__,ret);
+		//pObj->state= ???
+		return 0;
+	}
+	else
+	{
+		int search_ret=1;	//default is no error
+		//check err MB
+		//VPU_LOG("err MB: %d \r\n",outInfo.numOfErrMBs);
+
+		//VPU_LOG("pic type: %d \r\n",outInfo.picType);		
+#ifdef VPU_FLUSH_BEFORE_DEC_WORKAROUND
+		//if(outInfo.indexFrameDecoded>=0)	//need to check decindex or prescanresult ???
+		{
+			pObj->realWork=1;
+		}
+#endif
+
+#ifdef VPU_PROTECT_MULTI_INSTANCE
+		if(((CPU_IS_MX6X()) && (outInfo.decodingSuccess & 0x10)) ||
+			((CPU_IS_MX5X())&&((outInfo.prescanresult==0)&&(pObj->filemode==0))))
+		{
+			/*
+			iMX6: rollback
+			iMX5: stream mode with prescan 
+			*/
+			//1 FIXME:  add rollback for iMX5 ??
+			VPU_LOG("not completed frame \r\n");
+			//stream mode, and incomplete picture stream
+			*pOutRetCode=VPU_DEC_OUTPUT_NODIS;
+			/*workaround for decindex==-1: pepsi-p-diddy.mp4
+			   we need to carefully when enable: VPU_SUPPORT_NO_ENOUGH_FRAME
+			*/
+			outInfo.indexFrameDecoded=VPU_OUT_DEC_INDEX_NOMEANING;	//skip below some special process, such as VPU_DEC_NO_ENOUGH_BUF/VPU_DEC_OUTPUT_DROPPED 
+			*pOutInStreamModeEnough=0;
+		}
+		else
+#endif		
+		{
+			if(VPU_V_MJPG==pObj->CodecFormat)
+			{				
+				//for MJPG, output frame isn't related with indexFrameDisplay
+				//1 how to judge error output ??
+				if(outInfo.indexFrameDecoded>=0)		//???
+				{
+					outInfo.indexFrameDisplay=pObj->mjpg_frmidx;
+					outInfo.indexFrameDecoded=pObj->mjpg_frmidx;
+					VPU_API("MJPG: change index manually: indexFrameDecoded: %d, return indexFrameDisplay: %d \r\n",outInfo.indexFrameDecoded,outInfo.indexFrameDisplay);
+				}
+				//pObj->mjpg_frmidx=(pObj->mjpg_frmidx+1)%pObj->frameNum;
+			}
+
+#ifdef IMX6_WRONG_EOS_WORKAROUND
+			if((CPU_IS_MX6X()) && (outInfo.indexFrameDecoded>=0) && (outInfo.indexFrameDisplay==VPU_OUT_DIS_INDEX_EOS)){
+				VPU_ERROR("warning: vpu report wrong EOS flag, rectify disIndx from -1 to -3 \r\n");
+				outInfo.indexFrameDisplay=VPU_OUT_DIS_INDEX_NODIS;
+			}
+#endif
+
+			//update state
+			//pObj->state=VPU_DEC_STATE_OUTOK;
+
+			//set return code
+			if(VPU_OUT_DEC_INDEX_EOS==outInfo.indexFrameDecoded)
+			{	
+				// decode EOS, skip, no enough frame...?
+				//pFrameDecode==NULL;
+			}
+			else if(VPU_OUT_DEC_INDEX_UNDEC==outInfo.indexFrameDecoded)
+			{
+				// not decoded
+				//pFrameDecode==NULL;
+			}
+			else if(VPU_OUT_DEC_INDEX_UNDEFINE==outInfo.indexFrameDecoded)
+			{
+				ASSERT(0);
+				//pFrameDecode==NULL;
+			}
+			else
+			{
+				search_ret=VpuSearchFrameBuf(pObj,outInfo.indexFrameDecoded,&pFrameDecode);
+				if(search_ret)
+				{
+					//backup current decoded frame info
+					//VpuSaveDecodedFrameInfo(pObj,outInfo.indexFrameDecoded,&outInfo);
+#ifdef VPU_VC1_AP_SKIP_WORKAROUND	
+					if((pObj->CodecFormat==VPU_V_VC1_AP)
+						&&(VpuConvertPicType(pObj->CodecFormat,outInfo.picType,outInfo.idrFlg)==VPU_SKIP_PIC))
+					{
+						//ENGR00157397:we should not call VpuSaveDecodedFrameInfo(), avoid no display at the first seconds (mosaic type)
+						//don't change the state: 
+						//for skip frame, sometimes,may only have two states: free and display ??
+						VPU_ERROR("Caution: VC1 AP: SKIP frame, skip setting decode state(it may be in decode/display state) \r\n");
+					}
+					else
+#endif
+					{
+						int state;
+						//backup current decoded frame info
+						VpuSaveDecodedFrameInfo(pObj,outInfo.indexFrameDecoded,&outInfo,pFrameDecode);
+						*pOutDecoded=1;	//one frame is decoded by vpu
+						state=VpuGetDispFrameState(outInfo.indexFrameDecoded, pObj->frameBufState);
+						if(VPU_FRAME_STATE_FREE!=state)
+						{
+							//FIX some error clips: WVC1_stress_a0_stress06.wmv
+							VPU_ERROR("error: decoded into one unreleased buffer(disp state): don't set decode state, and then it will be skipped !!!\r\n");
+							//outInfo.picType=0x24;
+						}
+						else
+						{
+							VpuSetDispFrameState(outInfo.indexFrameDecoded, pObj->frameBufState,VPU_FRAME_STATE_DEC);
+						}
+					}
+				}
+//#ifdef VPU_IFRAME_SEARCH
+				if(pObj->iframesearch_allowed)
+				{
+					//VpuPicType pictype=VpuConvertPicType(pObj->CodecFormat,outInfo.picType);
+					//if(FRAME_IS_KEY(pictype))
+					{
+						if(pObj->keyDecCnt<MIN_KEY_CNT)
+						{
+							pObj->keyDecCnt++;
+						}
+					}
+				}
+//#endif				
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+				//only consider case: (H.264, filemode,non-interlaced)
+				if(0==pObj->seekKeyLoc)
+				{
+					if(pObj->CodecFormat==VPU_V_AVC)
+					{
+						VPU_LOG("pictype: %d \r\n",outInfo.picType);
+						VpuPicType pictype=VpuConvertPicType(pObj->CodecFormat,outInfo.picType,outInfo.idrFlg);
+						if((0==pObj->initInfo.nInterlace)&&(1==pObj->filemode))
+						{
+							if(FRAME_IS_KEY(pictype))
+							{
+								pObj->seekKeyLoc=1;
+								pObj->recommendFlush=0;
+							}
+							else
+							{
+								//FIXME: It is dangeous call vpu_DecBitBufferFlush() directly !!!!!!
+								//We should return one type to notify componet to call flushfilter() ?????
+								//VPU_API("calling vpu_DecBitBufferFlush() : non-key frame seek point \r\n");
+								//ret=vpu_DecBitBufferFlush(InVpuHandle);
+								//if(RETCODE_SUCCESS!=ret)
+								//{
+								//	VPU_ERROR("%s: vpu flush bit failure (in while loop), ret=%d \r\n",__FUNCTION__,ret);
+								//	//return 0;
+								//}	
+								pObj->recommendFlush=1;
+							}
+						}
+						else
+						{
+							//FIXME: It is complex to process interlace !!!
+							//FIXME: It is difficult to process stream mode !!! how to ???
+						}
+					}
+				}
+#endif
+			}
+
+#ifdef VPU_FILEMODE_WORKAROUND
+			if(1==VpuSearchFrameBuf(pObj,outInfo.indexFrameDisplay,&pFrameDisp))
+			{	
+				int state;
+				state=VpuGetDispFrameState(outInfo.indexFrameDisplay, pObj->frameBufState);
+				if((pObj->CodecFormat==VPU_V_VC1_AP) && (outInfo.indexFrameRangemap>=0))
+				{
+					state=VpuGetDispFrameState(outInfo.indexFrameRangemap, pObj->frameBufState);
+					if(outInfo.indexFrameRangemap!=outInfo.indexFrameDisplay)
+					{
+						//clear original decode buffer to avoid check error above
+						VpuSetDispFrameState(outInfo.indexFrameRangemap,pObj->frameBufState,VPU_FRAME_STATE_FREE);
+						//update state for the new disp buffer ??
+						//FIXME: still not sure !!!!
+						if(state==VPU_FRAME_STATE_DEC)
+						{
+							if(VPU_FRAME_STATE_FREE==VpuGetDispFrameState(outInfo.indexFrameDisplay, pObj->frameBufState))
+							{
+								VpuSetDispFrameState(outInfo.indexFrameDisplay,pObj->frameBufState,VPU_FRAME_STATE_DEC );	
+							}
+							else
+							{
+								//do nothing ??
+								//WVC1_APL1_720x480_30fps_1000kbps_NoAudio_MA10055.WMV
+							}
+						}
+						else
+						{
+							//output one frame not decoded before, drop it in below checking
+						}
+					}
+				}
+				if(VPU_FRAME_STATE_DEC!=state)
+				{
+					//FIXME: we should set dropped, but not discard it internally. otherwise, the timestamp is not matched!!!!
+					VPU_API("%s: calling vpu_DecClrDispFlag(): %d (invalid output) \r\n",__FUNCTION__,outInfo.indexFrameDisplay);				
+					ret=vpu_DecClrDispFlag(InVpuHandle,outInfo.indexFrameDisplay);
+					ASSERT(RETCODE_SUCCESS==ret);
+					//needn't clear frame state ?
+					//VpuClearDispFrame(outInfo.indexFrameDisplay, pVpuObj->obj.frameBufState);
+
+					if(pObj->CodecFormat==VPU_V_VC1_AP)
+					{
+						//Test_1440x576_WVC1_6Mbps.wmv: skip frame, already is set to disp state ??
+						//do nothing, only output error log
+						VPU_ERROR("error: output one frame not decoded at all !!!!!(may be in disp/free state) \r\n");
+					}
+					else if((pObj->CodecFormat==VPU_V_MPEG4)
+						||(pObj->CodecFormat==VPU_V_DIVX4)
+						||(pObj->CodecFormat==VPU_V_DIVX56)
+						||(pObj->CodecFormat==VPU_V_XVID)
+						||(pObj->CodecFormat==VPU_V_H263))
+					{
+						//now, we can't call vpu_DecBitBufferFlush, so the frame buffers may be not cleared enough at flush step 
+						outInfo.indexFrameDisplay=VPU_OUT_DIS_INDEX_NODIS;
+						VPU_ERROR("error:  output one frame not decoded at all !!!!!, we will discard it !!!!! \r\n");
+						disOrderOutput=1;
+					}
+					else
+					{
+						//fields + skipmode: buffer may be disorder: ch100-mpeg4sd-dec.ts
+						//discarding the frame is useful when enable VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE
+						outInfo.indexFrameDisplay=VPU_OUT_DIS_INDEX_NODIS;
+						VPU_ERROR("error: output one frame not decoded at all !!!!! \r\n");
+						disOrderOutput=1;
+					}
+				}
+			}
+#endif
+
+			if(VPU_OUT_DIS_INDEX_NODIS==outInfo.indexFrameDisplay)
+			{	
+				// not display
+				pFrameDisp=NULL;
+				*pOutRetCode=VPU_DEC_OUTPUT_NODIS;
+			}
+			else if(VPU_OUT_DIS_INDEX_NODIS_SKIP==outInfo.indexFrameDisplay)
+			{
+				// not display, related to skip option
+				pFrameDisp=NULL;
+				*pOutRetCode=VPU_DEC_OUTPUT_NODIS;
+			}
+			else if(VPU_OUT_DIS_INDEX_EOS==outInfo.indexFrameDisplay)
+			{
+				// stream EOS: no more ouput for display
+				pFrameDisp=NULL;
+				*pOutRetCode=VPU_DEC_OUTPUT_EOS;
+			}
+			else
+			{
+				// normal for display
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+				int dropFlag=0;
+#endif
+				VpuPicType picType;
+				int index=outInfo.indexFrameDisplay;
+				*pOutRetCode=VPU_DEC_OUTPUT_DIS;
+				VPU_LOG("indexFrameDisplay=%d \r\n",index);
+				search_ret=VpuSearchFrameBuf(pObj,index,&pFrameDisp);
+				if(search_ret)
+				{				
+					pObj->frameInfo.pDisplayFrameBuf=pFrameDisp;
+					//load current display frame info
+					ASSERT(pObj->frameBufInfo[index].viewID==outInfo.mvcPicInfo.viewIdxDisplay);
+					VpuLoadDispFrameInfo(pObj,index,&pObj->frameInfo,&outInfo);
+				}
+				picType=pObj->frameInfo.ePicType;
+				if((pObj->CodecFormat==VPU_V_VC1_AP) && (outInfo.indexFrameRangemap>=0))
+				{
+					picType=VpuConvertPicType(pObj->CodecFormat,pObj->frameBufInfo[outInfo.indexFrameRangemap].picType,pObj->frameBufInfo[outInfo.indexFrameRangemap].idrFlag);
+				}
+
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+				//(1) check drop B frame case
+				if(FRAME_IS_REF(picType))
+				{
+					VPU_LOG("%s: Ref frame %d \r\n",__FUNCTION__,picType);
+					if(pObj->refCnt<MIN_REF_CNT)
+					{
+						pObj->refCnt++;
+					}
+				}
+
+				if(FRAME_IS_B(picType)&&(pObj->refCnt<MIN_REF_CNT))
+				{
+					//drop B frame
+					dropFlag=1;
+					pObj->dropBCnt++;
+					VPU_LOG("%s: change B frame to dropped frame : %d \r\n",__FUNCTION__,pObj->dropBCnt);
+					if(pObj->dropBCnt>=MAX_DROPB_CNT)
+					{
+						//avoid freeze for real closed gop (I B B B B ... B B)
+						pObj->dropBCnt=0;	//clear cnt to 0	
+						pObj->refCnt=MIN_REF_CNT;
+					}
+				}
+
+				//(2) check drop non-I frame case
+#if 0			//FIXME: for some .ts clips, I Field + P Field, no KEY frame return, So we have to loose the condition
+				if(FRAME_IS_KEY(picType))
+#else			
+				if(((1==pObj->initInfo.nInterlace)&&FRAME_IS_REF(picType))
+					|| ((0==pObj->initInfo.nInterlace)&&FRAME_IS_KEY(picType)))
+				/*if(FRAME_IS_REF(picType))*/
+#endif					
+				{
+					VPU_LOG("%s: Key frame %d \r\n",__FUNCTION__,picType);
+					if(pObj->keyCnt<MIN_KEY_CNT)
+					{
+						pObj->keyCnt++;
+					}
+				}
+
+				if(FRAME_ISNOT_KEY(picType)&&(pObj->keyCnt<MIN_KEY_CNT))
+				{
+					//drop non-I frame
+					//here: we have not max drop number, not like drop B 
+					dropFlag=1;
+					VPU_LOG("%s: change non-I frame to dropped frame : \r\n",__FUNCTION__);
+				}
+#ifdef DIS_DROP_FRAME								
+				if(1==dropFlag)
+				{
+					VPU_LOG("unclosed gop: set it mosaic \r\n");
+					*pOutRetCode=VPU_DEC_OUTPUT_MOSAIC_DIS;
+				}
+#else			//to avoid seek timeout 
+				if(1==dropFlag)
+				{
+					//drop current frame
+					pFrameDisp=NULL;				
+					//add one type ( dropped ), but not VPU_DEC_OUTPUT_NODIS, since we need to notify user get one timestamp !!!
+					//*pOutRetCode=VPU_DEC_OUTPUT_NODIS;
+					*pOutRetCode=VPU_DEC_OUTPUT_DROPPED;
+
+					//we need to clear current frame, since user will not fetch/clear the frame buffer
+					VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,outInfo.indexFrameDisplay);				
+					ret=vpu_DecClrDispFlag(InVpuHandle,outInfo.indexFrameDisplay);
+					if(RETCODE_SUCCESS!=ret)
+					{
+						VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,outInfo.indexFrameDisplay,ret);
+						search_ret=0; //return fail
+					}
+					//clear frame state
+					VpuClearDispFrame(outInfo.indexFrameDisplay, pObj->frameBufState);					
+				}
+				else
+#endif
+#endif
+				{
+//#ifdef VPU_VC1_AP_SKIP_WORKAROUND	
+					int disIndex=outInfo.indexFrameDisplay;
+					//for case: display order: I B P(skip) 
+					//FIXME: we only simply drop P(skip) to avoid conflict logic
+					//if(pObj->CodecFormat==VPU_V_VC1_AP)
+					{
+						int state;
+						//if((pObj->CodecFormat==VPU_V_VC1_AP) && (-1!=outInfo.indexFrameRangemap))
+						//{
+						//	disIndex=outInfo.indexFrameRangemap;
+						//}
+						state=VpuGetDispFrameState(disIndex, pObj->frameBufState);
+						if(VPU_FRAME_STATE_DISP==state)	//still not released by user
+						{
+							//pFrameDisp=???
+							*pOutRetCode=VPU_DEC_OUTPUT_REPEAT;
+							VPU_ERROR("error: not released by user, drop this repeated frame \r\n");
+						}
+					}
+//#endif
+					//update frame state
+					VpuSetDispFrameState(disIndex,pObj->frameBufState,VPU_FRAME_STATE_DISP);
+
+					//check repeated frame (mainly for VC1 ?)
+
+					if((pFrameDisp) && (pObj->pPreDisplayFrameBuf==pFrameDisp))
+					{
+						*pOutRetCode=VPU_DEC_OUTPUT_REPEAT;
+						//previous frame(same address) will be cleared
+						//so we needn't clear current frame, not like VPU_DEC_OUTPUT_DROPPED
+					}
+
+					//record historical info
+					pObj->pPreDisplayFrameBuf=pFrameDisp;
+					//pObj->pPreDecodedFrameBuf=pFrameDecode;
+				}
+			}	
+		}
+
+		//update state
+		if((*pOutRetCode==VPU_DEC_OUTPUT_DIS)||(*pOutRetCode==VPU_DEC_OUTPUT_MOSAIC_DIS))
+		{
+			TIMER_MARK(TIMER_MARK_GETOUTPUT_ID);
+			pObj->state=VPU_DEC_STATE_OUTOK;	// user should call get output
+			if(VPU_DUMP_YUV)
+			{
+#define FRAME_ALIGN	 (32) //(16) for gpu limitation 
+#define Alignment(ptr,align)	(((unsigned int)(ptr)+(align)-1)/(align)*(align))
+				int colorformat=0;
+				int nPadStride=0;
+				nPadStride = Alignment(pObj->picWidth,FRAME_ALIGN);
+				if(VPU_V_MJPG==pObj->CodecFormat)
+				{
+					colorformat=pObj->initInfo.nMjpgSourceFormat;
+				}
+				WrapperFileDumpYUV(&fpYUV,pObj->frameInfo.pDisplayFrameBuf->pbufVirtY,
+					pObj->frameInfo.pDisplayFrameBuf->pbufVirtCb,
+					pObj->frameInfo.pDisplayFrameBuf->pbufVirtCr,
+					nPadStride*pObj->picHeight,nPadStride*pObj->picHeight/4,colorformat);
+			}			
+
+#if 1	//fix (-2,>0) case: 
+		//(1) for interlace/corrupt case: there is one valid output. eg. user will get two time stamps
+		//(2) for not codec case: [P B] chunk + not coded: only need to get one time stamps
+			if(0!=InSkipMode)
+			{
+				if(outInfo.indexFrameDecoded==VPU_OUT_DEC_INDEX_UNDEC/*eg. ==-2 ???*/)
+				{
+					if(1==pObj->frameBufInfo[outInfo.indexFrameDisplay].pFrameInPBPacket)	//needn't check range map(for VC1AP) since PB only occur in MPEG4
+					{
+						VPU_LOG("get only one timestamp for not coded \r\n");
+					}
+					else
+					{
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+						if(pObj->fieldDecoding)
+						{
+							pObj->oweFieldTS++;
+						}
+						else
+						{
+							*pOutRetCode=(*pOutRetCode)|VPU_DEC_SKIP;							
+						}
+#else
+						*pOutRetCode=(*pOutRetCode)|VPU_DEC_SKIP;
+#endif
+						//needn't clear it , only notify user to get one timestamp						
+					}
+					/*notify user to get skipped frame length info*/
+					VpuSaveDecodedFrameInfo(pObj,-1,&outInfo,NULL);
+					*pOutDecoded=1;	//one frame is consumed by vpu
+				}
+			}
+#endif
+		}
+		else if (*pOutRetCode==VPU_DEC_OUTPUT_EOS)
+		{
+			pObj->state=VPU_DEC_STATE_EOS;	// user should feed valid data for next play
+		}
+		else	
+		{
+			pObj->state=VPU_DEC_STATE_DEC;	//user need not call get output again
+//#ifdef VPU_IFRAME_SEARCH
+			if(pObj->iframesearch_allowed)
+			{
+				//we suppose: display index is also unvalid when decode index is unvalid, eg. when skipping, (decIndex<0 && disIndex<0)
+				if((pObj->keyDecCnt==0)
+					&& (outInfo.indexFrameDecoded==VPU_OUT_DEC_INDEX_UNDEC/*eg. ==-2 ???*/)
+					&& (outInfo.indexFrameDisplay<0))
+				{
+					//FIXME: need to check VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE ???
+					*pOutRetCode=VPU_DEC_OUTPUT_DROPPED;
+					//needn't clear it , only notify user to get one timestamp
+				}
+			}
+//#endif			
+
+#if 1 //skip mode ??
+			if(0!=InSkipMode)
+			{
+				if(((CPU_IS_MX6X())&&((outInfo.indexFrameDecoded==VPU_OUT_DEC_INDEX_UNDEC/*eg. ==-2 ???*/)
+					&& ((outInfo.indexFrameDisplay==VPU_OUT_DIS_INDEX_NODIS)||(outInfo.indexFrameDisplay==VPU_OUT_DIS_INDEX_NODIS_SKIP/*eg. ==-2 or -3??*/))))||
+					((CPU_IS_MX5X())&&((outInfo.indexFrameDecoded==VPU_OUT_DEC_INDEX_UNDEC/*eg. ==-2 ???*/)
+					&& (outInfo.indexFrameDisplay==VPU_OUT_DIS_INDEX_NODIS/*eg. ==-3 ??*/))))
+				{
+					/*
+						iMX5: -2, -3
+						iMX6: -2,-2 or -3
+					*/
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+					if(1==pObj->fieldDecoding)
+					{
+						pObj->oweFieldTS++;
+					}
+					else
+					{
+						*pOutRetCode=VPU_DEC_OUTPUT_DROPPED;					
+					}
+#else
+					*pOutRetCode=VPU_DEC_OUTPUT_DROPPED;
+#endif
+					//needn't clear it , only notify user to get one timestamp
+
+					/*notify user to get skipped frame length info*/
+					VpuSaveDecodedFrameInfo(pObj,-1,&outInfo,NULL);
+					*pOutDecoded=1;	//one frame is consumed by vpu
+				}
+			}
+#endif
+#ifdef VPU_FILEMODE_WORKAROUND
+			if(1==disOrderOutput)
+			{
+				//notify user to get one timestamp
+				*pOutRetCode=VPU_DEC_OUTPUT_DROPPED;
+			}
+#endif
+		}
+
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+		if((1==pObj->fieldDecoding)&&(pObj->oweFieldTS>0))
+		{
+			if((*pOutRetCode==VPU_DEC_OUTPUT_DIS)||
+				(*pOutRetCode==VPU_DEC_OUTPUT_MOSAIC_DIS)||
+				(*pOutRetCode==VPU_DEC_OUTPUT_DROPPED))
+			{
+				*pOutRetCode=(*pOutRetCode)|VPU_DEC_SKIP;
+				pObj->oweFieldTS--;
+			}
+		}
+#endif
+
+
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+		if(outInfo.indexFrameDecoded==VPU_OUT_DEC_INDEX_EOS)
+		{
+			//no enough frame buffer and return one output frame
+			*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_BUF;
+		}
+#endif
+
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+		if(1==pObj->recommendFlush)
+		{
+			*pOutRetCode=(*pOutRetCode)|VPU_DEC_FLUSH;
+		}
+#endif
+
+		return search_ret;		//0 or 1
+	}	
+}
+
+int VpuBitFlush(VpuDecHandleInternal * pVpuObj, int location)
+{
+	RetCode ret;		
+	int flush=0;
+
+	if(0==pVpuObj->obj.filemode)		
+	{
+		flush=1;
+		if(0)//if(CPU_IS_MX6X())	//for iMX6: workaround for some codecs
+		{
+			switch (pVpuObj->obj.CodecFormat)
+			{
+				////case VPU_V_H263:
+				case VPU_V_RV: // for RV9_1080x720_30_9590_NoAudio.mkv
+				//case VPU_V_VC1:	// for WMV9_MPML_360x240_30fps_1500K_4sec_10min.wmv
+				//case VPU_V_VC1_AP:	// for Test_1440x576_WVC1_6Mbps.wmv
+					flush=0;	
+					break;
+				default:
+					//flush=0;
+					break;
+			}
+		}
+	}
+#ifdef VPU_FILEMODE_WORKAROUND
+	else
+	{
+		switch (pVpuObj->obj.CodecFormat)
+		{
+			case VPU_V_MPEG4:
+			case VPU_V_DIVX4:
+			case VPU_V_DIVX56:
+			case VPU_V_XVID:
+			case VPU_V_H263:
+				//flush=1;	//seek failed for clips: H.263_mp3_352x288.avi;10s-vga-senchiro.avi
+				break;			
+			case VPU_V_AVC:
+				//flush=1;	//mosaic issue: DongxieXidu.ultra.mkv(e 0 80, or e 0 3), --now it is fixed, so we still can set flush=1
+				flush=1;		//technicolor/h264.mp4
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+				flush=1;		//philips: zdfhd.ts
+#endif
+				break;
+			case VPU_V_MPEG2:
+				flush=1;
+				break;
+			default:
+				//
+				break;
+		}
+	}
+#endif
+
+	if(1==flush)
+	{	
+#ifdef IMX6_INTER_DEBUG_RD_WR
+{
+	unsigned int rd,wr;
+//#define BIT_RD_PTR_0			0x120
+//#define BIT_WR_PTR_0			0x124
+	IOClkGateSet(1);
+	rd=VpuReadReg(0x120);
+	wr=VpuReadReg(0x124);
+	IOClkGateSet(0);
+	printf("vpu register: wr: 0x%X, rd: 0x%X \r\n", wr, rd);
+}
+#endif
+	
+		//we skip bit bufferflush operation for file mode
+		VPU_API("calling vpu_DecBitBufferFlush() : %d \r\n",location);
+		ret=vpu_DecBitBufferFlush(pVpuObj->handle);
+		if(RETCODE_SUCCESS!=ret)
+		{
+			VPU_ERROR("%s: vpu flush bit failure (in while loop), ret=%d \r\n",__FUNCTION__,ret);
+			return 0;
+		}	
+	}	
+	return 1;
+}
+
+int VpuDecClearOperationEOStoDEC(VpuDecHandle InHandle)
+{
+	VpuDecHandleInternal * pVpuObj;
+		
+	if(InHandle==NULL) 
+	{
+		return 0;
+	}
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+
+#if 0 //for iMX6: workaround
+	if(CPU_IS_MX6X())
+	{
+		if(pVpuObj->obj.CodecFormat==VPU_V_H263)
+		{
+			return 1;
+		}
+	}
+#endif
+#ifdef  VPU_NOT_RETURN_ALLBUF_AFTER_FLUSH
+	if(CPU_IS_MX6X())
+	{
+		RetCode ret;
+		int i;
+		for(i=0;i<pVpuObj->obj.frameNum;i++)
+		{
+			//for iMX6: we only need to clear buffers that is already decoded by vpu but still not be output to user.
+			if(pVpuObj->obj.frameBufState[i]==VPU_FRAME_STATE_DEC)
+			{
+				VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,i);
+				ret=vpu_DecClrDispFlag(pVpuObj->handle,i);
+				if(RETCODE_SUCCESS!=ret)
+				{
+					VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,i,ret);
+				}
+				VpuClearDispFrame(i, pVpuObj->obj.frameBufState);
+			}
+#ifdef VPU_IMX6_VC1AP_RANGEMAP_BUF_WORKAROUND
+			else if((pVpuObj->obj.CodecFormat==VPU_V_VC1_AP) &&(pVpuObj->obj.frameBufState[i]==VPU_FRAME_STATE_FREE)){
+				VPU_API("%s: workaround for VC1 AP rangemap: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,i);
+				vpu_DecClrDispFlag(pVpuObj->handle,i);
+			}
+#endif
+			
+		}	
+	}
+	/*FIXME: add process "else if(CPU_IS_MX5X){}" for iMX5X
+	else if(CPU_IS_MX5X())
+	{
+		RetCode ret;
+		int i;
+		for(i=0;i<pVpuObj->obj.frameNum;i++)
+		{
+			//for iMX5: vpu will clear all frame buffers automatically, so we need to reset those buffers which have not been released by user. 
+			if(pVpuObj->obj.frameBufState[i]==VPU_FRAME_STATE_DISP)
+			{
+				VpuSetClearFlag(pVpuObj->handle,&pVpuObj->obj,i);
+				//VpuSetDispFrameState(i, pVpuObj->obj.frameBufState,VPU_FRAME_STATE_DISP);
+			}
+		}
+	}
+	*/
+	else
+#endif
+	{
+		//FIXED: wrapper should not clear buffer itself, user should be responsible to clear it !!!otherwise, vpu may overwrite one output frame which still is hold by user.
+		//clear frame whose clear operations are missing by user
+		//VpuFreeAllDispFrame(pVpuObj->handle, pVpuObj->obj.frameNum, pVpuObj->obj.frameBufState);
+#ifdef VPU_FILEMODE_WORKAROUND
+		VpuClearAllDispFrameFlag(pVpuObj->handle, pVpuObj->obj.frameNum);
+#endif
+
+		//!!!: In fact, vpu will auto clear all buffers at vpu_DecBitBufferFlush() !!!
+		//So, user need to add additional logic(at user end if user care this case) to make protection
+		VpuClearAllDispFrame(pVpuObj->obj.frameNum, pVpuObj->obj.frameBufState);
+	}
+	//reset historical info
+	//pVpuObj->obj.pPreDisplayFrameBuf=NULL;
+
+	//if(1==pVpuObj->obj.filemode)
+	//{
+	//	//FIXED seek issue: 320x240-44-16s.avi (can not seek to 0 or 10 seconds)
+	//	return 1;
+	//}
+
+
+	//we skip bit bufferflush operation for file mode	
+	// In EOS, the bistream buffer may become disorder, such as RD pointer will overflow WR pointer
+	// So, we must flush bitstream here again, otherwise following data may not be filled since buffer is full (may have only 511 bytes).
+	if (0==VpuBitFlush(pVpuObj,2/*at the eos*/))
+	{
+		return 0;
+	}
+
+#ifdef IMX6_SKIPMODE_WORKAROUND_FILL_DUMMY//for iMX6 testing
+if(CPU_IS_MX6X())
+{
+#define DUMY_LEN	512
+	unsigned char* tmp=NULL;
+	switch(pVpuObj->obj.CodecFormat)
+	{
+		case VPU_V_MPEG4:
+		//case VPU_V_DIVX3:
+		case VPU_V_DIVX4:
+		case VPU_V_DIVX56:
+		case VPU_V_XVID:
+		case VPU_V_H263:
+		case VPU_V_AVC:
+		//case VPU_V_VC1:	
+		case VPU_V_VC1_AP:
+		case VPU_V_MPEG2:
+		//case VPU_V_RV:
+			tmp=malloc(DUMY_LEN);	
+			if(tmp)
+			{
+				vpu_memset(tmp,0,DUMY_LEN);
+				VpuFillData(pVpuObj->handle, &pVpuObj->obj, tmp, DUMY_LEN, 1, 0);
+				free(tmp);		
+			}
+			else
+			{
+				VPU_ERROR("LEVEL: 1: malloc %d bytes failure \r\n",DUMY_LEN);
+			}
+			break;
+		default:
+			break;
+	}
+}
+#endif
+	
+	return 1;
+
+}
+
+int VpuResolutionChangeResetGlobalVariables(VpuDecObj* pObj)
+{
+	vpu_memset(pObj->frameBuf,0,sizeof(pObj->frameBuf));
+	vpu_memset(pObj->frameBufInfo,0,sizeof(pObj->frameBufInfo));
+	vpu_memset(pObj->frameBufState,0,sizeof(pObj->frameBufState));
+
+	//pObj->nPrivateSeqHeaderInserted=0; //VC1_AP ???
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+	pObj->refCnt=0;				//for some .ts clips, we need to skip the first corrupt frames
+	pObj->dropBCnt=0;
+	pObj->keyCnt=0;				//for some .ts clips, we need to skip the first corrupt frames
+#endif	
+	pObj->keyDecCnt=0;
+
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+	pObj->seekKeyLoc=0;			//we consider the normal play (for .ts clips)
+	pObj->recommendFlush=0;
+#endif
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+	pObj->dataUsedInFileMode=0;
+	pObj->lastDatLenInFileMode=0;
+	pObj->lastConfigMode=0;
+#endif
+	// setting related with file mode
+	pObj->firstData=1;
+	pObj->firstDataSize=0;
+#ifdef VPU_PROTECT_MULTI_INSTANCE
+	pObj->filledEOS=0;
+#endif
+	pObj->pbPacket=0;
+	pObj->pbClips=0;
+
+#ifdef VPU_FLUSH_BEFORE_DEC_WORKAROUND
+	pObj->realWork=0;
+#endif
+
+#ifdef VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE
+	pObj->firstFrameMode=0;
+	pObj->fieldCnt=0;
+#endif
+
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+	//pObj->needMergeFields=VPU_FILEMODE_MERGE_FLAG;
+	pObj->lastFieldOffset=0;
+#endif
+
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+	pObj->fieldDecoding=0;
+	pObj->oweFieldTS=0;
+#endif
+
+	pObj->mjpg_frmidx=0;
+
+	pObj->nAccumulatedConsumedStufferBytes=0;
+	pObj->nAccumulatedConsumedFrmBytes=0;
+	pObj->nAccumulatedConsumedBytes=0;
+	pObj->pLastDecodedFrm=NULL;
+	pObj->nAdditionalSeqBytes=0;
+	pObj->nAdditionalFrmHeaderBytes=0;
+	pObj->nLastFrameEndPosPhy=(unsigned int)pObj->pBsBufPhyEnd-1+FRAME_END_OFFSET;	//make sure we can compute the length of sequence/config before the first frame
+
+	return 1;
+}
+
+int VpuResolutionChangeProcess(DecHandle* pInOutVpuHandle, VpuDecObj* pObj)
+{
+	RetCode ret;
+	PhysicalAddress Rd;
+	PhysicalAddress Wr;
+	unsigned long nSpace;
+	int nBakLen;
+	unsigned int nBsBufVirtEnd;
+	unsigned int nStart,nEnd;
+	DecHandle InVpuHandle=*pInOutVpuHandle;
+	int seqOK=0;
+	VpuBufferNode InData;
+	int nOutRetCode=0;
+	int nNoErr=1;
+
+	/*backup sequence data*/
+	VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+	ret=vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+	VPU_API("Wr: 0x%X, Rd: 0x%X, space: %d \r\n",(unsigned int)Wr,(unsigned int)Rd,(unsigned int)nSpace);
+	nBakLen=VpuComputeValidSizeInRingBuf(pObj->nLastFrameEndPosPhy, Wr,(unsigned int)pObj->pBsBufPhyStart,(unsigned int)pObj->pBsBufPhyEnd);
+	nBakLen-=2;	//reduce start and end themselves
+	nBakLen+=FRAME_END_OFFSET+FRAME_START_OFFSET;
+	if(nBakLen<=0)
+	{
+		VPU_ERROR("error last frame location !!! \r\n");
+		return 0;
+	}
+	if(pObj->pSeqBak)  //release previous buffer if exist
+	{
+		vpu_free(pObj->pSeqBak);
+	}
+	pObj->pSeqBak=vpu_malloc(nBakLen+16);//+16 since there will be one additonal byte copied into this buffer
+	if(NULL==pObj->pSeqBak)
+	{
+		VPU_ERROR("malloc %d bytes failure \r\n",nBakLen);
+		return 0;
+	}
+	ASSERT(1==FRAME_END_OFFSET);	//we copy data from nLastFrameEndPosPhy, but not nLastFrameEndPosPhy-1
+	ASSERT(0==FRAME_START_OFFSET);
+	nBsBufVirtEnd=(unsigned int)pObj->pBsBufVirtStart+((unsigned int)pObj->pBsBufPhyEnd-(unsigned int)pObj->pBsBufPhyStart);
+	nStart=(unsigned int)pObj->pBsBufVirtStart+((unsigned int)pObj->nLastFrameEndPosPhy-(unsigned int)pObj->pBsBufPhyStart);
+	nEnd=(unsigned int)pObj->pBsBufVirtStart+((unsigned int)Wr-(unsigned int)pObj->pBsBufPhyStart);
+	pObj->nSeqBakLen=VpuCopyValidSizeInRingBuf(pObj->pSeqBak, nStart, nEnd, (unsigned int)pObj->pBsBufVirtStart,nBsBufVirtEnd);
+	pObj->nSeqBakLen--;  //remove the 'nEnd' itself
+	ASSERT(pObj->nSeqBakLen==nBakLen);
+	VPU_LOG("backup sequence info: %d bytes: virtual range: [0x%X,0x%X), phy range: [0x%X, 0x%X) \r\n",pObj->nSeqBakLen,nStart,nEnd,pObj->nLastFrameEndPosPhy,Wr);
+
+	/*close and re-open vpu */
+	VPU_API("calling vpu_DecClose() \r\n");
+	ret=vpu_DecClose(InVpuHandle);
+	ASSERT(ret==RETCODE_SUCCESS);
+
+	VPU_API("calling vpu_DecOpen() : filePlayEnable: %d , format: %d \r\n",pObj->sDecOpenParam.filePlayEnable,pObj->sDecOpenParam.bitstreamFormat);
+	ret= vpu_DecOpen(&InVpuHandle, &pObj->sDecOpenParam);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: vpu open failure: ret=%d \r\n",__FUNCTION__,ret);
+		return -1;
+	}
+	*pInOutVpuHandle=InVpuHandle;  //update the vpu handle
+
+	/*clear related global variables*/
+	VpuResolutionChangeResetGlobalVariables(pObj);
+
+	/*re-seqinit*/
+	InData.nSize=pObj->nSeqBakLen;
+	InData.pPhyAddr=NULL;
+	InData.pVirAddr=pObj->pSeqBak;
+	InData.sCodecData.pData=NULL;
+	InData.sCodecData.nSize=0xFFFFFFFF; //regard as raw data
+	seqOK=VpuSeqInit(InVpuHandle, pObj, &InData, &nOutRetCode,&nNoErr);
+	if(0==seqOK)
+	{
+		VPU_ERROR("resolution change: seqinit fail \r\n");
+		return -1;
+	}
+	ASSERT(nOutRetCode==(VPU_DEC_INIT_OK|VPU_DEC_INPUT_USED));
+	ASSERT(pObj->state==VPU_DEC_STATE_INITOK);
+	
+	/*will wait re-register frames*/
+	//pObj->state=VPU_DEC_STATE_RESOLUTION_CHANGE;
+
+	return 1;
+}
+
+int VpuWaitBusy(int needWait)
+{
+	static int busy_cnt=0;
+	if(CPU_IS_MX6X())
+	{
+#if 0	//for rollback mode, we should not return 0(busy)
+		int ret=0;
+		if(needWait)
+		{	
+			VPU_API("while: calling vpu_WaitForInt(%d) \r\n",VPU_POLLING_TIME_OUT);
+			ret=vpu_WaitForInt(VPU_POLLING_TIME_OUT);
+		}
+		else
+		{
+			VPU_API("while: calling vpu_WaitForInt(%d) \r\n",VPU_POLLING_MIN_TIME_OUT);
+			ret=vpu_WaitForInt(VPU_POLLING_MIN_TIME_OUT);	// polling
+		}
+		if(ret!=0)
+		{
+			busy_cnt++;
+			if(busy_cnt> VPU_MAX_POLLING_BUSY_CNT)
+			{
+				VPU_ERROR("wait busy : time out : count: %d \r\n",busy_cnt);
+				busy_cnt=0;		//need to clear it ??
+				return -1;             //time out for some corrupt clips
+			}
+			return 0;	//busy
+		}
+		busy_cnt=0;
+#else
+		busy_cnt=0;
+		VPU_API("while: calling vpu_WaitForInt(%d) \r\n",VPU_POLLING_PRESCAN_TIME_OUT);
+		while(0!=vpu_WaitForInt(VPU_POLLING_PRESCAN_TIME_OUT))
+		{
+			busy_cnt++;
+			if(busy_cnt> VPU_MAX_POLLING_PRESCAN_BUSY_CNT)
+			{
+				VPU_ERROR("while: wait busy : time out : count: %d \r\n",busy_cnt);
+				return -1;             //time out for some corrupt clips
+			}
+		}
+#endif
+	}
+	else
+	{
+#ifdef VPU_PROTECT_MULTI_INSTANCE	
+		busy_cnt=0;
+		VPU_API("while: calling vpu_WaitForInt(%d) \r\n",VPU_POLLING_PRESCAN_TIME_OUT);
+		while(0!=vpu_WaitForInt(VPU_POLLING_PRESCAN_TIME_OUT))
+		{
+			busy_cnt++;
+			if(busy_cnt> VPU_MAX_POLLING_PRESCAN_BUSY_CNT)
+			{
+				VPU_ERROR("while: wait busy : time out : count: %d \r\n",busy_cnt);
+				return -1;             //time out for some corrupt clips
+			}
+		}
+#else //#ifdef VPU_PROTECT_MULTI_INSTANCE
+		VPU_API("calling vpu_IsBusy() \r\n");
+		if(vpu_IsBusy())
+		{
+			if(needWait)
+			{
+				VPU_API("busy: calling vpu_WaitForInt(%d) \r\n",VPU_POLLING_TIME_OUT);
+				if(0!=vpu_WaitForInt(VPU_POLLING_TIME_OUT))
+				{
+					busy_cnt++;
+					if(busy_cnt> VPU_MAX_POLLING_BUSY_CNT)
+					{
+						VPU_ERROR("wait busy : time out : count: %d \r\n",busy_cnt);
+						busy_cnt=0;		//need to clear it ??
+						return -1;             //time out for some corrupt clips
+					}
+					return 0;
+				}
+				else
+				{
+					busy_cnt=0;
+				}
+			}
+			else
+			{
+				return 0;
+			}
+		}
+		else
+		{
+			busy_cnt=0;
+			VPU_API("not busy: calling vpu_WaitForInt(%d) \r\n",VPU_POLLING_TIME_OUT);
+			vpu_WaitForInt(VPU_POLLING_MIN_TIME_OUT); //supposed return immediately
+		}
+#endif	//#ifdef VPU_PROTECT_MULTI_INSTANCE
+	}
+	return 1;	//not busy
+}	
+
+int VpuDecBuf(DecHandle* pVpuHandle, VpuDecObj* pObj ,VpuBufferNode* pInData,int* pOutRetCode,int* pNoErr,int* pOutInStreamModeEnough) 
+{
+	RetCode ret;
+	VpuDecBufRetCode bufUseState=VPU_DEC_INPUT_USED;
+	DecParam decParam;
+	unsigned char* pHeader=NULL;
+	unsigned int headerLen=0;
+
+	unsigned char aVC1Head[VC1_MAX_FRM_HEADER_SIZE];
+	unsigned char aVP8Head[VP8_FRM_HEADER_SIZE];
+	unsigned char aDIV3Head[DIV3_FRM_HEADER_SIZE];
+	int busyState;
+	int needWait;
+	static int skipframeMode=0;
+	int frmDecoded=0;	/*whether one frame is decoded by vpu*/
+	DecHandle InVpuHandle=*pVpuHandle;
+
+	*pOutRetCode=(VpuDecBufRetCode)0x0;
+	*pNoErr=1;	// set OK
+
+	//VPU_LOG("%s: pObj->state: %d \r\n",__FUNCTION__,pObj->state);
+
+	switch(pObj->CodecFormat)
+	{
+		case VPU_V_VC1:
+		case VPU_V_VC1_AP:
+			//for VC1, special header info may need to be inserted
+			pHeader=aVC1Head;
+			if(0==pObj->nPrivateSeqHeaderInserted)
+			{
+				//for raw file : .rcv/.vc1
+				//do nothing
+			}
+			else if (pInData->nSize==0) //(NULL==pInData->pVirAddr)
+			{
+				//eos
+			}
+			else
+			{
+				//insert frame header
+				if((pObj->CodecFormat==VPU_V_VC1_AP))
+				{
+					VC1CreateNalFrameHeader(pHeader,(int*)(&headerLen),(unsigned int*)(pInData->pVirAddr));
+				}
+				else
+				{
+					//need to insert header : frame size
+					VC1CreateRCVFrameHeader(pHeader,(int*)(&headerLen),pInData->nSize);
+				}	
+			}
+			break;
+		case VPU_V_VP8:
+			//for VP8, special header info may need to be inserted
+			pHeader=aVP8Head;
+			if(0==pObj->nPrivateSeqHeaderInserted)
+			{
+				//for raw file 
+				//do nothing
+			}
+			else if (pInData->nSize==0) //(NULL==pInData->pVirAddr)
+			{
+				//eos
+			}
+			else
+			{
+				//insert frame header
+				//need to insert header : frame size
+				VP8CreateFrameHeader(pHeader,(int*)(&headerLen),pInData->nSize,0,0);
+			}
+			break;
+		case  VPU_V_MJPG:
+			//for MJPG, need to user appoint the output frame
+			if(0==VpuSearchFreeFrameBuf(pObj, &pObj->mjpg_frmidx))
+			{
+				//no frame buffer
+				*pOutRetCode=VPU_DEC_OUTPUT_NODIS|VPU_DEC_NO_ENOUGH_BUF;
+				return 1;
+			}
+			break;
+		default:
+			if((CPU_IS_MX6X())&&(pObj->CodecFormat==VPU_V_DIVX3))
+			{
+				//for iMX6: DivX3
+				pHeader=aDIV3Head;
+				if(0==pObj->nPrivateSeqHeaderInserted)
+				{
+					//for raw file 
+					//do nothing
+				}
+				else if (pInData->nSize==0) //(NULL==pInData->pVirAddr)
+				{
+					//eos
+				}
+				else
+				{
+					//insert frame header
+					//need to insert header : frame size
+					DIV3CreateFrameHeader(pHeader,(int*)(&headerLen),pInData->nSize,0,0);
+				}
+			}
+			else
+			{
+				//do nothing for other formats
+			}
+			break;
+	}
+
+	if(0==pObj->filemode)
+	{
+		//check free space and fill data into vpu
+		if(0==VpuBitsBufIsEnough(InVpuHandle,headerLen+pInData->nSize))
+		{
+			//buffer is full	
+			bufUseState=VPU_DEC_INPUT_NOT_USED;	
+		}
+		else
+		{
+			//it is enough to fill
+			int fill_ret;
+			if(0!=headerLen)
+			{
+				fill_ret=VpuFillData(InVpuHandle,pObj,pHeader,headerLen,1,0);
+				VpuAccumulateConsumedBytes(pObj, headerLen, 1,NULL,NULL);
+			}
+
+			//allow pInData->nSize==0 for EOS
+			if(pObj->nIsAvcc){
+				VpuConvertAvccFrame(pInData->pVirAddr,pInData->nSize,pObj->nNalSizeLen);
+			}
+			fill_ret=VpuFillData(InVpuHandle,pObj,pInData->pVirAddr,pInData->nSize,1,headerLen);
+			ASSERT(fill_ret==1);
+		}
+	}
+	else
+	{
+		//file mode: only fill data at decode state
+		bufUseState=VPU_DEC_INPUT_NOT_USED;	
+	}
+
+
+	if(VPU_DEC_STATE_DEC==pObj->state)
+	{
+#ifdef VPU_PROTECT_MULTI_INSTANCE //#ifdef VPU_DEC_PIPELINE
+		if((0==pObj->filemode))
+		{
+			//only for stream mode
+			//when prescan is enabled, we need to make sure enough possible data before calling vpu_DecStartOneFrame() to improve performance.
+			PhysicalAddress Rd;
+			PhysicalAddress Wr;
+			unsigned long nSpace;
+			VPU_TRACE;
+			VPU_API("calling vpu_DecGetBitstreamBuffer() \r\n");
+			vpu_DecGetBitstreamBuffer(InVpuHandle, &Rd, &Wr, &nSpace);
+			//case ((VPU_BITS_BUF_SIZE-nSpace)>=VPU_MIN_UINT_SIZE): avoid wait timeout
+			//case (0!=pInData->nSize): avoid delay including no normal eos output at end of stream.
+			//case (0==pObj->filledEOS): avoid no normal eos output
+			if((((VPU_BITS_BUF_SIZE-nSpace)<VPU_MIN_UINT_SIZE)&&(0==pObj->filledEOS))
+				||((NotEnoughDecData(nSpace,(unsigned long)pObj->streamBufDelaySize))&&(0!=pInData->nSize)))
+			{
+				//return directly without decoding
+				VPU_LOG("nSpace: %d, filled : %d \r\n",(int)nSpace, (int)(VPU_BITS_BUF_SIZE-nSpace));
+				*pOutRetCode=bufUseState;				
+				return 0;
+			}	
+			VPU_LOG("nSpace: %d, filled : %d \r\n",(int)nSpace, (int)(VPU_BITS_BUF_SIZE-nSpace));
+		}
+#endif
+
+		//set dec parameters
+		//clear 0 firstly	
+		vpu_memset(&decParam,0,sizeof(DecParam));
+		decParam.skipframeMode=pObj->skipFrameMode;
+		decParam.skipframeNum=pObj->skipFrameNum;
+		decParam.iframeSearchEnable=pObj->iframeSearchEnable;
+		//VPU_LOG("before start one frame, skip mode: %d, num: %d, isearch: %d \r\n",pObj->skipFrameMode,pObj->skipFrameNum,pObj->iframeSearchEnable);
+//#ifdef VPU_IFRAME_SEARCH
+		if(pObj->iframesearch_allowed)
+		{
+			if(0==pObj->keyDecCnt)
+			{
+				if(1)	//we need to consider timestamp, so we enable skipframeMode, but not iframeSearchEnable
+				{
+					decParam.iframeSearchEnable=0;
+					decParam.skipframeMode=1;	//skip non-I frame
+					decParam.skipframeNum=1;		//only skip one non-I frame every time
+				}
+				else
+				{
+					decParam.iframeSearchEnable=1;
+					decParam.skipframeMode=0;
+					decParam.skipframeNum=0;		//skip all P/B frames until next I(IDR for H.264)
+				}
+			}
+			if(0)//if(CPU_IS_MX6X())	//for iMX6X: workaround for some codec ?
+			{
+				switch (pObj->CodecFormat)
+				{
+					case VPU_V_H263: // for H263_BP3_352x288_25_AACLC_48Khz_190kbps_pixar-ice_age_extra.avi
+					//case VPU_V_VC1:	//for WMV9_MPML_360x240_30fps_1500K_4sec_10min.wmv
+					//case VPU_V_VC1_AP:  // for WVC1_APL1_720x480_30fps_1000kbps_NoAudio_MA10055.WMV: the first frame is I/P field pair
+						decParam.iframeSearchEnable=0;
+						decParam.skipframeMode=0;
+						decParam.skipframeNum=0;	
+						break;
+					default:
+						break;
+				}	
+			}
+		}
+//#endif
+
+#ifdef VPU_DEC_DIRECT_INPUT
+		decParam.chunkSize=...
+		decParam.picStreamBufferAddr=...
+		decParam.picStartByteOffset=...
+#endif
+		if(1==pObj->filemode)
+		{
+			//decParam.picStreamBufferAddr=	// don't need to set it, since we don't enable dynamic buffer allocation.
+			if(1==pObj->firstData)
+			{
+				//re-use data at seqinit step
+				decParam.chunkSize=pObj->firstDataSize;
+				pObj->firstData=0;	//need not set it again later, since we only do seqinit once.
+				bufUseState=VPU_DEC_INPUT_NOT_USED;	
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+				//just filled the first field, record the offset and return directly
+				pObj->lastFieldOffset=decParam.chunkSize;
+				*pOutRetCode=VPU_DEC_INPUT_NOT_USED|VPU_DEC_SKIP;
+				return 1;
+#endif				
+			}
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+			else if (1==pObj->dataUsedInFileMode)
+			{
+				decParam.chunkSize=pObj->lastDatLenInFileMode;
+				decParam.skipframeMode=pObj->lastConfigMode;
+				bufUseState=VPU_DEC_INPUT_NOT_USED;	//use last data
+			}
+#endif
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+			else if((0!=pObj->needMergeFields)&&(0!=pObj->lastFieldOffset))
+			{
+				// feed the second field
+				int fill_ret;
+				fill_ret=VpuFillData(InVpuHandle,pObj,pInData->pVirAddr,pInData->nSize,1,pObj->lastFieldOffset);
+				ASSERT(fill_ret==1);	//always enough to fill data
+				decParam.chunkSize=pObj->lastFieldOffset+pInData->nSize;
+				pObj->lastFieldOffset=0;	//clear 0
+				bufUseState=VPU_DEC_INPUT_USED;	
+			}
+#endif
+			else
+			{			
+				//Here, we need to check headerLen !
+				int fill_ret;
+				if(0!=headerLen)
+				{
+					fill_ret=VpuFillData(InVpuHandle,pObj,pHeader,headerLen,1,0);
+					VpuAccumulateConsumedBytes(pObj, headerLen, 1,NULL,NULL);
+				}
+				if(pObj->nIsAvcc){
+					VpuConvertAvccFrame(pInData->pVirAddr,pInData->nSize,pObj->nNalSizeLen);
+				}
+				fill_ret=VpuFillData(InVpuHandle,pObj,pInData->pVirAddr,pInData->nSize,1,headerLen);
+				ASSERT(fill_ret==1);	//always enough to fill data
+				decParam.chunkSize=pInData->nSize+headerLen;
+				bufUseState=VPU_DEC_INPUT_USED;	
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+				//just filled the first field, record the offset and return directly
+				pObj->lastFieldOffset=decParam.chunkSize;
+				*pOutRetCode=VPU_DEC_INPUT_USED|VPU_DEC_SKIP;
+				return 1;
+#endif
+			}
+
+#ifdef VPU_FILEMODE_WORKAROUND
+			//IOClkGateSet(true);
+			//VpuWriteReg(0x124, pObj->pBsBufPhyStart+decParam.chunkSize);	//how to get instance number ?
+			//IOClkGateSet(false);			
+#endif
+#if 0		// can not enable this check !!!
+			if(0==decParam.chunkSize)
+			{
+				*pOutRetCode=(*pOutRetCode)|bufUseState;
+				return 1;
+			}
+#else
+			//Here: decParam.chunkSize==0 is allowed and required ???.
+#endif			
+			VPU_LOG("file mode: data size: %d \r\n",decParam.chunkSize);
+#if 0 // file mode debug
+			{
+				static FILE* fpBitstream=NULL;
+				LOG_PRINTF("0x%X \r\n",*((unsigned int*)pObj->pBsBufVirtStart));
+				WrapperFileDumpBitstrem(&fpBitstream,(unsigned char*)pObj->pBsBufVirtStart,decParam.chunkSize);
+			}			
+#endif
+
+#ifdef VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE
+			if(0!=pObj->initInfo.nInterlace)
+			{
+				if(pObj->fieldCnt==1)
+				{
+					decParam.skipframeMode=pObj->firstFrameMode;	//will decode the second field
+				}
+				else
+				{
+					pObj->firstFrameMode=decParam.skipframeMode;	//will decode the first field
+				}
+				////if(VPU_V_AVC==pObj->CodecFormat)	//FIXME: now only process H.264 !!!
+				//if(VPU_V_MPEG2!=pObj->CodecFormat)	//mpeg2: two fields will be mergee into one frame
+				//{
+				//	if(decParam.chunkSize>0)
+				//	{
+				//		pObj->fieldCnt=(pObj->fieldCnt==0)?1:0;
+				//	}
+				//}
+			}
+#else
+#ifdef VPU_FILEMODE_INTERLACE_WORKAROUND
+			if(0!=pObj->initInfo.nInterlace)
+			{
+				//for interlace, it is unstable if enable skipmode: FHD025.Sanyo(1min).1920x1080.MPEG2.AAC.1536Kbps.48KHz.mp4
+//#ifndef VPU_IFRAME_SEARCH
+				if(pObj->iframesearch_allowed==0)
+				{
+					decParam.skipframeMode=0;
+				}
+//#endif
+			}
+#endif
+#endif
+			if(pObj->pbClips==1)
+			{
+				//for pb chunk + file mode(stream mode seem be OK): both PB chunk and not_coded frame may be affected by skipmode.
+				//So, disable skip mode.
+				decParam.skipframeMode=0;
+			}
+			
+		}
+		else
+		{
+			//stream mode
+#ifdef VPU_PROTECT_MULTI_INSTANCE
+			if(CPU_IS_MX6X())
+			{
+				decParam.prescanEnable=0;//for iMX6: using rollback, but not prescan mode
+			}
+			else
+			{
+				decParam.prescanEnable=1;//for iMX5: stream mode
+			}
+			decParam.prescanMode=0; //0 = Start decoding, 1 = Returns without decoding
+#endif
+		}
+
+		if(VPU_V_MJPG==pObj->CodecFormat)
+		{
+			//for mjpg, we shouldn't set skipmode???
+			decParam.skipframeMode=0;
+			//for MJPG, need to user appoint the output frame
+			VPU_API("vpu_DecGiveCommand: SET_ROTATOR_OUTPUT: %d \r\n",pObj->mjpg_frmidx);
+			vpu_DecGiveCommand(InVpuHandle, SET_ROTATOR_OUTPUT, (void *)(&pObj->vpu_regframebuf[pObj->mjpg_frmidx]));
+			if(CPU_IS_MX6X())
+			{
+				if(pObj->mjpg_linebuffmode==1)
+				{
+					decParam.phyJpgChunkBase=(PhysicalAddress)pObj->pBsBufPhyStart;
+					decParam.virtJpgChunkBase=pObj->pBsBufVirtStart;
+					//decParam.chunkSize=;  //already been set 
+				}
+			}
+		}
+#ifdef VPU_BACKDOOR		
+		VpuLogClearFlag(InVpuHandle);
+#endif
+		// start decode frame
+		VPU_LOG("===================vpu_DecStartOneFrame: chunkSize: %d, search: %d \r\n",decParam.chunkSize,decParam.iframeSearchEnable);		
+		VPU_TRACE;
+		VPU_API("calling vpu_DecStartOneFrame(): %d, skipmode: %d \r\n",decParam.chunkSize,decParam.skipframeMode);
+		ret = vpu_DecStartOneFrame(InVpuHandle, &decParam);
+		VPU_TRACE;
+		if(ret == RETCODE_JPEG_EOS)	//for iMX6 with jpgLineBufferMode==0
+		{
+			pObj->state=VPU_DEC_STATE_EOS;
+			*pOutRetCode=bufUseState|VPU_DEC_OUTPUT_EOS;
+			VPU_API("MJPG: reach EOS \r\n");
+			goto AfterGetOuput;
+		}
+		else if(ret==RETCODE_JPEG_BIT_EMPTY)	//for iMX6
+		{
+			//need to skip vpu_WaitForInt() and vpu_DecGetOutputInfo()
+			//pObj->state=VPU_DEC_STATE_DEC;
+			*pOutRetCode=bufUseState|VPU_DEC_OUTPUT_NODIS;
+			*pOutInStreamModeEnough=0;
+			VPU_API("MJPG: BIT EMPTY \r\n");
+			goto AfterGetOuput;
+		}
+		else if (ret != RETCODE_SUCCESS)
+		{
+			*pOutRetCode=bufUseState;
+			*pNoErr=0;
+			return 0;
+		}
+
+		//update state
+		pObj->state=VPU_DEC_STATE_STARTFRAMEOK;
+
+		skipframeMode=decParam.skipframeMode;
+#ifdef VPU_FILEMODE_INTERLACE_WORKAROUND
+		if((0==skipframeMode)&&(0!=pObj->initInfo.nInterlace)&&(1==pObj->filemode)&&(0!=decParam.chunkSize))
+		{
+			//for interlace clips: 
+			//if user feed two fields seperately, we should drop the second field and get one timestamp
+			//clips: FHD025.Sanyo(1min).1920x1080.MPEG2.AAC.1536Kbps.48KHz.mp4
+			skipframeMode=1;
+		}
+		else
+		{
+			//here: we only consider filemode, for streammode, the timestamp will be not matched and timestamp queue may overflow.
+		}
+#endif
+#ifdef VPU_FILEMODE_CORRUPT_WORKAROUND
+		if((0==skipframeMode)&&(1==pObj->filemode)&&(0!=decParam.chunkSize))
+		{
+			//for corrupt clips: 
+			//if user feed one valid frame(size!=0), and vpu may return decIndex,disIndex=(-2,-3), in this case, we should drop it and get one timestamp
+			//clips: h264_P_B1.3_25.0fps_730k_320x240_aac_48KHz_128Kbps_c2_3min3s_Tomsk_iPod.mp4
+			skipframeMode=1;
+		}
+		else
+		{
+			//here: we only consider filemode, for streammode, the timestamp will be not matched and timestamp queue may overflow.
+		}
+#endif
+		
+	}
+
+	ASSERT(pObj->state==VPU_DEC_STATE_STARTFRAMEOK);
+
+	//set wait mode
+	if((0==pInData->nSize)||(VPU_DEC_INPUT_NOT_USED==bufUseState))
+	{
+		//strategy: wait only when : (1) no invalid input data (2) or bitstream buffer is full
+		needWait=1;
+	}
+	else
+	{
+		needWait=0;
+	}
+	busyState=VpuWaitBusy(needWait);
+	//0: busy, -1: timeout; 1: not busy
+	if(busyState<=0)
+	{
+		*pOutRetCode=bufUseState;
+		return busyState;
+	}
+	
+	//Be careful: We must make sure: one and only one successful vpu_WaitForInt() is called before calling VpuGetOutput()
+	*pNoErr=VpuGetOutput(InVpuHandle, pObj, pOutRetCode,skipframeMode,pOutInStreamModeEnough,decParam.chunkSize,&frmDecoded);
+
+	//add robust for corrupted clips to avoid dead loop:
+	if(0==pObj->filemode)
+	{
+		//buffer is full and still not find one valid frame: return dec failure to avoid dead loop
+		if((bufUseState==VPU_DEC_INPUT_NOT_USED)&&(0==*pOutInStreamModeEnough))
+		{
+			VPU_ERROR("buffer full and no valid frame is find !!!!\r\n");
+			*pNoErr=0;
+		}
+	}
+
+AfterGetOuput:
+
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+	if((VPU_DEC_NO_ENOUGH_BUF&(*pOutRetCode))
+		||(0!=pObj->pbPacket))
+	{
+		//record data length to avoid repeat copy next time, only for file mode
+		//we need not consider this issue in stream mode
+		//Here, we shouldn't check whether (VPU_DEC_INPUT_USED==bufUseState) !!!
+		pObj->dataUsedInFileMode=1;
+		pObj->lastDatLenInFileMode=decParam.chunkSize;
+		pObj->lastConfigMode=decParam.skipframeMode;
+	}
+	else
+	{
+		pObj->dataUsedInFileMode=0;
+		pObj->lastDatLenInFileMode=0;
+		pObj->lastConfigMode=0;
+	}
+
+#endif
+	
+	*pOutRetCode=(*pOutRetCode)|bufUseState;
+
+	/*check whether one frame is consumed by vpu: notify user get frame info*/
+	if((pObj->nDecFrameRptEnabled!=0)&&(frmDecoded==1))
+	{
+		*pOutRetCode=(*pOutRetCode)|VPU_DEC_ONE_FRM_CONSUMED;
+	}
+
+	/*check whether resolution change happen*/
+	if((pObj->nDecResolutionChangeEnabled!=0)&&(frmDecoded==1))
+	{
+		if(pObj->nResolutionChanged)
+		{
+			int retChange;
+			switch(pObj->state)
+			{
+				case VPU_DEC_STATE_OUTOK:
+				case VPU_DEC_STATE_DEC:
+					retChange=VpuResolutionChangeProcess(pVpuHandle, pObj);
+					if(retChange<0) //reopen vpu fail
+					{
+						return -1;  
+					}
+					else if (retChange>0) //ok
+					{
+						*pOutRetCode=(VpuDecBufRetCode)0x0;  //clear other flags first !!!
+						*pOutRetCode=(*pOutRetCode)|bufUseState;
+						*pOutRetCode=(*pOutRetCode)|VPU_DEC_RESOLUTION_CHANGED;
+					}
+					else	 // memory resource not enough 
+					{
+						//ignore this event
+					}
+					break;
+				case VPU_DEC_STATE_EOS:
+				default:
+					//impossible enter here !!
+					break;
+			}
+			pObj->nResolutionChanged=0; //clear it
+		}
+	}
+	return 1;
+}
+
+#ifdef VPU_FILEMODE_PBCHUNK_FLUSH_WORKAROUND
+int VpuPBChunkFlush(VpuDecHandleInternal * pVpuObj)
+{
+	RetCode ret;
+	int cnt=0;
+	VpuDecObj* pObj;
+	DecParam decParam;
+	DecOutputInfo outInfo;
+
+	pObj=&pVpuObj->obj;
+	
+	vpu_memset(&decParam,0,sizeof(DecParam));
+	decParam.skipframeMode=3;  // skip all
+	decParam.skipframeNum=1;
+	decParam.iframeSearchEnable=0;
+	decParam.chunkSize=pObj->lastDatLenInFileMode;	
+	decParam.skipframeMode=pObj->lastConfigMode;
+	VPU_API("calling vpu_DecStartOneFrame(): PB chunk: %d \r\n",decParam.chunkSize);
+	ret = vpu_DecStartOneFrame(pVpuObj->handle, &decParam);
+	if (ret != RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: vpu start one frame PB chunk failure: ret = 0x%X \r\n",__FUNCTION__,ret);
+		return 0;//return VPU_DEC_RET_FAILURE;
+	}		
+	VPU_API("calling PB chunk: vpu_WaitForInt(%d) \r\n",VPU_TIME_OUT);
+	while(0!=vpu_WaitForInt(VPU_TIME_OUT))
+	{
+		cnt++;
+		if(cnt >VPU_MAX_TIME_OUT_CNT)
+		{
+			VPU_ERROR("%s: flush PB chunk time out \r\n",__FUNCTION__);	
+			pObj->state=VPU_DEC_STATE_CORRUPT;
+			return 0;//return VPU_DEC_RET_FAILURE_TIMEOUT;
+		}
+	}
+	VPU_API("calling PB chunk: vpu_DecGetOutputInfo() \r\n");
+	ret = vpu_DecGetOutputInfo(pVpuObj->handle, &outInfo);
+	VPU_API("calling PB chunk: vpu_DecGetOutputInfo(), indexFrameDecoded: %d, return indexFrameDisplay: %d  \r\n",outInfo.indexFrameDecoded,outInfo.indexFrameDisplay);
+	
+	if (ret != RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: vpu get output info failure: ret = 0x%X \r\n",__FUNCTION__,ret);
+		return 0;//return VPU_DEC_RET_FAILURE;
+	}
+	if(outInfo.indexFrameDisplay>=0)
+	{
+		VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,outInfo.indexFrameDisplay);
+		ret=vpu_DecClrDispFlag(pVpuObj->handle,outInfo.indexFrameDisplay);
+		if(RETCODE_SUCCESS!=ret)
+		{
+			VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,outInfo.indexFrameDisplay,ret);
+			return 0;//return VPU_DEC_RET_FAILURE;
+		}
+		//clear frame state
+		VpuClearDispFrame(outInfo.indexFrameDisplay, pObj->frameBufState);	
+	}
+
+#ifdef VPU_FLUSH_BEFORE_DEC_WORKAROUND
+	//if(outInfo.indexFrameDecoded>=0)	//need to check decindex ???
+	{
+		pObj->realWork=1;
+	}
+#endif
+	
+	return 1;	//OK
+}
+#endif
+
+int VpuCheckDeadLoop(VpuDecObj* pObj ,VpuBufferNode* pInData,int* pOutRetCode,int* pNoErr) 
+{
+	//*pNoErr=1;		//don't reset it !!!!: the *pNoErr already has one valid value.
+#ifdef VPU_AVOID_DEAD_LOOP
+#define VPU_MAX_NULL_LOOP (500000)//set big enough, it is just used to avoid dead
+	static int total_init_size=0;		// avoid dead loop at init step
+	static int total_init_loop=0;	// avoid dead loop at init step 
+	static int total_dec_size=0;	// avoid dead loop at decode step
+	static int total_dec_loop=0;	// avoid dead loop at decode step
+	static int total_null_loop=0;	// avoid dead loop at null run at some unexpected cases
+	int size;
+	int cnt;
+	int noerr;
+
+	size=0;
+	cnt=0;
+	noerr=1;
+	//here, we don't consider the pInData->sCodecData.nSize
+	if(VPU_DEC_INPUT_USED&(*pOutRetCode))
+	{
+		size=pInData->nSize;		
+		if(size>0)	//it is important !!!
+		{
+			cnt=1;
+		}
+	}
+
+	if((size==0) && (NULL!=pInData->pVirAddr))
+	{
+		cnt=1;	//avoit deadloop for smaller clip:WVC1_APL4_16x16_30fps_46kbps_NoAudio_MA40263
+	}
+
+	total_null_loop++;
+
+	VPU_LOG("%s: total_dec_size: %d, total_dec_loop: %d, total_null_loop: %d \r\n",__FUNCTION__,total_dec_size,total_dec_loop,total_null_loop);
+	switch (pObj->state)
+	{
+		case VPU_DEC_STATE_OPEN:
+			total_init_size+=size;
+			total_init_loop+=cnt;
+			break;
+		case VPU_DEC_STATE_DEC:
+		case VPU_DEC_STATE_STARTFRAMEOK:
+			total_dec_size+=size;
+			total_dec_loop+=cnt;
+			break;	
+		default:
+			//clear 0
+			total_init_size=0;
+			total_init_loop=0;
+			total_dec_size=0;
+			total_dec_loop=0;
+			total_null_loop=0;
+			break;
+	}
+#if 0	//dangerous !!
+	if((total_dec_size>VPU_MAX_DEC_SIZE)||(total_dec_loop>VPU_MAX_DEC_LOOP))
+	//for some clips: MPEG1SS_MP2_720x480_29.97fps_a_32khz_224_welcometoBJ.mpg
+	//will timeout even set VPU_MAX_DEC_LOOP=4000, such as CMD_PLAY_STOP test
+#else
+	if((total_dec_size>VPU_MAX_DEC_SIZE))	
+	// for clip:H264_BP40_640x480_15_15107_MP3_48_192_2.avi, it will cache about 15 frames before the first ouput
+	// as result, VPU_MAX_DEC_SIZE == 1M isn't enough too. Now, we set bigger value to VPU_MAX_DEC_SIZE
+#endif		
+	{
+		//dead loop at decode step
+		noerr=0;
+		VPU_ERROR("decode dead loop: total_size: %d, total_cnt: %d \r\n",total_dec_size,total_dec_loop);
+	}
+#if 1	//dangerous !!
+	if((total_init_size>VPU_MAX_INIT_SIZE)||(total_init_loop>pObj->initDataCountThd)||(total_null_loop>VPU_MAX_NULL_LOOP))
+#else
+	if((total_init_size>VPU_MAX_INIT_SIZE))
+#endif
+	{
+		//dead loop at seq init step
+		if((0==pInData->nSize)&&(NULL!=pInData->pVirAddr))
+		{
+			//EOS: (addr!=NULL && size==0)
+			//here: we should not sent error event for eos case !!!!
+			*pOutRetCode=VPU_DEC_INPUT_NOT_USED|VPU_DEC_OUTPUT_EOS;		
+			pObj->state=VPU_DEC_STATE_EOS;
+		}
+		else
+		{
+			noerr=0;
+		}
+		VPU_ERROR("seq init dead loop: total_size: %d, total_cnt: %d, total null cnt: %d \r\n",total_init_size,total_init_loop,total_null_loop);
+	}
+
+#ifdef VPU_FILEMODE_QUICK_EXIT
+#define VPU_MAX_INIT_FILEMODE_LOOP	(200)	//I15_HT31_corrupted_header_keyframe_00.avi: the first 150 frames are corrupted
+	if((1==pObj->filemode) )
+	{
+		if(total_init_loop>VPU_MAX_INIT_FILEMODE_LOOP)
+		{
+			if((0==/*headerLen+*/pInData->nSize)&&(NULL!=pInData->pVirAddr))
+			{
+				//EOS: (addr!=NULL && size==0)
+				//here: we should not sent error event for eos case !!!!
+				*pOutRetCode=VPU_DEC_INPUT_NOT_USED|VPU_DEC_OUTPUT_EOS;		
+				pObj->state=VPU_DEC_STATE_EOS;
+			}
+			else
+			{
+				//will send error event
+				noerr=0;
+			}
+			VPU_ERROR("seq init dead loop (file mode): total_size: %d, total_cnt: %d \r\n",total_init_size,total_init_loop);			
+		}
+		else
+		{
+			if((pObj->state==VPU_DEC_STATE_OPEN)&&(pInData->nSize>0))
+			{
+				//for corrupt clips: we need to notify user to get one timestamp
+				*pOutRetCode=(*pOutRetCode)|VPU_DEC_OUTPUT_DROPPED;
+			}
+		}
+	}
+#endif
+
+	if(0==noerr)
+	{
+		//will send error event
+		*pNoErr=0;
+		//clear 0 for all count
+		total_init_size=0;
+		total_init_loop=0;
+		total_dec_size=0;
+		total_dec_loop=0;
+	}
+#else
+	//do nothing
+#endif
+	return 1;
+}
+
+VpuDecRetCode VPU_DecLoad()
+{
+	RetCode ret;
+
+	/*parser log level*/
+	VpuLogLevelParse(NULL);
+	
+	VPU_TRACE;
+	VPU_API("calling vpu_Init() \r\n");	
+	ret=vpu_Init(NULL);
+	VPU_TRACE;
+	if(RETCODE_SUCCESS !=ret)
+	{
+		VPU_ERROR("%s: vpu init failure \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_FAILURE;
+	}
+
+	TIMER_INIT;
+	
+	//TODO: add protection for exception exist ?
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecGetVersionInfo(VpuVersionInfo * pOutVerInfo)
+{
+	vpu_versioninfo ver;
+	RetCode ret;
+
+	if(pOutVerInfo==NULL)
+	{
+		VPU_ERROR("%s: failure: invalid parameterl \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_PARAM;
+	}
+	VPU_TRACE;
+	VPU_API("calling vpu_GetVersionInfo() \r\n");
+	ret=vpu_GetVersionInfo(&ver);
+	VPU_TRACE;
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ERROR("%s: get vpu version failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_DEC_RET_FAILURE;
+	}
+
+	pOutVerInfo->nFwMajor=ver.fw_major;
+	pOutVerInfo->nFwMinor=ver.fw_minor;
+	pOutVerInfo->nFwRelease=ver.fw_release;
+	pOutVerInfo->nLibMajor=ver.lib_major;
+	pOutVerInfo->nLibMinor=ver.lib_minor;
+	pOutVerInfo->nLibRelease=ver.lib_release;
+#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,7))	
+	pOutVerInfo->nFwCode=ver.fw_code;
+#else	
+	pOutVerInfo->nFwCode=0;
+#endif
+	VPU_API("%s: VPU FW: [major.minor.release_rcode]=[%d.%d.%d_r%d] \r\n",__FUNCTION__,pOutVerInfo->nFwMajor,pOutVerInfo->nFwMinor,pOutVerInfo->nFwRelease,pOutVerInfo->nFwCode);
+	VPU_API("%s: VPU LIB: [major.minor.release]=[%d.%d.%d] \r\n",__FUNCTION__,pOutVerInfo->nLibMajor,pOutVerInfo->nLibMinor,pOutVerInfo->nLibRelease);
+
+	return VPU_DEC_RET_SUCCESS;
+
+}
+
+VpuDecRetCode VPU_DecGetWrapperVersionInfo(VpuWrapperVersionInfo * pOutVerInfo)
+{
+	pOutVerInfo->nMajor= (VPU_WRAPPER_VERSION_CODE >> (16)) & 0xff;
+	pOutVerInfo->nMinor= (VPU_WRAPPER_VERSION_CODE >> (8)) & 0xff;
+	pOutVerInfo->nRelease= (VPU_WRAPPER_VERSION_CODE) & 0xff;
+#ifdef USER_SPECIFY_BINARY_VER
+printf("user specify version \r\n");
+	pOutVerInfo->pBinary=(char*)STR_USER_SPECIFY_BINARY_VER;
+#else
+	pOutVerInfo->pBinary=(char*)VPUWRAPPER_BINARY_VERSION_STR;
+#endif	
+	return VPU_DEC_RET_SUCCESS;	
+}
+
+VpuDecRetCode VPU_DecQueryMem(VpuMemInfo* pOutMemInfo)
+{
+	VpuMemSubBlockInfo * pMem;
+
+	if(pOutMemInfo==NULL)
+	{
+		VPU_ERROR("%s: failure: invalid parameterl \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_PARAM;	
+	}
+	pMem=&pOutMemInfo->MemSubBlock[VIRT_INDEX];
+	pMem->MemType=VPU_MEM_VIRT;
+	pMem->nAlignment=VPU_MEM_ALIGN;
+	pMem->nSize=sizeof(VpuDecHandleInternal);
+	pMem->pVirtAddr=NULL;
+	pMem->pPhyAddr=NULL;
+
+	pMem=&pOutMemInfo->MemSubBlock[PHY_INDEX];
+	pMem->MemType=VPU_MEM_PHY;
+	pMem->nAlignment=VPU_MEM_ALIGN;
+	pMem->nSize=VPU_BITS_BUF_SIZE;
+	pMem->pVirtAddr=NULL;
+	pMem->pPhyAddr=NULL;
+
+	if(CPU_IS_MX6X())  //for iMX6: VP8
+	{
+		ASSERT(VPU_VP8_MBPARA_SIZE<=(VPU_SLICE_SAVE_SIZE+VPU_PS_SAVE_SIZE));
+		//for vp8, use the same memory with avc
+	}
+	/*add slice/ps buffer support for avc */	
+	pMem->nSize+=VPU_SLICE_SAVE_SIZE+VPU_PS_SAVE_SIZE;
+
+	pOutMemInfo->nSubBlockNum=2;
+	
+	return VPU_DEC_RET_SUCCESS;
+}
+
+
+VpuDecRetCode VPU_DecOpen(VpuDecHandle *pOutHandle, VpuDecOpenParam * pInParam,VpuMemInfo* pInMemInfo)
+{
+	VpuMemSubBlockInfo * pMemPhy;
+	VpuMemSubBlockInfo * pMemVirt;
+	VpuDecHandleInternal* pVpuObj;
+	VpuDecObj* pObj;
+
+	RetCode ret;
+	DecOpenParam sDecOpenParam;
+	
+	pMemVirt=&pInMemInfo->MemSubBlock[VIRT_INDEX];
+	pMemPhy=&pInMemInfo->MemSubBlock[PHY_INDEX];
+	if ((pMemVirt->pVirtAddr==NULL) || MemNotAlign(pMemVirt->pVirtAddr,VPU_MEM_ALIGN)
+		||(pMemVirt->nSize!=sizeof(VpuDecHandleInternal)))
+	{
+		VPU_ERROR("%s: failure: invalid parameter ! \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_PARAM;
+	}
+
+	if ((pMemPhy->pVirtAddr==NULL) || MemNotAlign(pMemPhy->pVirtAddr,VPU_MEM_ALIGN)
+		||(pMemPhy->pPhyAddr==NULL) || MemNotAlign(pMemPhy->pPhyAddr,VPU_MEM_ALIGN)
+		||(pMemPhy->nSize!=(VPU_BITS_BUF_SIZE+VPU_SLICE_SAVE_SIZE+VPU_PS_SAVE_SIZE)))
+	{
+		VPU_ERROR("%s: failure: invalid parameter !! \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_PARAM;
+	}
+
+	pVpuObj=(VpuDecHandleInternal*)pMemVirt->pVirtAddr;
+	pObj=&pVpuObj->obj;
+
+	// clear vpu obj 
+	vpu_memset(pObj, 0, sizeof(VpuDecObj));
+	//clear 0 firstly
+	vpu_memset(&sDecOpenParam, 0, sizeof(DecOpenParam));
+
+	if(CPU_IS_MX6X())  
+	{
+		if(VPU_V_MJPG==pInParam->CodecFormat)
+		{
+			//for MJPG: linebuffer:1 similar with file mode; linebuffer:0 similar with stream mode
+#if 1		//for JPEG, only one frame is exist, we had better enable jpgLineBufferMode to decode the only frame in time.
+			sDecOpenParam.jpgLineBufferMode=1;
+#else
+			sDecOpenParam.jpgLineBufferMode=pInParam->nEnableFileMode;
+#endif
+		}
+		pInParam->nEnableFileMode=0;  // for iMX6: only support stream mode !!!
+		sDecOpenParam.bitstreamMode=1; //0-normal mode, 1-rollback mode
+	}
+
+	if(pInParam->nEnableFileMode)
+	{
+		sDecOpenParam.filePlayEnable = 1; /* always using file mode */
+	}
+	else
+	{
+		sDecOpenParam.filePlayEnable = 0; /* always using stream mode */
+	}
+
+	//sDecOpenParam.dynamicAllocEnable = 0;
+	VPU_LOG("format: %d \r\n",pInParam->CodecFormat);
+	switch (pInParam->CodecFormat) {
+		case VPU_V_MPEG2: 	 /**< AKA: H.262 */
+			sDecOpenParam.bitstreamFormat = STD_MPEG2;
+			//sDecOpenParam.filePlayEnable = 0;
+			VPU_LOG("open Mpeg2 \r\n");
+			break;
+		case VPU_V_H263:		 /**< H.263 */
+			sDecOpenParam.bitstreamFormat = STD_H263;
+			VPU_LOG("open H263 \r\n");
+			break;
+		case VPU_V_MPEG4: 	 /**< MPEG-4 */
+			sDecOpenParam.bitstreamFormat = STD_MPEG4;
+			sDecOpenParam.mp4Class = 0;
+			VPU_LOG("open Mpeg4 \r\n");
+			break;	
+		case VPU_V_DIVX56:		/**< DIVX 5/6 */
+			sDecOpenParam.bitstreamFormat = STD_MPEG4;
+			sDecOpenParam.mp4Class = 1;
+			VPU_LOG("open DIVX 56 \r\n");
+			LOG_DIVX_WARNING("LEVEL: 1 Error: Find DivX56, not supported ! \r\n");
+			break;
+		case VPU_V_XVID:		/**< XVID */
+			sDecOpenParam.bitstreamFormat = STD_MPEG4;
+			sDecOpenParam.mp4Class = 2;
+			VPU_LOG("open XVID \r\n");
+			break;			
+		case VPU_V_DIVX4:		/**< DIVX 4 */
+			sDecOpenParam.bitstreamFormat = STD_MPEG4;
+			sDecOpenParam.mp4Class = 5;
+			VPU_LOG("open DIVX 4 \r\n");
+			LOG_DIVX_WARNING("LEVEL: 1 Error: Find DivX4, not supported ! \r\n");
+			break;	
+		case VPU_V_DIVX3:		/**< DIVX 3 */ 
+			sDecOpenParam.bitstreamFormat = STD_DIV3;
+			sDecOpenParam.reorderEnable = 1;
+			//sDecOpenParam.filePlayEnable = 1; 
+			VPU_LOG("open DIVX 3 \r\n");
+			LOG_DIVX_WARNING("LEVEL: 1 Error: Find DivX3, not supported ! \r\n");
+			break;		
+		case VPU_V_RV:		
+			sDecOpenParam.bitstreamFormat = STD_RV;
+			sDecOpenParam.reorderEnable = 1;
+			//sDecOpenParam.filePlayEnable = 1; 
+			VPU_LOG("open RV \r\n");
+			break;		
+		case VPU_V_VC1:		 /**< all versions of Windows Media Video */
+		case VPU_V_VC1_AP:
+			sDecOpenParam.bitstreamFormat = STD_VC1;
+			//sDecOpenParam.filePlayEnable = 1; 
+			sDecOpenParam.reorderEnable = 1;
+			VPU_LOG("open VC1 \r\n");
+			break;
+		case VPU_V_AVC_MVC:
+			sDecOpenParam.avcExtension=1;
+		case VPU_V_AVC:
+			sDecOpenParam.bitstreamFormat = STD_AVC;
+			//pCodecPriv->sPsSaveBuffer.size = PS_SAVE_SIZE;
+			//GET_PHY_MEM(&(pCodecPriv->sPsSaveBuffer));
+			//pCodecPriv->sSliceBuffer.size = SLICE_SAVE_SIZE;
+			//GET_PHY_MEM(&(pCodecPriv->sSliceBuffer));
+			sDecOpenParam.reorderEnable = pInParam->nReorderEnable;
+			//sDecOpenParam.filePlayEnable = 0;
+			VPU_LOG("open H.264 \r\n");
+			break;
+		case VPU_V_MJPG:
+			sDecOpenParam.bitstreamFormat = STD_MJPG;
+			sDecOpenParam.mjpg_thumbNailDecEnable=0;	//no thumbnail ??
+			if(CPU_IS_MX6X())
+			{
+				sDecOpenParam.pBitStream=pMemPhy->pVirtAddr;
+				//sDecOpenParam.jpgLineBufferMode=1;	/*need to enable it*/
+			}
+			VPU_LOG("open MJPEG \r\n");
+			break;
+		case VPU_V_AVS:
+			sDecOpenParam.bitstreamFormat = STD_AVS;
+			sDecOpenParam.reorderEnable = 1;
+			VPU_LOG("open AVS \r\n");
+			break;
+		case VPU_V_VP8:
+			sDecOpenParam.bitstreamFormat = STD_VP8;
+			sDecOpenParam.reorderEnable = 1;
+			VPU_LOG("open VP8 \r\n");
+			break;
+		default:
+			VPU_ERROR("%s: failure: invalid format !!! \r\n",__FUNCTION__);	
+			return VPU_DEC_RET_INVALID_PARAM;
+	}
+
+	sDecOpenParam.bitstreamBuffer = (PhysicalAddress)pMemPhy->pPhyAddr;
+	sDecOpenParam.bitstreamBufferSize = VPU_BITS_BUF_SIZE;//pMemPhy->nSize;
+	//sDecOpenParam.psSaveBuffer = NULL;
+	//sDecOpenParam.psSaveBufferSize = 0;
+	sDecOpenParam.chromaInterleave = pInParam->nChromaInterleave;
+#if 1	//needed for divx3
+	sDecOpenParam.picWidth = pInParam->nPicWidth;	
+	sDecOpenParam.picHeight = pInParam->nPicHeight;
+#endif
+
+	/*record avc slice/ps buffer*/
+	pObj->pAvcSlicePhyBuf=pMemPhy->pPhyAddr+VPU_BITS_BUF_SIZE;
+	pObj->pAvcSPSPhyBuf=pMemPhy->pPhyAddr+VPU_BITS_BUF_SIZE+VPU_SLICE_SAVE_SIZE;
+	sDecOpenParam.psSaveBuffer=(PhysicalAddress)pObj->pAvcSPSPhyBuf;
+	sDecOpenParam.psSaveBufferSize=VPU_PS_SAVE_SIZE;
+
+#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,7))	
+	ASSERT(0==LINEAR_FRAME_MAP);
+	ASSERT(1==TILED_FRAME_MB_RASTER_MAP);
+	ASSERT(2==TILED_FIELD_MB_RASTER_MAP);
+	if(CPU_IS_MX6X())
+	{
+		sDecOpenParam.mapType=pInParam->nMapType;
+		sDecOpenParam.tiled2LinearEnable=pInParam->nTiled2LinearEnable;
+		pObj->nMapType=pInParam->nMapType;
+		pObj->nTiled2LinearEnable=pInParam->nTiled2LinearEnable;
+		if(pObj->nMapType!=0)
+		{
+			ASSERT(1==sDecOpenParam.chromaInterleave);
+		}
+	}
+#endif
+
+	VPU_TRACE;
+	VPU_API("calling vpu_DecOpen() : filePlayEnable: %d , format: %d \r\n",sDecOpenParam.filePlayEnable,sDecOpenParam.bitstreamFormat);
+	ret= vpu_DecOpen(&pVpuObj->handle, &sDecOpenParam);
+	VPU_TRACE;
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: vpu open failure: ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_DEC_RET_FAILURE;
+	}
+
+	// record open params info
+	pObj->CodecFormat  = pInParam->CodecFormat;
+	//pObj->blockmode=pInParam->block;
+	pObj->streamBufDelaySize=VPU_MIN_DEC_SIZE;	//set default buffer delay value
+	pObj->inputType=VPU_DEC_IN_NORMAL; //default: normal
+
+	//record resolution for some special formats (such as VC1,...)
+	pObj->picWidth = pInParam->nPicWidth;	
+	pObj->picHeight = pInParam->nPicHeight;
+	
+	// init bitstream buf info
+	pObj->pBsBufVirtStart= pMemPhy->pVirtAddr;
+	pObj->pBsBufPhyStart= pMemPhy->pPhyAddr;
+	//pObj->pBsBufPhyWritePtr= pVpuObj->obj.pBsBufPhyStart;
+	pObj->pBsBufPhyEnd=pMemPhy->pPhyAddr+VPU_BITS_BUF_SIZE;//+pMemPhy->nSize;
+
+	// init state
+	pObj->state=VPU_DEC_STATE_OPEN;
+
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+	//pObj->refCnt=MIN_REF_CNT;	//we only consider flush operation(eg. seek), so init it with valid value, but not 0
+	pObj->refCnt=0;				//for some .ts clips, we need to skip the first corrupt frames
+	pObj->dropBCnt=0;
+	//pObj->keyCnt=MIN_KEY_CNT;	//we only consider flush operation(eg. seek) ???
+	pObj->keyCnt=0;				//for some .ts clips, we need to skip the first corrupt frames
+#endif	
+//#ifdef VPU_IFRAME_SEARCH
+	//pObj->keyDecCnt=MIN_KEY_CNT;//we only consider flush operation(eg.seek)
+	pObj->keyDecCnt=0;
+	if(CPU_IS_MX6X())
+	{	
+		// iMX6X: stream mode
+		pObj->iframesearch_allowed=1;
+		pObj->fake_flush=1;
+	}
+	else
+	{	
+		// iMX5X: file mode
+		pObj->iframesearch_allowed=0;
+		pObj->fake_flush=0;
+	}		
+//#endif
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+	pObj->seekKeyLoc=0;			//we consider the normal play (for .ts clips)
+	pObj->recommendFlush=0;
+#endif
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+	pObj->dataUsedInFileMode=0;
+	pObj->lastDatLenInFileMode=0;
+	pObj->lastConfigMode=0;
+#endif
+	// setting related with file mode
+	pObj->filemode=sDecOpenParam.filePlayEnable;
+	pObj->firstData=1;
+	pObj->firstDataSize=0;
+#ifdef VPU_PROTECT_MULTI_INSTANCE
+	pObj->filledEOS=0;
+#endif
+	pObj->pbPacket=0;
+	pObj->pbClips=0;
+
+#ifdef VPU_FLUSH_BEFORE_DEC_WORKAROUND
+	pObj->realWork=0;
+#endif
+
+#ifdef VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE
+	pObj->firstFrameMode=0;
+	pObj->fieldCnt=0;
+#endif
+
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+	pObj->needMergeFields=VPU_FILEMODE_MERGE_FLAG;
+	pObj->lastFieldOffset=0;
+#endif
+
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+	pObj->fieldDecoding=0;
+	pObj->oweFieldTS=0;
+#endif
+
+	pObj->mjpg_frmidx=0;
+	if(CPU_IS_MX6X())
+	{
+		if((VPU_V_MJPG==pInParam->CodecFormat)&&(1==sDecOpenParam.jpgLineBufferMode))
+		{
+			//caution: in this case, vpu must be open with stream mode on iMX6.
+			pObj->filemode=1; //unify the logic: for filemode and linebuffermode
+			pObj->mjpg_linebuffmode=1;
+		}
+	}
+
+	pObj->nDecFrameRptEnabled=0;
+	pObj->nDecResolutionChangeEnabled=0;
+	if(CPU_IS_MX6X())
+	{
+		switch(pObj->CodecFormat)
+		{
+			//1 FIXME later
+			case VPU_V_DIVX4:
+			case VPU_V_DIVX56:
+			case VPU_V_XVID:
+			case VPU_V_MPEG4:
+			case VPU_V_AVC:				
+			case VPU_V_MPEG2:
+				pObj->nDecFrameRptEnabled=1;
+				pObj->nDecResolutionChangeEnabled=1;
+				break;
+			default:
+				pObj->nDecFrameRptEnabled=0;
+				pObj->nDecResolutionChangeEnabled=0;
+				break;
+		}
+	}
+	pObj->nAccumulatedConsumedStufferBytes=0;
+	pObj->nAccumulatedConsumedFrmBytes=0;
+	pObj->nAccumulatedConsumedBytes=0;
+	pObj->pLastDecodedFrm=NULL;
+	pObj->nAdditionalSeqBytes=0;
+	pObj->nAdditionalFrmHeaderBytes=0;
+	pObj->nLastFrameEndPosPhy=(unsigned int)pObj->pBsBufPhyEnd-1+FRAME_END_OFFSET;	//make sure we can compute the length of sequence/config before the first frame
+
+	pObj->pSeqBak=NULL;
+	pObj->nSeqBakLen=0;
+	pObj->sDecOpenParam=sDecOpenParam; /*backup open parameters*/
+
+	pObj->initDataCountThd=VPU_MAX_INIT_LOOP;
+	pObj->nLastErrorInfo=VPU_DEC_ERR_UNFOUND;
+	pObj->nIsAvcc=0;
+	*pOutHandle=(VpuDecHandle)pVpuObj;
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+
+VpuDecRetCode VPU_DecGetCapability(VpuDecHandle InHandle,VpuDecCapability eInCapability, int* pOutCapbility)
+{
+/*
+	Trick:
+	InHandle: NULL, get capability before open
+	InHandle: !NULL, get capability after open
+*/
+	VpuDecHandleInternal * pVpuObj=NULL;
+	VpuDecObj* pObj=NULL;
+	if (InHandle)
+	{
+		pVpuObj=(VpuDecHandleInternal *)InHandle;
+		pObj=&pVpuObj->obj;
+	}
+	switch(eInCapability)
+	{
+		case VPU_DEC_CAP_FILEMODE:
+			*pOutCapbility=(CPU_IS_MX6X())?0:1;	//only supported by iMX5
+			break;
+		case VPU_DEC_CAP_TILE:
+			*pOutCapbility=(CPU_IS_MX6X())?1:0;	//only supported by iMX6
+			break;
+		case VPU_DEC_CAP_FRAMESIZE:
+			if(pObj==NULL)
+			{
+				VPU_ERROR("%s: get capability(%d) failure: vpu hasn't been opened \r\n",__FUNCTION__,eInCapability);
+				return VPU_DEC_RET_INVALID_PARAM;
+			}
+			*pOutCapbility=pObj->nDecFrameRptEnabled;
+			break;
+		case VPU_DEC_CAP_RESOLUTION_CHANGE:
+			if(pObj==NULL)
+			{
+				VPU_ERROR("%s: get capability(%d) failure: vpu hasn't been opened \r\n",__FUNCTION__,eInCapability);
+				return VPU_DEC_RET_INVALID_PARAM;
+			}
+			*pOutCapbility=pObj->nDecResolutionChangeEnabled;			
+			break;
+		default:
+			VPU_ERROR("%s: unknown capability: 0x%X \r\n",__FUNCTION__,eInCapability);
+			return VPU_DEC_RET_INVALID_PARAM;
+	}
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecDisCapability(VpuDecHandle InHandle,VpuDecCapability eInCapability)
+{
+	VpuDecHandleInternal * pVpuObj=NULL;
+	VpuDecObj* pObj=NULL;
+	if (InHandle==NULL)	{
+		return VPU_DEC_RET_INVALID_PARAM;
+	}
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	pObj=&pVpuObj->obj;
+	if(pObj==NULL){
+		VPU_ERROR("%s: get capability(%d) failure: vpu hasn't been opened \r\n",__FUNCTION__,eInCapability);
+		return VPU_DEC_RET_INVALID_PARAM;
+	}	
+	switch(eInCapability)	{
+		case VPU_DEC_CAP_FRAMESIZE:
+			pObj->nDecFrameRptEnabled=0;
+			break;
+		case VPU_DEC_CAP_RESOLUTION_CHANGE:
+			/* if user always allocate enough frames(size/count), 
+			    vpu needn't trigger resolution change event which will lead to some additional payload (close/open vpu and re-regiser frames) */
+			pObj->nDecResolutionChangeEnabled=0;
+			break;
+		default:
+			VPU_ERROR("%s: unsupported capability: 0x%X \r\n",__FUNCTION__,eInCapability);
+			return VPU_DEC_RET_INVALID_PARAM;
+	}
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecConfig(VpuDecHandle InHandle, VpuDecConfig InDecConf, void* pInParam)
+{
+	VpuDecHandleInternal * pVpuObj;
+	VpuDecObj* pObj;
+	int para;
+	if(InHandle==NULL)
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);		
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+	
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	pObj=&pVpuObj->obj;
+	
+	switch(InDecConf)
+	{
+		case VPU_DEC_CONF_SKIPMODE:
+			para=*((int*)pInParam);
+			if(para==VPU_DEC_SKIPNONE)
+			{
+				pObj->skipFrameMode=0;
+				pObj->skipFrameNum=0;
+				pObj->iframeSearchEnable=0;
+			}
+			else if(para==VPU_DEC_SKIPPB)
+			{
+				pObj->skipFrameMode=1;
+				pObj->skipFrameNum=1;
+				pObj->iframeSearchEnable=0;
+			}
+			else if(para==VPU_DEC_SKIPB)
+			{
+				pObj->skipFrameMode=2;
+				pObj->skipFrameNum=1;
+				pObj->iframeSearchEnable=0;
+			}
+			else if(para==VPU_DEC_SKIPALL)
+			{
+				pObj->skipFrameMode=3;
+				pObj->skipFrameNum=1;
+				pObj->iframeSearchEnable=0;
+			}
+			else if(para==VPU_DEC_ISEARCH)
+			{
+				pObj->skipFrameMode=0;
+				pObj->skipFrameNum=0;
+				pObj->iframeSearchEnable=1;
+			}
+			else
+			{
+				VPU_ERROR("%s: failure: invalid skip parameter: %d \r\n",__FUNCTION__,para);	
+				return VPU_DEC_RET_INVALID_PARAM;
+			}
+			break;			
+		case VPU_DEC_CONF_INPUTTYPE:
+			para=*((int*)pInParam);
+			if((para!=VPU_DEC_IN_NORMAL)&&(para!=VPU_DEC_IN_KICK)&&(para!=VPU_DEC_IN_DRAIN))
+			{
+				VPU_ERROR("%s: failure: invalid inputtype parameter: %d \r\n",__FUNCTION__,para);	
+				return VPU_DEC_RET_INVALID_PARAM;				
+			}
+			pObj->inputType=para;
+			break;	
+		//case VPU_DEC_CONF_BLOCK:
+		//	pObj->blockmode=1;
+		//	break;
+		//case VPU_DEC_CONF_NONEBLOCK:
+		//	pObj->blockmode=0;
+		//	break;
+		case VPU_DEC_CONF_BUFDELAY:
+			para=*((int*)pInParam);
+			pObj->streamBufDelaySize=para;
+			break;
+		case VPU_DEC_CONF_INIT_CNT_THRESHOLD:
+			para=*((int*)pInParam);
+			if(para<=0){
+				return VPU_DEC_RET_INVALID_PARAM;
+			}
+			pObj->initDataCountThd=para;
+			break;
+		default:
+			VPU_ERROR("%s: failure: invalid setting \r\n",__FUNCTION__);	
+			return VPU_DEC_RET_INVALID_PARAM;
+	}
+	
+	return VPU_DEC_RET_SUCCESS;
+}
+
+
+VpuDecRetCode VPU_DecDecodeBuf(VpuDecHandle InHandle, VpuBufferNode* pInDataNode,int* pOutRetCode)
+{
+	VpuDecHandleInternal * pVpuObj;
+	VpuDecObj* pObj;
+	int noerr=1;
+	int streamModeEnough=1;
+	int seqOk=0;
+	VpuBufferNode sInDataBak;
+	VpuBufferNode* pInData;
+
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);		
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	pObj=&pVpuObj->obj;
+
+#if 1 //To decrease risk as possble, we maintain original logic relate with kick/drain: eg through checking addr==NULL and size==0 
+	if(pObj->inputType==VPU_DEC_IN_NORMAL)
+	{
+		pInData=pInDataNode;
+	}
+	else
+	{
+		//we may change the variables in input structure, so we backup it
+		sInDataBak=*pInDataNode;
+		pInData=&sInDataBak;
+		if(pObj->inputType==VPU_DEC_IN_KICK)
+		{
+			//in kick mode, user shouldn't set valid data
+			if((NULL!=pInData->pVirAddr)&& (pInData->nSize!=0))
+			{
+				VPU_ERROR("%s: in kick mode, data is ignored !!! \r\n",__FUNCTION__);
+			}
+			pInData->pVirAddr=NULL;
+			pInData->nSize=0;
+		}
+		else	 if(pObj->inputType==VPU_DEC_IN_DRAIN)
+		{
+			if((NULL!=pInData->pVirAddr)&& (pInData->nSize!=0))
+			{
+				VPU_ERROR("%s: in drain mode, data is ignored !!! \r\n",__FUNCTION__);
+			}
+			pInData->pVirAddr=(unsigned char*)pInData; //it is nomeaning, only set one non-null pointer
+			pInData->nSize=0;
+		}
+		else
+		{
+			VPU_ERROR("%s: in unknown mode: %d \r\n",__FUNCTION__,pObj->inputType);
+			return VPU_DEC_RET_FAILURE;
+		}
+	}
+#endif
+
+	//check NULL data, do nothing ? now, we need to NULL data to send EOS ?
+	if((1==pObj->filemode)&&(0==pObj->firstData))
+	{
+		//improve performance: CT: 38701782: transformer 2 1080p_mpeg4.mkv
+		if((NULL==pInData->pVirAddr)&&(0==pInData->nSize))
+		{
+			*pOutRetCode=VPU_DEC_INPUT_USED;
+#ifdef VPU_SUPPORT_NO_INBUF		
+			*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_INBUF;
+#endif			
+			return VPU_DEC_RET_SUCCESS;
+		}
+	}
+
+	//check MJPG
+	
+	if(VPU_V_MJPG==pObj->CodecFormat)
+	{
+		//ASSERT(1==pObj->filemode);
+		if(0==pInData->nSize)
+		{
+			if(NULL==pInData->pVirAddr)
+			{
+				if((1==pObj->filemode) &&(1==pObj->firstData)) //check 'firstData' for JPEG: only one frame is exist, and it may be feed to vpu already with config data together
+				{
+					//for JPEG(only one video frame + muti-frames audio), use may can't get video EOS immediately, we need to return the only video frame in time before EOS.					
+				}
+				else
+				{
+					*pOutRetCode=VPU_DEC_INPUT_USED;
+#ifdef VPU_SUPPORT_NO_INBUF		
+					*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_INBUF;
+#endif
+					return VPU_DEC_RET_SUCCESS;
+				}
+			}
+			else
+			{
+				//for mjpg: in file mode, vpu seem don't return -1 after update 0.
+				//so, here we need to return eos manually !!!
+				if((1==pObj->filemode)&&(0==pObj->firstData))  //check 'firstData' for JPEG: only one frame is exist, and it may be feed to vpu already with config data together
+				{
+					int index;
+					if(0==VpuSearchFreeFrameBuf(pObj, &index))
+					{
+						//no frame buffer, we need to reserved one frame for the last output even it doesn't contain valid data
+						VPU_API("MJPG: need to reserve on frame for the last output, return no output \r\n");
+						*pOutRetCode=VPU_DEC_OUTPUT_NODIS|VPU_DEC_NO_ENOUGH_BUF;
+					}
+					else
+					{
+						VPU_API("MJPG: return EOS manually \r\n");
+						*pOutRetCode=VPU_DEC_OUTPUT_EOS;
+						pObj->state=VPU_DEC_STATE_EOS;	// user should feed valid data for next play					
+					}
+					return VPU_DEC_RET_SUCCESS;
+				}
+			}			
+		}
+	}
+
+RepeatDec:
+	switch (pObj->state)
+	{
+		case VPU_DEC_STATE_OPEN:
+			//need to check (pInData->nSize==0) ?? we should not send 0 bytes at seqinit step 
+			seqOk=VpuSeqInit(pVpuObj->handle,pObj,pInData,pOutRetCode,&noerr);
+#ifdef VPU_SUPPORT_NO_INBUF
+			if((seqOk==0)&&((*pOutRetCode)&VPU_DEC_INPUT_USED))
+			{
+				if((NULL!=pInData->pVirAddr)&&(0==pInData->nSize))	//for iMX6X(stream mode)
+				{
+					//do nothing if meeting eos: stream mode: WVC1_APL4_16x16_30fps_46kbps_NoAudio_MA40263
+				}
+				else
+				{
+					*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_INBUF;
+				}
+			}
+#endif
+			break;
+		case VPU_DEC_STATE_INITOK:
+			VPU_ERROR("%s: failure: missing VPU_DecGetInitialInfo() \r\n",__FUNCTION__);
+			return VPU_DEC_RET_WRONG_CALL_SEQUENCE;
+		case VPU_DEC_STATE_REGFRMOK:
+			VPU_ERROR("%s: failure: missing VPU_DecRegisterFrameBuffer() \r\n",__FUNCTION__);
+			return VPU_DEC_RET_WRONG_CALL_SEQUENCE;			
+		case VPU_DEC_STATE_DEC:
+		case VPU_DEC_STATE_STARTFRAMEOK:
+#ifdef IMX6_BUFNOTENOUGH_WORKAROUND
+			//if(CPU_IS_MX6X())
+			if((CPU_IS_MX6X())&&(VPU_V_VP8==pVpuObj->obj.CodecFormat))  //now, only for iMX6/VP8
+			{
+				int used_num=0;
+				used_num=VpuQueryVpuHoldBufNum(pObj);
+				//if(used_num<pVpuObj->obj.initInfo.nMinFrameBufferCount)
+				if(used_num<pVpuObj->obj.initInfo.nMinFrameBufferCount-1)
+				{
+					VPU_LOG("buf may not enough, %d may been used by vpu , mini cnt: %d \r\n",used_num,pVpuObj->obj.initInfo.nMinFrameBufferCount);
+					*pOutRetCode=VPU_DEC_NO_ENOUGH_BUF|VPU_DEC_OUTPUT_NODIS;	
+					return VPU_DEC_RET_SUCCESS;
+				}
+			}
+#endif
+#ifdef VPU_BACKDOOR
+			//verify clear flag 
+			VpuVerifyClearFlag(pVpuObj->handle,pObj);
+#endif
+			if(-1==VpuDecBuf(&pVpuObj->handle,pObj,pInData,pOutRetCode,&noerr,&streamModeEnough))
+			{
+				VPU_ERROR("%s: time out \r\n",__FUNCTION__);	
+				pObj->state=VPU_DEC_STATE_CORRUPT;
+				return VPU_DEC_RET_FAILURE_TIMEOUT;
+			}
+#ifdef VPU_SUPPORT_NO_INBUF
+			if((*pOutRetCode)&VPU_DEC_INPUT_USED)
+			{
+				if((pInData->pVirAddr!=NULL)&&(pInData->nSize==0))
+				{
+					//in eos: shouldn't set no_enough_input
+				}
+				else
+				{
+					//if(1==pObj->filemode)
+					//{
+					//	*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_INBUF;					
+					//}
+					//else
+					{
+						if(0==streamModeEnough)
+						{
+							*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_INBUF;	
+						}
+					}
+				}
+			}
+#endif
+			
+			break;
+		case VPU_DEC_STATE_OUTOK:
+			VPU_ERROR("%s: failure: missing VPU_DecGetOutputFrame() \r\n",__FUNCTION__);
+			return VPU_DEC_RET_WRONG_CALL_SEQUENCE;
+		case VPU_DEC_STATE_EOS:
+			if(pInData->nSize>0)
+			{
+				if(0==VpuDecClearOperationEOStoDEC(InHandle))
+				{
+					VPU_ERROR("%s: trans eos to dec state failure ! \r\n",__FUNCTION__);
+					return VPU_DEC_RET_FAILURE;
+				}
+				pObj->state=VPU_DEC_STATE_DEC;  //repeat play
+				goto RepeatDec;
+			}
+			else if((pInData->pVirAddr!=NULL)&&(pInData->nSize==0))
+			{
+				//fix case: special EOS flag with 0 bytes
+				if(0==VpuDecClearOperationEOStoDEC(InHandle))
+				{
+					VPU_ERROR("%s: trans eos to dec state failure !!! \r\n",__FUNCTION__);
+					return VPU_DEC_RET_FAILURE;
+				}
+				pObj->state=VPU_DEC_STATE_DEC;  //repeat play
+				goto RepeatDec;				
+			}
+			else
+			{
+				*pOutRetCode=VPU_DEC_INPUT_USED;   //do nothing and return
+#ifdef VPU_SUPPORT_NO_INBUF
+				*pOutRetCode=(*pOutRetCode)|VPU_DEC_NO_ENOUGH_INBUF;
+#endif				
+				break;
+			}	
+		case VPU_DEC_STATE_CORRUPT:
+			// do nothing, wait calling VPU_Reset(), and then reload vpu again
+			*pOutRetCode=VPU_DEC_INPUT_NOT_USED;
+			break;
+		case VPU_DEC_STATE_RESOLUTION_CHANGE:
+		default:
+			VPU_ERROR("%s: failure: error state: %d \r\n",__FUNCTION__,pObj->state);
+			return VPU_DEC_RET_INVALID_PARAM;
+	}
+
+	VpuCheckDeadLoop(pObj,pInData,pOutRetCode,&noerr);
+	
+	if(noerr)
+	{
+		return VPU_DEC_RET_SUCCESS;
+	}
+	else
+	{
+		VPU_ERROR("%s: return failure \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_FAILURE;
+	}
+}
+
+
+VpuDecRetCode VPU_DecGetInitialInfo(VpuDecHandle InHandle, VpuDecInitInfo * pOutInitInfo)
+{
+	VpuDecHandleInternal * pVpuObj;
+
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	if(pVpuObj->obj.state!=VPU_DEC_STATE_INITOK)
+	{
+		VPU_ERROR("%s: failure: error state %d \r\n",__FUNCTION__,pVpuObj->obj.state);	
+		return VPU_DEC_RET_WRONG_CALL_SEQUENCE;
+	}
+
+	//update state
+	pVpuObj->obj.state=VPU_DEC_STATE_REGFRMOK;
+	VPU_TRACE;
+	*pOutInitInfo=pVpuObj->obj.initInfo;
+	VPU_TRACE;
+	
+	return VPU_DEC_RET_SUCCESS;
+}
+
+
+VpuDecRetCode VPU_DecRegisterFrameBuffer(VpuDecHandle InHandle,VpuFrameBuffer *pInFrameBufArray, int nNum)
+{
+	VpuDecHandleInternal * pVpuObj;
+	RetCode ret;
+	//FrameBuffer vpu_regframebuf[VPU_MAX_FRAME_INDEX];
+	DecBufInfo sBufInfo;
+	int i;
+	
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	if(pVpuObj->obj.state!=VPU_DEC_STATE_REGFRMOK)
+	{
+		VPU_ERROR("%s: failure: error state %d \r\n",__FUNCTION__,pVpuObj->obj.state);	
+		return VPU_DEC_RET_WRONG_CALL_SEQUENCE;
+	}
+
+	if(nNum>VPU_MAX_FRAME_INDEX)
+	{
+		VPU_ERROR("%s: failure: register frame number is too big(%d) \r\n",__FUNCTION__,nNum);		
+		return VPU_DEC_RET_INVALID_PARAM;
+	}
+
+	for(i=0;i<nNum;i++)
+	{
+		//record frame buf info
+		pVpuObj->obj.frameBuf[i]=*pInFrameBufArray;
+
+		//re-map frame buf info for vpu register
+		pVpuObj->obj.vpu_regframebuf[i].myIndex=i;
+		pVpuObj->obj.vpu_regframebuf[i].strideY=(unsigned long)pInFrameBufArray->nStrideY;
+		pVpuObj->obj.vpu_regframebuf[i].strideC=(unsigned long)pInFrameBufArray->nStrideC;
+#ifdef USE_NEW_VPU_API			
+		pVpuObj->obj.vpu_regframebuf[i].myIndex=i;
+#endif
+
+		//need to remap Y/Cb/Cr for tile format frame buffer 
+		if(pVpuObj->obj.nMapType!=0)
+		{
+			VpuTiledAddressMapping(pVpuObj->obj.nMapType, 
+				(unsigned int)pInFrameBufArray->pbufY, (unsigned int)pInFrameBufArray->pbufY_tilebot, (unsigned int)pInFrameBufArray->pbufCb, (unsigned int)pInFrameBufArray->pbufCb_tilebot, 
+				(unsigned int*)(&pVpuObj->obj.vpu_regframebuf[i].bufY), (unsigned int*)(&pVpuObj->obj.vpu_regframebuf[i].bufCb), (unsigned int*)(&pVpuObj->obj.vpu_regframebuf[i].bufCr));
+		}
+		else
+		{
+
+			pVpuObj->obj.vpu_regframebuf[i].bufY=(PhysicalAddress)pInFrameBufArray->pbufY;
+			pVpuObj->obj.vpu_regframebuf[i].bufCb=(PhysicalAddress)pInFrameBufArray->pbufCb;
+			pVpuObj->obj.vpu_regframebuf[i].bufCr=(PhysicalAddress)pInFrameBufArray->pbufCr;
+		}
+		pVpuObj->obj.vpu_regframebuf[i].bufMvCol=(PhysicalAddress)pInFrameBufArray->pbufMvCol;
+
+		VPU_API("input register frame %d: (phy)	Y:0x%X, U:0x%X, V:0x%X , Y_TileBot: 0x%X, Cb_TileBot: 0x%X \r\n",i,(unsigned int)pInFrameBufArray->pbufY,(unsigned int)pInFrameBufArray->pbufCb,(unsigned int)pInFrameBufArray->pbufCr,(unsigned int)pInFrameBufArray->pbufY_tilebot,(unsigned int)pInFrameBufArray->pbufCb_tilebot);
+		VPU_API("input register frame %d: (virt)	Y:0x%X, U:0x%X, V:0x%X , Y_TileBot: 0x%X, Cb_TileBot: 0x%X \r\n",i,(unsigned int)pInFrameBufArray->pbufVirtY,(unsigned int)pInFrameBufArray->pbufVirtCb,(unsigned int)pInFrameBufArray->pbufVirtCr,(unsigned int)pInFrameBufArray->pbufVirtY_tilebot,(unsigned int)pInFrameBufArray->pbufVirtCb_tilebot);
+		VPU_API("vpu register frame %d: (phy)	Y:0x%X, U:0x%X, V:0x%X \r\n",i,(unsigned int)pVpuObj->obj.vpu_regframebuf[i].bufY,(unsigned int)pVpuObj->obj.vpu_regframebuf[i].bufCb,(unsigned int)pVpuObj->obj.vpu_regframebuf[i].bufCr);
+		VPU_API("register mv    %d: (phy)	0x%X,    (virt)    0x%X \r\n",i,(unsigned int)pVpuObj->obj.vpu_regframebuf[i].bufMvCol,(unsigned int)pInFrameBufArray->pbufVirtMvCol);		
+		pInFrameBufArray++;
+	}
+	pVpuObj->obj.frameNum=nNum;
+
+	//1 not used sBufInfo again, only clear it
+	vpu_memset(&sBufInfo, 0, sizeof(DecBufInfo));
+
+	/*set slice save buf*/
+#ifdef USE_NEW_VPU_API		
+	sBufInfo.avcSliceBufInfo.bufferBase =(PhysicalAddress)pVpuObj->obj.pAvcSlicePhyBuf;
+	sBufInfo.avcSliceBufInfo.bufferSize =VPU_SLICE_SAVE_SIZE;	
+#else
+	sBufInfo.avcSliceBufInfo.sliceSaveBuffer=(PhysicalAddress)pVpuObj->obj.pAvcSlicePhyBuf;
+	sBufInfo.avcSliceBufInfo.sliceSaveBufferSize=VPU_SLICE_SAVE_SIZE;
+#endif	
+//#if 1 //for iMX6: Vp8
+#if 0	//we set maxDecFrmInfo with 0 : in order to support dynamic resolution
+	sBufInfo.maxDecFrmInfo.maxMbX=(pVpuObj->obj.initInfo.nPicWidth+15)/16;
+	if(pVpuObj->obj.initInfo.nInterlace)
+	{
+		sBufInfo.maxDecFrmInfo.maxMbY=((pVpuObj->obj.initInfo.nPicHeight+31)/32*32+15)/16;
+	}
+	else
+	{
+		sBufInfo.maxDecFrmInfo.maxMbY=(pVpuObj->obj.initInfo.nPicHeight+15)/16;
+	}
+	sBufInfo.maxDecFrmInfo.maxMbNum=sBufInfo.maxDecFrmInfo.maxMbX*sBufInfo.maxDecFrmInfo.maxMbY;
+#endif	
+	if(VPU_V_VP8==pVpuObj->obj.CodecFormat)
+	{
+		//use the same memory with avc
+		ASSERT((17*4*sBufInfo.maxDecFrmInfo.maxMbNum)<=VPU_VP8_MBPARA_SIZE);
+		ASSERT(VPU_VP8_MBPARA_SIZE<=(VPU_SLICE_SAVE_SIZE+VPU_PS_SAVE_SIZE));
+		sBufInfo.vp8MbDataBufInfo.bufferBase=(PhysicalAddress)pVpuObj->obj.pAvcSlicePhyBuf;
+		sBufInfo.vp8MbDataBufInfo.bufferSize=VPU_VP8_MBPARA_SIZE;
+	}
+//#endif		
+	VPU_TRACE;
+	VPU_API("calling vpu_DecRegisterFrameBuffer() \r\n");
+	ret = vpu_DecRegisterFrameBuffer(pVpuObj->handle,
+			pVpuObj->obj.vpu_regframebuf,
+			nNum,
+			pVpuObj->obj.vpu_regframebuf[0].strideY, /* necessary ? */
+			&sBufInfo);
+	VPU_TRACE;
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ERROR("%s: vpu register frame failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+
+	if(VPU_V_MJPG==pVpuObj->obj.CodecFormat)
+	{
+		unsigned int rot_angle = 0;
+		unsigned int mirror = 0;
+		//rot_angle=90;
+		VPU_API("vpu_DecGiveCommand: SET_ROTATION_ANGLE: %d \r\n",rot_angle);
+		vpu_DecGiveCommand(pVpuObj->handle, SET_ROTATION_ANGLE,(void*)(&rot_angle));
+		VPU_API("vpu_DecGiveCommand: SET_MIRROR_DIRECTION: %d \r\n",mirror);
+		vpu_DecGiveCommand(pVpuObj->handle, SET_MIRROR_DIRECTION,(void*)(&mirror));
+		VPU_API("vpu_DecGiveCommand: SET_ROTATOR_STRIDE: %d \r\n",(int)pVpuObj->obj.vpu_regframebuf[0].strideY);
+		vpu_DecGiveCommand(pVpuObj->handle, SET_ROTATOR_STRIDE,(void*)(&pVpuObj->obj.vpu_regframebuf[0].strideY));
+	}
+
+	//update state
+	pVpuObj->obj.state=VPU_DEC_STATE_DEC;	
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+
+
+VpuDecRetCode VPU_DecGetOutputFrame(VpuDecHandle InHandle, VpuDecOutFrameInfo * pOutFrameInfo)
+{
+	VpuDecHandleInternal * pVpuObj;
+
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	if(pVpuObj->obj.state!=VPU_DEC_STATE_OUTOK)
+	{
+		VPU_ERROR("%s: failure: error state: %d \r\n",__FUNCTION__,pVpuObj->obj.state);	
+		return VPU_DEC_RET_WRONG_CALL_SEQUENCE;
+	}
+
+	//update state
+	pVpuObj->obj.state=VPU_DEC_STATE_DEC;
+	VPU_TRACE;
+	*pOutFrameInfo=pVpuObj->obj.frameInfo;	
+	VPU_TRACE;
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecGetConsumedFrameInfo(VpuDecHandle InHandle,VpuDecFrameLengthInfo* pOutFrameLengthInfo)
+{
+	/*reserved to record some info for decoded(including dropped,corrupt etc) frame*/
+#if 0
+	*ppOutFrame=NULL;
+	*pOutFrameLength=-1;
+	VPU_ERROR("%s: it is still not implemented ! \r\n",__FUNCTION__);
+	return VPU_DEC_RET_FAILURE;
+#else
+	VpuDecHandleInternal * pVpuObj;
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	//if(NULL==pVpuObj->obj.pLastDecodedFrm)
+	//{
+	//	VPU_ERROR("%s: error state, no decoded frame info is ready ! \r\n", __FUNCTION__);
+	//}
+	pOutFrameLengthInfo->pFrame=pVpuObj->obj.pLastDecodedFrm;
+	pOutFrameLengthInfo->nStuffLength=pVpuObj->obj.nAccumulatedConsumedStufferBytes;
+	pOutFrameLengthInfo->nFrameLength=pVpuObj->obj.nAccumulatedConsumedFrmBytes;
+
+	/*clear recorded info*/
+	pVpuObj->obj.pLastDecodedFrm=NULL;
+	pVpuObj->obj.nAccumulatedConsumedStufferBytes=0;
+	pVpuObj->obj.nAccumulatedConsumedFrmBytes=0;
+	pVpuObj->obj.nAccumulatedConsumedBytes=0;
+	
+	return VPU_DEC_RET_SUCCESS;
+#endif
+}
+
+VpuDecRetCode VPU_DecOutFrameDisplayed(VpuDecHandle InHandle, VpuFrameBuffer* pInFrameBuf)
+{
+	VpuDecHandleInternal * pVpuObj;
+	RetCode ret;
+	int index;
+	
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+
+	switch(pVpuObj->obj.state)
+	{
+		case VPU_DEC_STATE_CORRUPT:
+		case VPU_DEC_STATE_RESOLUTION_CHANGE:
+			//skip calling vpu api
+			return VPU_DEC_RET_SUCCESS;
+		default:
+			break;
+	}
+
+	//search frame buffer index
+	index=VpuSearchFrameIndex(&pVpuObj->obj, pInFrameBuf);
+	if (-1==index)
+	{
+		VPU_ERROR("%s: failure: vpu can not find the frame buf, pInFrameBuf=0x%X \r\n",__FUNCTION__,(unsigned int)pInFrameBuf);
+		return VPU_DEC_RET_INVALID_PARAM;		
+	}
+
+
+	//clear disp flag: need to check since it may be cleared in flushall operation
+	if (VpuDispFrameIsNotCleared(index, pVpuObj->obj.frameBufState))
+	{
+		//clear frame state
+		VpuClearDispFrame( index, pVpuObj->obj.frameBufState);
+
+		VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,index);
+		//TIMER_START(TIMER_CLEARDISP_ID);
+		ret=vpu_DecClrDispFlag(pVpuObj->handle,index);
+		//TIMER_STOP(TIMER_CLEARDISP_ID);
+		if(RETCODE_SUCCESS!=ret)
+		{
+			VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,index,ret);
+			return VPU_DEC_RET_FAILURE;			
+		}
+
+		//reset historical info
+		if(pInFrameBuf==pVpuObj->obj.pPreDisplayFrameBuf)
+		{
+			pVpuObj->obj.pPreDisplayFrameBuf=NULL;
+		}
+	}
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecFlushAll(VpuDecHandle InHandle)
+{
+	VpuDecHandleInternal * pVpuObj;
+	VpuDecObj* pObj;
+	RetCode ret;
+	DecParam decParam;
+	DecOutputInfo outInfo;
+	int startFrameOK=0;
+	int nExtCount;		// for external while loop
+		
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	pObj=&pVpuObj->obj;
+
+	//set dec parameters		
+	//clear 0 firstly
+	vpu_memset(&decParam,0,sizeof(DecParam));
+
+	switch (pObj->state)
+	{
+		//allowed state
+		case VPU_DEC_STATE_OPEN:	//not sure the feasibility ??
+			VPU_ERROR("calling flush operation before seq init ok \r\n");
+		case VPU_DEC_STATE_INITOK:	
+		case VPU_DEC_STATE_REGFRMOK:
+			if(0==VpuBitFlush(pVpuObj, 0/*before decode state*/))
+			{
+				return VPU_DEC_RET_FAILURE;
+			}
+			//need not change state
+			return VPU_DEC_RET_SUCCESS;
+		case VPU_DEC_STATE_DEC:
+			break;
+		case VPU_DEC_STATE_STARTFRAMEOK:
+			startFrameOK=1;	//in this case, vpu may be busy status, we should not call vpu_DecBitBufferFlush()
+			//adjust state !!!
+			//pObj->state=VPU_DEC_STATE_DEC;
+			break;
+		case VPU_DEC_STATE_EOS:
+			break;
+		case VPU_DEC_STATE_CORRUPT:
+		case VPU_DEC_STATE_RESOLUTION_CHANGE:
+			//do nothing
+			return VPU_DEC_RET_SUCCESS;
+		default:
+			//forbidden state
+			//user should not call flush before seq init OK (eg, before getting correct resolution ???)
+			VPU_ERROR("%s: failure: error state: %d \r\n",__FUNCTION__,pObj->state);
+			return VPU_DEC_RET_FAILURE;
+	}
+
+	if(VPU_V_MJPG==pObj->CodecFormat)
+	{
+		if(1==pObj->filemode)
+		{
+			pObj->mjpg_frmidx=0;
+			goto FLUSH_FINISH;
+		}
+		else if(CPU_IS_MX6X())
+		{
+			//FIXME: some APIs, such as vpu_DecBitBufferFlush() can't be called
+			pObj->mjpg_frmidx=0;
+			goto FLUSH_FINISH;
+		}
+	}
+
+#ifdef VPU_FILEMODE_PBCHUNK_FLUSH_WORKAROUND
+	//pObj->pbClips=0;	//need not clear it .
+	if((0!=pObj->pbPacket)&&(1==pObj->dataUsedInFileMode)&&(1==pObj->filemode))
+	{
+		VPU_LOG("PB chunk is not completed !!!\r\n");
+		if(0==VpuPBChunkFlush(pVpuObj))
+		{
+			return VPU_DEC_RET_FAILURE;
+		}
+	}
+#endif	
+
+#ifdef VPU_FLUSH_BEFORE_DEC_WORKAROUND
+	if(0==pObj->realWork)
+	{
+		if(CPU_IS_MX6X()){
+			//fix ENGR242394: need to flush buffer to avoid get unexpected output
+			VPU_LOG(" flush before starting working \r\n");
+#if 1 //flush_before_start_workaround
+			/*	for some codec, such as AVC: [SPS + PPS] + Frame + Frame + Frame
+				(1) seqinit: vpu only read SPS;
+				(2) start the first frame: vpu will read PPS and decode frame
+				If bitstream buffer is flushed between (1) and (2), and no PPS feed to vpu later, 
+				vpu won't have opportunity to parse PPS info again, as result, no any valid frame are decoded until EOS.
+				so, we need to call vpu_DecStartOneFrame()/vpu_DecGetOutputInfo() to push vpu parse PPS info before vpu_DecBitBufferFlush().
+			*/
+			if(VPU_V_VC1_AP==pObj->CodecFormat){
+				//fix ENGR00284031:
+				/*seqinit (only consume sequence header) -> flush (entry point header is flushed) -> decode (can't find valid entry point)
+				    but for VC1, it has some limitation. e.g vpu only decode current frame when find following start code. 
+				    so we need to fill one additional start code to push vpu consume the entry point as possible*/
+				unsigned char temp[4];
+				temp[0]=temp[1]=0;
+				temp[2]=0x1;
+				VpuFillData(pVpuObj->handle,pObj,temp,3,1,0);
+			}
+			if(startFrameOK==0){
+				VPU_API("calling vpu_DecStartOneFrame \r\n");
+				ret = vpu_DecStartOneFrame(pVpuObj->handle, &decParam);
+				if(ret!=RETCODE_SUCCESS){
+					VPU_ERROR("vpu_DecStartOneFrame fail: %d !!!!!!!!!!!!\r\n",ret);
+				}
+				startFrameOK=1;
+			}
+#endif //flush_before_start_workaround
+		}
+		else{
+			//FIXME: for stream mode, it is still unsure !!!!!
+			ASSERT(pObj->filemode==1);
+			if(pObj->filemode==0)
+			{
+				//should skip calling bit flush in VpuDecClearOperationEOStoDEC() ???
+				return VPU_DEC_RET_SUCCESS;
+			}
+			//must skip update 0, otherwise, vpu always return -1(EOS) even feed it with valid data later
+			goto FLUSH_FINISH;
+		}
+	}
+#endif
+
+
+//#ifdef VPU_FAKE_FLUSH	//for testing: don't update 0
+	if(pObj->fake_flush)
+	{
+		if(startFrameOK==1)
+		{
+			if(CPU_IS_MX6X())	//iMX6: stream mode
+			{
+				VPU_API("calling vpu_WaitForInt(%d) \r\n",VPU_TIME_OUT);
+				if(0!=vpu_WaitForInt(VPU_TIME_OUT))
+				{
+					VPU_LOG("LEVEL: 1: in imx6 stream mode:  fake flush : no enough data , we should update 0 \r\n");
+					VPU_API("calling vpu_DecUpdateBitstreamBuffer(): %d \r\n",0);
+					ret=vpu_DecUpdateBitstreamBuffer(pVpuObj->handle, 0);	
+					if (ret != RETCODE_SUCCESS)
+					{
+						VPU_ERROR("%s: vpu update data failure: ret = 0x%X \r\n",__FUNCTION__,ret);	
+						return VPU_DEC_RET_FAILURE_TIMEOUT;
+					}
+					VPU_API("calling vpu_WaitForInt(%d) \r\n",VPU_TIME_OUT);
+					if(0!=vpu_WaitForInt(VPU_TIME_OUT))			
+					{
+						VPU_ERROR("LEVEL: 1: in imx6 stream mode: fake flush failure: timeout after update 0 \r\n");
+						return VPU_DEC_RET_FAILURE_TIMEOUT;
+					}			
+				}		
+			}
+			else
+			{
+				int cnt=0;
+				VPU_API("calling vpu_WaitForInt(%d) \r\n",VPU_TIME_OUT);
+				while(0!=vpu_WaitForInt(VPU_TIME_OUT))
+				{
+					cnt++;
+					if(cnt >VPU_MAX_TIME_OUT_CNT)
+					{
+						VPU_ERROR("%s: flush time out \r\n",__FUNCTION__);	
+						pObj->state=VPU_DEC_STATE_CORRUPT;
+						return VPU_DEC_RET_FAILURE_TIMEOUT;
+					}
+				}
+			}
+			VPU_API("calling vpu_DecGetOutputInfo() \r\n");
+			ret = vpu_DecGetOutputInfo(pVpuObj->handle, &outInfo);
+			VPU_API("calling vpu_DecGetOutputInfo(), indexFrameDecoded: %d, return indexFrameDisplay: %d, success: 0x%X  \r\n",outInfo.indexFrameDecoded,outInfo.indexFrameDisplay,outInfo.decodingSuccess);
+			
+			if (ret != RETCODE_SUCCESS)
+			{
+				VPU_ERROR("%s: vpu get output info failure: ret = 0x%X \r\n",__FUNCTION__,ret);
+				return VPU_DEC_RET_FAILURE;
+			}
+
+			if ((CPU_IS_MX6X()) &&(outInfo.decodingSuccess & 0x10))	//for iMX6 rollback mode
+			{
+				//current frame is not integrated, rollback to frame header
+			}
+			else
+			{		
+				if(outInfo.indexFrameDisplay>=0)
+				{
+					VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,outInfo.indexFrameDisplay);
+					ret=vpu_DecClrDispFlag(pVpuObj->handle,outInfo.indexFrameDisplay);
+					if(RETCODE_SUCCESS!=ret)
+					{
+						VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,outInfo.indexFrameDisplay,ret);
+						return VPU_DEC_RET_FAILURE;
+					}
+					//clear frame state
+					VpuClearDispFrame(outInfo.indexFrameDisplay, pObj->frameBufState);						
+				}
+				if(outInfo.indexFrameDecoded>=0){
+					VPU_API("%s: calling vpu_DecClrDispFlag() to clear decoded index: %d \r\n",__FUNCTION__,outInfo.indexFrameDecoded);
+					ret=vpu_DecClrDispFlag(pVpuObj->handle,outInfo.indexFrameDecoded);
+					if(RETCODE_SUCCESS!=ret){
+						VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,outInfo.indexFrameDecoded,ret);
+					}
+				}
+			}
+		}
+		
+		if(0==VpuBitFlush(pVpuObj, 1/*before eos*/))
+		{
+			return VPU_DEC_RET_FAILURE;
+		}
+		goto FLUSH_FINISH;
+	}
+//#endif  //VPU_FAKE_FLUSH
+
+	//flush bitstream to improve performance
+	if(startFrameOK==0)
+	{
+		if(0==VpuBitFlush(pVpuObj, 1/*before eos*/))
+		{
+			return VPU_DEC_RET_FAILURE;
+		}
+	}
+	else
+	{
+		//may enter dead loop if calling vpu_DecBitBufferFlush()
+		//so we need to call vpu_DecBitBufferFlush() after next vpu_DecStartOneFrame()
+	}
+
+	//send EOS flag
+	VPU_API("calling vpu_DecUpdateBitstreamBuffer(): %d \r\n",0);
+	ret=vpu_DecUpdateBitstreamBuffer(pVpuObj->handle, 0);	
+	if (ret != RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: vpu update data failure: ret = 0x%X \r\n",__FUNCTION__,ret);	
+		return VPU_DEC_RET_FAILURE;
+	}
+
+#if 0 //if we have flushed bitstream before, we need not set skip mode
+	decParam.skipframeMode=0;
+	decParam.skipframeNum=0;
+	decParam.iframeSearchEnable=0;
+#else
+	decParam.skipframeMode=3;  // skip all
+	decParam.skipframeNum=1;
+	decParam.iframeSearchEnable=0;
+#endif	
+
+	decParam.chunkSize=0;	//for file mode
+
+	if(startFrameOK==0)
+	{
+		// start decode frame
+		VPU_TRACE;
+		VPU_API("calling vpu_DecStartOneFrame() \r\n");
+		ret = vpu_DecStartOneFrame(pVpuObj->handle, &decParam);
+		VPU_TRACE;
+		if(ret == RETCODE_JPEG_EOS)
+		{
+			VPU_API("%s: MJPG: reach EOS \r\n",__FUNCTION__);
+			pObj->mjpg_frmidx=0;
+			goto FLUSH_FINISH;
+		}
+		else if(ret==RETCODE_JPEG_BIT_EMPTY)
+		{
+			//need to skip vpu_WaitForInt() and vpu_DecGetOutputInfo()
+			VPU_API("%s: MJPG: BIT EMPTY \r\n",__FUNCTION__);
+			pObj->mjpg_frmidx=0;
+			goto FLUSH_FINISH;
+		}
+		else if (ret != RETCODE_SUCCESS)
+		{
+			VPU_ERROR("%s: vpu start one frame failure: ret = 0x%X \r\n",__FUNCTION__,ret);
+			return VPU_DEC_RET_FAILURE;
+		}
+	}
+	else
+	{
+		//we already called vpu_DecStartOneFrame() before
+	}
+
+	nExtCount=0;
+	while(1)
+	{
+		int nCount=0;			// for internal while loop
+		// wait finished
+#if 1 
+		VPU_API("calling vpu_WaitForInt(%d) \r\n",VPU_TIME_OUT);
+		while(0!=vpu_WaitForInt(VPU_TIME_OUT))
+		{
+			nCount++;
+			if(nCount >VPU_MAX_TIME_OUT_CNT)
+			{
+				VPU_ERROR("%s: flush time out \r\n",__FUNCTION__);	
+				pObj->state=VPU_DEC_STATE_CORRUPT;
+				return VPU_DEC_RET_FAILURE_TIMEOUT;
+			}
+		}
+#else
+		VPU_API("calling vpu_IsBusy() \r\n");
+		while (vpu_IsBusy())
+		{
+			nCount++;
+			if(nCount >VPU_MAX_TIME_OUT_CNT)
+			{
+				VPU_ERROR("%s: flush time out \r\n",__FUNCTION__);	
+				pObj->state=VPU_DEC_STATE_CORRUPT;
+				return VPU_DEC_RET_FAILURE_TIMEOUT;
+			}
+			VPU_API("calling vpu_WaitForInt(%d): %d \r\n",VPU_TIME_OUT,nCount);
+			vpu_WaitForInt(VPU_TIME_OUT);
+		};
+#endif
+		// get output
+		VPU_TRACE;
+		VPU_API("calling vpu_DecGetOutputInfo() \r\n");
+		ret = vpu_DecGetOutputInfo(pVpuObj->handle, &outInfo);
+		VPU_API("calling vpu_DecGetOutputInfo(), indexFrameDecoded: %d, return indexFrameDisplay: %d , success: 0x%X \r\n",outInfo.indexFrameDecoded,outInfo.indexFrameDisplay,outInfo.decodingSuccess);
+		VPU_TRACE;
+		if (ret != RETCODE_SUCCESS)
+		{
+			VPU_ERROR("%s: vpu get output info failure: ret = 0x%X \r\n",__FUNCTION__,ret);
+			return VPU_DEC_RET_FAILURE;
+		}
+
+		if((outInfo.indexFrameDecoded<0)&&(outInfo.indexFrameDisplay<0)&&(VPU_OUT_DIS_INDEX_EOS!=outInfo.indexFrameDisplay))
+		{
+			//Be carefully: we may get many skipped output frames when skipmode is enabled, So, we had better call vpu_DecBitBufferFlush() !!!
+			nExtCount++;
+			//fixed case for: VGA1000kbps23fps128kbps44kHz.avi
+			//in such case, we can not get the EOS output. As result, enter dead loop
+			if(nExtCount>VPU_MAX_EOS_DEAD_LOOP_CNT)
+			{
+				VPU_ERROR("%s: eos time out \r\n",__FUNCTION__);
+				pObj->state=VPU_DEC_STATE_CORRUPT;
+				return VPU_DEC_RET_FAILURE_TIMEOUT;
+			}
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+			if(VPU_OUT_DEC_INDEX_EOS==outInfo.indexFrameDecoded)
+			{
+				//avoid eos time out !!!
+				//can repeat call clear flag !!!
+				VpuClearAllDispFrameFlag(pVpuObj->handle, pVpuObj->obj.frameNum);
+				VpuClearAllDispFrame(pVpuObj->obj.frameNum, pVpuObj->obj.frameBufState);
+			}
+#endif
+			
+		}
+		else
+		{
+			nExtCount=0;
+		}
+
+		//clear output frame
+		if(outInfo.indexFrameDisplay>=0)
+		{
+			VPU_TRACE;
+			VPU_API("%s: calling vpu_DecClrDispFlag(): %d \r\n",__FUNCTION__,outInfo.indexFrameDisplay);
+			ret=vpu_DecClrDispFlag(pVpuObj->handle,outInfo.indexFrameDisplay);
+			VPU_TRACE;
+			if(RETCODE_SUCCESS!=ret)
+			{
+				VPU_ERROR("%s: vpu clear display frame failure, index=0x%X, ret=%d \r\n",__FUNCTION__,outInfo.indexFrameDisplay,ret);
+				return VPU_DEC_RET_FAILURE;
+			}
+			//clear frame state
+			VpuClearDispFrame(outInfo.indexFrameDisplay, pObj->frameBufState);
+			//reset historical info
+			//if(pVpuObj->obj.frameBuf[outInfo.indexFrameDisplay]==pVpuObj->obj.pPreDisplayFrameBuf)
+			//{
+			//	pVpuObj->obj.pPreDisplayFrameBuf=NULL;
+			//}				
+		}
+
+		//check the EOS
+		if(VPU_OUT_DIS_INDEX_EOS==outInfo.indexFrameDisplay)
+		{
+			break;
+		}
+
+		//flush bitstream to :
+		//(1) improve performance
+		//(2) avoid get big nExtCount value (=> fake corrupt event)
+		if(startFrameOK==0)
+		{
+			//vpu_DecBitBufferFlush() have already been called before !
+		}
+		else
+		{
+			if(0==VpuBitFlush(pVpuObj, 1/*before eos*/))
+			{
+				return VPU_DEC_RET_FAILURE;
+			}		
+			startFrameOK=0; //clear it to avoid repeat calling vpu_DecBitBufferFlush() in current while(1) loop
+		}
+
+		// start decode frame
+		VPU_TRACE;
+		VPU_API("calling vpu_DecStartOneFrame() \r\n");
+		ret = vpu_DecStartOneFrame(pVpuObj->handle, &decParam);
+		VPU_TRACE;
+		if(ret == RETCODE_JPEG_EOS)
+		{
+			VPU_API("%s: MJPG: reach EOS \r\n",__FUNCTION__);
+			pObj->mjpg_frmidx=0;
+			goto FLUSH_FINISH;
+		}
+		else if(ret==RETCODE_JPEG_BIT_EMPTY)
+		{
+			//need to skip vpu_WaitForInt() and vpu_DecGetOutputInfo()
+			VPU_API("%s: MJPG: BIT EMPTY \r\n",__FUNCTION__);
+			pObj->mjpg_frmidx=0;
+			goto FLUSH_FINISH;
+		}
+		else if (ret != RETCODE_SUCCESS)
+		{
+			VPU_ERROR("%s: vpu start one frame failure: ret = 0x%X \r\n",__FUNCTION__,ret);
+			return VPU_DEC_RET_FAILURE;
+		}
+
+	}
+
+//#ifdef VPU_FAKE_FLUSH
+FLUSH_FINISH:
+//#endif
+
+	//FIX case: if user send 0 bytes after flush operation, decoder will always return EOS. it is not reasonable.
+	//so we set VPU_DEC_STATE_EOS state, but not VPU_DEC_STATE_DEC.
+	pObj->state=VPU_DEC_STATE_EOS;	
+
+#ifdef VPU_SUPPORT_UNCLOSED_GOP
+	pObj->refCnt=0;
+	pObj->dropBCnt=0;
+	pObj->keyCnt=0;
+#endif		
+//#ifdef VPU_IFRAME_SEARCH
+	pObj->keyDecCnt=0;
+//#endif
+#ifdef VPU_SEEK_ANYPOINT_WORKAROUND
+	pObj->seekKeyLoc=0;
+	pObj->recommendFlush=0;
+#endif
+#ifdef VPU_SUPPORT_NO_ENOUGH_FRAME
+	pObj->dataUsedInFileMode=0;
+	pObj->lastDatLenInFileMode=0;
+	pObj->lastConfigMode=0;
+#endif
+
+#ifdef VPU_FILEMODE_SUPPORT_INTERLACED_SKIPMODE
+	pObj->firstFrameMode=0;
+	pObj->fieldCnt=0;		/*now, we suppose parser always feed integrated frame !!!!*/
+#endif
+
+#ifdef VPU_FILEMODE_MERGE_INTERLACE_DEBUG
+	//pObj->needMergeFields=0;
+	pObj->lastFieldOffset=0;
+#endif
+
+#ifdef VPU_FILEMODE_INTERLACE_TIMESTAMP_ENHANCE
+	//pObj->fieldDecoding=;
+	pObj->oweFieldTS=0;
+#endif
+
+	pObj->nAccumulatedConsumedStufferBytes=0;
+	pObj->nAccumulatedConsumedFrmBytes=0;
+	pObj->nAccumulatedConsumedBytes=0;
+	pObj->pLastDecodedFrm=NULL;
+	pObj->nLastFrameEndPosPhy=(unsigned int)pObj->pBsBufPhyEnd-1+FRAME_END_OFFSET;
+
+	if(VPU_DUMP_RAW || VPU_DUMP_YUV){
+		g_seek_dump=1;
+	}
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecAllRegFrameInfo(VpuDecHandle InHandle, VpuFrameBuffer** ppOutFrameBuf, int* pOutNum)
+{
+	VpuDecHandleInternal * pVpuObj;
+	int i;
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	for(i=0;i<pVpuObj->obj.frameNum;i++)
+	{
+		*ppOutFrameBuf++=&pVpuObj->obj.frameBuf[i];
+	}
+	*pOutNum=pVpuObj->obj.frameNum;
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecGetNumAvailableFrameBuffers(VpuDecHandle InHandle,int* pOutBufNum)
+{
+	int i, cnt;
+	VpuDecHandleInternal * pVpuObj;
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+
+	cnt=0;
+	for (i=0;i<pVpuObj->obj.frameNum;i++){
+		if (pVpuObj->obj.frameBufState[i] == VPU_FRAME_STATE_FREE){
+			cnt++;
+		}
+	}
+	*pOutBufNum=cnt;
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecClose(VpuDecHandle InHandle)
+{
+	VpuDecHandleInternal * pVpuObj;
+	RetCode ret;
+	
+	if(InHandle==NULL) 
+	{
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+
+	//switch(pVpuObj->obj.state)
+	//{
+	//	case VPU_DEC_STATE_CORRUPT:
+	//		break;
+	//	default:
+	//		break;
+	//}
+#if 0 //for iMX6: reset is not recommended !!!!
+	if (CPU_IS_MX5X()) 
+	{
+		//add robust : if busy(fix some timeout issue) , reset it 
+		VPU_API("calling vpu_IsBusy() \r\n");
+		if(vpu_IsBusy())
+		{
+			VPU_API("calling vpu_SWReset(0x%X,0) \r\n",(unsigned int)pVpuObj->handle);
+			ret=vpu_SWReset(pVpuObj->handle,0);
+			if(RETCODE_SUCCESS!=ret)
+			{
+				VPU_ERROR("%s: vpu reset failure, ret=%d \r\n",__FUNCTION__,ret);
+				//return VPU_DEC_RET_FAILURE;
+			}	
+		}	
+	}
+#endif	
+
+	/*release seq bak buffer*/
+	if(pVpuObj->obj.pSeqBak)
+	{
+		vpu_free(pVpuObj->obj.pSeqBak);
+		pVpuObj->obj.pSeqBak=NULL;
+		pVpuObj->obj.nSeqBakLen=0;
+	}
+
+	//normal close
+	VPU_TRACE;
+	VPU_API("calling vpu_DecClose() \r\n");
+	ret=vpu_DecClose(pVpuObj->handle);
+	VPU_TRACE;
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ERROR("%s: vpu close failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+
+VpuDecRetCode VPU_DecUnLoad()
+{
+#if 0//#ifdef IMX6_MULTI_FORMATS_WORKAROUND	//below has been merged into vpu_SWReset()
+	printf("imx6: will reset \r\n");
+	ret=vpu_SWReset(pVpuObj->handle,0);
+/*
+	IOClkGateSet(1);
+	VpuWriteReg(0x24, 0x1F8);
+	usleep(1000);
+	// wait until reset is done
+	while(VpuReadReg(0x34) != 0){};
+	// clear sw reset (not automatically cleared)
+	VpuWriteReg(0x24, 0);
+	IOClkGateSet(0);
+*/	
+#endif
+
+#ifdef VPU_RESET_TEST
+	if (CPU_IS_MX6X()) 
+	{
+		//loading fw, avoid reset board after fw changing
+		IOClkGateSet(1);
+		VpuWriteReg(0x0, 0);
+		VpuWriteReg(0x14, 1);		
+		IOClkGateSet(0);
+	}
+	else
+	{
+		IOSysSWReset();	//for iMX5, iMX6 has not implemented it now
+	}
+#endif
+	VPU_TRACE;
+	VPU_API("calling vpu_UnInit() \r\n");
+	vpu_UnInit();
+	VPU_TRACE;
+
+	TIMER_MARK_REPORT(TIMER_MARK_GETOUTPUT_ID);
+	//TIMER_REPORT(TIMER_CLEARDISP_ID);
+	
+	return VPU_DEC_RET_SUCCESS;	
+}
+
+
+VpuDecRetCode VPU_DecReset(VpuDecHandle InHandle)
+{
+	VpuDecHandleInternal * pVpuObj;
+	RetCode ret;
+	VPU_LOG("in VPU_DecReset, InHandle: 0x%X  \r\n",InHandle);
+	
+	if(InHandle==NULL) 
+	{
+#if 0	//no use	
+#define MAX_NUM_INSTANCE	4	//in vpu_util.h
+		//VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);
+		//return VPU_DEC_RET_INVALID_HANDLE;
+		//reset all instances:
+		int index;
+		for(index=0;index<MAX_NUM_INSTANCE;index++)
+		{
+			VPU_API("calling vpu_SWReset(0,%d) \r\n",index);
+			ret=vpu_SWReset(0,index);
+			if(RETCODE_SUCCESS!=ret)
+			{
+				VPU_ERROR("%s: vpu reset failure, ret=%d \r\n",__FUNCTION__,ret);
+				return VPU_DEC_RET_FAILURE;
+			}	
+		}
+#endif		
+		return VPU_DEC_RET_SUCCESS;
+	}
+
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+
+	//TODO: current SWReset need to re-register all frame buffers again.
+	VPU_TRACE;
+	VPU_API("calling vpu_SWReset(0x%X,0) \r\n",(unsigned int)pVpuObj->handle);
+	ret=vpu_SWReset(pVpuObj->handle,0);
+	VPU_TRACE;
+
+#ifdef IMX6_MULTI_FORMATS_WORKAROUND	//1 for iMX6
+#if 0	//below has been merged into vpu_SWReset()
+	printf("imx6: will reset \r\n");
+	IOClkGateSet(1);
+	VpuWriteReg(0x24, 0x1F8);
+	usleep(1000);
+	// wait until reset is done
+	while(VpuReadReg(0x34) != 0){};
+	// clear sw reset (not automatically cleared)
+	VpuWriteReg(0x24, 0);
+	IOClkGateSet(0);
+#endif
+#if 0	//need ??
+	//loading fw, avoid reset board after fw changing
+	IOClkGateSet(1);
+	VpuWriteReg(0x0, 0);
+	VpuWriteReg(0x14, 1);	
+	IOClkGateSet(0);
+#endif	
+#endif
+
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ERROR("%s: vpu reset failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+
+	return VPU_DEC_RET_SUCCESS;
+	
+}
+
+VpuDecRetCode VPU_DecGetErrInfo(VpuDecHandle InHandle,VpuDecErrInfo* pErrInfo)
+{
+	/*it return the last error info*/
+	VpuDecHandleInternal * pVpuObj;	
+	if(InHandle==NULL){
+		VPU_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);
+		return VPU_DEC_RET_INVALID_HANDLE;
+	}
+	pVpuObj=(VpuDecHandleInternal *)InHandle;
+	*pErrInfo=pVpuObj->obj.nLastErrorInfo;
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecGetMem(VpuMemDesc* pInOutMem)
+{
+	int ret;
+	
+#ifdef __WINCE
+	VPUMemAlloc buff;
+	ret=vpu_AllocPhysMem(pInOutMem->nSize,&buff);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: get memory failure: size=%d, ret=%d \r\n",__FUNCTION__,pInOutMem->nSize,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+	pInOutMem->nPhyAddr=buff.PhysAdd;
+	pInOutMem->nVirtAddr=buff.VirtAdd;
+	pInOutMem->nCpuAddr=buff.Reserved;	
+#else
+	vpu_mem_desc buff;
+	buff.size=pInOutMem->nSize;
+	ret=IOGetPhyMem(&buff);
+	if(ret) //if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: get physical memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,ret);
+		return VPU_DEC_RET_FAILURE;
+	}
+	ret=IOGetVirtMem(&buff);
+	if(ret==0) //if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: get virtual memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,ret);
+		return VPU_DEC_RET_FAILURE;
+	}
+
+	pInOutMem->nPhyAddr=buff.phy_addr;
+	pInOutMem->nVirtAddr=buff.virt_uaddr;
+	pInOutMem->nCpuAddr=buff.cpu_addr;
+#endif
+
+	return VPU_DEC_RET_SUCCESS;
+}
+
+VpuDecRetCode VPU_DecFreeMem(VpuMemDesc* pInMem)
+{
+	int ret;
+
+#ifdef __WINCE
+	VPUMemAlloc buff;
+	buff.PhysAdd=pInMem->nPhyAddr;
+	buff.VirtAdd=pInMem->nVirtAddr;
+	buff.Reserved=pInMem->nCpuAddr;	
+	ret=vpu_FreePhysMem(&buff);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: free memory failure: size=%d, ret=%d \r\n",__FUNCTION__,pInMem->nSize,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+#else
+	vpu_mem_desc buff;
+	buff.size=pInMem->nSize;
+	buff.phy_addr=pInMem->nPhyAddr;
+	buff.virt_uaddr=pInMem->nVirtAddr;
+	buff.cpu_addr=pInMem->nCpuAddr;
+	ret=IOFreeVirtMem(&buff);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: free virtual memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+	ret=IOFreePhyMem(&buff);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ERROR("%s: free phy memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,ret);
+		return VPU_DEC_RET_FAILURE;
+	}	
+#endif
+
+	return VPU_DEC_RET_SUCCESS;	
+}
+
+/****************************** encoder part **************************************/
+typedef struct
+{
+	int nHeaderNeeded;	// indicate whether need to fill header(vos/pps/sps/...) info
+#ifdef VPU_ENC_SEQ_DATA_SEPERATE
+	int nJustOutputOneHeader;	//record the state
+	int nOutputHeaderCnt;		//for H.264: In fact, muxer may only receive the first header, So we had better 
+								//(1) for first header: output header and frame seperately
+								//(2) for non-first header: merge header and frame data
+#endif
+	int nDynamicEnabled;			//0: output is bitstream buf, 1(not supported on iMX6): output is pointed by user
+	unsigned char* pPhyBitstream;
+	unsigned char* pVirtBitstream;
+	int nBitstreamSize;
+	unsigned char* pPhyScratch;		//for mpeg4	
+	unsigned char* pVirtScratch;		//for mpeg4
+	int nScratchSize;
+	unsigned char* pPhyMjpgTable;		//for mjpg(IMX5)
+	unsigned char* pVirtMjpgTable;		//for mjpg(iMX5)	
+	int nFrameCnt;
+	int nMapType;
+	int nLinear2TiledEnable;
+	//int nChromaInterleave;
+	VpuColorFormat eColor;		// only for MJPEG non-420 color format
+	int nInsertSPSPPSToIDR;		// SPS/PPS is requred for every IDR, including the first IDR.
+	int nIsAvcc;					// only for H.264 format
+}VpuEncObj;
+
+typedef struct 
+{
+	EncHandle handle;
+	VpuEncObj obj;	
+}VpuEncHandleInternal;
+
+
+#ifdef VPU_ENC_OUTFRAME_ALIGN
+#define	VPU_ALIGN_BYTES_NUM	8	//for H.264, seems 4 bytes is not enough when writing SPS/PPS header ??? 
+#endif
+
+#define Align(ptr,align)	(((unsigned int)ptr+(align)-1)/(align)*(align))
+//#define MemAlign(mem,align)	((((unsigned int)mem)%(align))==0)
+//#define MemNotAlign(mem,align)	((((unsigned int)mem)%(align))!=0)
+
+#define VPU_ENC_MAX_FRAME_INDEX	30
+//#define ENC_MAX_FRAME_NUM		(VPU_ENC_MAX_NUM_MEM)
+//#define ENC_FRAME_SURPLUS	(1)
+
+//#define DEFAULT_ENC_FRM_WIDTH		(640)
+//#define DEFAULT_ENC_FRM_HEIGHT		(480)
+//#define DEFAULT_ENC_FRM_RATE			(30 * Q16_SHIFT)
+
+//#define DEFAULT_ENC_BUF_IN_CNT		0x3
+//#define DEFAULT_ENC_BUF_IN_SIZE		(DEFAULT_ENC_FRM_WIDTH*DEFAULT_ENC_FRM_HEIGHT*3/2)
+//#define DEFAULT_ENC_BUF_OUT_CNT		0x3
+
+#define ENC_VIRT_INDEX	0
+#define ENC_PHY_INDEX	1
+
+#define VPU_ENC_MEM_ALIGN			0x8
+#define VPU_ENC_BITS_BUF_SIZE		(1024*1024)		//bitstream buffer size 
+#define VPU_ENC_MPEG4_SCRATCH_SIZE	0x080000	//for mpeg4 data partition
+
+#define VPU_ENC_WAIT_TIME_OUT			(500)	//used for prescan mode
+#define VPU_ENC_MAX_BUSY_CNT			(4)		//used for prescan mode: max counts 
+
+/*******  jpeg part ******/
+unsigned char lumaDcBits[16] = {
+0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,
+0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+unsigned char lumaDcValue[16] = {
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00,
+};
+unsigned char lumaAcBits[16] = {
+0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,
+0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
+};
+unsigned char lumaAcValue[168] = {
+0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
+0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
+0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
+0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0,
+0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16,
+0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
+0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
+0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
+0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
+0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
+0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
+0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
+0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
+0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
+0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
+0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
+0xF9, 0xFA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+unsigned char chromaDcBits[16] = {
+0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+unsigned char chromaDcValue[16] = {
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+0x08, 0x09, 0x0A, 0x0B, 0x00, 0x00, 0x00, 0x00,
+};
+unsigned char chromaAcBits[16] = {
+0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04,
+0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77,
+};
+unsigned char chromaAcValue[168] = {
+0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
+0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
+0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
+0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0,
+0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34,
+0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26,
+0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38,
+0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
+0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96,
+0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5,
+0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4,
+0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3,
+0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2,
+0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA,
+0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9,
+0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
+0xF9, 0xFA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+unsigned char lumaQ[64] = {
+0x0C, 0x08, 0x08, 0x08, 0x09, 0x08, 0x0C, 0x09,
+0x09, 0x0C, 0x11, 0x0B, 0x0A, 0x0B, 0x11, 0x15,
+0x0F, 0x0C, 0x0C, 0x0F, 0x15, 0x18, 0x13, 0x13,
+0x15, 0x13, 0x13, 0x18, 0x11, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+};
+unsigned char chromaBQ[64] = {
+0x0D, 0x0B, 0x0B, 0x0D, 0x0E, 0x0D, 0x10, 0x0E,
+0x0E, 0x10, 0x14, 0x0E, 0x0E, 0x0E, 0x14, 0x14,
+0x0E, 0x0E, 0x0E, 0x0E, 0x14, 0x11, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x11, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+};
+unsigned char chromaRQ[64] = {
+0x0D, 0x0B, 0x0B, 0x0D, 0x0E, 0x0D, 0x10, 0x0E,
+0x0E, 0x10, 0x14, 0x0E, 0x0E, 0x0E, 0x14, 0x14,
+0x0E, 0x0E, 0x0E, 0x0E, 0x14, 0x11, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x11, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+};
+unsigned char lumaQ2[64] = {
+0x06, 0x04, 0x04, 0x04, 0x05, 0x04, 0x06, 0x05,
+0x05, 0x06, 0x09, 0x06, 0x05, 0x06, 0x09, 0x0B,
+0x08, 0x06, 0x06, 0x08, 0x0B, 0x0C, 0x0A, 0x0A,
+0x0B, 0x0A, 0x0A, 0x0C, 0x10, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x10, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+};
+unsigned char chromaBQ2[64] = {
+0x07, 0x07, 0x07, 0x0D, 0x0C, 0x0D, 0x18, 0x10,
+0x10, 0x18, 0x14, 0x0E, 0x0E, 0x0E, 0x14, 0x14,
+0x0E, 0x0E, 0x0E, 0x0E, 0x14, 0x11, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x11, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+};
+unsigned char chromaRQ2[64] = {
+0x07, 0x07, 0x07, 0x0D, 0x0C, 0x0D, 0x18, 0x10,
+0x10, 0x18, 0x14, 0x0E, 0x0E, 0x0E, 0x14, 0x14,
+0x0E, 0x0E, 0x0E, 0x0E, 0x14, 0x11, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x11, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x11, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
+};
+static unsigned char cInfoTable[5][24] = {
+    { 00, 02, 02, 00, 00, 00, 01, 01, 01, 01, 01, 01, 02, 01, 01, 01, 01, 01, 03, 00, 00, 00, 00, 00 }, //420
+    { 00, 02, 01, 00, 00, 00, 01, 01, 01, 01, 01, 01, 02, 01, 01, 01, 01, 01, 03, 00, 00, 00, 00, 00 }, //422H
+    { 00, 01, 02, 00, 00, 00, 01, 01, 01, 01, 01, 01, 02, 01, 01, 01, 01, 01, 03, 00, 00, 00, 00, 00 }, //422V
+    { 00, 01, 01, 00, 00, 00, 01, 01, 01, 01, 01, 01, 02, 01, 01, 01, 01, 01, 03, 00, 00, 00, 00, 00 }, //444
+    { 00, 01, 01, 00, 00, 00, 01, 00, 00, 00, 00, 00, 02, 00, 00, 00, 00, 00, 03, 00, 00, 00, 00, 00 }, //400
+};
+int VpuMJPGQueryTableSize()
+{
+	int size=0;
+	if (CPU_IS_MX6X())
+	{
+		//It will be stored in structure of open parameter
+		/*
+		Uint8 huffVal[4][162];
+		Uint8 huffBits[4][256];
+		Uint8 qMatTab[4][64];
+		Uint8 cInfoTab[4][6];
+		*/
+	}
+	else
+	{
+		size+=sizeof(lumaDcBits);
+		size+=sizeof(lumaDcValue);
+		size+=sizeof(lumaAcBits);
+		size+=sizeof(lumaAcValue);
+		size+=sizeof(chromaDcBits);
+		size+=sizeof(chromaDcValue);
+		size+=sizeof(chromaAcBits);
+		size+=sizeof(chromaAcValue);
+		VPU_ENC_LOG("MJPG: iM5X default table size: %d \r\n",size);
+	}
+	return size;
+}
+
+int VpuMJPGSetMX5Tables(unsigned char* pInBase,unsigned char** ppOutHuff, unsigned char** ppOutMat)
+{
+	unsigned char* huffTable;
+	unsigned char* qMatTable;
+	int i;
+	qMatTable=pInBase;
+	huffTable=pInBase+192;
+	/* Don't consider user defined hufftable this time */
+	/* Rearrange and insert pre-defined Huffman table to deticated variable. */		
+	for(i = 0; i < 16; i += 4)
+	{
+		huffTable[i] = lumaDcBits[i + 3];
+		huffTable[i + 1] = lumaDcBits[i + 2];
+		huffTable[i + 2] = lumaDcBits[i + 1];
+		huffTable[i + 3] = lumaDcBits[i];
+	}
+	for(i = 16; i < 32 ; i += 4)
+	{
+		huffTable[i] = lumaDcValue[i + 3 - 16];
+		huffTable[i + 1] = lumaDcValue[i + 2 - 16];
+		huffTable[i + 2] = lumaDcValue[i + 1 - 16];
+		huffTable[i + 3] = lumaDcValue[i - 16];
+	}
+	for(i = 32; i < 48; i += 4)
+	{
+		huffTable[i] = lumaAcBits[i + 3 - 32];
+		huffTable[i + 1] = lumaAcBits[i + 2 - 32];
+		huffTable[i + 2] = lumaAcBits[i + 1 - 32];
+		huffTable[i + 3] = lumaAcBits[i - 32];
+	}
+	for(i = 48; i < 216; i += 4)
+	{
+		huffTable[i] = lumaAcValue[i + 3 - 48];
+		huffTable[i + 1] = lumaAcValue[i + 2 - 48];
+		huffTable[i + 2] = lumaAcValue[i + 1 - 48];
+		huffTable[i + 3] = lumaAcValue[i - 48];
+	}
+	for(i = 216; i < 232; i += 4)
+	{
+		huffTable[i] = chromaDcBits[i + 3 - 216];
+		huffTable[i + 1] = chromaDcBits[i + 2 - 216];
+		huffTable[i + 2] = chromaDcBits[i + 1 - 216];
+		huffTable[i + 3] = chromaDcBits[i - 216];
+	}
+	for(i = 232; i < 248; i += 4)
+	{
+		huffTable[i] = chromaDcValue[i + 3 - 232];
+		huffTable[i + 1] = chromaDcValue[i + 2 - 232];
+		huffTable[i + 2] = chromaDcValue[i + 1 - 232];
+		huffTable[i + 3] = chromaDcValue[i - 232];
+	}
+	for(i = 248; i < 264; i += 4)
+	{
+		huffTable[i] = chromaAcBits[i + 3 - 248];
+		huffTable[i + 1] = chromaAcBits[i + 2 - 248];
+		huffTable[i + 2] = chromaAcBits[i + 1 - 248];
+		huffTable[i + 3] = chromaAcBits[i - 248];
+	}
+	for(i = 264; i < 432; i += 4)
+	{
+		huffTable[i] = chromaAcValue[i + 3 - 264];
+		huffTable[i + 1] = chromaAcValue[i + 2 - 264];
+		huffTable[i + 2] = chromaAcValue[i + 1 - 264];
+		huffTable[i + 3] = chromaAcValue[i - 264];
+	}
+
+	/* Rearrange and insert pre-defined Q-matrix to deticated variable. */
+	for(i = 0; i < 64; i += 4)
+	{
+		qMatTable[i] = lumaQ2[i + 3];
+		qMatTable[i + 1] = lumaQ2[i + 2];
+		qMatTable[i + 2] = lumaQ2[i + 1];
+		qMatTable[i + 3] = lumaQ2[i];
+	}
+	for(i = 64; i < 128; i += 4)
+	{
+		qMatTable[i] = chromaBQ2[i + 3 - 64];
+		qMatTable[i + 1] = chromaBQ2[i + 2 - 64];
+		qMatTable[i + 2] = chromaBQ2[i + 1 - 64];
+		qMatTable[i + 3] = chromaBQ2[i - 64];
+	}
+	for(i = 128; i < 192; i += 4)
+	{
+		qMatTable[i] = chromaRQ2[i + 3 - 128];
+		qMatTable[i + 1] = chromaRQ2[i + 2 - 128];
+		qMatTable[i + 2] = chromaRQ2[i + 1 - 128];
+		qMatTable[i + 3] = chromaRQ2[i - 128];
+	}
+
+	*ppOutHuff=huffTable;
+	*ppOutMat=qMatTable;
+	return 1;
+}
+
+int VpuMJPGSetMX6Tables(EncMjpgParam* pInVpuMJPGParam)
+{
+	int format;
+	/* Rearrange and insert pre-defined Huffman table to deticated variable. */
+	vpu_memcpy(pInVpuMJPGParam->huffBits[DC_TABLE_INDEX0], lumaDcBits, 16);   /* Luma DC BitLength */
+	vpu_memcpy(pInVpuMJPGParam->huffVal[DC_TABLE_INDEX0], lumaDcValue, 16);   /* Luma DC HuffValue */
+
+	vpu_memcpy(pInVpuMJPGParam->huffBits[AC_TABLE_INDEX0], lumaAcBits, 16);   /* Luma DC BitLength */
+	vpu_memcpy(pInVpuMJPGParam->huffVal[AC_TABLE_INDEX0], lumaAcValue, 162);  /* Luma DC HuffValue */
+
+	vpu_memcpy(pInVpuMJPGParam->huffBits[DC_TABLE_INDEX1], chromaDcBits, 16); /* Chroma DC BitLength */
+	vpu_memcpy(pInVpuMJPGParam->huffVal[DC_TABLE_INDEX1], chromaDcValue, 16); /* Chroma DC HuffValue */
+
+	vpu_memcpy(pInVpuMJPGParam->huffBits[AC_TABLE_INDEX1], chromaAcBits, 16); /* Chroma AC BitLength */
+	vpu_memcpy(pInVpuMJPGParam->huffVal[AC_TABLE_INDEX1], chromaAcValue, 162); /* Chorma AC HuffValue */
+
+	/* Rearrange and insert pre-defined Q-matrix to deticated variable. */
+	vpu_memcpy(pInVpuMJPGParam->qMatTab[DC_TABLE_INDEX0], lumaQ2, 64);
+	vpu_memcpy(pInVpuMJPGParam->qMatTab[AC_TABLE_INDEX0], chromaBQ2, 64);
+
+	vpu_memcpy(pInVpuMJPGParam->qMatTab[DC_TABLE_INDEX1], pInVpuMJPGParam->qMatTab[DC_TABLE_INDEX0], 64);
+	vpu_memcpy(pInVpuMJPGParam->qMatTab[AC_TABLE_INDEX1], pInVpuMJPGParam->qMatTab[AC_TABLE_INDEX0], 64);
+
+	format = pInVpuMJPGParam->mjpg_sourceFormat;
+
+	vpu_memcpy(pInVpuMJPGParam->cInfoTab, cInfoTable[format], 6 * 4);
+	return 1;
+}
+
+/*******  jpeg part end******/
+
+#ifdef VPU_ENC_OUTFRAME_ALIGN
+int VpuEncFillZeroBytesForAlign(unsigned int nInPhyAddr, unsigned int nInVirtAddr)
+{
+	unsigned int nBaseAddr;
+	unsigned int nAlignedAddr;
+	int nFillZeroSize;
+	nBaseAddr=nInPhyAddr;
+	nAlignedAddr=(unsigned int)Align(nBaseAddr, VPU_ALIGN_BYTES_NUM);
+	nFillZeroSize=nAlignedAddr-nBaseAddr;
+	vpu_memset((void*)nInVirtAddr,0,nFillZeroSize);	
+	ASSERT(nFillZeroSize>=0);
+	return nFillZeroSize;
+}
+#endif
+
+int VpuEncFillHeader(EncHandle InHandle,VpuEncEncParam* pInParam, unsigned char* pInHeaderBufPhy,
+	int* pOutHeaderLen,int* pOutPadLen,unsigned char* pInHeaderBufVirt,int mode,
+	unsigned char* pInBitstreamPhy,unsigned char* pInBitstreamVirt)
+{
+#define BitVirtAddr(phy)	((int)pInBitstreamVirt+(int)phy-(int)pInBitstreamPhy)
+	EncHeaderParam sEncHdrParam;
+	int nMbPicNum;
+	unsigned char* pPhyPtr=pInHeaderBufPhy;
+	unsigned char* pVirtPtr=pInHeaderBufVirt;
+	int nHeaderLen=0;
+	int nFilledZeroBytes=0;
+
+	vpu_memset(&sEncHdrParam, 0, sizeof(EncHeaderParam));
+	//Now, sEncHdrParam.buf is only valid when mode==0 or 1(eg. dynamic)
+	sEncHdrParam.buf=(PhysicalAddress)pPhyPtr;
+	
+	/* Must put encode header before encoding */
+	//for MPEG4: at least VOL is required
+	//for H264: SPS/PPS are required
+	if(pInParam->eFormat==VPU_V_MPEG4)
+	{
+		int nFrameRate=pInParam->nFrameRate;
+		int nEncPicWidth=pInParam->nPicWidth;
+		int nEncPicHeight=pInParam->nPicHeight;
+		
+		sEncHdrParam.headerType = VOS_HEADER;
+		/*
+		* Please set userProfileLevelEnable to 0 if you need to generate
+		* user profile and level automaticaly by resolution, here is one
+		* sample of how to work when userProfileLevelEnable is 1.
+		*/
+		sEncHdrParam.userProfileLevelEnable = 1;
+		nMbPicNum = ((nEncPicWidth + 15) / 16) *((nEncPicHeight+ 15) / 16);
+		/* Please set userProfileLevelIndication to 8 if L0 is needed */
+		if (nEncPicWidth<= 176 && nEncPicHeight <= 144 &&	nMbPicNum * nFrameRate <= 1485)
+		{
+			sEncHdrParam.userProfileLevelIndication = 8; /* L1 */
+		}
+		else if (nEncPicWidth <= 352 && nEncPicHeight<= 288 &&	nMbPicNum * nFrameRate <= 5940)
+		{
+			sEncHdrParam.userProfileLevelIndication = 2; /* L2 */
+		}
+		else if (nEncPicWidth <= 352 && nEncPicHeight <= 288 &&nMbPicNum * nFrameRate <= 11880)
+		{
+			sEncHdrParam.userProfileLevelIndication = 3; /* L3 */
+		}
+		else if (nEncPicWidth <= 640 && nEncPicHeight<= 480 &&	nMbPicNum * nFrameRate <= 36000)
+		{
+			sEncHdrParam.userProfileLevelIndication = 4; /* L4a */
+		}
+		else if (nEncPicWidth <= 720 && nEncPicHeight <= 576 &&nMbPicNum * nFrameRate <= 40500)
+		{
+			sEncHdrParam.userProfileLevelIndication = 5; /* L5 */
+		}
+		else
+		{
+			sEncHdrParam.userProfileLevelIndication = 6; /* L6 */
+		}
+
+		VPU_ENC_API("calling vpu_EncGiveCommand(VOS_HEADER) \r\n");
+		vpu_EncGiveCommand(InHandle, ENC_PUT_MP4_HEADER, &sEncHdrParam);
+		VPU_ENC_LOG("VOS length: %d \r\n",sEncHdrParam.size);		
+		if(mode==1)
+		{
+			nHeaderLen+=sEncHdrParam.size;	//record VOS length
+			nFilledZeroBytes=VpuEncFillZeroBytesForAlign((unsigned int)(pPhyPtr+nHeaderLen),(unsigned int)(pVirtPtr+nHeaderLen));
+			nHeaderLen+=nFilledZeroBytes;
+		}
+		else if(mode==2)
+		{
+			VPU_ENC_LOG("header memcpy: dst: 0x%X, src: 0x%X, size: %d \r\n",(pVirtPtr+nHeaderLen),BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			vpu_memcpy((void*)(pVirtPtr+nHeaderLen),(void*)BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			nHeaderLen+=sEncHdrParam.size;	//record VOS length
+		}
+		sEncHdrParam.headerType = VIS_HEADER;
+		sEncHdrParam.buf=(PhysicalAddress)(pPhyPtr+nHeaderLen);	//skip VOS
+		VPU_ENC_API("calling vpu_EncGiveCommand(VIS_HEADER) \r\n");		
+		vpu_EncGiveCommand(InHandle, ENC_PUT_MP4_HEADER, &sEncHdrParam);
+		VPU_ENC_LOG("VIS length: %d \r\n",sEncHdrParam.size);		
+		if(mode==1)
+		{
+			nHeaderLen+=sEncHdrParam.size;	//record VIS length
+			nFilledZeroBytes=VpuEncFillZeroBytesForAlign((unsigned int)(pPhyPtr+nHeaderLen),(unsigned int)(pVirtPtr+nHeaderLen));
+			nHeaderLen+=nFilledZeroBytes;
+		}
+		else if(mode==2)
+		{
+			VPU_ENC_LOG("header memcpy: dst: 0x%X, src: 0x%X, size: %d \r\n",(pVirtPtr+nHeaderLen),BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			vpu_memcpy((void*)(pVirtPtr+nHeaderLen),(void*)BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			nHeaderLen+=sEncHdrParam.size;	//record VIS length
+		}
+		sEncHdrParam.headerType = VOL_HEADER;
+		sEncHdrParam.buf=(PhysicalAddress)(pPhyPtr+nHeaderLen);	//skip VOS and VIS
+		VPU_ENC_API("calling vpu_EncGiveCommand(VOL_HEADER) \r\n");		
+		vpu_EncGiveCommand(InHandle, ENC_PUT_MP4_HEADER, &sEncHdrParam);
+		VPU_ENC_LOG("VOL length: %d \r\n",sEncHdrParam.size);		
+		if(mode==1)
+		{
+			nHeaderLen+=sEncHdrParam.size;	//record VOL length
+			nFilledZeroBytes=VpuEncFillZeroBytesForAlign((unsigned int)(pPhyPtr+nHeaderLen),(unsigned int)(pVirtPtr+nHeaderLen));
+			nHeaderLen+=nFilledZeroBytes;
+		}
+		else if(mode==2)
+		{
+			VPU_ENC_LOG("header memcpy: dst: 0x%X, src: 0x%X, size: %d \r\n",(pVirtPtr+nHeaderLen),BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);	
+			vpu_memcpy((void*)(pVirtPtr+nHeaderLen),(void*)BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			nHeaderLen+=sEncHdrParam.size;	//record VOL length		
+		}
+	}
+	else if (pInParam->eFormat == VPU_V_AVC) 
+	{
+		sEncHdrParam.headerType = SPS_RBSP;
+		VPU_ENC_API("calling vpu_EncGiveCommand(SPS_RBSP) \r\n");
+		vpu_EncGiveCommand(InHandle, ENC_PUT_AVC_HEADER, &sEncHdrParam);
+		VPU_ENC_LOG("SPS_RBSP length: %d \r\n",sEncHdrParam.size);
+		if(mode==1)
+		{
+			nHeaderLen+=sEncHdrParam.size;	//record SPS length
+			nFilledZeroBytes=VpuEncFillZeroBytesForAlign((unsigned int)(pPhyPtr+nHeaderLen),(unsigned int)(pVirtPtr+nHeaderLen));
+			nHeaderLen+=nFilledZeroBytes;
+		}
+		else if(mode==2)
+		{
+			VPU_ENC_LOG("header memcpy: dst: 0x%X, src: 0x%X, size: %d \r\n",(pVirtPtr+nHeaderLen),BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);	
+			vpu_memcpy((void*)(pVirtPtr+nHeaderLen),(void*)BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			nHeaderLen+=sEncHdrParam.size;	//record SPS length		
+		}
+		sEncHdrParam.headerType = PPS_RBSP;
+		sEncHdrParam.buf=(PhysicalAddress)(pPhyPtr+nHeaderLen);	//skip SPS 
+		VPU_ENC_API("calling vpu_EncGiveCommand(PPS_RBSP) \r\n");
+		vpu_EncGiveCommand(InHandle, ENC_PUT_AVC_HEADER, &sEncHdrParam);
+		VPU_ENC_LOG("PPS_RBSP length: %d \r\n",sEncHdrParam.size);
+		if(mode==1)
+		{
+			nHeaderLen+=sEncHdrParam.size;	//record PPS length
+			nFilledZeroBytes=VpuEncFillZeroBytesForAlign((unsigned int)(pPhyPtr+nHeaderLen),(unsigned int)(pVirtPtr+nHeaderLen));
+			nHeaderLen+=nFilledZeroBytes;
+		}
+		else if(mode==2)
+		{
+			VPU_ENC_LOG("header memcpy: dst: 0x%X, src: 0x%X, size: %d \r\n",(pVirtPtr+nHeaderLen),BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);			
+			vpu_memcpy((void*)(pVirtPtr+nHeaderLen),(void*)BitVirtAddr(sEncHdrParam.buf),sEncHdrParam.size);
+			nHeaderLen+=sEncHdrParam.size;	//record PPS length		
+		}
+	}
+	else if (pInParam->eFormat == VPU_V_MJPG) 
+	{
+		//don't care mode 
+		if(CPU_IS_MX6X())
+		{
+			EncParamSet sEncJpgHdrParam;
+			vpu_memset(&sEncJpgHdrParam, 0, sizeof(EncParamSet));
+			sEncJpgHdrParam.size = pInParam->nInOutputBufLen;	//init one big enough size
+			sEncJpgHdrParam.pParaSet = pVirtPtr;//pPhyPtr;
+			vpu_EncGiveCommand(InHandle,ENC_GET_JPEG_HEADER, &sEncJpgHdrParam);
+			nHeaderLen+=sEncJpgHdrParam.size;	//record jpeg header
+		}
+		else
+		{
+			//for IMX5: do nothing
+		}
+	}	
+	else
+	{
+		//
+	}
+
+	*pOutHeaderLen=nHeaderLen;	
+	*pOutPadLen=nFilledZeroBytes;
+	return 1;
+}
+
+int VpuEncSetSrcFrame(VpuColorFormat eColor,FrameBuffer* pFrame, unsigned char* pSrc, int nSize, int nPadW,int nPadH, unsigned char format)
+{
+	int yStride;
+	int uvStride;	
+	int ySize;
+	int uvSize;
+	//int mvSize;	
+
+	yStride=nPadW;
+	ySize=yStride*nPadH;
+
+	switch(eColor)
+	{
+		case VPU_COLOR_420:
+			uvStride=yStride/2;
+			uvSize=ySize/4;
+			break;
+		case VPU_COLOR_422H:
+			uvStride=yStride/2;
+			uvSize=ySize/2;
+			break;
+		case VPU_COLOR_422V:
+			uvStride=yStride;
+			uvSize=ySize/2;
+			break;
+		case VPU_COLOR_444:
+			uvStride=yStride;
+			uvSize=ySize;
+			break;
+		case VPU_COLOR_400:
+			uvStride=0;
+			uvSize=0;
+			break;			
+		default: 
+			uvStride=yStride/2;
+			uvSize=ySize/4;
+			break;
+	}
+	//mvSize=uvSize;	//1 set 0 ?
+	
+	pFrame->bufY=(PhysicalAddress)pSrc;
+	pFrame->bufCb=(PhysicalAddress)(pSrc+ySize);
+	pFrame->bufCr=(PhysicalAddress)(pSrc+ySize+uvSize);
+	pFrame->bufMvCol=(PhysicalAddress)(pSrc+ySize+uvSize*2);	//1 ??
+	pFrame->strideY=yStride;
+	pFrame->strideC=uvStride;
+
+	return 1;	
+}
+
+int VpuEncWaitBusy()
+{
+	int busy_cnt=0;
+
+	VPU_ENC_API("while: calling vpu_WaitForInt(%d) \r\n",VPU_ENC_WAIT_TIME_OUT);
+	while(0!=vpu_WaitForInt(VPU_ENC_WAIT_TIME_OUT))
+	{
+		busy_cnt++;
+		if(busy_cnt> VPU_ENC_MAX_BUSY_CNT)
+		{
+			VPU_ENC_ERROR("while: wait busy : time out : count: %d \r\n",(UINT32)busy_cnt);
+			return -1;             //time out for some corrupt clips
+		}
+	}
+	return 1;
+}
+
+int VpuEncGetRotStride(int nInRot,int nInOriWidth,int nInOriHeight,int* pOutWidth,int* pOutHeight)
+{
+	if ((nInRot== 90) || (nInRot == 270)) 
+	{
+		*pOutWidth =nInOriHeight;
+		*pOutHeight = nInOriWidth;
+	} 
+	else
+	{
+		*pOutWidth =nInOriWidth;
+		*pOutHeight = nInOriHeight;
+	}
+	return 1;
+}
+
+int VpuEncGetIntraQP(VpuEncOpenParamSimp * pInParam)
+{
+#if 0 
+	//FIXME: we need set one appropriate value for it based on other parameters (such as bitrate,resolution,framerate,...)
+	//based on bits/pixel  ???
+	if(VPU_V_AVC==pInParam->eFormat)
+	{
+		return 20;	//0-51
+	}
+	else
+	{
+		return 15;	//1-31
+	}
+#else
+	return -1;
+#endif
+}
+
+int VpuFindAVCStartCode(unsigned char* pData, int nSize,unsigned char** ppStart)
+{
+#define AVC_START_CODE 0x00000001
+	unsigned int startcode=0xFFFFFFFF;
+	unsigned char* p=pData;
+	unsigned char* pEnd=pData+nSize;
+	while(p<pEnd){
+		startcode=(startcode<<8)|p[0];
+		if(AVC_START_CODE==startcode){			
+			break;
+		}
+		p++;
+	}
+	if(p>=pEnd){
+		VPU_LOG("not find valid start code \r\n");
+		*ppStart=NULL;
+		return 0;
+	}
+	*ppStart=p-3;
+	return 1;
+}
+
+int VpuConvertToAvccHeader(unsigned char* pData, int nSize, int*pFilledSize)
+{
+	unsigned char* pPre=pData;
+	int spsSize=0, ppsSize=0;
+	unsigned char *sps=NULL, *pps=NULL;
+	unsigned char* pNext=NULL;
+	unsigned char naltype;
+	int length=nSize;
+	char* pTemp=NULL,*pFilled=NULL;
+	int filledSize=0;
+	/*search boundary of sps and pps */
+	if(0==VpuFindAVCStartCode(pData,length,&pPre)){
+		goto search_finish;
+	}
+	pPre+=4; //skip 4 bytes of startcode
+	length-=(pPre-pData);
+	if(length<=0){
+		goto search_finish;
+	}
+	while(1){
+		int size;
+		VpuFindAVCStartCode(pPre,length,&pNext);
+		if(pNext){
+			size=pNext-pPre;
+		}
+		else{
+			size=length; //last nal
+		}
+		naltype=pPre[0] & 0x1f;
+		VPU_LOG("find one nal, type: 0x%X, size: %d \r\n",naltype,size);
+		if (naltype==7) { /* SPS */
+			sps=pPre;
+			spsSize=size;
+		}
+		else if (naltype==8) { /* PPS */
+			pps= pPre;
+			ppsSize=size;
+		}
+		if(pNext==NULL){
+			goto search_finish;
+		}
+		pNext+=4;
+		length-=(pNext-pPre);			
+		if(length<=0){
+			goto search_finish;
+		}
+		pPre=pNext;
+	}
+search_finish:
+	if((sps==NULL)||(pps==NULL)){
+		VPU_ERROR("failed to create avcc header: no sps/pps in codec data !\r\n");	
+		return 0;
+	}
+
+	/*fill valid avcc header*/
+	pTemp=vpu_malloc(nSize+20); // need to allocate more bytes(more than 6+2+1+2 bytes) for additonal tag info
+	if(pTemp==NULL){
+		VPU_ERROR("malloc %d bytes failure \r\n",nSize);
+		return 0;
+	}
+	pFilled=pTemp;
+	pFilled[0]=1;		/* version */
+	pFilled[1]=sps[1];	/* profile */
+	pFilled[2]=sps[2];	/* profile compat */
+	pFilled[3]=sps[3];	/* level */
+	pFilled[4]=0xFF;	/* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+	pFilled[5]=0xE1;	/* 3 bits reserved (111) + 5 bits number of sps (00001) */
+	pFilled+=6;
+
+	pFilled[0]=(spsSize>>8)&0xFF; /*sps size*/
+	pFilled[1]=spsSize&0xFF;
+	pFilled+=2;
+	vpu_memcpy(pFilled,sps,spsSize); /*sps data*/
+	pFilled+=spsSize;
+
+	pFilled[0]=1;		/* number of pps */
+	pFilled++;
+	pFilled[0]=(ppsSize>>8)&0xFF;	/*pps size*/
+	pFilled[1]=ppsSize&0xFF;
+	pFilled+=2;
+	vpu_memcpy(pFilled,pps,ppsSize); /*pps data*/	
+
+	filledSize=6+2+spsSize+1+2+ppsSize;
+	vpu_memcpy(pData,pTemp,filledSize);
+	
+	if(pTemp){
+		vpu_free(pTemp);
+	}
+	VPU_LOG("created on avcc header: %d bytes, sps size: %d, pps size: %d \r\n",filledSize,spsSize, ppsSize);
+	*pFilledSize=filledSize;
+	return 1;
+}
+
+int VpuConvertToAvccData(unsigned char* pData, int nSize)
+{
+	/*we will replace the 'start code'(00000001) with 'nal size'(4bytes), and the buffer length no changed*/
+	unsigned char* pPre=pData;
+	int length=nSize;
+	int nalSize=0;
+	int outSize=0;
+	int i=0;
+	unsigned char* pNext=NULL;
+	VPU_LOG("convert to avcc data: %d bytes \r\n",nSize);
+	if(0==VpuFindAVCStartCode(pData,length,&pPre)){
+		goto finish;
+	}
+	pPre+=4; //skip 4 bytes of startcode
+	length-=(pPre-pData);
+	while(1){
+		VpuFindAVCStartCode(pPre,length,&pNext);
+		if(pNext){
+			nalSize=pNext-pPre;
+		}
+		else{
+			nalSize=length; //last nal
+		}
+		pPre[-4]=(nalSize>>24)&0xFF;
+		pPre[-3]=(nalSize>>16)&0xFF;
+		pPre[-2]=(nalSize>>8)&0xFF;
+		pPre[-1]=(nalSize)&0xFF;
+		VPU_LOG("[%d]: fill one nal size: %d \r\n",i,nalSize);
+		i++;
+		outSize+=nalSize+4;
+		if(pNext==NULL){
+			goto finish;
+		}
+		pNext+=4;
+		length-=(pNext-pPre);			
+		pPre=pNext;
+	}
+finish:
+	if(outSize!=nSize){
+		VPU_ERROR("error: size not matched in convert progress of avcc !\r\n");
+	}
+	if(i==0){
+		VPU_ERROR("error: no find any nal start code in convert progress of avcc !\r\n");
+	}
+	return 1;
+}
+
+VpuEncRetCode VPU_EncLoad()
+{
+	RetCode ret;
+
+	/*parser log level*/
+	VpuLogLevelParse(NULL);	
+
+	VPU_ENC_API("calling vpu_Init() \r\n");	
+	ret=vpu_Init(NULL);
+	if(RETCODE_SUCCESS !=ret)
+	{
+		VPU_ENC_ERROR("%s: vpu init failure \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_FAILURE;
+	}
+
+	//TIMER_INIT;
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncUnLoad()
+{
+#ifdef VPU_RESET_TEST
+	if (CPU_IS_MX6X()) 
+	{
+		//loading fw, avoid reset board after fw changing
+		IOClkGateSet(1);
+		VpuWriteReg(0x0, 0);
+		VpuWriteReg(0x14, 1);		
+		IOClkGateSet(0);
+	}
+	else
+	{
+		IOSysSWReset();	//for iMX5, iMX6 has not implemented it now
+	}
+#endif
+
+	VPU_ENC_API("calling vpu_UnInit() \r\n");
+	vpu_UnInit();
+	//TIMER_REPORT(...);
+	return VPU_ENC_RET_SUCCESS;	
+}
+
+VpuEncRetCode VPU_EncReset(VpuEncHandle InHandle)
+{
+	VpuEncHandleInternal * pVpuObj;
+	RetCode ret;
+	
+	if(InHandle==NULL) 
+	{
+		return VPU_ENC_RET_SUCCESS;
+	}
+
+	pVpuObj=(VpuEncHandleInternal *)InHandle;
+
+	//TODO: current SWReset need to re-register all frame buffers again.
+	VPU_ENC_API("calling vpu_SWReset(0x%X,0) \r\n",(UINT32)pVpuObj->handle);
+	ret=vpu_SWReset(pVpuObj->handle,0);
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ENC_ERROR("%s: vpu reset failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_ENC_RET_FAILURE;
+	}	
+	
+	return VPU_ENC_RET_SUCCESS;
+	
+}
+
+VpuEncRetCode VPU_EncOpen(VpuEncHandle *pOutHandle, VpuMemInfo* pInMemInfo,VpuEncOpenParam* pInParam)
+{
+	VpuMemSubBlockInfo * pMemPhy;
+	VpuMemSubBlockInfo * pMemVirt;
+	VpuEncHandleInternal* pVpuObj;
+	VpuEncObj* pObj;
+
+	RetCode ret;
+	EncOpenParam sEncOpenParam;
+	int nValidWidth;
+	int nValidHeight;
+	
+	pMemVirt=&pInMemInfo->MemSubBlock[ENC_VIRT_INDEX];
+	pMemPhy=&pInMemInfo->MemSubBlock[ENC_PHY_INDEX];
+	if ((pMemVirt->pVirtAddr==NULL) || MemNotAlign(pMemVirt->pVirtAddr,VPU_ENC_MEM_ALIGN)
+		||(pMemVirt->nSize!=sizeof(VpuEncHandleInternal)))
+	{
+		VPU_ENC_ERROR("%s: failure: invalid parameter ! \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_PARAM;
+	}
+
+	if ((pMemPhy->pVirtAddr==NULL) || MemNotAlign(pMemPhy->pVirtAddr,VPU_ENC_MEM_ALIGN)
+		||(pMemPhy->pPhyAddr==NULL) || MemNotAlign(pMemPhy->pPhyAddr,VPU_ENC_MEM_ALIGN)
+		||(pMemPhy->nSize<VPU_ENC_BITS_BUF_SIZE))
+	{
+		VPU_ENC_ERROR("%s: failure: invalid parameter !! \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_PARAM;
+	}
+
+	nValidWidth=pInParam->nPicWidth;
+	nValidHeight=pInParam->nPicHeight;
+#ifdef VPU_ENC_ALIGN_LIMITATION
+	nValidWidth=nValidWidth/16*16;
+	nValidHeight=nValidHeight/16*16;
+#endif
+
+	pVpuObj=(VpuEncHandleInternal*)pMemVirt->pVirtAddr;
+	pObj=&pVpuObj->obj;
+
+	//clear 0 firstly
+	vpu_memset(&sEncOpenParam, 0, sizeof(EncOpenParam));
+	vpu_memset(pObj, 0, sizeof(VpuEncObj));
+	
+	//set parameters
+	sEncOpenParam.bitstreamBuffer =  (PhysicalAddress)pMemPhy->pPhyAddr;
+	sEncOpenParam.bitstreamBufferSize = VPU_ENC_BITS_BUF_SIZE;
+
+	if (CPU_IS_MX6X()) 
+	{
+		ASSERT(pMemPhy->nSize>=VPU_ENC_BITS_BUF_SIZE+VPU_ENC_MPEG4_SCRATCH_SIZE);
+		pObj->pPhyBitstream=pMemPhy->pPhyAddr;
+		pObj->pVirtBitstream=pMemPhy->pVirtAddr;
+		pObj->nBitstreamSize=VPU_ENC_BITS_BUF_SIZE;
+		pObj->pPhyScratch=pMemPhy->pPhyAddr+VPU_ENC_BITS_BUF_SIZE; //make sure it is aligned
+		pObj->pVirtScratch=pMemPhy->pVirtAddr+VPU_ENC_BITS_BUF_SIZE; //make sure it is aligned	
+		pObj->nScratchSize=VPU_ENC_MPEG4_SCRATCH_SIZE;
+		VPU_ENC_LOG("bitstream: phy: 0x%X, virt: 0x%X, size: %d \r\n",pObj->pPhyBitstream,pObj->pVirtBitstream,pObj->nBitstreamSize);
+	}
+	else
+	{
+		pObj->pPhyMjpgTable=pMemPhy->pPhyAddr+VPU_ENC_BITS_BUF_SIZE; 
+		pObj->pVirtMjpgTable=pMemPhy->pVirtAddr+VPU_ENC_BITS_BUF_SIZE; 
+	}
+
+#if 0 //1 eagle debug
+	pInParam->BistreamPhy=(unsigned int)pMemPhy->pPhyAddr;
+	pInParam->BistreamVirt=(unsigned int)pMemPhy->pVirtAddr;
+	pInParam->BitstreamSize=(unsigned int)pMemPhy->nSize;
+#endif
+
+	/* If rotation angle is 90 or 270, pic width and height are swapped */
+	VpuEncGetRotStride(pInParam->nRotAngle,nValidWidth,nValidHeight,(int*)(&sEncOpenParam.picWidth),(int*)(&sEncOpenParam.picHeight));
+
+	sEncOpenParam.frameRateInfo = pInParam->nFrameRate;
+	sEncOpenParam.bitRate = pInParam->nBitRate;
+	sEncOpenParam.gopSize = pInParam->nGOPSize;
+	sEncOpenParam.slicemode.sliceMode = pInParam->sliceMode.sliceMode;	/* 0: 1 slice per picture; 1: Multiple slices per picture */
+	sEncOpenParam.slicemode.sliceSizeMode = pInParam->sliceMode.sliceSizeMode; /* 0: silceSize defined by bits; 1: sliceSize defined by MB number*/
+	sEncOpenParam.slicemode.sliceSize = pInParam->sliceMode.sliceSize;  /* Size of a slice in bits or MB numbers */
+
+	sEncOpenParam.initialDelay = pInParam->nInitialDelay;
+	sEncOpenParam.vbvBufferSize = pInParam->nVbvBufferSize;        /* 0 = ignore 8 */
+	//sEncOpenParam.enableAutoSkip = 1;
+	sEncOpenParam.intraRefresh = pInParam->nIntraRefresh;
+	sEncOpenParam.sliceReport = 0;
+	sEncOpenParam.mbReport = 0;
+	sEncOpenParam.mbQpReport = 0;
+	sEncOpenParam.rcIntraQp = pInParam->nRcIntraQp;
+	sEncOpenParam.userQpMax = pInParam->nUserQpMax;
+	sEncOpenParam.userQpMin = pInParam->nUserQpMin;
+	sEncOpenParam.userQpMinEnable = pInParam->nUserQpMinEnable;
+	sEncOpenParam.userQpMaxEnable = pInParam->nUserQpMaxEnable;
+
+	sEncOpenParam.userGamma = pInParam->nUserGamma;         /*  (0*32768 <= gamma <= 1*32768) */
+	sEncOpenParam.RcIntervalMode= pInParam->nRcIntervalMode;        /* 0:normal, 1:frame_level, 2:slice_level, 3: user defined Mb_level */
+	sEncOpenParam.MbInterval = pInParam->nMbInterval;
+	sEncOpenParam.avcIntra16x16OnlyModeEnable = pInParam->nAvcIntra16x16OnlyModeEnable;
+
+	sEncOpenParam.ringBufferEnable = 0;
+	sEncOpenParam.dynamicAllocEnable = 1;	//1  using dynamic method
+	pObj->nDynamicEnabled=1;
+	if (CPU_IS_MX6X()) 
+	{
+		sEncOpenParam.dynamicAllocEnable = 0;	//dynamic is not supported on iMX6
+		pObj->nDynamicEnabled=0;	
+	}
+	sEncOpenParam.chromaInterleave = pInParam->nChromaInterleave;
+
+	switch(pInParam->eFormat)
+	{
+		case VPU_V_MPEG4:
+			sEncOpenParam.EncStdParam.mp4Param.mp4_dataPartitionEnable = pInParam->VpuEncStdParam.mp4Param.mp4_dataPartitionEnable;
+			sEncOpenParam.EncStdParam.mp4Param.mp4_reversibleVlcEnable = pInParam->VpuEncStdParam.mp4Param.mp4_reversibleVlcEnable;
+			sEncOpenParam.EncStdParam.mp4Param.mp4_intraDcVlcThr = pInParam->VpuEncStdParam.mp4Param.mp4_intraDcVlcThr;
+			sEncOpenParam.EncStdParam.mp4Param.mp4_hecEnable = pInParam->VpuEncStdParam.mp4Param.mp4_hecEnable;
+			sEncOpenParam.EncStdParam.mp4Param.mp4_verid = pInParam->VpuEncStdParam.mp4Param.mp4_verid;
+			sEncOpenParam.bitstreamFormat = STD_MPEG4;
+			break;
+		case VPU_V_H263:
+			if (CPU_IS_MX6X()) 
+			{
+				sEncOpenParam.EncStdParam.h263Param.h263_annexIEnable = pInParam->VpuEncStdParam.h263Param.h263_annexIEnable;
+			}
+			sEncOpenParam.EncStdParam.h263Param.h263_annexJEnable = pInParam->VpuEncStdParam.h263Param.h263_annexJEnable;
+			sEncOpenParam.EncStdParam.h263Param.h263_annexKEnable = pInParam->VpuEncStdParam.h263Param.h263_annexKEnable;
+			sEncOpenParam.EncStdParam.h263Param.h263_annexTEnable = pInParam->VpuEncStdParam.h263Param.h263_annexTEnable;
+			sEncOpenParam.bitstreamFormat = STD_H263;
+			break;
+		case VPU_V_AVC:
+			sEncOpenParam.EncStdParam.avcParam.avc_constrainedIntraPredFlag = pInParam->VpuEncStdParam.avcParam.avc_constrainedIntraPredFlag;
+			sEncOpenParam.EncStdParam.avcParam.avc_disableDeblk = pInParam->VpuEncStdParam.avcParam.avc_disableDeblk;
+			sEncOpenParam.EncStdParam.avcParam.avc_deblkFilterOffsetAlpha = pInParam->VpuEncStdParam.avcParam.avc_deblkFilterOffsetAlpha;
+			sEncOpenParam.EncStdParam.avcParam.avc_deblkFilterOffsetBeta = pInParam->VpuEncStdParam.avcParam.avc_deblkFilterOffsetBeta;
+			sEncOpenParam.EncStdParam.avcParam.avc_chromaQpOffset = pInParam->VpuEncStdParam.avcParam.avc_chromaQpOffset;
+			sEncOpenParam.EncStdParam.avcParam.avc_audEnable = pInParam->VpuEncStdParam.avcParam.avc_audEnable;
+			if (CPU_IS_MX6X()) 
+			{
+				int nWidthDiff=0;
+				int nHeightDiff=0;
+				sEncOpenParam.EncStdParam.avcParam.avc_frameCroppingFlag = 0;
+				sEncOpenParam.EncStdParam.avcParam.avc_frameCropLeft = 0;
+				sEncOpenParam.EncStdParam.avcParam.avc_frameCropRight = 0;
+				sEncOpenParam.EncStdParam.avcParam.avc_frameCropTop = 0;
+				sEncOpenParam.EncStdParam.avcParam.avc_frameCropBottom = 0;
+				nWidthDiff=nValidWidth%16;
+				nHeightDiff=nValidHeight%16;
+				if(nHeightDiff>0){
+					sEncOpenParam.EncStdParam.avcParam.avc_frameCroppingFlag = 1;
+					switch(pInParam->nRotAngle){
+						case 0:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropBottom=nHeightDiff;break;
+						case 90:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropRight=nHeightDiff;break;
+						case 180:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropTop=nHeightDiff;break;
+						case 270:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropLeft=nHeightDiff;break;
+						default:
+							VPU_ENC_ERROR("unsupported rotation: %d \r\n",pInParam->nRotAngle);	break;
+					}
+				}
+				if(nWidthDiff>0){
+					sEncOpenParam.EncStdParam.avcParam.avc_frameCroppingFlag = 1;
+					switch(pInParam->nRotAngle){
+						case 0:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropRight=nWidthDiff;break;
+						case 90:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropTop=nWidthDiff;break;
+						case 180:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropLeft=nWidthDiff;break;
+						case 270:
+							sEncOpenParam.EncStdParam.avcParam.avc_frameCropBottom=nWidthDiff;break;
+						default:
+							VPU_ENC_ERROR("unsupported rotation: %d \r\n",pInParam->nRotAngle);	break;
+					}
+				}
+				VPU_ENC_LOG("[width,heigh]=[%d,%d]: enable AVC crop flag: rot: %d, [top,bot,left,right]: [%d,%d,%d,%d]\r\n",nValidWidth,nValidHeight,pInParam->nRotAngle,
+						sEncOpenParam.EncStdParam.avcParam.avc_frameCropTop,sEncOpenParam.EncStdParam.avcParam.avc_frameCropBottom,
+						sEncOpenParam.EncStdParam.avcParam.avc_frameCropLeft,sEncOpenParam.EncStdParam.avcParam.avc_frameCropRight);
+				/* will be supported on imx6 in future ?
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoEnable = pInParam->VpuEncStdParam.avcParam.avc_fmoEnable;
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoType = pInParam->VpuEncStdParam.avcParam.avc_fmoType;
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoSliceNum = pInParam->VpuEncStdParam.avcParam.avc_fmoSliceNum;
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoSliceSaveBufSize = pInParam->VpuEncStdParam.avcParam.avc_fmoSliceSaveBufSize;			
+				*/
+#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,7))	
+				if(CPU_IS_MX6X()) 
+				{
+					sEncOpenParam.EncStdParam.avcParam.mvc_extension=0;
+					sEncOpenParam.EncStdParam.avcParam.interview_en=0;
+					sEncOpenParam.EncStdParam.avcParam.paraset_refresh_en=0;
+					sEncOpenParam.EncStdParam.avcParam.prefix_nal_en=0;
+				}
+#endif
+			}
+			else
+			{
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoEnable = pInParam->VpuEncStdParam.avcParam.avc_fmoEnable;
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoType = pInParam->VpuEncStdParam.avcParam.avc_fmoType;
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoSliceNum = pInParam->VpuEncStdParam.avcParam.avc_fmoSliceNum;
+				sEncOpenParam.EncStdParam.avcParam.avc_fmoSliceSaveBufSize = pInParam->VpuEncStdParam.avcParam.avc_fmoSliceSaveBufSize;
+			}
+			sEncOpenParam.bitstreamFormat = STD_AVC;
+			break;
+		case VPU_V_MJPG:
+			ASSERT(0==pInParam->nMapType);	//MJPEG don't support tile
+			sEncOpenParam.EncStdParam.mjpgParam.mjpg_sourceFormat = pInParam->eColorFormat;
+			sEncOpenParam.EncStdParam.mjpgParam.mjpg_restartInterval = 60;
+			sEncOpenParam.EncStdParam.mjpgParam.mjpg_thumbNailEnable = 0;
+			sEncOpenParam.EncStdParam.mjpgParam.mjpg_thumbNailWidth = 0;
+			sEncOpenParam.EncStdParam.mjpgParam.mjpg_thumbNailHeight = 0;
+			if(CPU_IS_MX6X())
+			{
+				VpuMJPGSetMX6Tables(&sEncOpenParam.EncStdParam.mjpgParam);
+			}
+			else
+			{
+				unsigned char* pHuff;
+				unsigned char* pMat;
+				VpuMJPGSetMX5Tables(pObj->pVirtMjpgTable, &pHuff, &pMat);
+				sEncOpenParam.EncStdParam.mjpgParam.mjpg_hufTable = pHuff;
+				sEncOpenParam.EncStdParam.mjpgParam.mjpg_qMatTable = pMat;
+			}
+			sEncOpenParam.bitstreamFormat = STD_MJPG;
+			pObj->eColor=pInParam->eColorFormat;
+			break;
+		default:
+			//unknow format ?
+			//return VPU_ENC_RET_INVALID_PARAM;
+			break;
+	}
+
+	if (CPU_IS_MX6X()) 
+	{
+		sEncOpenParam.MESearchRange=pInParam->nMESearchRange;
+		sEncOpenParam.MEUseZeroPmv=pInParam->nMEUseZeroPmv;
+		sEncOpenParam.IntraCostWeight=pInParam->nIntraCostWeight;
+		if(VPU_V_H263==pInParam->eFormat)
+		{
+			sEncOpenParam.MESearchRange=3; // must set 3 for H.263
+		}
+#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,7))	
+		ASSERT(0==LINEAR_FRAME_MAP);
+		ASSERT(1==TILED_FRAME_MB_RASTER_MAP);
+		ASSERT(2==TILED_FIELD_MB_RASTER_MAP);		
+		sEncOpenParam.mapType=pInParam->nMapType;
+		sEncOpenParam.linear2TiledEnable=pInParam->nLinear2TiledEnable;
+
+		pObj->nMapType=pInParam->nMapType;
+		pObj->nLinear2TiledEnable=pInParam->nLinear2TiledEnable;
+		//pObj->nChromaInterleave=pInParam->nChromaInterleave;
+		if(pInParam->nMapType!=0)
+		{
+			ASSERT(1==pInParam->nChromaInterleave);
+		}
+#endif
+	}
+
+#if 0
+	VPU_ENC_LOG("gop: %d, initial delay: %d, intrarefresh: %d, mbinterval: %d, intervalMode: %d, rcIntraQP: %d, slicemode: %d, slicesize: %d, slicesizemode: %d \r\n",
+		sEncOpenParam.gopSize, sEncOpenParam.initialDelay,sEncOpenParam.intraRefresh,
+		sEncOpenParam.MbInterval, sEncOpenParam.RcIntervalMode, sEncOpenParam.rcIntraQp,
+		sEncOpenParam.slicemode.sliceMode,sEncOpenParam.slicemode.sliceSize, sEncOpenParam.slicemode.sliceSizeMode);
+	VPU_ENC_LOG("gamma: %d, qpmax: %d, maxenable: %d, qpmin: %d, minenable: %d, vbvsize: %d, avcintra16x16only: %d \r\n",
+		sEncOpenParam.userGamma, sEncOpenParam.userQpMax, sEncOpenParam.userQpMaxEnable,
+		sEncOpenParam.userQpMin,sEncOpenParam.userQpMinEnable,
+		sEncOpenParam.vbvBufferSize, sEncOpenParam.avcIntra16x16OnlyModeEnable);
+
+	VPU_ENC_LOG("bitrate: %d, autoskip: %d, intracost: %d, MEsearch: %d, MEUseZeroPmv: %d  \r\n",
+		sEncOpenParam.bitRate,sEncOpenParam.enableAutoSkip,sEncOpenParam.IntraCostWeight, sEncOpenParam.MESearchRange,sEncOpenParam.MEUseZeroPmv);
+	VPU_ENC_LOG("avc_intrapred: %d, avc_desaDeblk: %d, avc_alpha: %d, avc_beta: %d,  avc_qpoff: %d, avc_aud: %d \r\n",
+		sEncOpenParam.EncStdParam.avcParam.avc_constrainedIntraPredFlag,
+		sEncOpenParam.EncStdParam.avcParam.avc_disableDeblk,
+		sEncOpenParam.EncStdParam.avcParam.avc_deblkFilterOffsetAlpha,
+		sEncOpenParam.EncStdParam.avcParam.avc_deblkFilterOffsetBeta,
+		sEncOpenParam.EncStdParam.avcParam.avc_chromaQpOffset,
+		sEncOpenParam.EncStdParam.avcParam.avc_audEnable);
+#endif
+
+	VPU_ENC_API("calling vpu_EncOpen() \r\n");
+	ret= vpu_EncOpen(&pVpuObj->handle, &sEncOpenParam);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ENC_ERROR("%s: vpu open failure: ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_ENC_RET_FAILURE;
+	}
+
+	//give commands for rotation
+	if (0!=pInParam->nRotAngle) 
+	{
+		VPU_ENC_API("calling vpu_EncGiveCommand(ENABLE_ROTATION) \r\n");
+		vpu_EncGiveCommand(pVpuObj->handle, ENABLE_ROTATION, 0);
+		VPU_ENC_API("calling vpu_EncGiveCommand(ENABLE_MIRRORING) \r\n");
+		vpu_EncGiveCommand(pVpuObj->handle, ENABLE_MIRRORING, 0);
+		VPU_ENC_API("calling vpu_EncGiveCommand(SET_ROTATION_ANGLE) \r\n");
+		vpu_EncGiveCommand(pVpuObj->handle, SET_ROTATION_ANGLE,&pInParam->nRotAngle);
+		VPU_ENC_API("calling vpu_EncGiveCommand(SET_MIRROR_DIRECTION) \r\n");
+		vpu_EncGiveCommand(pVpuObj->handle, SET_MIRROR_DIRECTION, &pInParam->sMirror);
+	}
+
+	if(pInParam->eFormat==VPU_V_MJPG){
+		int stuff_ena=0;
+		vpu_EncGiveCommand(pVpuObj->handle, ENC_ENABLE_SOF_STUFF, &stuff_ena);
+	}
+
+	pObj->nHeaderNeeded=1;
+	
+#ifdef VPU_ENC_SEQ_DATA_SEPERATE
+	pObj->nJustOutputOneHeader=0;
+	pObj->nOutputHeaderCnt=0;
+#endif
+
+	pObj->nInsertSPSPPSToIDR=0;
+#ifdef VPU_ENC_SEQ_DATA_SEPERATE
+	pObj->nIsAvcc=((0!=pInParam->nIsAvcc) && (VPU_V_AVC==pInParam->eFormat))?1:0;
+#else
+	pObj->nIsAvcc=0;
+#endif
+
+	*pOutHandle=(VpuEncHandle)pVpuObj;	
+
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncOpenSimp(VpuEncHandle *pOutHandle, VpuMemInfo* pInMemInfo,VpuEncOpenParamSimp * pInParam)
+{
+	VpuEncRetCode ret;
+	VpuEncOpenParam sEncOpenParamMore;
+
+	vpu_memset(&sEncOpenParamMore,0,sizeof(VpuEncOpenParam));
+
+	sEncOpenParamMore.eFormat=pInParam->eFormat;
+	sEncOpenParamMore.nPicWidth=pInParam->nPicWidth;
+	sEncOpenParamMore.nPicHeight=pInParam->nPicHeight;
+	sEncOpenParamMore.nRotAngle=pInParam->nRotAngle;
+	sEncOpenParamMore.nFrameRate= pInParam->nFrameRate;
+	sEncOpenParamMore.nBitRate= pInParam->nBitRate;
+	sEncOpenParamMore.nGOPSize= pInParam->nGOPSize;
+
+	sEncOpenParamMore.nChromaInterleave= pInParam->nChromaInterleave;	
+	sEncOpenParamMore.sMirror= pInParam->sMirror;	
+
+	sEncOpenParamMore.nMapType= pInParam->nMapType;
+	sEncOpenParamMore.nLinear2TiledEnable= pInParam->nLinear2TiledEnable;
+	sEncOpenParamMore.eColorFormat= pInParam->eColorFormat;
+	
+	sEncOpenParamMore.sliceMode.sliceMode = 0;	/* 0: 1 slice per picture; 1: Multiple slices per picture */
+	sEncOpenParamMore.sliceMode.sliceSizeMode = 0; /* 0: silceSize defined by bits; 1: sliceSize defined by MB number*/
+	sEncOpenParamMore.sliceMode.sliceSize = 4000;  /* Size of a slice in bits or MB numbers */
+
+	sEncOpenParamMore.nInitialDelay=0;
+	sEncOpenParamMore.nVbvBufferSize=0;
+
+	sEncOpenParamMore.nIntraRefresh = pInParam->nIntraRefresh;
+	//sEncOpenParamMore.nRcIntraQp = -1;
+	if(0==pInParam->nIntraQP){
+		sEncOpenParamMore.nRcIntraQp =VpuEncGetIntraQP(pInParam);
+	}
+	else{
+		sEncOpenParamMore.nRcIntraQp=pInParam->nIntraQP;
+	}
+
+	sEncOpenParamMore.nUserQpMax = 0;
+	sEncOpenParamMore.nUserQpMin = 0;
+	sEncOpenParamMore.nUserQpMinEnable = 0;
+	sEncOpenParamMore.nUserQpMaxEnable = 0;
+
+	sEncOpenParamMore.nUserGamma = (int)(0.75*32768);         /*  (0*32768 <= gamma <= 1*32768) */
+	sEncOpenParamMore.nRcIntervalMode= 0;        /* 0:normal, 1:frame_level, 2:slice_level, 3: user defined Mb_level */
+	sEncOpenParamMore.nMbInterval = 0;
+	sEncOpenParamMore.nAvcIntra16x16OnlyModeEnable = 0;
+
+	//set some default value structure 'VpuEncOpenParamMore'
+	switch(pInParam->eFormat)
+	{
+		case VPU_V_MPEG4:
+			sEncOpenParamMore.VpuEncStdParam.mp4Param.mp4_dataPartitionEnable = 0;
+			sEncOpenParamMore.VpuEncStdParam.mp4Param.mp4_reversibleVlcEnable = 0;
+			sEncOpenParamMore.VpuEncStdParam.mp4Param.mp4_intraDcVlcThr = 0;
+			sEncOpenParamMore.VpuEncStdParam.mp4Param.mp4_hecEnable = 0;
+			sEncOpenParamMore.VpuEncStdParam.mp4Param.mp4_verid = 2;
+			break;
+		case VPU_V_H263:
+			if (CPU_IS_MX6X())
+			{
+				sEncOpenParamMore.VpuEncStdParam.h263Param.h263_annexIEnable = 0;
+			}
+			sEncOpenParamMore.VpuEncStdParam.h263Param.h263_annexJEnable = 1;
+			sEncOpenParamMore.VpuEncStdParam.h263Param.h263_annexKEnable = 0;
+			sEncOpenParamMore.VpuEncStdParam.h263Param.h263_annexTEnable = 0;
+			break;
+		case VPU_V_AVC:
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_constrainedIntraPredFlag = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_disableDeblk = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_deblkFilterOffsetAlpha = 0;//6;  set 0 to improve quality: ENGR00305955: bottom line flicker issue
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_deblkFilterOffsetBeta = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_chromaQpOffset = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_audEnable = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_fmoEnable = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_fmoType = 0;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_fmoSliceNum = 1;
+			sEncOpenParamMore.VpuEncStdParam.avcParam.avc_fmoSliceSaveBufSize = 32; /* FMO_SLICE_SAVE_BUF_SIZE */			
+			break;
+		//case VPU_V_MJPG:
+		default:
+			//unknow format ?
+			//return VPU_ENC_RET_INVALID_PARAM;
+			break;
+	}
+
+	if (CPU_IS_MX6X())
+	{
+		sEncOpenParamMore.nMESearchRange=0;
+		sEncOpenParamMore.nMEUseZeroPmv=0;
+		sEncOpenParamMore.nIntraCostWeight=0;
+	}
+	sEncOpenParamMore.nIsAvcc=pInParam->nIsAvcc;
+	ret=VPU_EncOpen(pOutHandle,pInMemInfo,&sEncOpenParamMore);
+
+	return ret;
+}
+
+VpuEncRetCode VPU_EncClose(VpuEncHandle InHandle)
+{
+	VpuEncHandleInternal * pVpuObj;
+	RetCode ret;
+	
+	if(InHandle==NULL) 
+	{
+		VPU_ENC_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuEncHandleInternal *)InHandle;
+
+	//add robust : if busy(fix some timeout issue) , reset it 
+	VPU_ENC_API("calling vpu_IsBusy() \r\n");
+	if(vpu_IsBusy())
+	{
+		VPU_ENC_API("calling vpu_SWReset(0x%X,0) \r\n",(UINT32)pVpuObj->handle);
+		ret=vpu_SWReset(pVpuObj->handle,0);
+		if(RETCODE_SUCCESS!=ret)
+		{
+			VPU_ENC_ERROR("%s: vpu reset failure, ret=%d \r\n",__FUNCTION__,ret);
+			//return VPU_ENC_RET_FAILURE;
+		}	
+	}	
+
+	//normal close
+	VPU_ENC_API("calling vpu_EncClose() \r\n");
+	ret=vpu_EncClose(pVpuObj->handle);
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ENC_ERROR("%s: vpu close failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_ENC_RET_FAILURE;
+	}	
+	
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncGetInitialInfo(VpuEncHandle InHandle, VpuEncInitInfo * pOutInitInfo)
+{
+	RetCode ret;
+	VpuEncHandleInternal * pVpuObj;
+	EncInitialInfo sInitInfo;
+
+	if(InHandle==NULL) 
+	{
+		VPU_ENC_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuEncHandleInternal *)InHandle;
+
+	VPU_ENC_API("calling vpu_EncGetInitialInfo() \r\n");
+	//ret = vpu_EncGetInitialInfo(pVpuObj->handle, &pOutInitInfo->sInitInfo);
+	ret = vpu_EncGetInitialInfo(pVpuObj->handle, &sInitInfo);
+	if (ret != RETCODE_SUCCESS)
+	{
+		VPU_ENC_ERROR("%s: Encoder GetInitialInfo failed \r\n",__FUNCTION__);
+		return VPU_ENC_RET_FAILURE;
+	}
+	pOutInitInfo->nMinFrameBufferCount=sInitInfo.minFrameBufferCount;
+	pOutInitInfo->nAddressAlignment=1;
+
+	if (CPU_IS_MX6X())
+	{
+		//FIXME: In generally, every subsamp buffer need about 1/4 frame buff size. we can move this into QueryMem() to save memory size
+		pOutInitInfo->nMinFrameBufferCount+=2;	//for subsamp A,B
+		//FIXME: In fact, for MJPG, subA/B are not required.
+	}
+
+#if 1	//FIXME: we can uncoment this if user can set valid stride to VPU_EncRegisterFrameBuffer() when num==0
+	if(0==pOutInitInfo->nMinFrameBufferCount)
+	{	
+		//for iMX5 MJPG, min cnt may be 0
+		//in this case, we need to let user appoint one valid stride(related with rotation) before calling VPU_EncRegisterFrameBuffer()
+		pOutInitInfo->nMinFrameBufferCount=1;  
+	}	
+#endif
+	
+	if(pVpuObj->obj.nMapType!=0)
+	{
+		//alignment for Y,Cb,Cr pointer
+		pOutInitInfo->nAddressAlignment=VPU_TILE_ALIGN;
+	}
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncGetVersionInfo(VpuVersionInfo * pOutVerInfo)
+{
+	vpu_versioninfo ver;
+	RetCode ret;
+
+	if(pOutVerInfo==NULL)
+	{
+		VPU_ENC_ERROR("%s: failure: invalid parameterl \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_PARAM;
+	}
+	VPU_ENC_API("calling vpu_GetVersionInfo() \r\n");
+	ret=vpu_GetVersionInfo(&ver);
+	if(RETCODE_SUCCESS!=ret)
+	{
+		VPU_ENC_ERROR("%s: get vpu version failure, ret=%d \r\n",__FUNCTION__,ret);
+		return VPU_ENC_RET_FAILURE;
+	}
+
+	pOutVerInfo->nFwMajor=ver.fw_major;
+	pOutVerInfo->nFwMinor=ver.fw_minor;
+	pOutVerInfo->nFwRelease=ver.fw_release;
+	pOutVerInfo->nLibMajor=ver.lib_major;
+	pOutVerInfo->nLibMinor=ver.lib_minor;
+	pOutVerInfo->nLibRelease=ver.lib_release;
+#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,7))	
+	pOutVerInfo->nFwCode=ver.fw_code;
+#else
+	pOutVerInfo->nFwCode=0;
+#endif
+	VPU_API("%s: VPU FW: [major.minor.release_rcode]=[%d.%d.%d_r%d] \r\n",__FUNCTION__,pOutVerInfo->nFwMajor,pOutVerInfo->nFwMinor,pOutVerInfo->nFwRelease,pOutVerInfo->nFwCode);
+	VPU_API("%s: VPU LIB: [major.minor.release]=[%d.%d.%d] \r\n",__FUNCTION__,pOutVerInfo->nLibMajor,pOutVerInfo->nLibMinor,pOutVerInfo->nLibRelease);
+
+	return VPU_ENC_RET_SUCCESS;
+
+}
+
+VpuEncRetCode VPU_EncGetWrapperVersionInfo(VpuWrapperVersionInfo * pOutVerInfo)
+{
+	pOutVerInfo->nMajor= (VPU_WRAPPER_VERSION_CODE >> (16)) & 0xff;
+	pOutVerInfo->nMinor= (VPU_WRAPPER_VERSION_CODE >> (8)) & 0xff;
+	pOutVerInfo->nRelease= (VPU_WRAPPER_VERSION_CODE) & 0xff;
+#ifdef USER_SPECIFY_BINARY_VER
+printf("user specify version \r\n");
+	pOutVerInfo->pBinary=(char*)STR_USER_SPECIFY_BINARY_VER;
+#else
+	pOutVerInfo->pBinary=(char*)VPUWRAPPER_BINARY_VERSION_STR;
+#endif	
+	return VPU_DEC_RET_SUCCESS;	
+}
+
+VpuEncRetCode VPU_EncRegisterFrameBuffer(VpuEncHandle InHandle,VpuFrameBuffer *pInFrameBufArray, int nNum,int nSrcStride)
+{
+	VpuEncHandleInternal * pVpuObj;
+	RetCode ret;
+	FrameBuffer framebuf[VPU_ENC_MAX_FRAME_INDEX];
+	unsigned int yBot[VPU_ENC_MAX_FRAME_INDEX];	//for field tile
+	unsigned int cbBot[VPU_ENC_MAX_FRAME_INDEX];	//for field tile
+	int i;
+	ExtBufCfg sScratch;
+	vpu_memset(&sScratch, 0, sizeof(ExtBufCfg));
+    
+	
+	if(InHandle==NULL) 
+	{
+		VPU_ENC_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuEncHandleInternal *)InHandle;
+
+	if(nNum>VPU_ENC_MAX_FRAME_INDEX)
+	{
+		VPU_ENC_ERROR("%s: failure: register frame number is too big(%d) \r\n",__FUNCTION__,nNum);		
+		return VPU_ENC_RET_INVALID_PARAM;
+	}
+
+	for(i=0;i<nNum;i++)
+	{
+		//record frame buf info
+		//pVpuObj->obj.frameBuf[i]=*pInFrameBufArray;
+#ifdef USE_NEW_VPU_API
+		if (CPU_IS_MX6X())
+		{
+			framebuf[i].myIndex=i;
+		}
+#endif
+		//re-map frame buf info for vpu register
+		framebuf[i].strideY=(unsigned long)pInFrameBufArray->nStrideY;
+		framebuf[i].strideC=(unsigned long)pInFrameBufArray->nStrideC;
+		framebuf[i].bufY=(PhysicalAddress)pInFrameBufArray->pbufY;
+		framebuf[i].bufCb=(PhysicalAddress)pInFrameBufArray->pbufCb;
+		framebuf[i].bufCr=(PhysicalAddress)pInFrameBufArray->pbufCr;
+		framebuf[i].bufMvCol=(PhysicalAddress)pInFrameBufArray->pbufMvCol;
+
+		VPU_ENC_LOG("register frame %d: (phy)	Y:0x%X, U:0x%X, V:0x%X \r\n",(UINT32)i,(UINT32)framebuf[i].bufY,(UINT32)framebuf[i].bufCb,(UINT32)framebuf[i].bufCr);
+		VPU_ENC_LOG("register frame %d: (virt)	Y:0x%X, U:0x%X, V:0x%X \r\n",(UINT32)i,(UINT32)pInFrameBufArray->pbufVirtY,(UINT32)pInFrameBufArray->pbufVirtCb,(UINT32)pInFrameBufArray->pbufVirtCr);
+		VPU_ENC_LOG("register mv    %d: (phy)	0x%X,    (virt)    0x%X \r\n",(UINT32)i,(UINT32)framebuf[i].bufMvCol,(UINT32)pInFrameBufArray->pbufVirtMvCol);		
+
+		yBot[i]=(PhysicalAddress)pInFrameBufArray->pbufY_tilebot;
+		cbBot[i]=(PhysicalAddress)pInFrameBufArray->pbufCb_tilebot;
+		VPU_ENC_LOG("register field address: %d: (phy) YBot: 0x%X, CbBot: 0x%X \r\n",(UINT32)i,(UINT32)yBot[i],(UINT32)cbBot[i]);
+		pInFrameBufArray++;
+	}
+	//pVpuObj->obj.frameNum=nNum;
+
+	if (CPU_IS_MX6X())
+	{
+		nNum-=2;
+		sScratch.bufferBase=(PhysicalAddress)pVpuObj->obj.pPhyScratch;
+		sScratch.bufferSize=pVpuObj->obj.nScratchSize;
+		pVpuObj->obj.nFrameCnt=nNum;
+	}
+
+	//need to remap Y/Cb/Cr for tile format frame buffer: (not include subsample A,B)
+	if(pVpuObj->obj.nMapType!=0)
+	{
+		for(i=0;i<nNum;i++)
+		{
+			VpuTiledAddressMapping(pVpuObj->obj.nMapType, 
+				(unsigned int)framebuf[i].bufY, yBot[i], (unsigned int)framebuf[i].bufCb, cbBot[i], 
+				(unsigned int*)(&framebuf[i].bufY), (unsigned int*)(&framebuf[i].bufCb), (unsigned int*)(&framebuf[i].bufCr));
+		}
+	}
+
+	VPU_ENC_API("calling vpu_EncRegisterFrameBuffer() \r\n");
+	//here, we expect the source stride == enc stride
+#ifdef USE_NEW_VPU_API
+	#if (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,7))
+		VPU_ENC_LOG("register: num: %d, subsamp A: 0x%X, subsamp B: 0x%X, scratch: 0x%X(size: %d) \r\n",nNum,framebuf[nNum].bufY,framebuf[nNum+1].bufY,sScratch.bufferBase,sScratch.bufferSize);
+		if (CPU_IS_MX6X())
+		{
+			EncExtBufInfo extbufinfo;
+			vpu_memset(&extbufinfo, 0, sizeof(EncExtBufInfo));
+			extbufinfo.scratchBuf = sScratch;
+			ret = vpu_EncRegisterFrameBuffer(pVpuObj->handle,framebuf,nNum, framebuf[0].strideY, /*framebuf[0].strideY*/nSrcStride,framebuf[nNum].bufY,framebuf[nNum+1].bufY,&extbufinfo);
+		}
+		else
+		{
+			ret = vpu_EncRegisterFrameBuffer(pVpuObj->handle,framebuf,nNum, framebuf[0].strideY, /*framebuf[0].strideY*/nSrcStride,0,0,0);
+		}
+	#elif (VPU_LIB_VERSION_CODE >=VPU_LIB_VERSION(5,3,3))
+		VPU_ENC_LOG("register: num: %d, subsamp A: 0x%X, subsamp B: 0x%X, scratch: 0x%X(size: %d) \r\n",nNum,framebuf[nNum].bufY,framebuf[nNum+1].bufY,sScratch.bufferBase,sScratch.bufferSize);
+		if (CPU_IS_MX6X())
+		{
+			ret = vpu_EncRegisterFrameBuffer(pVpuObj->handle,framebuf,nNum, framebuf[0].strideY, /*framebuf[0].strideY*/nSrcStride,framebuf[nNum].bufY,framebuf[nNum+1].bufY,&sScratch);
+		}
+		else
+		{
+			ret = vpu_EncRegisterFrameBuffer(pVpuObj->handle,framebuf,nNum, framebuf[0].strideY, /*framebuf[0].strideY*/nSrcStride,0,0,0);
+		}
+	#else
+		ret = vpu_EncRegisterFrameBuffer(pVpuObj->handle,framebuf,nNum, framebuf[0].strideY, /*framebuf[0].strideY*/nSrcStride,0,0);
+	#endif
+#else
+	ret = vpu_EncRegisterFrameBuffer(pVpuObj->handle,framebuf,nNum, framebuf[0].strideY, /*framebuf[0].strideY*/nSrcStride);
+#endif
+	if (ret != RETCODE_SUCCESS) 
+	{
+		VPU_ENC_ERROR("%s: Register frame buffer failed \r\n",__FUNCTION__);
+		return VPU_ENC_RET_FAILURE;
+	}
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncQueryMem(VpuMemInfo* pOutMemInfo)
+{
+	VpuMemSubBlockInfo * pMem;
+	int nMjpgTableSize;
+	
+	if(pOutMemInfo==NULL)
+	{
+		VPU_ENC_ERROR("%s: failure: invalid parameterl \r\n",__FUNCTION__);	
+		return VPU_ENC_RET_INVALID_PARAM;	
+	}
+	pMem=&pOutMemInfo->MemSubBlock[ENC_VIRT_INDEX];
+	pMem->MemType=VPU_MEM_VIRT;
+	pMem->nAlignment=VPU_ENC_MEM_ALIGN;
+	pMem->nSize=sizeof(VpuEncHandleInternal);
+	pMem->pVirtAddr=NULL;
+	pMem->pPhyAddr=NULL;
+
+	pMem=&pOutMemInfo->MemSubBlock[ENC_PHY_INDEX];
+	pMem->MemType=VPU_MEM_PHY;
+	pMem->nAlignment=VPU_ENC_MEM_ALIGN;
+	pMem->nSize=VPU_ENC_BITS_BUF_SIZE;
+	nMjpgTableSize=VpuMJPGQueryTableSize();
+	if (CPU_IS_MX6X())
+	{
+		//pMem->nSize+=VPU_ENC_MEM_ALIGN+width*heigth*3/8;	//subsamp A,B
+		pMem->nSize+=VPU_ENC_MEM_ALIGN+VPU_ENC_MPEG4_SCRATCH_SIZE;	//for scratch
+		ASSERT(nMjpgTableSize<=VPU_ENC_MPEG4_SCRATCH_SIZE);
+	}
+	else
+	{
+		pMem->nSize+=VPU_ENC_MEM_ALIGN+nMjpgTableSize;
+	}
+
+	pMem->pVirtAddr=NULL;
+	pMem->pPhyAddr=NULL;
+
+	pOutMemInfo->nSubBlockNum=2;
+	
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncGetMem(VpuMemDesc* pInOutMem)
+{
+	int ret;
+	vpu_mem_desc buff;
+	buff.size=pInOutMem->nSize;
+	ret=IOGetPhyMem(&buff);
+	if(ret) //if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ENC_ERROR("%s: get physical memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,(UINT32)ret);
+		return VPU_ENC_RET_FAILURE;
+	}
+	ret=IOGetVirtMem(&buff);
+	if(ret==0) //if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ENC_ERROR("%s: get virtual memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,(UINT32)ret);
+		return VPU_ENC_RET_FAILURE;
+	}
+
+	pInOutMem->nPhyAddr=buff.phy_addr;
+	pInOutMem->nVirtAddr=buff.virt_uaddr;
+	pInOutMem->nCpuAddr=buff.cpu_addr;
+
+	VPU_ENC_LOG("%s: size: %d, phy addr: 0x%X, virt addr: 0x%X \r\n",__FUNCTION__,buff.size,(UINT32)buff.phy_addr,(UINT32)buff.virt_uaddr);
+	return VPU_ENC_RET_SUCCESS;
+}
+
+
+VpuEncRetCode VPU_EncFreeMem(VpuMemDesc* pInMem)
+{
+	int ret;
+	vpu_mem_desc buff;
+	buff.size=pInMem->nSize;
+	buff.phy_addr=pInMem->nPhyAddr;
+	buff.virt_uaddr=pInMem->nVirtAddr;
+	buff.cpu_addr=pInMem->nCpuAddr;
+	ret=IOFreeVirtMem(&buff);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ENC_ERROR("%s: free virtual memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,(UINT32)ret);
+		return VPU_ENC_RET_FAILURE;
+	}	
+	ret=IOFreePhyMem(&buff);
+	if(ret!=RETCODE_SUCCESS)
+	{
+		VPU_ENC_ERROR("%s: free phy memory failure: size=%d, ret=%d \r\n",__FUNCTION__,buff.size,(UINT32)ret);
+		return VPU_ENC_RET_FAILURE;
+	}	
+
+	return VPU_ENC_RET_SUCCESS;	
+}
+
+VpuEncRetCode VPU_EncConfig(VpuEncHandle InHandle, VpuEncConfig InEncConf, void* pInParam)
+{
+	VpuEncHandleInternal * pVpuObj;
+	VpuEncObj* pObj;
+	int para;
+	if(InHandle==NULL)
+	{
+		VPU_ENC_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);		
+		return VPU_ENC_RET_INVALID_HANDLE;
+	}
+	
+	pVpuObj=(VpuEncHandleInternal *)InHandle;
+	pObj=&pVpuObj->obj;
+	
+	switch(InEncConf)
+	{
+		//case VPU_DEC_CONF_SKIPNONE:
+		//	break;
+		case VPU_ENC_CONF_NONE:
+			break;
+		case VPU_ENC_CONF_BIT_RATE:
+			para=*((int*)pInParam);
+			if(para<0){
+				VPU_ENC_ERROR("%s: invalid bit rate parameter: %d \r\n",__FUNCTION__,para);
+				return VPU_ENC_RET_INVALID_PARAM;
+			}
+			vpu_EncGiveCommand(pVpuObj->handle, ENC_SET_BITRATE, &para);
+			break;
+		case VPU_ENC_CONF_INTRA_REFRESH:
+			para=*((int*)pInParam);
+			if(para<0){
+				VPU_ENC_ERROR("%s: invalid intra refresh parameter: %d \r\n",__FUNCTION__,para);
+				return VPU_ENC_RET_INVALID_PARAM;
+			}
+			VPU_ENC_LOG("%s: intra fresh number: %d \r\n",__FUNCTION__,para);
+			vpu_EncGiveCommand(pVpuObj->handle, ENC_SET_INTRA_MB_REFRESH_NUMBER, &para);
+			break;
+		case VPU_ENC_CONF_ENA_SPSPPS_IDR:
+			/*	nInsertSPSPPSToIDR
+				0: sequence header(SPS/PPS) + IDR +P +P +...+ (SPS/PPS)+IDR+....
+				1: sequence header(SPS/PPS) + (SPS/PPS)+IDR +P +P +...+ (SPS/PPS)+IDR+....
+			*/
+			VPU_ENC_LOG("%s: enable SPS/PPS for IDR frames %d \r\n",__FUNCTION__);
+			pObj->nInsertSPSPPSToIDR=1;
+			break;
+		case VPU_ENC_CONF_RC_INTRA_QP: /*avc: 0..51, other 1..31*/
+			para=*((int*)pInParam);
+			if(para<0){
+				VPU_ENC_ERROR("%s: invalid intra qp %d \r\n",__FUNCTION__,para);
+				return VPU_ENC_RET_INVALID_PARAM;
+			}
+			VPU_ENC_LOG("%s: intra qp : %d \r\n",__FUNCTION__,para);
+			vpu_EncGiveCommand(pVpuObj->handle, ENC_SET_INTRA_QP, &para);
+			break;
+		case VPU_ENC_CONF_INTRA_REFRESH_MODE:
+			para=*((int*)pInParam);
+			if(para<0){
+				VPU_ENC_ERROR("%s: invalid intra refresh mode parameter: %d \r\n",__FUNCTION__,para);
+				return VPU_ENC_RET_INVALID_PARAM;
+			}
+			VPU_ENC_LOG("%s: intra fresh mode: %d \r\n",__FUNCTION__,para);
+			vpu_EncGiveCommand(pVpuObj->handle, ENC_SET_INTRA_REFRESH_MODE, &para);
+			break;
+		default:
+			VPU_ENC_ERROR("%s: failure: invalid setting \r\n",__FUNCTION__);	
+			return VPU_ENC_RET_INVALID_PARAM;
+	}
+	
+	return VPU_ENC_RET_SUCCESS;
+}
+
+VpuEncRetCode VPU_EncEncodeFrame(VpuEncHandle InHandle, VpuEncEncParam* pInOutParam)
+{
+	VpuEncHandleInternal * pVpuObj;
+	RetCode ret;
+	EncParam sEncParam;
+	EncOutputInfo sEncOutInfo;
+	FrameBuffer sFramBuf;
+	VpuEncBufRetCode bufRet=VPU_ENC_INPUT_NOT_USED;
+	int nHeaderLen=0;
+	int nPadLen=0;
+//#ifdef VPU_WRAPPER_DUMP
+	static FILE* fpYUV=NULL;	//input
+	int nPhy_virt_offset=0;
+	static FILE* fpBitstream=NULL;	//output 
+//#endif
+	if(InHandle==NULL)
+	{
+		VPU_ENC_ERROR("%s: failure: handle is null \r\n",__FUNCTION__);		
+		return VPU_ENC_RET_INVALID_HANDLE;
+	}
+
+	pVpuObj=(VpuEncHandleInternal *)InHandle;
+
+	//For H.264, we will insert sps/pps before every IDR frame
+	if((1==pVpuObj->obj.nHeaderNeeded)||((VPU_V_AVC==pInOutParam->eFormat)&&(0!=pInOutParam->nForceIPicture)))
+	{
+#ifdef VPU_ENC_SEQ_DATA_SEPERATE	
+		if((1==pVpuObj->obj.nJustOutputOneHeader)&&(pVpuObj->obj.nInsertSPSPPSToIDR==0))
+		{
+			//avoid dead loop in filling header
+		}
+		else
+#endif
+		{
+			unsigned char* pHeaderBufPhy;
+			unsigned char* pHeaderBufVirt;
+			int mode=0;	
+			/*
+			mode 0: dynamic 1: needn't pad zero
+			mode 1: dynamic 1: need pad zero
+			mode 2: non-dynamic, non-ringbuf(or ringbuf ?)
+			*/ 
+			if(pVpuObj->obj.nDynamicEnabled)
+			{
+				pHeaderBufPhy=(unsigned char*)pInOutParam->nInPhyOutput;
+				pHeaderBufVirt=(unsigned char*)pInOutParam->nInVirtOutput;
+#ifdef VPU_ENC_OUTFRAME_ALIGN
+				mode=1;
+#endif
+			}
+			else
+			{
+				pHeaderBufPhy=(unsigned char*)pInOutParam->nInPhyOutput;	
+				pHeaderBufVirt=(unsigned char*)pInOutParam->nInVirtOutput;
+				mode=2;
+			}
+			//In fact, we need not send pHeaderBufVirt, but vpu has some limitation about address aligment.
+			//As result we need to fill some zero bytes in header 
+			if(-1==VpuEncFillHeader(pVpuObj->handle,pInOutParam,pHeaderBufPhy,&nHeaderLen,&nPadLen,pHeaderBufVirt,mode,pVpuObj->obj.pPhyBitstream,pVpuObj->obj.pVirtBitstream))
+			{
+				return VPU_ENC_RET_FAILURE;
+			}
+			//only fill header info once
+			if(VPU_V_MJPG==pInOutParam->eFormat)
+			{
+				//for MJPG: always fill header before every frame
+				pVpuObj->obj.nHeaderNeeded=1;
+			}
+			else
+			{
+				pVpuObj->obj.nHeaderNeeded=0;
+			}
+			ASSERT(nHeaderLen<=(int)pInOutParam->nInOutputBufLen);
+		}
+	}	
+
+#ifdef VPU_ENC_SEQ_DATA_SEPERATE
+	//if(nHeaderLen>0)
+	//now, for MJPG, header and frame data always merged together
+	if((nHeaderLen>0)&&(0==pVpuObj->obj.nOutputHeaderCnt)&&((VPU_V_MJPG!=pInOutParam->eFormat)))
+	{
+		//output sequence header firstly
+		ASSERT(nHeaderLen-nPadLen>0);
+		pInOutParam->nOutOutputSize=nHeaderLen-nPadLen;	//needn't align boundary again if we only output header
+		pInOutParam->eOutRetCode=(VpuEncBufRetCode)(VPU_ENC_INPUT_NOT_USED|VPU_ENC_OUTPUT_SEQHEADER);	
+		pVpuObj->obj.nJustOutputOneHeader=1;	//output header
+		pVpuObj->obj.nOutputHeaderCnt++;
+		if(pVpuObj->obj.nIsAvcc){
+			VpuConvertToAvccHeader((unsigned char*)pInOutParam->nInVirtOutput,pInOutParam->nOutOutputSize,&pInOutParam->nOutOutputSize);
+		}
+	}
+	else
+#endif
+	{
+		unsigned int nbufYBot=NULL;	//for field tile input
+		unsigned int nbufCbBot=NULL;	//for field tile input
+		//clear 0 firstly
+		vpu_memset(&sEncParam, 0, sizeof(EncParam));
+		vpu_memset(&sFramBuf,0,sizeof(FrameBuffer));
+
+		//set encoder parameters
+		if (CPU_IS_MX6X())	//for iMX6: it is very important !!!
+		{
+			sFramBuf.myIndex=pVpuObj->obj.nFrameCnt+1;
+		}
+		sEncParam.sourceFrame=&sFramBuf;
+		if(pInOutParam->pInFrame!=NULL)
+		{
+			//user assigned the address to implement crop 
+			sFramBuf.bufY= (PhysicalAddress)pInOutParam->pInFrame->pbufY;
+			nbufYBot=(PhysicalAddress)pInOutParam->pInFrame->pbufY_tilebot;
+			sFramBuf.bufCb = (PhysicalAddress)pInOutParam->pInFrame->pbufCb;
+			nbufCbBot=(PhysicalAddress)pInOutParam->pInFrame->pbufCb_tilebot;
+			sFramBuf.bufCr= (PhysicalAddress)pInOutParam->pInFrame->pbufCr;
+			sFramBuf.strideY= pInOutParam->pInFrame->nStrideY;
+			sFramBuf.strideC = pInOutParam->pInFrame->nStrideC;
+			sFramBuf.bufMvCol = 1; //no mv needed
+		}
+		else
+		{
+			VpuEncSetSrcFrame(pVpuObj->obj.eColor,sEncParam.sourceFrame,(unsigned char*)pInOutParam->nInPhyInput,pInOutParam->nInInputSize,pInOutParam->nPicWidth,pInOutParam->nPicHeight,NULL);
+		}
+		sEncParam.quantParam = pInOutParam->nQuantParam;
+		sEncParam.forceIPicture = pInOutParam->nForceIPicture;
+		sEncParam.skipPicture = pInOutParam->nSkipPicture;
+		sEncParam.enableAutoSkip = pInOutParam->nEnableAutoSkip;
+
+		sEncParam.encLeftOffset = 0;
+		sEncParam.encTopOffset = 0;
+
+		if(pVpuObj->obj.nDynamicEnabled)
+		{
+			//set output for dynmaic method	
+			sEncParam.picStreamBufferAddr=(PhysicalAddress)(pInOutParam->nInPhyOutput+nHeaderLen);
+			//sEncParam.picStreamBufferSize=pInOutParam->nInOutputBufLen;
+		}
+		else
+		{
+			//sEncParam.picStreamBufferAddr=(PhysicalAddress)pVpuObj->obj.pPhyBitstream;
+		}
+
+		if(VPU_DUMP_YUV){
+			int colorformat=0;
+			//if(VPU_V_MJPG==pObj->CodecFormat)
+			//{
+			//	colorformat=pObj->initInfo.nMjpgSourceFormat;
+			//}
+			nPhy_virt_offset=pInOutParam->nInVirtInput-pInOutParam->nInPhyInput;
+			WrapperFileDumpYUV(&fpYUV, (unsigned char*)sEncParam.sourceFrame->bufY+nPhy_virt_offset, (unsigned char*)sEncParam.sourceFrame->bufCb+nPhy_virt_offset, (unsigned char*)sEncParam.sourceFrame->bufCr+nPhy_virt_offset, sEncParam.sourceFrame->strideY*pInOutParam->nPicHeight, sEncParam.sourceFrame->strideC*pInOutParam->nPicHeight/2,colorformat);
+		}	
+
+		if(pVpuObj->obj.nMapType!=0)
+		{
+			if(0==pVpuObj->obj.nLinear2TiledEnable)
+			{
+				VPU_ENC_LOG("tile(maptype: %d) input: usr set addr: Y: 0x%X, Cb: 0x%X \r\n",pVpuObj->obj.nMapType,sEncParam.sourceFrame->bufY,sEncParam.sourceFrame->bufCb);
+				VpuTiledAddressMapping(pVpuObj->obj.nMapType, 
+					(unsigned int)sEncParam.sourceFrame->bufY, nbufYBot, (unsigned int)sEncParam.sourceFrame->bufCb, nbufCbBot, 
+					(unsigned int*)(&sEncParam.sourceFrame->bufY), (unsigned int*)(&sEncParam.sourceFrame->bufCb), (unsigned int*)(&sEncParam.sourceFrame->bufCr));
+				VPU_ENC_LOG("tile(maptype: %d) input: remapped addr: Y: 0x%X, Cb: 0x%X , Cr: 0x%X \r\n",pVpuObj->obj.nMapType,sEncParam.sourceFrame->bufY,sEncParam.sourceFrame->bufCb,sEncParam.sourceFrame->bufCr);
+			}
+		}
+
+		VPU_ENC_LOG("sourceframe: y: 0x%X, u: 0x%X, v: 0x%X, ystride: %d, uvstride: %d, size: %d \r\n",
+			(UINT32)sEncParam.sourceFrame->bufY,(UINT32)sEncParam.sourceFrame->bufCb,(UINT32)sEncParam.sourceFrame->bufCr,
+			(UINT32)sEncParam.sourceFrame->strideY,(UINT32)sEncParam.sourceFrame->strideC,(UINT32)pInOutParam->nInInputSize);
+		VPU_ENC_API("calling vpu_EncStartOneFrame(): dynamic buff: 0x%X , size: %d \r\n",(UINT32)sEncParam.picStreamBufferAddr,sEncParam.picStreamBufferSize);
+		//TIMER_START(...);
+		ret = vpu_EncStartOneFrame(pVpuObj->handle, &sEncParam);
+		if (ret != RETCODE_SUCCESS)
+		{
+			VPU_ENC_ERROR("vpu_EncStartOneFrame failed Err code:%d \r\n",ret);
+			return VPU_ENC_RET_FAILURE;
+		}
+
+		if(-1==VpuEncWaitBusy())
+		{
+			return VPU_ENC_RET_FAILURE_TIMEOUT;
+		}
+
+		//clear 0 firstly ??
+		vpu_memset(&sEncOutInfo, 0, sizeof(EncOutputInfo));
+
+		VPU_ENC_API("calling vpu_EncGetOutputInfo() \r\n");
+		ret = vpu_EncGetOutputInfo(pVpuObj->handle, &sEncOutInfo);
+		if (ret != RETCODE_SUCCESS) 
+		{
+			VPU_ENC_ERROR("vpu_EncGetOutputInfo failed Err code: %d \r\n",ret);
+			return VPU_ENC_RET_FAILURE;
+		}
+		//TIMER_STOP(...);
+		VPU_ENC_LOG("out frame: type: %d, addr: 0x%X, size: %d \r\n",(UINT32)sEncOutInfo.picType,(UINT32)sEncOutInfo.bitstreamBuffer,(UINT32)sEncOutInfo.bitstreamSize);
+
+		if(sEncOutInfo.skipEncoded)
+		{
+			//
+		}
+
+		if(sEncOutInfo.bitstreamBuffer)
+		{
+			//valid output
+			bufRet=(VpuEncBufRetCode)(VPU_ENC_INPUT_USED|VPU_ENC_OUTPUT_DIS);
+			if(0==pVpuObj->obj.nDynamicEnabled)
+			{
+				unsigned char* pVirt=(unsigned char*)((int)pVpuObj->obj.pVirtBitstream+(int)sEncOutInfo.bitstreamBuffer-(int)pVpuObj->obj.pPhyBitstream);
+				ASSERT(pVirt==pVpuObj->obj.pVirtBitstream);
+				VPU_ENC_LOG("frame memcpy: dst: 0x%X, src: 0x%X, size: %d \r\n",(pInOutParam->nInVirtOutput+nHeaderLen),pVirt,sEncOutInfo.bitstreamSize);	
+				vpu_memcpy((void*)(pInOutParam->nInVirtOutput+nHeaderLen),(void*)pVirt,sEncOutInfo.bitstreamSize);
+			}
+		}
+		else
+		{
+			bufRet=(VpuEncBufRetCode)(VPU_ENC_INPUT_USED|VPU_ENC_OUTPUT_NODIS);
+		}
+
+		pInOutParam->nOutOutputSize=sEncOutInfo.bitstreamSize+nHeaderLen;
+		pInOutParam->eOutRetCode=bufRet;
+#ifdef VPU_ENC_SEQ_DATA_SEPERATE		
+		pVpuObj->obj.nJustOutputOneHeader=0;	//output data
+#endif
+		if(pVpuObj->obj.nIsAvcc){
+			VpuConvertToAvccData((unsigned char*)pInOutParam->nInVirtOutput,pInOutParam->nOutOutputSize);
+		}
+	}
+
+	if((unsigned int)pInOutParam->nOutOutputSize > pInOutParam->nInOutputBufLen){
+		VPU_ERROR("memory overflow: buffer size: %d, actual filled size: %d \r\n",pInOutParam->nInOutputBufLen,pInOutParam->nOutOutputSize);
+	}
+	if(VPU_DUMP_RAW){
+		WrapperFileDumpBitstrem(&fpBitstream,(unsigned char*)pInOutParam->nInVirtOutput,pInOutParam->nOutOutputSize);
+	}
+
+	//ASSERT(pInOutParam->nOutOutputSize<=(int)pInOutParam->nInOutputBufLen);
+	return VPU_ENC_RET_SUCCESS;
+}
+
+
+
+
+ 
diff --git a/OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.h b/OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.h
new file mode 100755
index 0000000..e64b64b
--- /dev/null
+++ b/OpenMAXIL/src/component/vpu_wrapper/vpu_wrapper.h
@@ -0,0 +1,697 @@
+/*
+ *  Copyright (c) 2010-2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ *	Vpu_wrapper.h
+ *	header file contain all related vpu interface info
+ *	History :
+ *	Date	(y.m.d)		Author			Version			Description
+ *	2010-09-07		eagle zhou		0.1				Created
+ *	2011-02-17		eagle zhou		0.2				Add encoder part
+ *	2011-12-22		eagle zhou		1.0				refine api
+ *	2012-01-**		eagle zhou		1.0.*			add new features: including tile format,etc
+ */
+
+#ifndef VPU_WRAPPER_H
+#define VPU_WRAPPER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**************************** version info ***********************************/
+#define VPU_WRAPPER_VERSION(major, minor, release)	 \
+	(((major) << 16) + ((minor) << 8) + (release))
+#define VPU_WRAPPER_VERSION_CODE	VPU_WRAPPER_VERSION(1, 0, 49)
+
+/**************************** decoder part **********************************/
+
+#define VPU_DEC_MAX_NUM_MEM_REQS 2
+
+//typedef RetCode VpuRetCode;
+//typedef vpu_versioninfo VpuVersionInfo;
+//typedef DecHandle VpuDecHandle;
+typedef unsigned int VpuDecHandle;
+//typedef DecOpenParam VpuDecOpenParam;
+//typedef DecInitialInfo VpuSeqInfo;
+//typedef FrameBuffer VpuFrameBuffer;
+//typedef DecBufInfo VpuDecBufInfo;
+//typedef CodecCommand VpuCodecCommand;
+//typedef DecParam VpuDecParam;
+
+typedef enum {
+	VPU_DEC_ERR_UNFOUND=0,
+	VPU_DEC_ERR_NOT_SUPPORTED, /*the profile/level/features/... outrange the vpu's capability*/
+	VPU_DEC_ERR_CORRUPT, /*some syntax errors are detected*/
+}VpuDecErrInfo;
+
+typedef enum {
+	VPU_V_MPEG4 = 0,
+	VPU_V_DIVX3,
+	VPU_V_DIVX4,
+	VPU_V_DIVX56,
+	VPU_V_XVID,
+	VPU_V_H263,
+	VPU_V_AVC,
+	VPU_V_AVC_MVC,
+	VPU_V_VC1,
+	VPU_V_VC1_AP,
+	VPU_V_MPEG2,
+	VPU_V_RV,
+	VPU_V_MJPG,
+	VPU_V_AVS,
+	VPU_V_VP8,
+} VpuCodStd;
+
+typedef enum {
+	VPU_DEC_SKIPNONE=0,
+	VPU_DEC_SKIPPB,
+	VPU_DEC_SKIPB,
+	VPU_DEC_SKIPALL,
+	VPU_DEC_ISEARCH,	/*only decode IDR*/
+}VpuDecSkipMode;
+
+typedef enum {
+	VPU_DEC_IN_NORMAL=0,
+	VPU_DEC_IN_KICK,
+	VPU_DEC_IN_DRAIN,
+}VpuDecInputType;
+
+typedef enum {
+	VPU_DEC_CONF_SKIPMODE=0,		/*parameter value: VPU_DEC_SKIPNONE(default); VPU_DEC_SKIPPB; VPU_DEC_SKIPB; VPU_DEC_SKIPALL;VPU_DEC_ISEARCH*/
+	VPU_DEC_CONF_INPUTTYPE,		/*parameter value:
+										VPU_DEC_IN_NOMAL: normal(default)
+										VPU_DEC_IN_KICK: kick -- input data/size in VPU_DecDecodeBuf() will be ignored
+										VPU_DEC_IN_DRAIN: drain -- stream reach end, and input data/size in VPU_DecDecodeBuf() will be ignored
+									*/
+	//VPU_DEC_CONF_BLOCK,
+	//VPU_DEC_CONF_NONEBLOCK,
+	VPU_DEC_CONF_BUFDELAY,		/*for stream mode:
+									    parameter represent buf size(unit: bytes), buffer size==0 indicate no any delay*/
+	VPU_DEC_CONF_INIT_CNT_THRESHOLD,  /*at seqinit stage: vpu will report error if data count reach the threshold*/
+} VpuDecConfig;
+
+typedef enum 
+{
+	VPU_DEC_RET_SUCCESS = 0,
+	VPU_DEC_RET_FAILURE,
+	VPU_DEC_RET_INVALID_PARAM,
+	VPU_DEC_RET_INVALID_HANDLE,
+	VPU_DEC_RET_INVALID_FRAME_BUFFER,
+	VPU_DEC_RET_INSUFFICIENT_FRAME_BUFFERS,
+	VPU_DEC_RET_INVALID_STRIDE,
+	VPU_DEC_RET_WRONG_CALL_SEQUENCE,
+	VPU_DEC_RET_FAILURE_TIMEOUT,
+}VpuDecRetCode;
+
+typedef enum
+{
+	/* bit[0]: input buf info */
+	VPU_DEC_INPUT_NOT_USED=0x0,
+	VPU_DEC_INPUT_USED=0x1,
+	/* bit[1:6]: frame output info */
+	VPU_DEC_OUTPUT_EOS=0x2,
+	VPU_DEC_OUTPUT_DIS=0x4,			/*one frame is output*/
+	VPU_DEC_OUTPUT_NODIS=0x8,		/*no frame output*/
+	VPU_DEC_OUTPUT_REPEAT=0x10,		/*one frame is output repeatly: mainly for VC1 specification: user need to get one timestamp*/
+	VPU_DEC_OUTPUT_DROPPED=0x20,	/*for unclose gop case: (1) drop B or (2) drop non-I frame: user need to get one timestamp*/
+	VPU_DEC_OUTPUT_MOSAIC_DIS=0x40,	/*for unclose gop case: the frame will be output, but not dropped by decoder: user need to get one timestamp*/
+	/* bit[7:8]: frame output info */
+	VPU_DEC_NO_ENOUGH_BUF=0x80,		/*no enough frame buffer*/
+	VPU_DEC_NO_ENOUGH_INBUF=0x100,	/*no enough input buffer: to avoid null run*/
+	/* bit[9]: init output info */
+	VPU_DEC_INIT_OK=0x200,			/*user need to call VPU_DecGetInitialInfo()*/
+	/* bit[10]: skip decode */
+	VPU_DEC_SKIP=0x400,				/*added for cases: need to get two time stamp*/
+										/*not decoded: interlace or corrupt: user need to get one time stamp*/
+	/*bit[11]: reserved to represent one frame is decoded*/
+	VPU_DEC_ONE_FRM_CONSUMED=0x800,/*added for case: need to get decoded(or skipped,corrupt...) frame length*/
+										/*user may call related api to get the decoded/skipped/.. frame related info*/
+	/*bit[12]: reolution changed*/	
+	VPU_DEC_RESOLUTION_CHANGED=0x1000,/*added for case: upward change in resolution*/
+										/*user need to release all frames, call VPU_DecGetInitialInfo() and re-allocation/register frames according to new bigger resolution*/	
+	/* bit[31]: flush is recommended */
+	VPU_DEC_FLUSH=0x80000000,			/*for some clisps, special for h.264 TS stream(may has no IDR at all), the random start/seek point may introduce unrecoverable mosaic*/
+}VpuDecBufRetCode;
+
+typedef enum {
+	VPU_DEC_CAP_FILEMODE=0,	/* file mode is supported ? 0: not; 1: yes*/
+	VPU_DEC_CAP_TILE,			/* tile format is supported ? 0: not; 1: yes*/
+	VPU_DEC_CAP_FRAMESIZE,	/* reporting frame size  ? 0: not; 1: yes*/
+	VPU_DEC_CAP_RESOLUTION_CHANGE, /*resolution change notification ? 0: not; 1: yes*/
+}VpuDecCapability;
+
+typedef enum 
+{
+	VPU_MEM_VIRT   = 0,    	/* 0 for virtual Memory */
+	VPU_MEM_PHY    = 1,		/* 1 for physical continuous Memory */
+}VpuMemType;
+
+typedef enum
+{
+	VPU_I_PIC=0,			/*I frame or I sclie(H.264)*/
+	VPU_P_PIC,				/*P frame or P sclie(H.264)*/
+	VPU_B_PIC,				/*B frame or B sclie(H.264)*/
+	VPU_IDR_PIC,			/*IDR frame(H.264)*/
+	VPU_BI_PIC,				/*BI frame(VC1)*/
+	VPU_SKIP_PIC,			/*Skipped frame(VC1)*/
+	VPU_UNKNOWN_PIC,		/*reserved*/
+}VpuPicType;
+
+typedef enum
+{
+	VPU_FIELD_NONE=0,		/*frame*/
+	VPU_FIELD_TOP,			/*only top field*/
+	VPU_FIELD_BOTTOM,		/*only bottom field*/
+	VPU_FIELD_TB,			/*top field + bottom field*/
+	VPU_FIELD_BT,			/*bottom field + top field*/
+	VPU_FIELD_UNKNOWN,	/*reserved*/
+}VpuFieldType;
+
+typedef struct {
+	int nAlignment;			/* alignment limitation */
+	int	nSize;				/* Size in bytes */
+	VpuMemType MemType; /* Flag to indicate Static, Scratch or output data memory */
+	unsigned char* pVirtAddr;		/* virtual address:Pointer to the base memory , which will be allocated and filled by the application*/
+	unsigned char* pPhyAddr;		/* physical address: Pointer to the base memory , which will be allocated and filled by the application*/
+
+	int nReserved[3];				/*reserved for future extension*/
+} VpuMemSubBlockInfo;
+
+typedef struct{
+	int nSubBlockNum;
+	VpuMemSubBlockInfo MemSubBlock[VPU_DEC_MAX_NUM_MEM_REQS];
+}VpuMemInfo;
+
+
+typedef struct 
+{
+	int nFwMajor;		/* firmware major version */
+	int nFwMinor;		/* firmware minor version */
+	int nFwRelease;		/* firmware release version */
+	int nFwCode;			/* firmware code version */
+	int nLibMajor;		/* library major version */
+	int nLibMinor;		/* library minor version */
+	int nLibRelease;		/* library release version */
+	int nReserved;		/*reserved for future extension*/
+}VpuVersionInfo;
+
+typedef struct 
+{
+	int nMajor;		/* major version */
+	int nMinor;		/* minor version */
+	int nRelease;		/* release version */
+	char* pBinary;	/* version info specified by user(such as build time), below is one example in makefile:
+					     CFLAGS+=-DUSER_SPECIFY_BINARY_VER -DSTR_USER_SPECIFY_BINARY_VER=\"binary version specified by user\"
+					*/
+	int nReserved[4];	/*reserved for future extension*/
+}VpuWrapperVersionInfo;
+
+typedef struct {
+	VpuCodStd CodecFormat;
+	//unsigned int bitstreamBuffer;
+	//int bitstreamBufferSize;
+	//int qpReport;
+	//int mp4DeblkEnable;
+	int nReorderEnable;
+	int nChromaInterleave;	//should be set to 1 when (nMapType!=0)
+	int nMapType;			//registered frame buffer type: 0--linear; 1--frame tile; 2--field tile
+	int nTiled2LinearEnable;	//output frame(only valid when nMapType!=0) : 0--tile. eg. same with registered frame ; 1--linear(not supported)  
+	//int filePlayEnable;
+	int nPicWidth;
+	int nPicHeight;
+	//int dynamicAllocEnable;
+	//int streamStartByteOffset;
+	//int mjpg_thumbNailDecEnable;
+	//unsigned int psSaveBuffer;
+	//int psSaveBufferSize;
+	//int mp4Class;
+	//int block;
+	int nEnableFileMode;
+
+	int nReserved[3];			/*reserved for future extension*/
+	void* pAppCxt;			/*reserved for future application extension*/
+} VpuDecOpenParam;
+
+
+typedef struct {
+	/* stride info */
+	unsigned int nStrideY;
+	unsigned int nStrideC;
+
+	/* physical address */
+	unsigned char* pbufY;			//luma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufCb;		//chroma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufCr;
+	unsigned char* pbufMvCol;
+	unsigned char* pbufY_tilebot;	//for field tile: luma bottom pointer
+	unsigned char* pbufCb_tilebot;	//for field tile: chroma bottom pointer
+	//unsigned char* pbufCr_tilebot;	//not required since always enable interleave for tile
+
+	/* virtual address */
+	unsigned char* pbufVirtY;		//luma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufVirtCb;		//chroma frame pointer or top field pointer(for field tile)
+	unsigned char* pbufVirtCr;
+	unsigned char* pbufVirtMvCol;
+	unsigned char* pbufVirtY_tilebot;	//for field tile: luma bottom pointer
+	unsigned char* pbufVirtCb_tilebot;	//for field tile: chroma bottom pointer
+	//unsigned char* pbufVirtCr_tilebot;	//not required since always enable interleave for tile
+
+	int nReserved[5];				/*reserved for future extension*/
+	void* pPrivate;				/*reserved for future special extension*/
+} VpuFrameBuffer;
+
+typedef struct {
+	unsigned int nLeft;
+	unsigned int nTop;
+	unsigned int nRight;
+	unsigned int nBottom;
+} VpuRect;
+
+//typedef struct {
+//	unsigned int sliceSaveBuffer;
+//	int sliceSaveBufferSize;
+//} VpuDecAvcSliceBufInfo;
+
+//typedef struct {
+//	VpuDecAvcSliceBufInfo avcSliceBufInfo;
+//} VpuDecBufInfo;
+
+
+typedef struct {
+	int nPicWidth;		// {(PicX+15)/16} * 16
+	int nPicHeight;		// {(PicY+15)/16} * 16
+	int nFrameRateRes;	// frameinfo: numerator.  <=0 represent invalid
+	int nFrameRateDiv;	// frameinfo: denominator. <=0 represent invalid
+	VpuRect PicCropRect;
+
+	//int mp4_dataPartitionEnable;
+	//int mp4_reversibleVlcEnable;
+	//int mp4_shortVideoHeader;
+	//int h263_annexJEnable;
+
+	int nMinFrameBufferCount;
+	//int frameBufDelay;
+	//int nextDecodedIdxNum;
+	//int normalSliceSize;
+	//int worstSliceSize;
+	//int mjpg_thumbNailEnable;
+	int nMjpgSourceFormat;
+
+	//int streamInfoObtained;
+	//int profile;
+	//int level;
+	int nInterlace;
+	//int constraint_set_flag[4];
+	//int direct8x8Flag;
+	//int vc1_psf;
+	unsigned int nQ16ShiftWidthDivHeightRatio;	//fixed point for width/height: 1: 0x10000; 0.5: 0x8000;...
+	//Uint32 errorcode;
+	int nConsumedByte;		/*reserved to record sequence length: value -1 indicate unknow*/
+	//DecReportBufSize reportBufSize;
+	int nAddressAlignment;	/*address alignment for Y/Cb/Cr (unit: bytes)*/
+
+	int nReserved[5];			/*reserved for future extension*/
+	void* pSpecialInfo;		/*reserved for future special extension*/
+} VpuDecInitInfo;
+
+/*
+typedef struct {
+	//int prescanEnable;
+	//int prescanMode;
+	//int dispReorderBuf;
+	//int iframeSearchEnable;
+	int skipframeMode;
+	//int skipframeNum;
+#if 0  //move into 	VPU_DecDecBuf(..., VpuBufferNode* pInData,...)
+	int chunkSize;
+	int picStartByteOffset;
+	unsigned int picStreamBufferAddr;
+#endif	
+} VpuDecParam;
+*/
+
+typedef struct {
+	int nFrmWidth;			/*support dynamic resolution*/
+	int nFrmHeight;			/*support dynamic resolution*/
+	VpuRect FrmCropRect;	/*support dynamic resolution*/
+	unsigned int nQ16ShiftWidthDivHeightRatio;	/*support dynamic ratio, refer to definition in struct 'VpuDecInitInfo'*/
+	int nReserved[9];		/*reserved for recording other info*/
+}VpuFrameExtInfo;
+
+typedef struct {
+	//int indexFrameDisplay;
+	//int indexFrameDecoded;
+	VpuFrameBuffer * pDisplayFrameBuf;
+	//VpuFrameBuffer * pDecodedFrameBuf;
+	//int NumDecFrameBuf;
+	VpuPicType ePicType;
+	//int numOfErrMBs;
+	//Uint32 *qpInfo;
+	//int hScaleFlag;
+	//int vScaleFlag;
+	//int indexFrameRangemap;
+	//int prescanresult;
+	//int notSufficientPsBuffer;
+	//int notSufficientSliceBuffer;
+	//int decodingSuccess;
+	//int interlacedFrame;
+	//int mp4PackedPBframe;
+	//int h264Npf;
+
+	//int pictureStructure;
+	//int nTopFieldFirst;
+	//int nRepeatFirstField;
+	//union {
+	//    int progressiveFrame;
+	//    int vc1_repeatFrame;
+	//};
+	//int fieldSequence;
+
+	//int decPicHeight;
+	//int decPicWidth;
+	//Rect decPicCrop;
+
+	//DecReportInfo mbInfo;
+	//DecReportInfo mvInfo;
+	//DecReportInfo frameBufStat;
+	//DecReportInfo userData;
+	//int nConsumedByte;		/*reserved to record frame length: value -1 indicate unknow*/
+	VpuFieldType	eFieldType;	/*added for user to implement deinterlace process*/
+	int nMVCViewID;	/*used to indicate which view of MVC clips*/
+
+	VpuFrameExtInfo * pExtInfo;	/*extended info: support dynamic resolution, ...*/
+	int nReserved[2];			/*reserved for future extension*/
+	void* pPrivate;			/*reserved for future special extension*/
+} VpuDecOutFrameInfo;
+
+
+typedef struct
+{
+	unsigned char* pData;		/*buffer virtual addr*/
+	unsigned int nSize;		/*valid data length */	
+}VpuCodecData;
+
+
+typedef struct
+{
+	unsigned char* pPhyAddr;	/*buffer physical base addr*/
+	unsigned char* pVirAddr;	/*buffer virtual base addr*/
+	unsigned int nSize;		/*valid data length */
+	VpuCodecData sCodecData;	/*private data specified by codec*/
+
+	int nReserved[2];				/*reserved for future extension*/
+	void* pPrivate;				/*reserved for future special extension*/
+}VpuBufferNode;
+
+typedef struct 
+{
+	int nSize;				/*!requested memory size */
+	unsigned long nPhyAddr;	/*!physical memory address allocated */
+	unsigned long nCpuAddr;	/*!cpu addr for system free usage */
+	unsigned long nVirtAddr;	/*!virtual user space address */	
+	int nReserved[4];			/*reserved for future extension*/
+}VpuMemDesc;
+
+typedef struct {
+	VpuFrameBuffer* pFrame;	/*point to the frame buffer. if it is NULL, it represent the frame is skipped by vpu, but the other length info are still valid*/
+	int nStuffLength;			/*stuff data length ahead of frame. If it is < 0, mean the config data contain some valid frames, user need to process this case carefully*/
+	int nFrameLength;		/*valid frame length: should be > 0*/
+	int nReserved[5];			/*reserved for recording other info*/
+}VpuDecFrameLengthInfo;
+
+/**************************** encoder part **********************************/
+
+typedef unsigned int VpuEncHandle;
+
+typedef enum
+{
+	/*the value comply with the vpu lib header file, don't change it !*/
+	VPU_COLOR_420=0,
+	VPU_COLOR_422H=1,
+	VPU_COLOR_422V=2,
+	VPU_COLOR_444=3,	
+	VPU_COLOR_400=4,
+}VpuColorFormat;
+
+typedef enum {
+	VPU_ENC_MIRDIR_NONE,
+	VPU_ENC_MIRDIR_VER,
+	VPU_ENC_MIRDIR_HOR,
+	VPU_ENC_MIRDIR_HOR_VER
+} VpuEncMirrorDirection;
+
+typedef struct {
+	int nMinFrameBufferCount;
+	int nAddressAlignment;		/*address alignment for Y/Cb/Cr (unit: bytes)*/
+} VpuEncInitInfo;
+
+typedef enum 
+{
+	VPU_ENC_RET_SUCCESS = 0,
+	VPU_ENC_RET_FAILURE,
+	VPU_ENC_RET_INVALID_PARAM,
+	VPU_ENC_RET_INVALID_HANDLE,
+	VPU_ENC_RET_INVALID_FRAME_BUFFER,
+	VPU_ENC_RET_INSUFFICIENT_FRAME_BUFFERS,
+	VPU_ENC_RET_INVALID_STRIDE,
+	VPU_ENC_RET_WRONG_CALL_SEQUENCE,
+	VPU_ENC_RET_FAILURE_TIMEOUT,
+}VpuEncRetCode;
+
+typedef enum
+{
+	/* bit[0]: input buf info */
+	VPU_ENC_INPUT_NOT_USED=0x0,
+	VPU_ENC_INPUT_USED=0x1,
+	/* bit[1:4]: frame output info */
+	//VPU_ENC_OUTPUT_EOS=,
+	VPU_ENC_OUTPUT_SEQHEADER=0x4,	/*sequence header(for H.264: SPS/PPS)*/
+	VPU_ENC_OUTPUT_DIS=0x8,
+	VPU_ENC_OUTPUT_NODIS=0x10,
+	//VPU_ENC_OUTPUT_REPEAT=,	
+}VpuEncBufRetCode;
+
+typedef struct {
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nRotAngle;
+	int nFrameRate;
+	int nBitRate;				/*unit: kbps*/
+	int nGOPSize;
+	int nIntraRefresh;		/*intra macro block numbers*/
+	int nIntraQP;				/*0: auto, >0: qp value*/
+	int nChromaInterleave;	/*should be set to 1 when (nMapType!=0)*/
+	VpuEncMirrorDirection sMirror;
+	//int nQuantParam;
+	int nMapType;			/*frame buffer: 0--linear ; 1--frame tile; 2--field tile*/
+	int nLinear2TiledEnable; 	/*valid when (nMapType!=0): 0--tile input; 1--yuv input*/
+	VpuColorFormat eColorFormat;	/*only MJPG support non-420*/
+	int nIsAvcc;				/*it is used for H.264 data format, 0: byte stream ; 1: avcc format*/
+
+	int nReserved[3];				/*reserved for future extension*/
+	void* pAppCxt;				/*reserved for future extension*/
+} VpuEncOpenParamSimp;
+
+typedef struct {
+	int sliceMode;
+	int sliceSizeMode;
+	int sliceSize;
+	int nReserved;			/*reserved for future extension*/
+} VpuEncSliceMode;
+
+typedef struct {
+	int mp4_dataPartitionEnable;
+	int mp4_reversibleVlcEnable;
+	int mp4_intraDcVlcThr;
+	int mp4_hecEnable;
+	int mp4_verid;
+	int nReserved[3];			/*reserved for future extension*/
+} VpuEncMp4Param;
+
+typedef struct {
+	int h263_annexIEnable;	
+	int h263_annexJEnable;
+	int h263_annexKEnable;
+	int h263_annexTEnable;
+	int nReserved[4];			/*reserved for future extension*/
+} VpuEncH263Param;
+
+typedef struct {
+	int avc_constrainedIntraPredFlag;
+	int avc_disableDeblk;
+	int avc_deblkFilterOffsetAlpha;
+	int avc_deblkFilterOffsetBeta;
+	int avc_chromaQpOffset;
+	int avc_audEnable;
+	int avc_fmoEnable;
+	int avc_fmoSliceNum;
+	int avc_fmoType;
+	int avc_fmoSliceSaveBufSize;
+	int nReserved[6];				/*reserved for future extension*/
+} VpuEncAvcParam;
+
+typedef struct {
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nRotAngle;
+	int nFrameRate;
+	int nBitRate;				/*unit: kbps*/
+	int nGOPSize;
+	int nChromaInterleave;	/*should be set to 1 when (nMapType!=0)*/
+	VpuEncMirrorDirection sMirror;
+	//int nQuantParam;
+	int nMapType;			/*frame buffer: 0--linear ; 1--frame tile; 2--field tile*/
+	int nLinear2TiledEnable; 	/*valid when (nMapType!=0): 0--tile input; 1--yuv input*/
+	VpuColorFormat eColorFormat;	/*only MJPG support non-420*/
+
+	int nUserQpMax;
+	int nUserQpMin;
+	int nUserQpMinEnable;
+	int nUserQpMaxEnable;
+
+	int nIntraRefresh;
+	int nRcIntraQp;
+
+	int nUserGamma;
+	int nRcIntervalMode;		/* 0:normal, 1:frame_level, 2:slice_level, 3: user defined Mb_level */
+	int nMbInterval;			/* use when RcintervalMode is 3 */
+	int nAvcIntra16x16OnlyModeEnable;
+	
+	VpuEncSliceMode sliceMode;
+
+	int nInitialDelay;
+	int nVbvBufferSize;
+	union {
+		VpuEncMp4Param mp4Param;
+		VpuEncH263Param h263Param;
+		VpuEncAvcParam avcParam;
+		//EncMjpgParam mjpgParam;
+	} VpuEncStdParam;
+
+	int nMESearchRange;      // 3: 16x16, 2:32x16, 1:64x32, 0:128x64, H.263(Short Header : always 3)
+	int nMEUseZeroPmv;       // 0: PMV_ENABLE, 1: PMV_DISABLE
+	int nIntraCostWeight;    // Additional weight of Intra Cost for mode decision to reduce Intra MB density
+	int nIsAvcc;				/*it is used for H.264 data format, 0: byte stream ; 1: avcc format*/
+
+	int nReserved[8];				/*reserved for future extension*/
+	void* pAppCxt;			/*reserved for future extension*/
+} VpuEncOpenParam;
+
+typedef struct {
+//[IN]	
+	VpuCodStd eFormat;
+	int nPicWidth;
+	int nPicHeight;	
+	int nFrameRate;
+	int nQuantParam;
+
+	unsigned int nInPhyInput;	//input buffer address
+	unsigned int nInVirtInput;
+	int nInInputSize;	
+	unsigned int nInPhyOutput;	//output frame address
+	unsigned int nInVirtOutput;
+	unsigned int nInOutputBufLen;
+
+	/*advanced options*/
+	int nForceIPicture;
+	int nSkipPicture;
+	int nEnableAutoSkip;
+	
+//[OUT]	
+	VpuEncBufRetCode eOutRetCode;
+	int nOutOutputSize;
+//[Reserved]
+	VpuFrameBuffer * pInFrame;/*extended for advanced user to set crop info: if this pointer isn't null, the Y/Cb/Cr address in this struct will be adopted*/
+	int nReserved[2];			/*reserved for future extension*/
+	void* pPrivate;			/*reserved for future extension*/
+} VpuEncEncParam;
+
+typedef enum {
+	VPU_ENC_CONF_NONE=0,
+	//VPU_DEC_CONF_SKIPPB,
+	//VPU_DEC_CONF_SKIPB,	
+	//VPU_DEC_CONF_SKIPALL,
+	//VPU_DEC_CONF_ISEARCH,
+	//VPU_DEC_CONF_BLOCK,
+	//VPU_DEC_CONF_NONEBLOCK,
+	VPU_ENC_CONF_BIT_RATE,  /*parameter: kbps*/
+	VPU_ENC_CONF_INTRA_REFRESH, /*intra refresh: minimum number of macroblocks to refresh in a frame*/
+	VPU_ENC_CONF_ENA_SPSPPS_IDR, /*some muxers may ignore the sequence or config data(such as ts muxer), so SPS/PPS is needed for every IDR frame, including the first IDR*/
+	VPU_ENC_CONF_RC_INTRA_QP, /*intra qp value*/
+	VPU_ENC_CONF_INTRA_REFRESH_MODE, /*intra refresh mode: 0: normal; 1: cyclic*/
+} VpuEncConfig;
+
+
+
+/********************************** decoder APIs ***************************************/
+
+VpuDecRetCode VPU_DecLoad();
+VpuDecRetCode VPU_DecGetVersionInfo(VpuVersionInfo * pOutVerInfo);
+VpuDecRetCode VPU_DecGetWrapperVersionInfo(VpuWrapperVersionInfo * pOutVerInfo);
+VpuDecRetCode VPU_DecQueryMem(VpuMemInfo* pOutMemInfo);
+VpuDecRetCode VPU_DecOpen(VpuDecHandle *pOutHandle, VpuDecOpenParam * pInParam,VpuMemInfo* pInMemInfo);
+VpuDecRetCode VPU_DecGetCapability(VpuDecHandle InHandle,VpuDecCapability eInCapability, int* pOutCapbility);
+VpuDecRetCode VPU_DecDisCapability(VpuDecHandle InHandle,VpuDecCapability eInCapability);
+
+//VpuDecRetCode VPU_DecSeqInit(VpuDecHandle InHandle, VpuBufferNode* pInData, VpuSeqInfo * pOutInfo);
+VpuDecRetCode VPU_DecConfig(VpuDecHandle InHandle, VpuDecConfig InDecConf, void* pInParam); 
+VpuDecRetCode VPU_DecDecodeBuf(VpuDecHandle InHandle, VpuBufferNode* pInData,int* pOutBufRetCode);
+VpuDecRetCode VPU_DecGetInitialInfo(VpuDecHandle InHandle, VpuDecInitInfo * pOutInitInfo);
+
+VpuDecRetCode VPU_DecRegisterFrameBuffer(VpuDecHandle InHandle,VpuFrameBuffer *pInFrameBufArray, int nNum);
+
+VpuDecRetCode VPU_DecGetOutputFrame(VpuDecHandle InHandle, VpuDecOutFrameInfo * pOutFrameInfo);
+VpuDecRetCode VPU_DecGetConsumedFrameInfo(VpuDecHandle InHandle,VpuDecFrameLengthInfo* pOutFrameInfo);
+
+VpuDecRetCode VPU_DecOutFrameDisplayed(VpuDecHandle InHandle, VpuFrameBuffer* pInFrameBuf);
+
+//VpuDecRetCode VPU_DecFlushLeftStream(VpuDecHandle InHandle);
+//VpuDecRetCode VPU_DecFlushLeftFrame(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecFlushAll(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecAllRegFrameInfo(VpuDecHandle InHandle, VpuFrameBuffer** ppOutFrameBuf, int* pOutNum);
+VpuDecRetCode VPU_DecGetNumAvailableFrameBuffers(VpuDecHandle InHandle,int* pOutBufNum);
+
+VpuDecRetCode VPU_DecClose(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecUnLoad();
+
+VpuDecRetCode VPU_DecReset(VpuDecHandle InHandle);
+VpuDecRetCode VPU_DecGetErrInfo(VpuDecHandle InHandle,VpuDecErrInfo* pErrInfo);
+
+VpuDecRetCode VPU_DecGetMem(VpuMemDesc* pInOutMem);
+VpuDecRetCode VPU_DecFreeMem(VpuMemDesc* pInMem);
+
+/********************************** encoder APIs ***************************************/
+VpuEncRetCode VPU_EncLoad();
+VpuEncRetCode VPU_EncUnLoad();
+VpuEncRetCode VPU_EncReset(VpuEncHandle InHandle);
+VpuEncRetCode VPU_EncOpenSimp(VpuEncHandle *pOutHandle, VpuMemInfo* pInMemInfo,VpuEncOpenParamSimp * pInParam);
+VpuEncRetCode VPU_EncOpen(VpuEncHandle *pOutHandle, VpuMemInfo* pInMemInfo,VpuEncOpenParam* pInParam);
+VpuEncRetCode VPU_EncClose(VpuEncHandle InHandle);
+VpuEncRetCode VPU_EncGetInitialInfo(VpuEncHandle InHandle, VpuEncInitInfo * pOutInitInfo);
+VpuEncRetCode VPU_EncGetVersionInfo(VpuVersionInfo * pOutVerInfo);
+VpuEncRetCode VPU_EncGetWrapperVersionInfo(VpuWrapperVersionInfo * pOutVerInfo);
+VpuEncRetCode VPU_EncRegisterFrameBuffer(VpuEncHandle InHandle,VpuFrameBuffer *pInFrameBufArray, int nNum,int nSrcStride);
+VpuEncRetCode VPU_EncQueryMem(VpuMemInfo* pOutMemInfo);
+VpuEncRetCode VPU_EncGetMem(VpuMemDesc* pInOutMem);
+VpuEncRetCode VPU_EncFreeMem(VpuMemDesc* pInMem);
+VpuEncRetCode VPU_EncConfig(VpuEncHandle InHandle, VpuEncConfig InEncConf, void* pInParam);
+VpuEncRetCode VPU_EncEncodeFrame(VpuEncHandle InHandle, VpuEncEncParam* pInOutParam);
+VpuEncRetCode VPU_EncEncodeFrame(VpuEncHandle InHandle, VpuEncEncParam* pInOutParam);
+
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  //#ifndef VPU_WRAPPER_H
+
diff --git a/OpenMAXIL/src/core/Android.mk b/OpenMAXIL/src/core/Android.mk
new file mode 100755
index 0000000..cd8c944
--- /dev/null
+++ b/OpenMAXIL/src/core/Android.mk
@@ -0,0 +1,26 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	OMXCore.cpp
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+ 
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) 
+
+LOCAL_SHARED_LIBRARIES := lib_omx_osal_v2_arm11_elinux \
+    			  lib_omx_utils_v2_arm11_elinux \
+			  lib_omx_res_mgr_v2_arm11_elinux
+
+LOCAL_PRELINK_MODULE := false
+
+LOCAL_MODULE:= lib_omx_core_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/OpenMAXIL/src/core/Makefile b/OpenMAXIL/src/core/Makefile
new file mode 100755
index 0000000..f687953
--- /dev/null
+++ b/OpenMAXIL/src/core/Makefile
@@ -0,0 +1,48 @@
+#####################################################################################
+#
+#   Copyright (c) 2009, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+# Set the root directory
+OMX_ROOT_DIR=../../..
+
+# Set the BUILD information
+include $(OMX_ROOT_DIR)/Makefile.defines
+
+CORE_LIB_NAME=core_v2
+CORE_SO_NAME= lib_omx_$(CORE_LIB_NAME)_$(PROCESSOR)_$(OSTYPE).so
+
+LFLAGS+= -l$(OSAL_LIB_NAME) -l$(UTILS_LIB_NAME) -l$(RESOURCE_MGR_LIB_NAME)
+
+SOURCE_FILES = $(SRC_DIR)/OMXCore.cpp \
+
+OBJECTS = $(SOURCE_FILES:.cpp=.o)
+
+all: $(CORE_SO_NAME)
+
+$(CORE_SO_NAME):$(OBJECTS)
+	$(CXX) -shared -Wl,-soname,$(CORE_SO_NAME) -o $(CORE_SO_NAME) $(OBJECTS) $(LFLAGS) 
+
+	mv $(CORE_SO_NAME) $(RELEASE_LIB_DIR)/$(CORE_SO_NAME)
+	@echo "-----------------------------------------------------------------------------------"
+
+.cpp.o:
+	$(CXX) $(CXXFLAGS) -o $@ -c $<
+
+clean:
+	@echo "cleaning ..."
+	rm  -f $(SRC_DIR)/*.o
+	rm  -f $(RELEASE_LIB_DIR)/$(CORE_SO_NAME)
+			
+
+
diff --git a/OpenMAXIL/src/core/OMXCore.cpp b/OpenMAXIL/src/core/OMXCore.cpp
new file mode 100755
index 0000000..4b7e64c
--- /dev/null
+++ b/OpenMAXIL/src/core/OMXCore.cpp
@@ -0,0 +1,1073 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file OpenMAXIL/src/core/OMXCore.cpp
+ *  @brief Open MAX IL core implement.
+ *  @ingroup core
+ */
+
+#include "Mem.h"
+#include "Log.h"
+#include "RegistryAnalyser.h"
+#include "OMXCore.h"
+#include "OMX_Component.h"
+#include "OMX_Implement.h"
+#include "OMX_ContentPipe.h"
+#include "PlatformResourceMgrItf.h"
+
+OMX_ERRORTYPE OMXCore::OMX_Init() 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	lock = NULL;
+	if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&lock, fsl_osal_mutex_normal)) {
+		LOG_ERROR("Create mutex for camera device failed.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	LibMgr = FSL_NEW(ShareLibarayMgr, ());
+        if(LibMgr == NULL)
+            return OMX_ErrorInsufficientResources;
+
+	/** Get component info of the core */
+	ret = ComponentRegister();
+	if (ret != OMX_ErrorNone)
+	{
+		return ret;
+	}
+
+	/** Get content pipe info of the core */
+	ret = ContentPipeRegister();
+	if (ret != OMX_ErrorNone)
+	{
+		return ret;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::ComponentRegister()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	REG_ERRORTYPE ret_reg;
+	OMX_STRING ComponentRegisterFile;
+	OMX_U32 EntryIndex;
+	List<REG_ENTRY> *RegEntry;
+	RegistryAnalyser RegistryAnalyser;
+
+	ComponentRegisterFile = fsl_osal_getenv_new("COMPONENT_REGISTER_FILE");
+	if (ComponentRegisterFile == NULL)
+	{
+		LOG_WARNING("Can't get component register file.\n");
+		ComponentRegisterFile = (OMX_STRING)"/etc/omx_registry/component_register";
+	}
+
+	ret_reg = RegistryAnalyser.Open(ComponentRegisterFile);
+	if (ret_reg != REG_SUCCESS)
+	{
+		LOG_ERROR("Open component register file fail.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	do
+	{
+		RegEntry = RegistryAnalyser.GetNextEntry();
+		if (RegEntry->GetNodeCnt() == 0)
+		{
+			LOG_DEBUG("Read register finished.\n");
+			break;
+		}
+
+		COMPONENT_INFO *pComponentInfo = FSL_NEW(COMPONENT_INFO, ());
+		if (pComponentInfo == NULL)
+		{
+			LOG_ERROR("Can't get memory.\n");
+			return OMX_ErrorInsufficientResources;
+		}
+
+		fsl_osal_memset(pComponentInfo, 0, sizeof(COMPONENT_INFO));
+
+		for (EntryIndex=0; ;EntryIndex++)
+		{
+			REG_ENTRY *pRegEntryItem = RegEntry->GetNode(EntryIndex);
+			if (pRegEntryItem == NULL)
+			{
+				break;
+			}
+			else
+			{
+				if (!fsl_osal_strcmp(pRegEntryItem->name, "component_name"))
+				{
+					fsl_osal_strcpy((fsl_osal_char *)pComponentInfo->ComponentName, \
+							pRegEntryItem->value);
+				}
+				else if (!fsl_osal_strcmp(pRegEntryItem->name, "component_role"))
+				{
+					ROLE_INFO *pRoleInfo = FSL_NEW(ROLE_INFO, ());
+					fsl_osal_memset(pRoleInfo, 0, sizeof(ROLE_INFO));
+					fsl_osal_strcpy((fsl_osal_char *)pRoleInfo->role, pRegEntryItem->value);
+					pRoleInfo->priority = 3;
+					EntryIndex ++;
+					REG_ENTRY *pRegEntryItem = RegEntry->GetNode(EntryIndex);
+					if (pRegEntryItem == NULL)
+					{
+						break;
+					}
+
+					if (!fsl_osal_strcmp(pRegEntryItem->name, "role_priority"))
+					{
+						pRoleInfo->priority = fsl_osal_atoi(pRegEntryItem->value);
+					}
+					else
+					{
+						EntryIndex --;
+					}
+
+					pComponentInfo->RoleList.Add(pRoleInfo);
+				}
+				else if (!fsl_osal_strcmp(pRegEntryItem->name, "library_path"))
+				{
+					fsl_osal_strcpy((fsl_osal_char *)pComponentInfo->LibName, \
+							pRegEntryItem->value);
+				}
+				else if (!fsl_osal_strcmp(pRegEntryItem->name, "component_entry_function"))
+				{
+					fsl_osal_strcpy((fsl_osal_char *)pComponentInfo->EntryFunction, \
+							pRegEntryItem->value);
+				}
+				else
+				{
+					LOG_WARNING("Unknow register entry.\n");
+				}
+			}
+		}
+
+		ComponentList.Add(pComponentInfo);
+
+	}while (1);
+
+	ret_reg = RegistryAnalyser.Close();
+	if (ret_reg != REG_SUCCESS)
+	{
+		LOG_ERROR("Registry analyser close fail.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::ContentPipeRegister()
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	REG_ERRORTYPE ret_reg;
+	OMX_STRING ContentPipeRegisterFile;
+	OMX_U32 EntryIndex;
+	List<REG_ENTRY> *RegEntry;
+	RegistryAnalyser RegistryAnalyser;
+
+	ContentPipeRegisterFile = fsl_osal_getenv_new("CONTENTPIPE_REGISTER_FILE");
+	if (ContentPipeRegisterFile == NULL)
+	{
+		LOG_WARNING("Can't get content pipe register file.\n");
+		ContentPipeRegisterFile = (OMX_STRING)"/etc/omx_registry/contentpipe_register";
+	}
+
+	ret_reg = RegistryAnalyser.Open(ContentPipeRegisterFile);
+	if (ret_reg != REG_SUCCESS)
+	{
+		LOG_ERROR("Open contentpipe register file fail.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	do
+	{
+		RegEntry = RegistryAnalyser.GetNextEntry();
+		if (RegEntry->GetNodeCnt() == 0)
+		{
+			LOG_DEBUG("Read register finished.\n");
+			break;
+		}
+
+		CONTENTPIPE_INFO *pContentPipeInfo = FSL_NEW(CONTENTPIPE_INFO, ());
+		if (pContentPipeInfo == NULL)
+		{
+			LOG_ERROR("Can't get memory.\n");
+			return OMX_ErrorInsufficientResources;
+		}
+
+		fsl_osal_memset(pContentPipeInfo, 0, sizeof(CONTENTPIPE_INFO));
+
+		for (EntryIndex=0; ;EntryIndex++)
+		{
+			REG_ENTRY *pRegEntryItem = RegEntry->GetNode(EntryIndex);
+			if (pRegEntryItem == NULL)
+			{
+				break;
+			}
+			else
+			{
+				if (!fsl_osal_strcmp(pRegEntryItem->name, "content_pipe_name"))
+				{
+					fsl_osal_strcpy((fsl_osal_char *)pContentPipeInfo->ContentPipeName, \
+							pRegEntryItem->value);
+				}
+				else if (!fsl_osal_strcmp(pRegEntryItem->name, "content_pipe_library_path"))
+				{
+					fsl_osal_strcpy((fsl_osal_char *)pContentPipeInfo->LibName, \
+							pRegEntryItem->value);
+				}
+				else if (!fsl_osal_strcmp(pRegEntryItem->name, "content_pipe_entry_function"))
+				{
+					fsl_osal_strcpy((fsl_osal_char *)pContentPipeInfo->EntryFunction, \
+							pRegEntryItem->value);
+				}
+				else
+				{
+					LOG_ERROR("Unknow register entry.\n");
+				}
+			}
+		}
+
+		ContentPipeList.Add(pContentPipeInfo);
+
+	}while (1);
+
+	ret_reg = RegistryAnalyser.Close();
+	if (ret_reg != REG_SUCCESS)
+	{
+		LOG_ERROR("Registry analyser close fail.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_Deinit() 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	/** Free all component */
+	ret = FreeAllComponent();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Free all component fail.\n");
+		return ret;
+	}
+
+	/** Free all content pipe */
+	ret = FreeAllContentPipe();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Free all content pipe fail.\n");
+		return ret;
+	}
+
+	/** Release core resouce */
+	ret = FreeCoreResource();
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Free core resource fail.\n");
+		return ret;
+	}
+
+	if(lock)
+		fsl_osal_mutex_destroy(lock);
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::FreeAllComponent() 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	HANDLE_INFO *HandleListPtr;
+	OMX_S32 RefCnt, i;
+	OMX_U32 ComponentCnt;
+
+    fsl_osal_mutex_lock(lock);
+	ComponentCnt = HandleList.GetNodeCnt();
+	if (ComponentCnt == 0)
+	{
+		fsl_osal_mutex_unlock(lock);
+		return ret;
+	}
+
+	for (i=ComponentCnt-1; i>=0; i--)
+	{
+		HandleListPtr = HandleList.GetNode(i);
+		if (HandleListPtr == NULL)
+		{
+			LOG_ERROR("Handle item is NULL.\n");
+			fsl_osal_mutex_unlock(lock);
+			return OMX_ErrorUndefined;
+		}
+
+		ret = OMX_FreeHandle(HandleListPtr->pHandle);
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_ERROR("Free component fail.\n");
+			fsl_osal_mutex_unlock(lock);
+			return OMX_ErrorUndefined;
+		}
+	}
+
+    fsl_osal_mutex_unlock(lock);
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::FreeAllContentPipe() 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	HANDLE_INFO *ContentPipeHandleListPtr;
+	OMX_S32 RefCnt, i;
+	OMX_U32 ContentPipeCnt;
+
+	fsl_osal_mutex_lock(lock);
+	ContentPipeCnt = ContentPipeHandleList.GetNodeCnt();
+	if (ContentPipeCnt == 0)
+	{
+		fsl_osal_mutex_unlock(lock);
+		return ret;
+	}
+
+	for (i=ContentPipeCnt-1; i>=0; i--)
+	{
+		ContentPipeHandleListPtr = ContentPipeHandleList.GetNode(i);
+		if (ContentPipeHandleListPtr == NULL)
+		{
+			LOG_ERROR("Content pipe handle item is NULL.\n");
+			fsl_osal_mutex_unlock(lock);
+			return OMX_ErrorUndefined;
+		}
+
+		CP_PIPETYPE *pPipe = (CP_PIPETYPE *)ContentPipeHandleListPtr->pHandle;
+		FSL_DELETE(pPipe);
+		ContentPipeHandleListPtr->pHandle = NULL;
+		RefCnt = LibMgr->unload(ContentPipeHandleListPtr->hlib);
+		if (RefCnt != 0)
+		{
+			LOG_ERROR("Library refer count isn't to 0.\n");
+			fsl_osal_mutex_unlock(lock);
+			return OMX_ErrorUndefined;
+		}
+		ContentPipeHandleList.Remove(ContentPipeHandleListPtr);
+		FSL_DELETE(ContentPipeHandleListPtr);
+		ContentPipeHandleListPtr = NULL;
+	}
+
+	fsl_osal_mutex_unlock(lock);
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::FreeCoreResource() 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+	/** Free component information list */
+	OMX_S32 i;
+	COMPONENT_INFO *pComponentInfoPtr;
+
+	for (i = ComponentList.GetNodeCnt() - 1; i >= 0; i--)
+	{
+		pComponentInfoPtr = ComponentList.GetNode(i);
+		if (pComponentInfoPtr == NULL)
+		{
+			break;
+		}
+
+		OMX_S32 j;
+		ROLE_INFO *pRoleInfo;
+		for (j = pComponentInfoPtr->RoleList.GetNodeCnt() - 1; j >= 0; j --)
+		{
+			pRoleInfo = pComponentInfoPtr->RoleList.GetNode(j);
+			if (pRoleInfo == NULL)
+			{
+				break;
+			}
+
+			pComponentInfoPtr->RoleList.Remove(pRoleInfo);
+			FSL_DELETE(pRoleInfo);
+			pRoleInfo = NULL;
+		}
+
+		ComponentList.Remove(pComponentInfoPtr);
+		FSL_DELETE(pComponentInfoPtr);
+		pComponentInfoPtr = NULL;
+	}
+
+	CONTENTPIPE_INFO *pContentPipeInfo;
+	/** Free Content pipe information list */
+	for (i = ContentPipeList.GetNodeCnt() - 1; i >= 0; i --)
+	{
+		pContentPipeInfo = ContentPipeList.GetNode(i);
+		if (pContentPipeInfo == NULL)
+		{
+			break;
+		}
+
+		ContentPipeList.Remove(pContentPipeInfo);
+		FSL_DELETE(pContentPipeInfo);
+		pContentPipeInfo = NULL;
+	}
+
+
+	/** Free library manager resource */
+	FSL_DELETE(LibMgr);
+	LibMgr = NULL;
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_ComponentNameEnum(
+        OMX_STRING cComponentName, 
+        OMX_U32 nNameLength, 
+        OMX_U32 nIndex) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 nComponentCnt;
+	COMPONENT_INFO *pComponentInfoPtr;
+
+	nComponentCnt = ComponentList.GetNodeCnt();
+	if (nIndex > nComponentCnt-1)
+	{
+		LOG_DEBUG("Component index is out of range.\n");
+		return OMX_ErrorNoMore;
+	}
+
+	pComponentInfoPtr = ComponentList.GetNode(nIndex);
+	if (nNameLength >= fsl_osal_strlen((fsl_osal_char *)pComponentInfoPtr->ComponentName)+1)
+	{
+		fsl_osal_strcpy((fsl_osal_char *)cComponentName, (fsl_osal_char *)pComponentInfoPtr->ComponentName);
+	}
+	else
+	{
+		LOG_ERROR("Component name buffer is too small.\n");
+		return OMX_ErrorInsufficientResources;
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_GetHandle(
+        OMX_HANDLETYPE *pHandle, 
+        OMX_STRING cComponentName,
+        OMX_PTR pAppData, 
+        OMX_CALLBACKTYPE *pCallBacks) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	COMPONENT_INFO *pComponentInfoPtr;
+	HANDLE_INFO *pHandleInfo = FSL_NEW(HANDLE_INFO, ());
+	OMX_COMPONENTTYPE *pComp = FSL_NEW(OMX_COMPONENTTYPE, ());
+	OMX_HANDLETYPE hHandle = (OMX_HANDLETYPE)pComp;
+	
+	fsl_osal_memset(pHandleInfo, 0, sizeof(HANDLE_INFO));
+	OMX_INIT_STRUCT(pComp, OMX_COMPONENTTYPE);
+
+	/** Search component in component list. */
+	pComponentInfoPtr = SearchComponent(cComponentName);
+	if (pComponentInfoPtr == NULL)
+	{
+		FSL_DELETE(pHandleInfo);
+		pHandleInfo = NULL;
+		FSL_DELETE(pComp);
+		pComp = NULL;
+		LOG_ERROR("Can't find component based on component name: %s\n", cComponentName);
+		return OMX_ErrorComponentNotFound;
+	}
+
+	/** Load library and call entry function */
+	ret = ConstructComponent(pHandleInfo, hHandle, pComponentInfoPtr);
+	if (ret != OMX_ErrorNone)
+	{
+		FSL_DELETE(pHandleInfo);
+		pHandleInfo = NULL;
+		FSL_DELETE(pComp);
+		pComp = NULL;
+		LOG_ERROR("Load and call entry function fail.\n");
+		return ret;
+	}
+
+	/** Set callback function */
+	ret = pComp->SetCallbacks(hHandle, pCallBacks, pAppData);
+	if (ret != OMX_ErrorNone)
+	{
+		FSL_DELETE(pHandleInfo);
+		pHandleInfo = NULL;
+		FSL_DELETE(pComp);
+		pComp = NULL;
+		LOG_ERROR("Component set callbacks fail.\n");
+		return ret;
+	}
+
+	/** Record handle info to handle list */
+    fsl_osal_mutex_lock(lock);
+	HandleList.Add(pHandleInfo);
+    fsl_osal_mutex_unlock(lock);
+	*pHandle = hHandle;
+	
+	return ret;
+}
+
+COMPONENT_INFO *OMXCore::SearchComponent(
+        OMX_STRING cComponentName) 
+{
+	OMX_U32 i;
+	COMPONENT_INFO *pComponentInfoPtr;
+
+	for (i =  0; ; i++)
+	{
+		pComponentInfoPtr = ComponentList.GetNode(i);
+		if (pComponentInfoPtr == NULL)
+		{
+			break;
+		}
+		if (!fsl_osal_strcmp((fsl_osal_char *)cComponentName, (fsl_osal_char *) \
+					pComponentInfoPtr->ComponentName))
+		{
+			return pComponentInfoPtr;
+		}
+	}
+
+	return NULL;
+}
+
+OMX_ERRORTYPE OMXCore::ConstructComponent(
+		HANDLE_INFO *pHandleInfo,
+		OMX_HANDLETYPE hHandle,
+		COMPONENT_INFO *pComponentInfoPtr)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_ERRORTYPE (*ComponentEntry)(OMX_HANDLETYPE);
+
+    fsl_osal_mutex_lock(lock);
+	pHandleInfo->hlib = LibMgr->load((fsl_osal_char *)pComponentInfoPtr->LibName);
+    fsl_osal_mutex_unlock(lock);
+	if (pHandleInfo->hlib == NULL)
+	{
+		LOG_ERROR("Load library fail. library name: %s\n", pComponentInfoPtr->LibName);
+		return OMX_ErrorComponentNotFound;
+	}
+
+	ComponentEntry = (OMX_ERRORTYPE (*)(void*))LibMgr->getSymbol(pHandleInfo->hlib, \
+			(fsl_osal_char *)pComponentInfoPtr->EntryFunction);
+	if (ComponentEntry == NULL)
+	{
+		LOG_ERROR("Can't get component entry function.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	ret = ComponentEntry(hHandle);
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Can't initialize component.\n");
+		return ret;
+	}
+	pHandleInfo->pHandle = hHandle;
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_FreeHandle(
+        OMX_HANDLETYPE hComponent) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_COMPONENTTYPE *pComponent = NULL;
+	HANDLE_INFO *pHandleInfo;
+	OMX_S32 i;
+
+	if (hComponent == NULL)
+	{
+		LOG_ERROR("NULL point.\n");
+		return OMX_ErrorBadParameter;
+	}
+
+    fsl_osal_mutex_lock(lock);
+	for (i = HandleList.GetNodeCnt() - 1; i >= 0; i --)
+	{
+		pHandleInfo = HandleList.GetNode(i);
+		if (pHandleInfo == NULL)
+		{
+			LOG_ERROR("Free handle list error.\n");
+			fsl_osal_mutex_unlock(lock);
+			return OMX_ErrorUndefined;
+		}
+
+		if (pHandleInfo->pHandle == hComponent)
+		{
+			pComponent = (OMX_COMPONENTTYPE *)hComponent;
+
+			/** Call component de-initialize */
+			ret = pComponent->ComponentDeInit(hComponent);
+			if (ret != OMX_ErrorNone)
+			{
+				LOG_ERROR("Can't de-initialize component.\n");
+				fsl_osal_mutex_unlock(lock);
+				return ret;
+			}
+
+			/** Free handle memory and close library and release handle list resouce */
+			FSL_DELETE(pComponent);
+			pComponent = NULL;
+			LibMgr->unload(pHandleInfo->hlib);
+			HandleList.Remove(pHandleInfo);
+			FSL_DELETE(pHandleInfo);
+			pHandleInfo = NULL;
+
+			fsl_osal_mutex_unlock(lock);
+			return OMX_ErrorNone;
+		}
+	}
+
+	LOG_ERROR("Can't find the component in component list.\n");
+    fsl_osal_mutex_unlock(lock);
+	return OMX_ErrorBadParameter;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_GetComponentsOfRole(
+        OMX_STRING role, 
+        OMX_U32 *pNumComps, 
+        OMX_U8 **compNames) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 i, j, k, nComponentCnt;
+	COMPONENT_INFO *pComponentInfo;
+	ROLE_INFO *pRoleInfo;
+	OMX_S32 RolePriority[MAX_COMPONENTNUM_WITH_SAME_ROLE] = { 0 };
+	List<COMPONENT_INFO> ComponentInfoOfRoleList;
+
+	k = 0;
+	for (i = 0; ; i ++)
+	{
+		pComponentInfo = ComponentList.GetNode(i);
+		if (pComponentInfo == NULL)
+		{
+			break;
+		}
+
+		for (j = 0; ; j ++)
+		{
+			pRoleInfo = pComponentInfo->RoleList.GetNode(j);
+			if (pRoleInfo == NULL)
+			{
+				break;
+			}
+
+			if (!fsl_osal_strcmp((fsl_osal_char *)pRoleInfo->role, (fsl_osal_char *)role))
+			{
+				ComponentInfoOfRoleList.Add(pComponentInfo);
+				RolePriority[k] = pRoleInfo->priority;
+				k ++;
+				if (k >= MAX_COMPONENTNUM_WITH_SAME_ROLE)
+				{
+					LOG_WARNING("Too many component with the role.");
+					goto SEARCH_BREAK;
+				}
+			}
+		}
+	}
+SEARCH_BREAK:
+
+	/** If compNames is NULL, return with the numbers which support the role */
+	nComponentCnt = k;
+	if (compNames == NULL)
+	{
+		*pNumComps = nComponentCnt;
+		return ret;
+	}
+
+	if (nComponentCnt == 0)
+	{
+		*pNumComps = 0;
+		LOG_DEBUG("Haven't found component with role: %s\n.", role);
+		return ret;
+	}
+
+	if (*pNumComps > nComponentCnt)
+	{
+		*pNumComps = nComponentCnt;
+	}
+
+	for (i = 0; i < *pNumComps; i ++)
+	{
+		k = 0;
+		for (j = 1; j < nComponentCnt; j ++)
+		{
+			if (RolePriority[j] > RolePriority[k])
+			{
+				k = j;
+			}
+		}
+		RolePriority[k] = 0;
+
+		pComponentInfo = ComponentInfoOfRoleList.GetNode(k);
+		if (pComponentInfo == NULL)
+		{
+			LOG_ERROR("NULL point.\n");
+			return OMX_ErrorUndefined;
+		}
+
+		fsl_osal_strcpy(((fsl_osal_char *)compNames[i]), (fsl_osal_char *)pComponentInfo->ComponentName);
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_GetRolesOfComponent(
+        OMX_STRING compName, 
+        OMX_U32 *pNumRoles, 
+        OMX_U8 **roles) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_U32 i, nRoleCnt;
+	COMPONENT_INFO *pComponentInfo = NULL;
+	ROLE_INFO *pRoleInfo;
+
+	for (i = 0; ; i ++)
+	{
+		pComponentInfo = ComponentList.GetNode(i);
+		if (pComponentInfo == NULL)
+		{
+			break;
+		}
+
+		if (!fsl_osal_strcmp((fsl_osal_char *)pComponentInfo->ComponentName, (fsl_osal_char *)compName))
+		{
+			break;
+		}
+	}
+
+	if (pComponentInfo == NULL)
+	{
+		*pNumRoles = 0;
+		LOG_DEBUG("Haven't found component: %s\n.", compName);
+		return OMX_ErrorComponentNotFound;
+	}
+
+	/** If roles is NULL, return with the numbers of roles of the component */
+	nRoleCnt = pComponentInfo->RoleList.GetNodeCnt();
+	if (roles == NULL)
+	{
+		*pNumRoles = nRoleCnt;
+		return ret;
+	}
+
+	if (nRoleCnt == 0)
+	{
+		*pNumRoles = 0;
+		LOG_DEBUG("Haven't found role for the component: %s\n.", compName);
+		return ret;
+	}
+
+	if (*pNumRoles > nRoleCnt)
+	{
+		*pNumRoles = nRoleCnt;
+	}
+
+	for (i = 0; i < *pNumRoles; i ++)
+	{
+		pRoleInfo = pComponentInfo->RoleList.GetNode(i);
+		if (pRoleInfo == NULL)
+		{
+			break;
+		}
+
+		fsl_osal_strcpy(((fsl_osal_char *)(*roles) + i*COMPONENT_NAME_LEN), (fsl_osal_char *)pRoleInfo->role);
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_SetupTunnel(
+        OMX_HANDLETYPE hOutput, 
+        OMX_U32 nPortOutput, 
+        OMX_HANDLETYPE hInput, 
+        OMX_U32 nPortInput) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_TUNNELSETUPTYPE TunnelSetup;
+	OMX_COMPONENTTYPE *pInComp, *pOutComp;
+
+	if (hOutput == NULL)
+	{
+		return OMX_ErrorInvalidComponent;
+	}
+
+	fsl_osal_memset(&TunnelSetup, 0, sizeof(OMX_TUNNELSETUPTYPE));
+	pInComp = (OMX_COMPONENTTYPE *)hInput;
+	pOutComp = (OMX_COMPONENTTYPE *)hOutput;
+
+	TunnelSetup.nTunnelFlags = OMX_PORTTUNNELFLAG_READONLY;
+
+	ret = pOutComp->ComponentTunnelRequest(hOutput, nPortOutput, hInput, nPortInput, &TunnelSetup);
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_DEBUG("Component tunnel request fail.");
+		return ret;
+	}
+
+        if(hInput == NULL)
+            return ret;
+
+	ret = pInComp->ComponentTunnelRequest(hInput, nPortInput, hOutput, nPortOutput, &TunnelSetup);
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_DEBUG("Component tunnel request fail.");
+		ret = pOutComp->ComponentTunnelRequest(hOutput, nPortOutput, NULL, 0, NULL);
+		if (ret != OMX_ErrorNone)
+		{
+			LOG_DEBUG("Component tunnel request fail.");
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::OMX_GetContentPipe(
+        OMX_HANDLETYPE *hPipe, 
+        OMX_STRING szURI) 
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_S32 i;
+	CONTENTPIPE_INFO *pContentPipeInfo;
+	HANDLE_INFO *ContentPipeHandleListPtr;
+	CP_PIPETYPE *pPipe = FSL_NEW(CP_PIPETYPE, ());
+	HANDLE_INFO	*pContentPipeHandleInfo = FSL_NEW(HANDLE_INFO, ());
+
+	/* Check if the content pipe already loaded */
+	for (i=0; ; i++)
+	{
+		fsl_osal_mutex_lock(lock);
+		ContentPipeHandleListPtr = ContentPipeHandleList.GetNode(i);
+		fsl_osal_mutex_unlock(lock);
+		if (ContentPipeHandleListPtr == NULL)
+		{
+			break;
+		}
+
+		if (!fsl_osal_strcmp((fsl_osal_char *)szURI, (fsl_osal_char *)ContentPipeHandleListPtr->ContentPipeName))
+		{
+			FSL_DELETE(pPipe);
+			pPipe = NULL;
+			FSL_DELETE(pContentPipeHandleInfo);
+			pContentPipeHandleInfo = NULL;
+			LOG_DEBUG("Content pipe: %s already loaded.\n", szURI);
+			*hPipe = ContentPipeHandleListPtr->pHandle;
+			return ret;
+		}
+	}
+
+	fsl_osal_memset(pPipe, 0, sizeof(CP_PIPETYPE));
+
+	for (i = 0; ; i ++)
+	{
+		pContentPipeInfo = ContentPipeList.GetNode(i);
+		if (pContentPipeInfo == NULL)
+		{
+			break;
+		}
+
+		if (!fsl_osal_strcmp((fsl_osal_char *)szURI, (fsl_osal_char *)pContentPipeInfo->ContentPipeName))
+		{
+			break;
+		}
+	}
+
+	if (pContentPipeInfo == NULL)
+	{
+		FSL_DELETE(pPipe);
+		pPipe = NULL;
+		FSL_DELETE(pContentPipeHandleInfo);
+		pContentPipeHandleInfo = NULL;
+		LOG_ERROR("Content pipe can't find.\n");
+		return OMX_ErrorContentPipeCreationFailed;
+	}
+
+	ret = ConstructContentPipe(pContentPipeHandleInfo, pPipe, pContentPipeInfo);
+	if (ret != OMX_ErrorNone)
+	{
+		FSL_DELETE(pPipe);
+		pPipe = NULL;
+		FSL_DELETE(pContentPipeHandleInfo);
+		pContentPipeHandleInfo = NULL;
+		LOG_ERROR("Create content pipe fail.\n");
+		return ret;
+	}
+
+	fsl_osal_strcpy((fsl_osal_char *)pContentPipeHandleInfo->ContentPipeName, (fsl_osal_char *)szURI);
+    fsl_osal_mutex_lock(lock);
+	ContentPipeHandleList.Add(pContentPipeHandleInfo);
+    fsl_osal_mutex_unlock(lock);
+	*hPipe = (OMX_HANDLETYPE)pPipe;
+
+	return ret;
+}
+
+OMX_ERRORTYPE OMXCore::ConstructContentPipe(
+		HANDLE_INFO *pHandleInfo,
+		OMX_HANDLETYPE hHandle,
+		CONTENTPIPE_INFO *pContentPipeInfoPtr)
+{
+	OMX_ERRORTYPE ret = OMX_ErrorNone;
+	OMX_ERRORTYPE (*ContentPipeEntry)(OMX_HANDLETYPE);
+
+	pHandleInfo->hlib = LibMgr->load((fsl_osal_char *)pContentPipeInfoPtr->LibName);
+	if (pHandleInfo->hlib == NULL)
+	{
+		LOG_ERROR("Load library fail. library name: %s\n", pContentPipeInfoPtr->LibName);
+		return OMX_ErrorUndefined;
+	}
+
+	ContentPipeEntry = (OMX_ERRORTYPE (*)(OMX_HANDLETYPE))LibMgr->getSymbol(pHandleInfo->hlib, (fsl_osal_char *)pContentPipeInfoPtr->EntryFunction);
+	if (ContentPipeEntry == NULL)
+	{
+		LOG_ERROR("Can't get content pipe entry function.\n");
+		return OMX_ErrorUndefined;
+	}
+
+	ret = ContentPipeEntry(hHandle);
+	if (ret != OMX_ErrorNone)
+	{
+		LOG_ERROR("Can't initialize component.\n");
+		return ret;
+	}
+	pHandleInfo->pHandle = hHandle;
+
+	return ret;
+}
+
+/**< C style functions to expose entry point for the shared library */
+extern "C" 
+{
+    /**< OMX core handle definition, global variable */
+    OMXCore *gCoreHandle = NULL;
+    static OMX_S32 refCnt = 0;
+
+    OMX_ERRORTYPE OMX_Init() 
+    {
+        OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+        if(NULL == gCoreHandle) {
+            gCoreHandle = FSL_NEW(OMXCore, ());
+            if(NULL == gCoreHandle)
+                return OMX_ErrorInsufficientResources;
+            ret = gCoreHandle->OMX_Init();
+            if(ret != OMX_ErrorNone) {
+                FSL_DELETE(gCoreHandle);
+                return ret;
+            }
+
+            CreatePlatformResMgr();
+
+            LOG_DEBUG("OMXCore is Created.\n");
+        }
+
+        refCnt ++;
+
+        return ret;
+    }
+
+    OMX_ERRORTYPE OMX_Deinit() 
+    {
+        refCnt --;
+        if(refCnt > 0)
+            return OMX_ErrorNone;
+
+        if(NULL != gCoreHandle) {
+            gCoreHandle->OMX_Deinit();
+            FSL_DELETE(gCoreHandle);
+            gCoreHandle = NULL;
+        }
+
+        DestroyPlatformResMgr();
+
+        LOG_DEBUG("OMXCore is Destroyed.\n");
+
+        return OMX_ErrorNone;
+    }
+
+    OMX_ERRORTYPE OMX_ComponentNameEnum(
+            OMX_STRING cComponentName, 
+            OMX_U32 nNameLength, 
+            OMX_U32 nIndex) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_ComponentNameEnum(cComponentName, nNameLength, nIndex);
+    }
+
+    OMX_ERRORTYPE OMX_GetHandle(
+            OMX_HANDLETYPE *pHandle, 
+            OMX_STRING cComponentName,
+            OMX_PTR pAppData, 
+            OMX_CALLBACKTYPE *pCallBacks) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_GetHandle(pHandle, cComponentName, pAppData, pCallBacks);
+    }
+
+    OMX_ERRORTYPE OMX_FreeHandle(
+            OMX_HANDLETYPE hComponent) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_FreeHandle(hComponent);
+    }
+
+    OMX_ERRORTYPE OMX_GetComponentsOfRole(
+            OMX_STRING role, 
+            OMX_U32 *pNumComps, 
+            OMX_U8 **compNames) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_GetComponentsOfRole(role, pNumComps, compNames);
+    }
+
+    OMX_ERRORTYPE OMX_GetRolesOfComponent(
+            OMX_STRING compName, 
+            OMX_U32 *pNumRoles, 
+            OMX_U8 **roles) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_GetRolesOfComponent(compName, pNumRoles, roles);
+    }
+
+    OMX_ERRORTYPE OMX_SetupTunnel(
+            OMX_HANDLETYPE hOutput, 
+            OMX_U32 nPortOutput, 
+            OMX_HANDLETYPE hInput, 
+            OMX_U32 nPortInput) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_SetupTunnel(hOutput, nPortOutput, hInput, nPortInput);
+    }
+
+    OMX_ERRORTYPE OMX_GetContentPipe(
+            OMX_HANDLETYPE *hPipe, 
+            OMX_STRING szURI) 
+    {
+        if(NULL == gCoreHandle)
+            return OMX_ErrorNotReady;
+
+        return gCoreHandle->OMX_GetContentPipe(hPipe, szURI);
+    }
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/core/OMXCore.h b/OpenMAXIL/src/core/OMXCore.h
new file mode 100755
index 0000000..d0648a4
--- /dev/null
+++ b/OpenMAXIL/src/core/OMXCore.h
@@ -0,0 +1,84 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file OMXCore.h
+ *  @brief Class definition of OpenMAX core
+ *  @ingroup OMXCore
+ */
+
+#ifndef OMXCore_h
+#define OMXCore_h
+
+#include "List.h"
+#include "OMX_Core.h"
+#include "ShareLibarayMgr.h"
+#include "OMX_Implement.h"
+
+typedef struct _CONTENTPIPE_INFO {
+    OMX_S8 ContentPipeName[CONTENTPIPE_NAME_LEN];
+    OMX_S8 LibName[LIB_NAME_LEN];
+    OMX_S8 EntryFunction[FUNCTION_NAME_LEN];
+}CONTENTPIPE_INFO;
+
+typedef struct _ROLE_INFO {
+    OMX_S8 role[ROLE_NAME_LEN];
+    OMX_S32 priority; /**< Component priority, [1, 5]. 3 is the normal priority, 
+						1 is the lowest priority, 5 is the highest priority */ 
+}ROLE_INFO;
+
+
+typedef struct _COMPONENT_INFO {
+    OMX_S8 ComponentName[COMPONENT_NAME_LEN];
+    OMX_S8 LibName[LIB_NAME_LEN];
+    OMX_S8 EntryFunction[FUNCTION_NAME_LEN];
+    List<ROLE_INFO> RoleList;
+}COMPONENT_INFO;
+
+
+typedef struct _HANDLE_INFO {
+    OMX_HANDLETYPE pHandle;
+    OMX_PTR hlib;
+    OMX_S8 ContentPipeName[CONTENTPIPE_NAME_LEN];
+}HANDLE_INFO;
+
+class OMXCore {
+public:
+    OMX_ERRORTYPE OMX_Init();
+    OMX_ERRORTYPE OMX_Deinit();
+    OMX_ERRORTYPE OMX_ComponentNameEnum(OMX_STRING cComponentName, OMX_U32 nNameLength, OMX_U32 nIndex);
+    OMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE *pHandle, OMX_STRING cComponentName,
+                                OMX_PTR pAppData, OMX_CALLBACKTYPE *pCallBacks);
+    OMX_ERRORTYPE OMX_FreeHandle(OMX_HANDLETYPE hComponent);
+    OMX_ERRORTYPE OMX_GetComponentsOfRole(OMX_STRING role, OMX_U32 *pNumComps, OMX_U8 **compNames);
+    OMX_ERRORTYPE OMX_GetRolesOfComponent(OMX_STRING compName, OMX_U32 *pNumRoles, OMX_U8 **roles);
+    OMX_ERRORTYPE OMX_SetupTunnel(OMX_HANDLETYPE hOutput, OMX_U32 nPortOutput, OMX_HANDLETYPE hInput, OMX_U32 nPortInput);
+    OMX_ERRORTYPE OMX_GetContentPipe(OMX_HANDLETYPE *hPipe, OMX_STRING szURI);
+private:
+	List<CONTENTPIPE_INFO> ContentPipeList;
+    List<COMPONENT_INFO> ComponentList;
+    List<HANDLE_INFO> HandleList;
+	List<HANDLE_INFO> ContentPipeHandleList;
+    ShareLibarayMgr *LibMgr;
+	fsl_osal_mutex lock;
+	OMX_ERRORTYPE ComponentRegister();
+	OMX_ERRORTYPE ContentPipeRegister();
+	OMX_ERRORTYPE FreeAllComponent();
+	OMX_ERRORTYPE FreeAllContentPipe();
+	OMX_ERRORTYPE FreeCoreResource();
+	COMPONENT_INFO *SearchComponent(OMX_STRING cComponentName);
+	OMX_ERRORTYPE ConstructComponent(HANDLE_INFO *pHandleInfo, OMX_HANDLETYPE hHandle, \
+			COMPONENT_INFO *pComponentInfoPtr);
+	OMX_ERRORTYPE ConstructContentPipe(HANDLE_INFO *pHandleInfo, OMX_HANDLETYPE hHandle, \
+			CONTENTPIPE_INFO *pContentPipeInfoPtr);
+
+};
+
+#endif
+/* File EOF */
diff --git a/OpenMAXIL/src/resource_mgr/Android.mk b/OpenMAXIL/src/resource_mgr/Android.mk
new file mode 100755
index 0000000..2cd5e5a
--- /dev/null
+++ b/OpenMAXIL/src/resource_mgr/Android.mk
@@ -0,0 +1,25 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	PlatformResourceMgr.cpp
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+ 
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) 
+
+LOCAL_SHARED_LIBRARIES := lib_omx_osal_v2_arm11_elinux \
+                          lib_omx_utils_v2_arm11_elinux
+
+LOCAL_PRELINK_MODULE := false
+	
+LOCAL_MODULE:= lib_omx_res_mgr_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/OpenMAXIL/src/resource_mgr/Makefile b/OpenMAXIL/src/resource_mgr/Makefile
new file mode 100755
index 0000000..e2fbcde
--- /dev/null
+++ b/OpenMAXIL/src/resource_mgr/Makefile
@@ -0,0 +1,47 @@
+#####################################################################################
+#
+#   Copyright (c) 2009, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+# Set the root directory
+OMX_ROOT_DIR=../../..
+
+# Set the BUILD information
+include $(OMX_ROOT_DIR)/Makefile.defines
+
+RESOURCE_MGR_SO_NAME= lib$(RESOURCE_MGR_LIB_NAME).so
+
+LFLAGS+= -l$(OSAL_LIB_NAME)
+
+SOURCE_FILES = $(SRC_DIR)/PlatformResourceMgr.cpp
+
+OBJECTS = $(SOURCE_FILES:.cpp=.o)
+
+all: $(RESOURCE_MGR_SO_NAME)
+
+$(RESOURCE_MGR_SO_NAME):$(OBJECTS)
+	$(CXX) -shared -Wl,-soname,$(RESOURCE_MGR_SO_NAME) -o $(RESOURCE_MGR_SO_NAME) $(OBJECTS) $(LFLAGS) 
+
+	mv $(RESOURCE_MGR_SO_NAME) $(RELEASE_LIB_DIR)/$(RESOURCE_MGR_SO_NAME)
+	@echo "-----------------------------------------------------------------------------------"
+
+.cpp.o:
+	$(CXX) $(CXXFLAGS) -o $@ -c $<
+
+clean:
+	@echo "cleaning ..."
+	rm  -f $(SRC_DIR)/*.o
+	rm  -f $(RELEASE_LIB_DIR)/$(RESOURCE_MGR_SO_NAME)
+			
+
+
diff --git a/OpenMAXIL/src/resource_mgr/PlatformResourceMgr.cpp b/OpenMAXIL/src/resource_mgr/PlatformResourceMgr.cpp
new file mode 100755
index 0000000..27e1e7b
--- /dev/null
+++ b/OpenMAXIL/src/resource_mgr/PlatformResourceMgr.cpp
@@ -0,0 +1,175 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "PlatformResourceMgr.h"
+#include "PlatformResourceMgrItf.h"
+
+OMX_ERRORTYPE PlatformResourceMgr::Init()
+{
+    PlatformDataList = NULL;
+    PlatformDataList = FSL_NEW(List<PLATFORM_DATA>, ());
+    if(PlatformDataList == NULL)
+        return OMX_ErrorInsufficientResources;
+
+    lock = NULL;
+    if(E_FSL_OSAL_SUCCESS != fsl_osal_mutex_init(&lock, fsl_osal_mutex_normal)) {
+        DeInit();
+        return OMX_ErrorInsufficientResources;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE PlatformResourceMgr::DeInit()
+{
+    if(PlatformDataList != NULL)
+        FSL_DELETE(PlatformDataList);
+
+    if(lock != NULL)
+        fsl_osal_mutex_destroy(lock);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE PlatformResourceMgr::AddHwBuffer(
+        OMX_PTR pPhyiscAddr, 
+        OMX_PTR pVirtualAddr)
+{
+    PLATFORM_DATA *pData = NULL;
+
+    pData = (PLATFORM_DATA*)FSL_MALLOC(sizeof(PLATFORM_DATA));
+    if(pData == NULL)
+        return OMX_ErrorInsufficientResources;
+
+    pData->pVirtualAddr = pVirtualAddr;
+    pData->pPhyiscAddr = pPhyiscAddr;
+
+    fsl_osal_mutex_lock(lock);
+    if(LIST_SUCCESS != PlatformDataList->Add(pData)) {
+        FSL_FREE(pData);
+        fsl_osal_mutex_unlock(lock);
+        return OMX_ErrorUndefined;
+    }
+    fsl_osal_mutex_unlock(lock);
+
+    return OMX_ErrorNone;
+}
+
+
+OMX_ERRORTYPE PlatformResourceMgr::RemoveHwBuffer(
+        OMX_PTR pVirtualAddr)
+{
+    PLATFORM_DATA *pData = NULL;
+
+    fsl_osal_mutex_lock(lock);
+    pData = (PLATFORM_DATA*) SearchData(pVirtualAddr);
+    if(pData == NULL) {
+        fsl_osal_mutex_unlock(lock);
+        return OMX_ErrorUndefined;
+    }
+    PlatformDataList->Remove(pData);
+    FSL_FREE(pData);
+    fsl_osal_mutex_unlock(lock);
+
+    return OMX_ErrorNone;
+}
+
+OMX_PTR PlatformResourceMgr::GetHwBuffer(
+        OMX_PTR pVirtualAddr)
+{
+    PLATFORM_DATA *pData = NULL;
+    OMX_PTR ptr = NULL;
+
+    fsl_osal_mutex_lock(lock);
+    pData = (PLATFORM_DATA*) SearchData(pVirtualAddr);
+    if(pData == NULL) {
+        fsl_osal_mutex_unlock(lock);
+        return NULL;
+    }
+    ptr = pData->pPhyiscAddr;
+    fsl_osal_mutex_unlock(lock);
+
+    return ptr;
+}
+
+OMX_PTR PlatformResourceMgr::SearchData(
+        OMX_PTR pVirtualAddr)
+{
+    PLATFORM_DATA *pData = NULL;
+    fsl_osal_u32 i = 0, cnt;
+
+    cnt = PlatformDataList->GetNodeCnt();
+    for(i=0; i<cnt; i++) {
+        pData = PlatformDataList->GetNode(i);
+        if(pData->pVirtualAddr == pVirtualAddr)
+            break;
+        pData = NULL;
+    }
+
+    return pData;
+}
+
+
+/**< C style functions to expose entry point for the shared library */
+PlatformResourceMgr *gPlatformResMgr = NULL;
+
+OMX_ERRORTYPE CreatePlatformResMgr()
+{
+    if(NULL == gPlatformResMgr) {
+        gPlatformResMgr = FSL_NEW(PlatformResourceMgr, ());
+        if(NULL == gPlatformResMgr)
+            return OMX_ErrorInsufficientResources;
+        gPlatformResMgr->Init();
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE DestroyPlatformResMgr()
+{
+    if(NULL != gPlatformResMgr) {
+        gPlatformResMgr->DeInit();
+        FSL_DELETE(gPlatformResMgr);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE AddHwBuffer(
+        OMX_PTR pPhyiscAddr, 
+        OMX_PTR pVirtualAddr)
+{
+    if(gPlatformResMgr == NULL)
+        return OMX_ErrorResourcesLost;
+
+    return gPlatformResMgr->AddHwBuffer(pPhyiscAddr, pVirtualAddr);
+}
+
+OMX_ERRORTYPE RemoveHwBuffer(
+        OMX_PTR pVirtualAddr)
+{
+    if(gPlatformResMgr == NULL)
+        return OMX_ErrorResourcesLost;
+
+    return gPlatformResMgr->RemoveHwBuffer(pVirtualAddr);
+}
+
+OMX_ERRORTYPE GetHwBuffer(
+        OMX_PTR pVirtualAddr, 
+        OMX_PTR *ppPhyiscAddr)
+{
+    if(gPlatformResMgr == NULL)
+        return OMX_ErrorResourcesLost;
+
+    *ppPhyiscAddr = gPlatformResMgr->GetHwBuffer(pVirtualAddr);
+
+    return OMX_ErrorNone;
+}
+
+/* File EOF */
diff --git a/OpenMAXIL/src/resource_mgr/PlatformResourceMgr.h b/OpenMAXIL/src/resource_mgr/PlatformResourceMgr.h
new file mode 100755
index 0000000..ed36da1
--- /dev/null
+++ b/OpenMAXIL/src/resource_mgr/PlatformResourceMgr.h
@@ -0,0 +1,41 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file PlatformResourceMgr.h
+ *  @brief Interface definition of PlatformResourceMgr
+ *  @ingroup State
+ */
+
+#ifndef PlatformResourceMgr_h
+#define PlatformResourceMgr_h
+
+#include "OMX_Core.h"
+#include "fsl_osal.h"
+#include "List.h"
+
+typedef struct {
+    OMX_PTR pVirtualAddr;
+    OMX_PTR pPhyiscAddr;
+}PLATFORM_DATA;
+
+class PlatformResourceMgr {
+    public:
+        OMX_ERRORTYPE Init();
+        OMX_ERRORTYPE DeInit();
+        OMX_ERRORTYPE AddHwBuffer(OMX_PTR pPhyiscAddr, OMX_PTR pVirtualAddr);
+        OMX_ERRORTYPE RemoveHwBuffer(OMX_PTR pVirtualAddr);
+        OMX_PTR GetHwBuffer(OMX_PTR pVirtualAddr);
+    private:
+	List<PLATFORM_DATA> *PlatformDataList;
+        fsl_osal_mutex lock;
+        OMX_PTR SearchData(OMX_PTR pVirtualAddr);
+};
+
+#endif
diff --git a/OpenMAXIL/test/vpu_test/Android.mk b/OpenMAXIL/test/vpu_test/Android.mk
new file mode 100755
index 0000000..61d0ad7
--- /dev/null
+++ b/OpenMAXIL/test/vpu_test/Android.mk
@@ -0,0 +1,22 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	vpu_test.cpp
+		
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS) -DDIVXINT_USE_STDINT
+ 
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES)
+
+LOCAL_SHARED_LIBRARIES := lib_omx_osal_v2_arm11_elinux \
+                          lib_omx_core_v2_arm11_elinux \
+			  lib_omx_utils_v2_arm11_elinux
+	
+LOCAL_MODULE:= omx_vpu_test_arm11_elinux
+
+include $(BUILD_EXECUTABLE)
+
+endif
diff --git a/OpenMAXIL/test/vpu_test/Makefile b/OpenMAXIL/test/vpu_test/Makefile
new file mode 100755
index 0000000..ae502ea
--- /dev/null
+++ b/OpenMAXIL/test/vpu_test/Makefile
@@ -0,0 +1,50 @@
+#####################################################################################
+#
+#   Copyright (c) 2009-2010, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+# Set the root directory
+OMX_ROOT_DIR=../../..
+
+# Set the BUILD information
+include $(OMX_ROOT_DIR)/Makefile.defines
+
+MODULE_NAME = omx_vpu_test
+BINARY_NAME = $(MODULE_NAME)_$(PROCESSOR)_$(OSTYPE)
+
+CORE_LIB_NAME=core_v2
+LFLAGS+= -l_omx_$(CORE_LIB_NAME)_$(PROCESSOR)_$(OSTYPE) -l$(OSAL_LIB_NAME) -l$(UTILS_LIB_NAME)
+
+SOURCE_FILES = $(SRC_DIR)/vpu_test.cpp
+
+OBJECTS = $(SOURCE_FILES:.cpp=.o)
+
+all: $(BINARY_NAME)
+
+$(BINARY_NAME):$(OBJECTS)
+	$(CXX) -Wl,-rpath,$(RELEASE_LIB_DIR) -o $(BINARY_NAME) $(OBJECTS) $(LFLAGS) -lpthread -ldl 
+	#$(CXX) -o $(BINARY_NAME) $(OBJECTS) $(LFLAGS) -lpthread -ldl 
+
+	mv $(BINARY_NAME) $(RELEASE_EXE_DIR)/$(BINARY_NAME)
+	@echo "-----------------------------------------------------------------------------------"
+
+.cpp.o:
+	$(CXX) $(CXXFLAGS) -o $@ -c $<
+
+clean:
+	@echo "cleaning ..."
+	rm  -f $(SRC_DIR)/*.o
+	rm  -f $(RELEASE_EXE_DIR)/$(BINARY_NAME)
+			
+
+
diff --git a/OpenMAXIL/test/vpu_test/vpu_test.cpp b/OpenMAXIL/test/vpu_test/vpu_test.cpp
new file mode 100755
index 0000000..894c2ae
--- /dev/null
+++ b/OpenMAXIL/test/vpu_test/vpu_test.cpp
@@ -0,0 +1,789 @@
+/**
+ *  Copyright (c) 2009-2011, 2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include "OMX_Implement.h"
+#include "fsl_osal.h"
+#include "Mem.h"
+#include "Log.h"
+
+#include "OMX_Core.h"
+#include "OMX_Component.h"    
+#include "Queue.h"
+
+#define MAX_PORT_NUM 8
+#define MAX_PORT_BUFFER 32
+
+typedef enum {
+    MPEG4 = 0,
+    H264
+}FORMAT;
+
+typedef enum {
+    EVENT = 0,
+    EMPTY_DONE,
+    FILL_DONE,
+    EXIT
+}MSG_TYPE;
+
+typedef struct {
+    OMX_EVENTTYPE eEvent;
+    OMX_U32 nData1;
+    OMX_U32 nData2;
+    OMX_PTR pEventData;
+}EVENT_TYPE;
+
+typedef struct {
+    OMX_BUFFERHEADERTYPE* pBuffer;
+}BUFFER;
+
+typedef struct _MSG {
+    OMX_HANDLETYPE hComponent;
+    MSG_TYPE type;
+    union {
+        EVENT_TYPE event;
+        BUFFER buffer;
+    }data;
+}MSG;
+
+typedef struct _HTEST {
+    OMX_COMPONENTTYPE *hComponent;
+    OMX_STRING name;
+    OMX_STRING role;
+    OMX_U32 nPorts;
+    OMX_BOOL bAllocater[MAX_PORT_NUM];
+    OMX_U32 nBufferHdr[MAX_PORT_NUM];
+    OMX_DIRTYPE PortDir[MAX_PORT_NUM];
+    OMX_BUFFERHEADERTYPE *pBufferHdr[MAX_PORT_NUM][MAX_PORT_BUFFER];
+    Queue *pMsgQ;
+    EVENT_TYPE sCmdDone;
+    fsl_osal_ptr pThreadId;
+    OMX_BOOL bInEos;
+    OMX_BOOL bOutEos;
+    OMX_BOOL bError;
+    OMX_BOOL bHoldBuffers;
+    OMX_S32 nFrame;
+    FILE *pInFile;
+    FILE *pOutFile;
+    FORMAT fmt;
+    OMX_U32 (*get_video_frame_len)(_HTEST *hTest);
+}HTEST;
+
+OMX_ERRORTYPE start_data_process(HTEST *hTest);
+void * process_thread(void *ptr);
+
+#define NALU_START_CODE 0x01
+
+OMX_U32 get_h264_frame_length(HTEST *hTest) 
+{
+    OMX_S32 nIndex = 0, nChar;
+    OMX_U32 nInputBuf = 0xffffffff;
+    OMX_BOOL bFound = OMX_FALSE;
+    OMX_BOOL bSlice = OMX_FALSE;
+    FILE *fp = hTest->pInFile;
+
+    for (nIndex = 0; (nChar = fgetc(fp)) != EOF; nIndex++)  {
+        nInputBuf = (nInputBuf << 8) | (nChar & 0xff);
+        if (nInputBuf == NALU_START_CODE) {
+            /* find one NALU */
+            nChar = fgetc(fp);
+            if((nChar&0x1f) < 6 && (nChar&0x1f) > 0) {
+                /* This is a slice NALU */
+                if(bSlice == OMX_TRUE)
+                    bFound = OMX_TRUE;
+                bSlice = OMX_TRUE;
+            }
+            else {
+                if(bSlice == OMX_TRUE)
+                    bFound = OMX_TRUE;
+            }
+
+            fseek(fp, -1, SEEK_CUR);
+            if(bFound == OMX_TRUE)
+                break;
+        }
+    }
+
+    if(bFound) {
+        fseek(fp, -(nIndex+1), SEEK_CUR);
+        return nIndex-3;
+    }
+
+    return 0;   // EOF reached
+}
+
+#define VOP_START_CODE 0x000001B6
+#define VOP_START_CODE_SIZE 0x04
+
+OMX_U32 get_mpeg4_frame_length(HTEST *hTest) 
+{
+    OMX_S32 nIndex = 0, nChar;
+    OMX_U32 nInputBuf = 0;
+    FILE *fp = hTest->pInFile;
+    static OMX_BOOL bFirst = OMX_FALSE;
+
+    for (nIndex = 1; (nChar = fgetc(fp)) != EOF; nIndex++) {
+        nInputBuf = (nInputBuf << 8) | (nChar & 0xff);
+        if (nInputBuf == VOP_START_CODE) {
+            if(bFirst == OMX_TRUE) {
+                if (nIndex > VOP_START_CODE_SIZE) {
+                    fseek(fp, -nIndex, SEEK_CUR);
+                    return nIndex - VOP_START_CODE_SIZE;
+                }
+            }
+            bFirst = OMX_TRUE;
+        }
+    }
+
+    fseek(fp, -nIndex+1, SEEK_CUR);
+
+    return nIndex-1;
+}
+
+OMX_ERRORTYPE read_frame(HTEST *hTest, OMX_BUFFERHEADERTYPE *pBufferHdr)
+{
+    OMX_U32 size = 0;
+    OMX_S32 frame_len = 0;
+
+    hTest->nFrame ++;
+    printf("\rDecoding frame: %d", hTest->nFrame);
+
+    pBufferHdr->nFilledLen = 0;
+    pBufferHdr->nOffset = 0;
+
+    frame_len = hTest->get_video_frame_len(hTest);
+    //printf("frame len: %d\n", frame_len);
+    if(frame_len > 0) {
+        if(frame_len > (OMX_S32)pBufferHdr->nAllocLen) {
+            printf("In buffer is overflow.\n");
+            return OMX_ErrorUndefined;
+        }
+
+        size = fread(pBufferHdr->pBuffer, 1, frame_len, hTest->pInFile);
+        pBufferHdr->nFilledLen = size;
+        pBufferHdr->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
+    }
+    else {
+        pBufferHdr->nFlags = OMX_BUFFERFLAG_EOS;
+        hTest->bInEos = OMX_TRUE;
+        printf("Input EOS.\n");
+    }
+
+    return OMX_ErrorNone;
+
+}
+
+OMX_ERRORTYPE write_data(HTEST *hTest, OMX_BUFFERHEADERTYPE *pBufferHdr)
+{
+    fwrite(pBufferHdr->pBuffer, 1, pBufferHdr->nFilledLen, hTest->pOutFile);
+    fflush(hTest->pOutFile);
+    pBufferHdr->nFilledLen = 0;
+    pBufferHdr->nOffset = 0;
+    if(pBufferHdr->nFlags & OMX_BUFFERFLAG_EOS) {
+        hTest->bOutEos = OMX_TRUE;
+        printf("Output EOS.\n");
+    }
+
+    return OMX_ErrorNone;
+}
+
+
+OMX_ERRORTYPE gm_EventHandler(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_EVENTTYPE eEvent,
+        OMX_IN OMX_U32 nData1,
+        OMX_IN OMX_U32 nData2,
+        OMX_IN OMX_PTR pEventData)
+{
+    MSG sMsg;
+    HTEST *hTest = (HTEST*)pAppData;
+
+    //printf("Client receive event [eEvent:%d, nData1: %d, nData2: %d]\n",
+    //        (int)eEvent, (int)nData1, (int)nData2);
+
+    if(eEvent == OMX_EventCmdComplete) {
+        hTest->sCmdDone.eEvent = OMX_EventCmdComplete;
+        hTest->sCmdDone.nData1 = nData1;
+        hTest->sCmdDone.nData2 = nData2;
+        hTest->sCmdDone.pEventData = pEventData;
+    }
+    else if(eEvent == OMX_EventError)
+        hTest->bError = OMX_TRUE;
+    else {
+        sMsg.hComponent = hComponent;
+        sMsg.type = EVENT;
+        sMsg.data.event.eEvent = eEvent;
+        sMsg.data.event.nData1 = nData1;
+        sMsg.data.event.nData2 = nData2;
+        sMsg.data.event.pEventData = pEventData;
+        hTest->pMsgQ->Add(&sMsg);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE gm_EmptyBufferDone(
+        OMX_IN OMX_HANDLETYPE hComponent,
+        OMX_IN OMX_PTR pAppData,
+        OMX_IN OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    MSG sMsg;
+    HTEST *hTest = (HTEST*)pAppData;
+
+    //printf("Client receive EmptyBufferDone [%p]\n", pBuffer);
+
+    sMsg.hComponent = hComponent;
+    sMsg.type = EMPTY_DONE;
+    sMsg.data.buffer.pBuffer = pBuffer;
+    hTest->pMsgQ->Add(&sMsg);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE gm_FillBufferDone(
+        OMX_OUT OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_PTR pAppData,
+        OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    MSG sMsg;
+    HTEST *hTest = (HTEST*)pAppData;
+
+    //printf("Client receive FillBufferDone [%p]\n", pBuffer);
+
+    write_data(hTest, pBuffer);
+
+    sMsg.hComponent = hComponent;
+    sMsg.type = FILL_DONE;
+    sMsg.data.buffer.pBuffer = pBuffer;
+    hTest->pMsgQ->Add(&sMsg);
+
+    return OMX_ErrorNone;
+}
+
+/**/
+OMX_CALLBACKTYPE gCallBacks =
+{
+    gm_EventHandler,
+    gm_EmptyBufferDone,
+    gm_FillBufferDone
+};
+
+OMX_ERRORTYPE WaitCommand(
+        HTEST *hTest, 
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam1,
+        OMX_PTR pCmdData)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    while(1) {
+        if(hTest->sCmdDone.eEvent == OMX_EventCmdComplete
+                && hTest->sCmdDone.nData1 == (OMX_U32)Cmd
+                && hTest->sCmdDone.nData2 == nParam1
+                && hTest->sCmdDone.pEventData == pCmdData)
+            break;
+        else if(hTest->bError == OMX_TRUE) {
+            ret = OMX_ErrorUndefined;
+            break;
+        }
+        else
+            usleep(10000);
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE SendCommand(
+        HTEST *hTest, 
+        OMX_COMMANDTYPE Cmd, 
+        OMX_U32 nParam1,
+        OMX_PTR pCmdData,
+        OMX_BOOL bSync)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_HANDLETYPE hComponent = hTest->hComponent;
+
+    hTest->sCmdDone.eEvent = OMX_EventMax;
+    hTest->bError = OMX_FALSE;
+    ret = OMX_SendCommand(hComponent, Cmd, nParam1, pCmdData);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if(bSync == OMX_TRUE)
+        WaitCommand(hTest, Cmd, nParam1, pCmdData);
+
+    return OMX_ErrorNone;
+}
+
+OMX_U32 get_component_ports(OMX_HANDLETYPE hComponent)
+{
+    OMX_PORT_PARAM_TYPE sPortPara;
+    OMX_U32 aPorts, vPorts, iPorts, oPorts;
+
+    OMX_INIT_STRUCT(&sPortPara, OMX_PORT_PARAM_TYPE);
+    aPorts = vPorts = iPorts = oPorts = 0;
+
+    if(OMX_ErrorNone == OMX_GetParameter(hComponent, OMX_IndexParamAudioInit, &sPortPara))
+        aPorts = sPortPara.nPorts;
+    if(OMX_ErrorNone == OMX_GetParameter(hComponent, OMX_IndexParamVideoInit, &sPortPara))
+        vPorts = sPortPara.nPorts;
+    if(OMX_ErrorNone == OMX_GetParameter(hComponent, OMX_IndexParamImageInit, &sPortPara))
+        iPorts = sPortPara.nPorts;
+    if(OMX_ErrorNone == OMX_GetParameter(hComponent, OMX_IndexParamOtherInit, &sPortPara))
+        oPorts = sPortPara.nPorts;
+
+    return aPorts + vPorts + iPorts + oPorts;
+}
+
+OMX_ERRORTYPE load_component(HTEST *hTest)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_HANDLETYPE hComponent = NULL;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_U32 i;
+
+    ret = OMX_GetHandle(&hComponent, hTest->name, hTest, &gCallBacks);
+    if(ret != OMX_ErrorNone) {
+        printf("Load component %s failed.\n", hTest->name);
+        return ret;
+    }
+
+    OMX_PARAM_COMPONENTROLETYPE CurRole;
+    OMX_INIT_STRUCT(&CurRole, OMX_PARAM_COMPONENTROLETYPE);
+    fsl_osal_memcpy(&CurRole.cRole, hTest->role, OMX_MAX_STRINGNAME_SIZE);
+    OMX_SetParameter(hComponent, OMX_IndexParamStandardComponentRole, &CurRole);
+
+    hTest->hComponent = (OMX_COMPONENTTYPE*)hComponent;
+    hTest->nPorts = get_component_ports(hComponent);
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    for(i=0; i<hTest->nPorts; i++) {
+        sPortDef.nPortIndex = i;
+        OMX_GetParameter(hComponent, OMX_IndexParamPortDefinition, &sPortDef);
+        hTest->PortDir[i] = sPortDef.eDir;
+        if(hTest->PortDir[i] == OMX_DirInput)
+            hTest->bAllocater[i] = OMX_FALSE;  //in buffer allocated by client
+        if(hTest->PortDir[i] == OMX_DirOutput)
+            hTest->bAllocater[i] = OMX_TRUE;   // out buffer allocated by component
+    }
+
+    fsl_osal_thread_create(&hTest->pThreadId, NULL, process_thread, hTest);
+
+    printf("Load component %s done.\n", hTest->name);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE unload_component(HTEST *hTest)
+{
+    OMX_FreeHandle(hTest->hComponent);
+
+    MSG sMsg;
+    sMsg.type = EXIT;
+    hTest->pMsgQ->Add(&sMsg);
+    fsl_osal_thread_destroy(hTest->pThreadId);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE prepare_port_buffers(HTEST *hTest, OMX_U32 nPortIndex)
+{
+    OMX_COMPONENTTYPE *hComponent = NULL;
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    OMX_U8 *pBuffer = NULL;
+    OMX_U32 i;
+
+    hComponent = hTest->hComponent;
+    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+    sPortDef.nPortIndex = nPortIndex;
+    OMX_GetParameter(hComponent, OMX_IndexParamPortDefinition, &sPortDef);
+    for(i=0; i<sPortDef.nBufferCountActual; i++) {
+        if(hTest->bAllocater[nPortIndex] == OMX_TRUE) {
+            OMX_AllocateBuffer(hComponent, &pBufferHdr, nPortIndex, NULL, sPortDef.nBufferSize);
+            printf("Port #%d Allocate buffer done.\n", nPortIndex);
+        }
+        else {
+            pBuffer = (OMX_U8*)FSL_MALLOC(sPortDef.nBufferSize);
+            OMX_UseBuffer(hComponent, &pBufferHdr, nPortIndex, NULL, sPortDef.nBufferSize, pBuffer);
+            printf("Port #%d Use buffer done.\n", nPortIndex);
+        }
+        hTest->pBufferHdr[nPortIndex][i] = pBufferHdr;
+    }
+    hTest->nBufferHdr[nPortIndex] = sPortDef.nBufferCountActual;
+
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE free_port_buffers(HTEST *hTest, OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_COMPONENTTYPE *hComponent;
+    OMX_U32 i;
+
+    hComponent = hTest->hComponent;
+    for(i=0; i<hTest->nBufferHdr[nPortIndex]; i++) {
+        OMX_U8 *ptr = NULL;
+        if(hTest->pBufferHdr[nPortIndex][i] == NULL)
+            continue;
+        ptr = hTest->pBufferHdr[nPortIndex][i]->pBuffer;
+        OMX_FreeBuffer(hComponent, nPortIndex, hTest->pBufferHdr[nPortIndex][i]);
+        hTest->pBufferHdr[nPortIndex][i] = 0;
+        if(hTest->bAllocater[nPortIndex] == OMX_FALSE)
+            FSL_FREE(ptr);
+        printf("port #%d free buffer done.\n", nPortIndex);
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Load2Idle(HTEST *hTest)
+{
+    OMX_U32 i;
+    for(i=0; i<hTest->nPorts; i++)
+        prepare_port_buffers(hTest, i);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE Idle2Load(HTEST *hTest)
+{
+    OMX_U32 i;
+
+    for(i=0; i<hTest->nPorts; i++)
+        free_port_buffers(hTest, i);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE StateTrans(HTEST *hTest, OMX_STATETYPE eState)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_COMPONENTTYPE *hComponent = NULL;
+    OMX_STATETYPE eCurState = OMX_StateInvalid;
+
+    hComponent = hTest->hComponent;
+    OMX_GetState(hComponent, &eCurState);
+    ret = SendCommand(hTest, OMX_CommandStateSet,eState,NULL, OMX_FALSE);
+    if(ret != OMX_ErrorNone) {
+        printf("State trans to %d failed.\n", eState);
+        return ret;
+    }
+
+    /* Loaded->Idle */
+    if(eCurState == OMX_StateLoaded && eState == OMX_StateIdle)
+        Load2Idle(hTest);
+    /* Exec->Idle */
+    else if(eCurState == OMX_StateExecuting && eState == OMX_StateIdle)
+        hTest->bHoldBuffers = OMX_TRUE;
+    /* Pause->Idle */
+    else if(eCurState == OMX_StatePause && eState == OMX_StateIdle)
+        hTest->bHoldBuffers = OMX_TRUE;
+    /* Idle->Loaded */
+    else if(eCurState == OMX_StateIdle && eState == OMX_StateLoaded)
+        Idle2Load(hTest);
+    else
+        printf("Ivalid state trans.\n");
+
+    ret = WaitCommand(hTest, OMX_CommandStateSet, eState, NULL);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    printf("State trans: [%x] -> [%d] done.\n", eCurState, eState);
+
+    /* Idle->Exec/Idle->Pause done */
+    if(eCurState == OMX_StateIdle && (eState == OMX_StateExecuting || eState == OMX_StatePause))
+        start_data_process(hTest);
+
+    return ret;
+}
+
+OMX_ERRORTYPE port_disable(HTEST *hTest, OMX_U32 nPortIndex)
+{
+    OMX_COMPONENTTYPE *hComponent;
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    hComponent = hTest->hComponent;
+    ret = SendCommand(hTest, OMX_CommandPortDisable, nPortIndex, NULL, OMX_FALSE);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    hTest->bHoldBuffers = OMX_TRUE;
+
+    free_port_buffers(hTest, nPortIndex);
+
+    WaitCommand(hTest, OMX_CommandPortDisable, nPortIndex, NULL);
+
+    printf("port disbale done.\n");
+
+    return OMX_ErrorNone;
+}
+
+
+OMX_ERRORTYPE port_enable(HTEST *hTest, OMX_U32 nPortIndex)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_COMPONENTTYPE *hComponent;
+    OMX_U32 i;
+
+    hComponent = hTest->hComponent;
+    ret = SendCommand(hTest, OMX_CommandPortEnable, nPortIndex, NULL, OMX_FALSE);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    prepare_port_buffers(hTest, nPortIndex);
+
+    WaitCommand(hTest, OMX_CommandPortEnable, nPortIndex, NULL);
+
+    hTest->bHoldBuffers = OMX_FALSE;
+    for(i=0; i<hTest->nBufferHdr[nPortIndex]; i++) {
+        if(hTest->PortDir[nPortIndex] == OMX_DirInput) {
+            read_frame(hTest, hTest->pBufferHdr[nPortIndex][i]);
+            OMX_EmptyThisBuffer(hTest->hComponent, hTest->pBufferHdr[nPortIndex][i]);
+        }
+    }
+
+    printf("port enable done.\n");
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE cmd_process(HTEST *hTest)
+{
+    char rep[10];
+    OMX_BOOL bExit = OMX_FALSE;
+
+    while(bExit == OMX_FALSE) {
+        printf("Input test cmd:\n");
+        printf("[l]load component\n");
+        printf("[s]state trans\n");
+        printf("[x]exit\n");
+        scanf("%s", rep);
+        if(rep[0] == 'l')
+            load_component(hTest);
+        else if(rep[0] == 's') {
+            OMX_U32 state = 0;
+            printf("State trans to:\n");
+            printf("1 -- Loaded\n");
+            printf("2 -- Idle\n");
+            printf("3 -- Executing\n");
+            printf("4 -- Pause\n");
+            scanf("%d", (int*)&state);
+            StateTrans(hTest, (OMX_STATETYPE)state);
+        }
+        else if(rep[0] == 'x') {
+            unload_component(hTest);
+            bExit = OMX_TRUE;
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE process_event(HTEST *hTest, MSG *pMsg)
+{
+    OMX_EVENTTYPE event = pMsg->data.event.eEvent;
+    OMX_U32 nPortIndex = pMsg->data.event.nData1;
+
+    if(event == OMX_EventPortSettingsChanged) {
+        port_disable(hTest, nPortIndex);
+        port_enable(hTest, nPortIndex);
+
+        OMX_STATETYPE eState = OMX_StateInvalid;
+        OMX_GetState(hTest->hComponent, &eState);
+        if(eState == OMX_StateExecuting) {
+            /* Send output buffers */
+            OMX_U32 i;
+            for(i=0; i<hTest->nBufferHdr[1]; i++) {
+                hTest->pBufferHdr[1][i]->nFilledLen = 0;
+                hTest->pBufferHdr[1][i]->nOffset = 0;
+                OMX_FillThisBuffer(hTest->hComponent, hTest->pBufferHdr[1][i]);
+            }
+        }
+    }
+
+    return OMX_ErrorNone;
+}
+
+void * process_thread(void *ptr)
+{
+    HTEST *hTest = (HTEST*)ptr;
+    OMX_BUFFERHEADERTYPE *pBufferHdr = NULL;
+    MSG sMsg;
+
+    while(1) {
+        hTest->pMsgQ->Get(&sMsg);
+        if(sMsg.type == EVENT) {
+            process_event(hTest, &sMsg);
+        }
+        else if(sMsg.type == EMPTY_DONE) {
+            pBufferHdr = sMsg.data.buffer.pBuffer;
+            if(hTest->bHoldBuffers != OMX_TRUE && hTest->bInEos != OMX_TRUE) {
+                read_frame(hTest, pBufferHdr);
+                OMX_EmptyThisBuffer(sMsg.hComponent, pBufferHdr);
+            }
+        }
+        else if(sMsg.type == FILL_DONE) {
+            pBufferHdr = sMsg.data.buffer.pBuffer;
+            if(pBufferHdr->nFlags & OMX_BUFFERFLAG_EOS)
+                break;
+
+            if(hTest->bHoldBuffers != OMX_TRUE)
+                OMX_FillThisBuffer(sMsg.hComponent, pBufferHdr);
+        }
+        else if(sMsg.type == EXIT) {
+            break;
+        }
+    }
+
+    return NULL;
+}
+
+OMX_ERRORTYPE start_data_process(HTEST *hTest)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 i;
+
+    hTest->bHoldBuffers = OMX_FALSE;
+
+    /* Send output buffers */
+    for(i=0; i<hTest->nBufferHdr[1]; i++) {
+        hTest->pBufferHdr[1][i]->nFilledLen = 0;
+        hTest->pBufferHdr[1][i]->nOffset = 0;
+        OMX_FillThisBuffer(hTest->hComponent, hTest->pBufferHdr[1][i]);
+    }
+
+    /* Send input buffers */
+    for(i=0; i<hTest->nBufferHdr[0]; i++) {
+        read_frame(hTest, hTest->pBufferHdr[0][i]);
+        OMX_EmptyThisBuffer(hTest->hComponent, hTest->pBufferHdr[0][i]);
+    }
+
+    return ret;
+}
+
+OMX_ERRORTYPE wait_eos(HTEST *hTest)
+{
+    while(hTest->bOutEos != OMX_TRUE)
+        sleep(1);
+
+    return OMX_ErrorNone;
+}
+
+HTEST * create_test(
+        OMX_STRING component,
+        OMX_STRING in_file,
+        OMX_STRING out_file,
+        FORMAT fmt)
+{
+    HTEST *hTest = NULL;
+
+    hTest = (HTEST*)FSL_MALLOC(sizeof(HTEST));
+    if(hTest == NULL) {
+        printf("Failed to allocate memory for test handle.\n");
+        return 0;
+    }
+    fsl_osal_memset(hTest, 0, sizeof(HTEST));
+
+    hTest->name = component;
+
+    hTest->pMsgQ = FSL_NEW(Queue, ());
+    if(hTest->pMsgQ == NULL) {
+        printf("Create message queue failed.\n");
+        return 0;
+    }
+    hTest->pMsgQ->Create(128, sizeof(MSG), E_FSL_OSAL_TRUE);
+
+    hTest->pInFile = fopen(in_file, "rb");
+    if(hTest->pInFile == NULL) {
+        printf("Failed to open file: %s\n", in_file);
+        return 0;
+    }
+
+    hTest->pOutFile = fopen(out_file, "wb");
+    if(hTest->pOutFile == NULL) {
+        printf("Failed to open file: %s\n", out_file);
+        return 0;
+    }
+
+    hTest->fmt = fmt;
+    if(fmt == MPEG4) {
+        hTest->role = (OMX_STRING)"video_decoder.mpeg4";
+        hTest->get_video_frame_len = get_mpeg4_frame_length;
+    }
+    if(fmt == H264) {
+        hTest->role = (OMX_STRING)"video_decoder.avc";
+        hTest->get_video_frame_len = get_h264_frame_length;
+    }
+
+    return hTest;
+}
+
+OMX_ERRORTYPE delete_test(HTEST *hTest)
+{
+    fclose(hTest->pInFile);
+    fclose(hTest->pOutFile);
+    hTest->pMsgQ->Free();
+    FSL_FREE(hTest);
+
+    return OMX_ErrorNone;
+}
+
+int main(int argc, char *argv[])
+{
+    HTEST *hTest = NULL;
+    OMX_STRING component = NULL;
+    OMX_STRING in_file = NULL, out_file = NULL;
+    FORMAT fmt;
+
+    if(argc < 4) {
+        printf("Unit test of vpu component.\n");
+        printf("This test read data from in_file then store the decoded data to out_file.\n");
+        printf("Usage: ./bin <in_file> <out_file> <format>\n");
+        printf("format: 0 -- mpeg4\n");
+        printf("        1 -- h264\n");
+        return 0;
+    }
+
+    OMX_Init();
+    component = (OMX_STRING)"OMX.Freescale.std.video_decoder.avc.v3.hw-based";
+    in_file = argv[1];
+    out_file = argv[2];
+    fmt = (FORMAT) atoi(argv[3]);
+    hTest = create_test(component, in_file, out_file, fmt);
+    if(hTest == NULL) {
+        printf("Create test failed.\n");
+        return 0;
+    }
+
+#if 1
+    load_component(hTest);
+    StateTrans(hTest, OMX_StateIdle);
+    StateTrans(hTest, OMX_StateExecuting);
+    wait_eos(hTest);
+    StateTrans(hTest, OMX_StateIdle);
+    StateTrans(hTest, OMX_StateLoaded);
+    unload_component(hTest);
+#else
+    cmd_process(hTest);
+#endif
+
+    delete_test(hTest);
+    OMX_Deinit();
+
+    printf("Vpu component test is done.\n");
+
+    return 1;
+}
+
+/* File EOF */
diff --git a/codec_env.mk b/codec_env.mk
new file mode 100644
index 0000000..a896262
--- /dev/null
+++ b/codec_env.mk
@@ -0,0 +1 @@
+HAVE_FSL_IMX_CODEC := false
diff --git a/stagefright/Android.mk b/stagefright/Android.mk
new file mode 100755
index 0000000..28ab0f9
--- /dev/null
+++ b/stagefright/Android.mk
@@ -0,0 +1,48 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libstagefrighthw
+
+LOCAL_ARM_MODE := arm
+
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+
+LOCAL_C_INCLUDES := $(FSL_OMX_INCLUDES)
+
+ifeq ($(findstring x2.3,x$(PLATFORM_VERSION)), x2.3)
+LOCAL_SRC_FILES := src/OMXFSLPlugin.cpp \
+    		   src/FSLRenderer.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+        libbinder         \
+        libmedia          \
+        libutils          \
+        libcutils         \
+        libsurfaceflinger_client \
+	libdl \
+	libipu lib_omx_res_mgr_v2_arm11_elinux
+endif
+
+ifeq ($(findstring x3.,x$(PLATFORM_VERSION)), x3.)
+LOCAL_SRC_FILES := src/OMXFSLPlugin_new.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    	lib_omx_core_v2_arm11_elinux \
+	lib_omx_res_mgr_v2_arm11_elinux \
+	libui libutils libcutils
+endif
+
+ifeq ($(findstring x4.,x$(PLATFORM_VERSION)), x4.)
+LOCAL_SRC_FILES := src/OMXFSLPlugin_new.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    	lib_omx_core_v2_arm11_elinux \
+    	lib_omx_osal_v2_arm11_elinux \
+	lib_omx_res_mgr_v2_arm11_elinux \
+	libui libutils libcutils
+endif
+
+include $(BUILD_SHARED_LIBRARY)
+
diff --git a/stagefright/src/FSLRenderer.cpp b/stagefright/src/FSLRenderer.cpp
new file mode 100755
index 0000000..bb19098
--- /dev/null
+++ b/stagefright/src/FSLRenderer.cpp
@@ -0,0 +1,175 @@
+/**
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "FSLRenderer"
+#include <utils/Log.h>
+
+#include <media/stagefright/HardwareAPI.h>
+#include <media/stagefright/VideoRenderer.h>
+
+#include <binder/MemoryHeapBase.h>
+#include <binder/MemoryHeapPmem.h>
+#include <media/stagefright/MediaDebug.h>
+#include <surfaceflinger/ISurface.h>
+#include "mxc_ipu_hl_lib.h"
+#include "FSLRenderer.h"
+#include "PlatformResourceMgrItf.h"
+
+#define ipu_fourcc(a,b,c,d) \
+    (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+
+using android::sp;
+using android::ISurface;
+using android::VideoRenderer;
+
+VideoRenderer *createRenderer(
+        const android::sp<android::ISurface> &surface,
+        const char *componentName,
+        OMX_COLOR_FORMATTYPE colorFormat,
+        size_t displayWidth, size_t displayHeight,
+        size_t decodedWidth, size_t decodedHeight)
+{
+	//LOGD("componentName %s, colorFormat %d\n",componentName,colorFormat);
+	if (colorFormat == OMX_COLOR_FormatYUV420Planar
+        && !strncmp(componentName, "OMX.Freescale.std.video_decoder.",32)) {
+        return new android::FSLRenderer(colorFormat,surface, 
+        				displayWidth, displayHeight,
+                decodedWidth, decodedHeight);
+    }
+	return NULL;
+}
+
+namespace android {
+
+FSLRenderer::FSLRenderer(
+        OMX_COLOR_FORMATTYPE colorFormat,
+        const sp<ISurface> &surface,
+        size_t displayWidth, size_t displayHeight,
+        size_t decodedWidth, size_t decodedHeight)
+    : mColorFormat(colorFormat),
+      mISurface(surface),
+      mDisplayWidth(displayWidth),
+      mDisplayHeight(displayHeight),
+      mDecodedWidth(decodedWidth),
+      mDecodedHeight(decodedHeight),
+      mDevInited(false)
+{  
+}
+   
+
+FSLRenderer::~FSLRenderer() {
+    if(mDevInited)
+        mxc_ipu_lib_task_uninit(&ipu_handle);
+}
+
+void FSLRenderer::render(
+        const void *data, size_t size, void *platformPrivate) {
+        
+	int err;
+	OMX_PTR pVirtualAddr,pPhyiscAddr;
+	//pVirtualAddr = data;
+	GetHwBuffer( (void *)data, &pPhyiscAddr);
+	if(pPhyiscAddr == NULL){
+		LOGV("Can not find buffer %p\n",data);
+		return;
+	}
+
+	if(!mDevInited){
+		err = IpulibInit(pPhyiscAddr);
+		CHECK_EQ(err, 0);
+		if(err == 0)
+			mDevInited = true;
+	}
+	
+	/* call ipu task */
+	if(mDevInited){
+		err = mxc_ipu_lib_task_buf_update(&ipu_handle, (int)pPhyiscAddr, NULL, NULL, NULL, NULL);
+		CHECK_EQ(err, 0);
+	}
+}
+
+
+int FSLRenderer::IpulibInit(const void* data)
+{
+    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+    int mode, ret;  
+    ipu_lib_input_param_t sInParam;
+    ipu_lib_output_param_t sOutParam;
+
+    /* set ipu task input parameter */
+    memset(&sInParam, 0, sizeof(ipu_lib_input_param_t));
+    sInParam.width = mDecodedWidth;
+    sInParam.height = mDecodedHeight;
+    sInParam.input_crop_win.pos.x = 0;
+    sInParam.input_crop_win.pos.y = 0;
+    sInParam.input_crop_win.win_w = (mDecodedWidth + 7)/8*8;
+    sInParam.input_crop_win.win_h = mDecodedHeight;
+    sInParam.fmt = ipu_fourcc('I', '4', '2', '0');
+    sInParam.user_def_paddr[0] = (int)data;
+
+    LOGV("sInParam width %d, height %d,crop x %d, y %d, w %d, h %d, color %d\n",
+            sInParam.width,sInParam.height ,
+            sInParam.input_crop_win.pos.x,sInParam.input_crop_win.pos.y,
+            sInParam.input_crop_win.win_w,sInParam.input_crop_win.win_h,
+            sInParam.fmt
+          );  
+
+    /* set ipu task output parameter */
+    memset(&sOutParam, 0, sizeof(ipu_lib_output_param_t));
+    if( mISurface != 0 ){
+		int left,right,top,bottom,rot;
+		status_t err = mISurface->getDestRect(&left, &right, &top, &bottom, &rot);
+		if(0 == err) {
+			LOGV("mISurface: left %d, right %d, top %d, bottom %d, rot %d\n",
+				left, right, top, bottom, rot);
+			sOutParam.width = right-left;
+			sOutParam.height = bottom-top;
+	 		sOutParam.fb_disp.pos.x = left;
+			sOutParam.fb_disp.pos.y = top;
+			sOutParam.rot = rot;
+		}
+    }else{
+		sOutParam.width = mDisplayWidth;
+		sOutParam.height = mDisplayHeight;
+		sOutParam.fb_disp.pos.x = 0;
+		sOutParam.fb_disp.pos.y = 0;
+    }
+    sOutParam.fmt = ipu_fourcc('U', 'Y', 'V', 'Y');
+    sOutParam.show_to_fb = true;
+	
+    if(1)// lcd mode
+        sOutParam.fb_disp.fb_num = 2;
+    else // tv mode
+        sOutParam.fb_disp.fb_num = 1;
+
+    LOGV("sOutParam width %d, height %d,crop x %d, y %d, rot: %d, color %d\n",
+            sOutParam.width, sOutParam.height ,
+            sOutParam.fb_disp.pos.x, sOutParam.fb_disp.pos.y,
+            sOutParam.rot, sOutParam.fmt
+          );  
+
+    /* ipu lib task init */
+    mode = OP_NORMAL_MODE | TASK_PP_MODE;
+    memset(&ipu_handle, 0, sizeof(ipu_lib_handle_t));
+    ret = mxc_ipu_lib_task_init(&sInParam, NULL, &sOutParam, mode, &ipu_handle);
+    if(ret < 0) {
+        LOGE("mxc_ipu_lib_task_init failed!\n");
+        return -1;
+    }
+    return 0;
+}
+
+
+}  // namespace android
+
+
+
diff --git a/stagefright/src/FSLRenderer.h b/stagefright/src/FSLRenderer.h
new file mode 100755
index 0000000..54e7ea5
--- /dev/null
+++ b/stagefright/src/FSLRenderer.h
@@ -0,0 +1,53 @@
+/**
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef FSL_RENDERER_H_
+
+#define FSL_RENDERER_H_
+
+#include <media/stagefright/VideoRenderer.h>
+#include <utils/RefBase.h>
+
+namespace android {
+
+class ISurface;
+
+class FSLRenderer : public VideoRenderer {
+
+public:
+    FSLRenderer(
+            OMX_COLOR_FORMATTYPE colorFormat,
+            const sp<ISurface> &surface,
+            size_t displayWidth, size_t displayHeight,
+            size_t decodedWidth, size_t decodedHeight);
+
+    virtual ~FSLRenderer();
+
+    virtual void render(
+            const void *data, size_t size, void *platformPrivate);
+
+private:
+    OMX_COLOR_FORMATTYPE mColorFormat; 
+	sp<ISurface> mISurface;
+    size_t mDisplayWidth, mDisplayHeight;
+    size_t mDecodedWidth, mDecodedHeight;
+	ipu_lib_handle_t ipu_handle;
+    bool mDevInited;
+
+
+    FSLRenderer(const FSLRenderer &);
+    FSLRenderer &operator=(const FSLRenderer &);
+    int IpulibInit(const void* data);
+    
+};
+
+}  // namespace android
+
+#endif  // FSL_RENDERER_H_
+
diff --git a/stagefright/src/OMXFSLPlugin.cpp b/stagefright/src/OMXFSLPlugin.cpp
new file mode 100755
index 0000000..7a8faed
--- /dev/null
+++ b/stagefright/src/OMXFSLPlugin.cpp
@@ -0,0 +1,261 @@
+/**
+ *  Copyright (c) 2010-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+ 
+#define LOG_TAG "FSLOMXPlugin"
+
+#include <media/stagefright/OMXPluginBase.h>
+#include <media/stagefright/MediaDebug.h>
+#include <cutils/log.h>      
+#include <dlfcn.h>
+#include "OMX_Core.h"
+#include "OMX_Component.h"
+#include "OMX_Audio.h"
+#include "OMX_Image.h"
+#include "OMX_Video.h"
+#include "OMX_Other.h"
+
+
+typedef OMX_ERRORTYPE   OMX_APIENTRY (*tpOMX_Init)(void);
+typedef OMX_ERRORTYPE   OMX_APIENTRY (*tpOMX_Deinit)(void);
+typedef OMX_ERRORTYPE   OMX_APIENTRY (*tpOMX_ComponentNameEnum)(
+        OMX_OUT OMX_STRING cComponentName,
+        OMX_IN  OMX_U32 nNameLength,
+        OMX_IN  OMX_U32 nIndex);
+
+typedef OMX_ERRORTYPE   OMX_APIENTRY (*tpOMX_GetHandle)(
+        OMX_OUT OMX_HANDLETYPE* pHandle, 
+        OMX_IN  OMX_STRING cComponentName,
+        OMX_IN  OMX_PTR pAppData,
+        OMX_IN  OMX_CALLBACKTYPE*   pCallBacks);
+
+typedef OMX_ERRORTYPE   OMX_APIENTRY (*tpOMX_FreeHandle)(
+        OMX_IN  OMX_HANDLETYPE hComponent);
+
+typedef OMX_ERRORTYPE   OMX_APIENTRY (*tpOMX_SetupTunnel)(
+        OMX_IN  OMX_HANDLETYPE hOutput,
+        OMX_IN  OMX_U32 nPortOutput,
+        OMX_IN  OMX_HANDLETYPE hInput,
+        OMX_IN  OMX_U32 nPortInput);
+
+typedef OMX_ERRORTYPE       (*tpOMX_GetContentPipe)(
+        OMX_OUT OMX_HANDLETYPE *hPipe,
+        OMX_IN OMX_STRING   szURI);
+
+typedef OMX_ERRORTYPE   (*tpOMX_GetComponentsOfRole) ( 
+        OMX_IN          OMX_STRING role,
+        OMX_INOUT       OMX_U32 *pNumComps,
+        OMX_INOUT       OMX_U8  **compNames);
+
+typedef OMX_ERRORTYPE   (*tpOMX_GetRolesOfComponent)(   
+        OMX_IN          OMX_STRING compName, 
+        OMX_INOUT       OMX_U32 *pNumRoles,
+        OMX_OUT         OMX_U8 **roles);
+
+#define OMX_CORE_LIBRARY "lib_omx_core_v2_arm11_elinux.so"
+
+class   FSLOMXInterface{
+    public:
+        void* pShareLibHandle;
+        FSLOMXInterface()
+        {
+            pShareLibHandle = dlopen(OMX_CORE_LIBRARY, RTLD_NOW);
+            if (NULL == pShareLibHandle)
+            {       
+                pOMX_Init   =   NULL;
+                pOMX_Deinit =   NULL;
+                pOMX_ComponentNameEnum = NULL;
+                pOMX_GetHandle = NULL;
+                pOMX_FreeHandle =   NULL;
+                pOMX_GetComponentsOfRole = NULL;
+                pOMX_GetRolesOfComponent = NULL;
+                pOMX_SetupTunnel = NULL;
+                pOMX_GetContentPipe =   NULL;
+                const char* lError = dlerror();
+                if (lError)
+                {
+                    LOGE("Error: %s\n", lError);
+                }
+
+                LOGE("LoadLibrary %s failed\n",OMX_CORE_LIBRARY);        
+            }
+            else
+            {
+                pOMX_Init   =   (tpOMX_Init)dlsym(pShareLibHandle, "OMX_Init");
+                pOMX_Deinit =   (tpOMX_Deinit)dlsym(pShareLibHandle, "OMX_Deinit");
+                pOMX_ComponentNameEnum = (tpOMX_ComponentNameEnum)dlsym(pShareLibHandle, "OMX_ComponentNameEnum");
+                pOMX_GetHandle = (tpOMX_GetHandle)dlsym(pShareLibHandle, "OMX_GetHandle");
+                pOMX_FreeHandle =   (tpOMX_FreeHandle)dlsym(pShareLibHandle, "OMX_FreeHandle");
+                pOMX_GetComponentsOfRole = (tpOMX_GetComponentsOfRole)dlsym(pShareLibHandle, "OMX_GetComponentsOfRole");
+                pOMX_GetRolesOfComponent = (tpOMX_GetRolesOfComponent)dlsym(pShareLibHandle, "OMX_GetRolesOfComponent");
+                pOMX_SetupTunnel = (tpOMX_SetupTunnel)dlsym(pShareLibHandle, "OMX_SetupTunnel");
+                pOMX_GetContentPipe =   (tpOMX_GetContentPipe)dlsym(pShareLibHandle, "OMX_GetContentPipe");
+            }
+
+        };   
+
+        ~FSLOMXInterface()
+        {
+            if ( pShareLibHandle && (0 !=   dlclose(pShareLibHandle)))
+            {
+                LOGE("UnloadLibrary %s failed\n",OMX_CORE_LIBRARY);
+            }
+            pShareLibHandle =   NULL;
+        };
+        
+        tpOMX_Init                          pOMX_Init;
+        tpOMX_Deinit                        pOMX_Deinit;
+        tpOMX_ComponentNameEnum             pOMX_ComponentNameEnum;
+        tpOMX_GetHandle                     pOMX_GetHandle;
+        tpOMX_FreeHandle                    pOMX_FreeHandle;
+        tpOMX_GetComponentsOfRole           pOMX_GetComponentsOfRole;
+        tpOMX_GetRolesOfComponent           pOMX_GetRolesOfComponent;
+        tpOMX_SetupTunnel                   pOMX_SetupTunnel;
+        tpOMX_GetContentPipe                pOMX_GetContentPipe;
+
+};
+
+
+namespace   android{
+class   OMXFSLPlugin : public   OMXPluginBase   {
+    public:
+        OMXFSLPlugin();
+        virtual ~OMXFSLPlugin();
+
+        virtual OMX_ERRORTYPE   makeComponentInstance(
+                const   char *name,
+                const   OMX_CALLBACKTYPE *callbacks,
+                OMX_PTR appData,
+                OMX_COMPONENTTYPE   **component);
+
+        virtual OMX_ERRORTYPE   destroyComponentInstance(
+                OMX_COMPONENTTYPE   *component);
+
+        virtual OMX_ERRORTYPE   enumerateComponents(
+                OMX_STRING name,
+                size_t size,
+                OMX_U32 index);
+
+        virtual OMX_ERRORTYPE   getRolesOfComponent(
+                const   char *name,
+                Vector<String8> *roles);
+            OMXPluginBase* Instance();
+    private:
+            FSLOMXInterface *pFSLOMX;
+
+    };
+    
+    OMXFSLPlugin::OMXFSLPlugin() {
+        pFSLOMX =   new FSLOMXInterface();
+        if(pFSLOMX &&   pFSLOMX->pOMX_Init)
+            pFSLOMX->pOMX_Init();
+    }
+
+    OMXFSLPlugin::~OMXFSLPlugin()   {
+        if(pFSLOMX){
+            if( pFSLOMX->pOMX_Deinit)
+                pFSLOMX->pOMX_Deinit();
+            delete  pFSLOMX;
+            pFSLOMX =   NULL;
+        }
+    }
+
+
+    OMXPluginBase* OMXFSLPlugin::Instance()
+    {
+        return reinterpret_cast<OMXPluginBase *> (new OMXFSLPlugin());
+    };
+
+    OMX_ERRORTYPE OMXFSLPlugin::makeComponentInstance(
+        const   char *name,
+        const   OMX_CALLBACKTYPE *callbacks,
+        OMX_PTR appData,
+        OMX_COMPONENTTYPE   **component) {
+        if(pFSLOMX &&   pFSLOMX->pOMX_GetHandle){
+            return pFSLOMX->pOMX_GetHandle(
+        reinterpret_cast<OMX_HANDLETYPE *>(component),
+        const_cast<char *>(name),
+        appData,
+        const_cast<OMX_CALLBACKTYPE *>(callbacks));     
+        }else{
+            return OMX_ErrorNotImplemented;
+        }
+    
+        return OMX_ErrorNotImplemented;
+    }
+
+    OMX_ERRORTYPE   OMXFSLPlugin::destroyComponentInstance(
+        OMX_COMPONENTTYPE   *component) {
+        if(pFSLOMX &&   pFSLOMX->pOMX_FreeHandle){
+            return pFSLOMX->pOMX_FreeHandle(reinterpret_cast<OMX_HANDLETYPE *>(component));
+        }else{
+            return OMX_ErrorNotImplemented;
+        }
+    }
+
+    OMX_ERRORTYPE   OMXFSLPlugin::enumerateComponents(
+        OMX_STRING name,
+        size_t size,
+        OMX_U32 index) {
+        if(pFSLOMX  && pFSLOMX->pOMX_ComponentNameEnum){
+            return  pFSLOMX->pOMX_ComponentNameEnum(name, size, index);
+        }else{
+            return OMX_ErrorNotImplemented;
+        }
+        return OMX_ErrorNotImplemented;
+    }
+
+    OMX_ERRORTYPE   OMXFSLPlugin::getRolesOfComponent(
+        const   char *name,
+        Vector<String8> *roles) {
+        if( NULL== pFSLOMX ||   NULL ==pFSLOMX->pOMX_GetRolesOfComponent){
+            return OMX_ErrorNotImplemented;
+        }   
+
+        roles->clear();
+        OMX_U32 numRoles;
+        OMX_ERRORTYPE   err =
+            pFSLOMX->pOMX_GetRolesOfComponent(
+                const_cast<char *>(name),
+                &numRoles,
+                NULL);
+        if (err != OMX_ErrorNone) {
+            return err;
+        }
+
+        if (numRoles > 0) {
+            OMX_U8 **array = new OMX_U8 *[numRoles];
+            for (OMX_U32 i = 0; i   <   numRoles;   ++i) {
+                array[i] = new OMX_U8[OMX_MAX_STRINGNAME_SIZE];
+            }
+            OMX_U32 numRoles2;
+            err =   pFSLOMX->pOMX_GetRolesOfComponent(
+                const_cast<char *>(name),   &numRoles2, array);
+            if (err != OMX_ErrorNone) {
+                return err;
+            }
+
+            for (OMX_U32 i = 0; i < numRoles; ++i) {
+                String8 s((const char   *)array[i]);
+                roles->push(s);
+                delete[] array[i];
+                array[i] = NULL;
+            }
+            
+            delete[] array;
+            array   =   NULL;
+        }
+        return OMX_ErrorNone;
+    }
+
+    OMXPluginBase* createOMXPlugin()
+    {
+        return reinterpret_cast<OMXPluginBase *> (new OMXFSLPlugin());
+    }
+}
+
diff --git a/stagefright/src/OMXFSLPlugin_new.cpp b/stagefright/src/OMXFSLPlugin_new.cpp
new file mode 100755
index 0000000..aa825f4
--- /dev/null
+++ b/stagefright/src/OMXFSLPlugin_new.cpp
@@ -0,0 +1,745 @@
+/**
+ *  Copyright (c) 2011-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#if (ANDROID_VERSION <= ICS)
+    #include <media/stagefright/OMXPluginBase.h>
+    #include <media/stagefright/HardwareAPI.h>
+#elif (ANDROID_VERSION >= JELLY_BEAN_42)
+    #include <OMXPluginBase.h>
+    #include <HardwareAPI.h>
+    #include <media/hardware/MetadataBufferType.h>
+#endif
+
+#include <ui/GraphicBuffer.h>
+#include <gralloc_priv.h>
+#include <ui/Rect.h>
+#include <ui/GraphicBufferMapper.h>
+
+#include "OMX_Index.h"
+#include "OMX_Implement.h"
+#include "PlatformResourceMgrItf.h"
+
+#if (ANDROID_VERSION >= JELLY_BEAN_42)
+#define LOGE ALOGE
+#define LOGV ALOGV
+#endif
+
+#define MAX_BUFFER_CNT (32)
+
+namespace android {
+
+class FSLOMXWrapper {
+    public:
+        FSLOMXWrapper();
+        OMX_COMPONENTTYPE *MakeWapper(OMX_HANDLETYPE pHandle);
+        OMX_COMPONENTTYPE *GetComponentHandle();
+
+        OMX_ERRORTYPE GetVersion(OMX_STRING pComponentName, OMX_VERSIONTYPE* pComponentVersion, 
+                                 OMX_VERSIONTYPE* pSpecVersion, OMX_UUIDTYPE* pComponentUUID) {
+            return OMX_GetComponentVersion(
+                    ComponentHandle, pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+        }
+        OMX_ERRORTYPE SendCommand(OMX_COMMANDTYPE Cmd, OMX_U32 nParam1, OMX_PTR pCmdData) {
+            return OMX_SendCommand(ComponentHandle, Cmd, nParam1, pCmdData);
+        }
+        OMX_ERRORTYPE GetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE SetParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure);
+        OMX_ERRORTYPE GetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure) {
+            return OMX_GetConfig(ComponentHandle, nParamIndex, pStructure);
+        }
+        OMX_ERRORTYPE SetConfig(OMX_INDEXTYPE nParamIndex, OMX_PTR pStructure) {
+            return OMX_SetConfig(ComponentHandle, nParamIndex, pStructure);
+        }
+        OMX_ERRORTYPE GetExtensionIndex(OMX_STRING cParameterName, OMX_INDEXTYPE* pIndexType);
+        OMX_ERRORTYPE GetState(OMX_STATETYPE* pState) {
+            return OMX_GetState(ComponentHandle, pState);
+        }
+        OMX_ERRORTYPE TunnelRequest(OMX_U32 nPortIndex, OMX_HANDLETYPE hTunneledComp,
+                                    OMX_U32 nTunneledPort, OMX_TUNNELSETUPTYPE* pTunnelSetup) {
+            return ComponentHandle->ComponentTunnelRequest(
+                    ComponentHandle, nPortIndex, hTunneledComp, nTunneledPort, pTunnelSetup);
+        }
+        OMX_ERRORTYPE UseBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                OMX_PTR pAppPrivate, OMX_U32 nSizeBytes, OMX_U8* pBuffer) {
+            return OMX_UseBuffer(ComponentHandle, ppBuffer, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+        }
+        OMX_ERRORTYPE AllocateBuffer(OMX_BUFFERHEADERTYPE** ppBuffer, OMX_U32 nPortIndex,
+                                     OMX_PTR pAppPrivate, OMX_U32 nSizeBytes) {
+            return OMX_AllocateBuffer(ComponentHandle, ppBuffer, nPortIndex, pAppPrivate, nSizeBytes);
+        }
+        OMX_ERRORTYPE FreeBuffer(OMX_U32 nPortIndex, OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE EmptyThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer);
+        OMX_ERRORTYPE FillThisBuffer(OMX_BUFFERHEADERTYPE* pBuffer) {
+            return OMX_FillThisBuffer(ComponentHandle, pBuffer);
+        }
+        OMX_ERRORTYPE SetCallbacks(OMX_CALLBACKTYPE* pCbs, OMX_PTR pAppData) {
+            return ComponentHandle->SetCallbacks(ComponentHandle, pCbs, pAppData);
+        }
+        OMX_ERRORTYPE ComponentDeInit() {
+            return ComponentHandle->ComponentDeInit(ComponentHandle);
+        }
+        OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex,
+                                  OMX_PTR pAppPrivate, void *eglImage) {
+            return OMX_UseEGLImage(ComponentHandle, ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+        }
+        OMX_ERRORTYPE ComponentRoleEnum(OMX_U8 *cRole, OMX_U32 nIndex) {
+            return ComponentHandle->ComponentRoleEnum(ComponentHandle, cRole, nIndex);
+        }
+
+    private:
+        typedef struct {
+            OMX_BUFFERHEADERTYPE *pBufferHdr;
+            sp<GraphicBuffer> mGraphicBuffer;
+        }BufferMapper;
+
+        OMX_COMPONENTTYPE WrapperHandle;
+        OMX_COMPONENTTYPE *ComponentHandle;
+        OMX_BOOL bEnableNativeBuffers;
+        OMX_U32 nNativeBuffersUsage;
+        OMX_BOOL bStoreMetaData;
+        OMX_BOOL bSetGrallocBufferParameter;
+        BufferMapper sBufferMapper[MAX_BUFFER_CNT];
+        OMX_S32 nBufferCnt;
+
+        OMX_ERRORTYPE DoUseNativeBuffer(UseAndroidNativeBufferParams *pNativBufferParam);
+};
+
+class FSLOMXPlugin : public OMXPluginBase {
+    public:
+        FSLOMXPlugin() {
+            OMX_Init();
+        };
+
+        virtual ~FSLOMXPlugin() {
+            OMX_Deinit();
+        };
+
+        OMX_ERRORTYPE makeComponentInstance(
+                const char *name,
+                const OMX_CALLBACKTYPE *callbacks,
+                OMX_PTR appData,
+                OMX_COMPONENTTYPE **component);
+
+        OMX_ERRORTYPE destroyComponentInstance(
+                OMX_COMPONENTTYPE *component);
+
+        OMX_ERRORTYPE enumerateComponents(
+                OMX_STRING name,
+                size_t size,
+                OMX_U32 index);
+
+        OMX_ERRORTYPE getRolesOfComponent(
+                const char *name,
+                Vector<String8> *roles);
+    private:
+};
+
+#define GET_WRAPPER(handle) \
+    ({\
+        FSLOMXWrapper *wrapper = NULL; \
+        if(handle == NULL) return OMX_ErrorInvalidComponent; \
+        OMX_COMPONENTTYPE *hComp = (OMX_COMPONENTTYPE*)handle; \
+        wrapper = (FSLOMXWrapper*)(hComp->pComponentPrivate); \
+        wrapper; \
+    })
+
+static OMX_ERRORTYPE WrapperGetComponentVersion(
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_OUT OMX_STRING pComponentName,
+        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,
+        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,
+        OMX_OUT OMX_UUIDTYPE* pComponentUUID)
+{
+    return GET_WRAPPER(hComponent)->GetVersion(pComponentName, pComponentVersion, pSpecVersion, pComponentUUID);
+}
+
+static OMX_ERRORTYPE WrapperSendCommand(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_COMMANDTYPE Cmd,
+            OMX_IN  OMX_U32 nParam1,
+            OMX_IN  OMX_PTR pCmdData)
+{
+    return GET_WRAPPER(hComponent)->SendCommand(Cmd, nParam1, pCmdData);
+}
+
+static OMX_ERRORTYPE WrapperGetParameter(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nParamIndex,  
+            OMX_INOUT OMX_PTR pStructure)
+{
+    return GET_WRAPPER(hComponent)->GetParameter(nParamIndex, pStructure);
+}
+
+static OMX_ERRORTYPE WrapperSetParameter(
+            OMX_IN  OMX_HANDLETYPE hComponent, 
+            OMX_IN  OMX_INDEXTYPE nParamIndex,  
+            OMX_INOUT OMX_PTR pStructure)
+{
+    return GET_WRAPPER(hComponent)->SetParameter(nParamIndex, pStructure);
+}
+
+static OMX_ERRORTYPE WrapperGetConfig(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_INOUT OMX_PTR pComponentConfigStructure)
+{
+    return GET_WRAPPER(hComponent)->GetConfig(nIndex, pComponentConfigStructure);
+}
+
+
+static OMX_ERRORTYPE WrapperSetConfig(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_INDEXTYPE nIndex, 
+            OMX_IN  OMX_PTR pComponentConfigStructure)
+{
+    return GET_WRAPPER(hComponent)->SetConfig(nIndex, pComponentConfigStructure);
+}
+
+static OMX_ERRORTYPE WrapperGetExtensionIndex(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_STRING cParameterName,
+            OMX_OUT OMX_INDEXTYPE* pIndexType)
+{
+    return GET_WRAPPER(hComponent)->GetExtensionIndex(cParameterName, pIndexType);
+}
+
+static OMX_ERRORTYPE WrapperGetState(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_OUT OMX_STATETYPE* pState)
+{
+    return GET_WRAPPER(hComponent)->GetState(pState);
+}
+
+static OMX_ERRORTYPE WrapperComponentTunnelRequest(
+        OMX_IN  OMX_HANDLETYPE hComponent,
+        OMX_IN  OMX_U32 nPort,
+        OMX_IN  OMX_HANDLETYPE hTunneledComp,
+        OMX_IN  OMX_U32 nTunneledPort,
+        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup)
+{
+    return GET_WRAPPER(hComponent)->TunnelRequest(nPort, hTunneledComp, nTunneledPort, pTunnelSetup);
+}
+
+
+static OMX_ERRORTYPE WrapperUseBuffer(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes,
+            OMX_IN OMX_U8* pBuffer)
+{
+    return GET_WRAPPER(hComponent)->UseBuffer(ppBufferHdr, nPortIndex, pAppPrivate, nSizeBytes, pBuffer);
+}
+
+
+static OMX_ERRORTYPE WrapperAllocateBuffer(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN OMX_U32 nSizeBytes)
+{
+    return GET_WRAPPER(hComponent)->AllocateBuffer(ppBuffer, nPortIndex, pAppPrivate, nSizeBytes);
+}
+
+static OMX_ERRORTYPE WrapperFreeBuffer(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_U32 nPortIndex,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    return GET_WRAPPER(hComponent)->FreeBuffer(nPortIndex, pBuffer);
+}
+
+static OMX_ERRORTYPE WrapperEmptyThisBuffer(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    return GET_WRAPPER(hComponent)->EmptyThisBuffer(pBufferHdr);
+}
+
+
+static OMX_ERRORTYPE WrapperFillThisBuffer(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+    return GET_WRAPPER(hComponent)->FillThisBuffer(pBuffer);
+}
+
+
+static OMX_ERRORTYPE WrapperSetCallbacks(
+            OMX_IN  OMX_HANDLETYPE hComponent,
+            OMX_IN  OMX_CALLBACKTYPE* pCbs, 
+            OMX_IN  OMX_PTR pAppData)
+{
+    return GET_WRAPPER(hComponent)->SetCallbacks(pCbs, pAppData);
+}
+
+
+static OMX_ERRORTYPE WrapperComponentDeInit(
+            OMX_IN  OMX_HANDLETYPE hComponent)
+{
+    return GET_WRAPPER(hComponent)->ComponentDeInit();
+}
+
+
+static OMX_ERRORTYPE WrapperUseEGLImage(
+            OMX_IN OMX_HANDLETYPE hComponent,
+            OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            OMX_IN OMX_U32 nPortIndex,
+            OMX_IN OMX_PTR pAppPrivate,
+            OMX_IN void* eglImage)
+{
+    return GET_WRAPPER(hComponent)->UseEGLImage(ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+}
+
+
+static OMX_ERRORTYPE WrapperComponentRoleEnum(
+        OMX_IN OMX_HANDLETYPE hComponent,
+		OMX_OUT OMX_U8 *cRole,
+		OMX_IN OMX_U32 nIndex)
+{
+    return GET_WRAPPER(hComponent)->ComponentRoleEnum(cRole, nIndex);
+}
+
+FSLOMXWrapper::FSLOMXWrapper()
+{
+    nBufferCnt = 0;
+    ComponentHandle = NULL;
+    nNativeBuffersUsage = GRALLOC_USAGE_SW_READ_NEVER | GRALLOC_USAGE_SW_WRITE_NEVER | GRALLOC_USAGE_FORCE_CONTIGUOUS;
+    bStoreMetaData = OMX_FALSE;
+    bSetGrallocBufferParameter = OMX_FALSE;
+    memset(&WrapperHandle, 0, sizeof(OMX_COMPONENTTYPE));
+    memset(sBufferMapper, 0, sizeof(BufferMapper) * MAX_BUFFER_CNT);
+}
+
+OMX_COMPONENTTYPE *FSLOMXWrapper::MakeWapper(OMX_HANDLETYPE pHandle)
+{
+    if(pHandle == NULL)
+        return NULL;
+
+    ComponentHandle = (OMX_COMPONENTTYPE*)pHandle;
+
+    WrapperHandle.pComponentPrivate = this;
+    WrapperHandle.GetComponentVersion = WrapperGetComponentVersion;
+    WrapperHandle.SendCommand = WrapperSendCommand;
+    WrapperHandle.GetParameter = WrapperGetParameter;
+    WrapperHandle.SetParameter = WrapperSetParameter;
+    WrapperHandle.GetConfig = WrapperGetConfig;
+    WrapperHandle.SetConfig = WrapperSetConfig;
+    WrapperHandle.GetExtensionIndex = WrapperGetExtensionIndex;
+    WrapperHandle.GetState = WrapperGetState;
+    WrapperHandle.ComponentTunnelRequest = WrapperComponentTunnelRequest;
+    WrapperHandle.UseBuffer = WrapperUseBuffer;
+    WrapperHandle.AllocateBuffer = WrapperAllocateBuffer;
+    WrapperHandle.FreeBuffer = WrapperFreeBuffer;
+    WrapperHandle.EmptyThisBuffer = WrapperEmptyThisBuffer;
+    WrapperHandle.FillThisBuffer = WrapperFillThisBuffer;
+    WrapperHandle.SetCallbacks = WrapperSetCallbacks;
+    WrapperHandle.ComponentDeInit = WrapperComponentDeInit;
+    WrapperHandle.UseEGLImage = WrapperUseEGLImage;
+    WrapperHandle.ComponentRoleEnum = WrapperComponentRoleEnum;
+
+    return &WrapperHandle;
+}
+
+OMX_COMPONENTTYPE * FSLOMXWrapper::GetComponentHandle()
+{
+    return ComponentHandle;
+}
+
+OMX_ERRORTYPE FSLOMXWrapper::GetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pStructure == NULL)
+        return OMX_ErrorBadParameter;
+
+    switch((int)nParamIndex) {
+        case OMX_IndexParamEnableAndroidNativeBuffers:
+            {
+                EnableAndroidNativeBuffersParams *pParams = (EnableAndroidNativeBuffersParams*)pStructure;
+                if(pParams->nPortIndex != 1)
+                    return OMX_ErrorUnsupportedIndex;
+                pParams->enable = bEnableNativeBuffers;
+            }
+            break;
+        case OMX_IndexParamNativeBufferUsage:
+            {
+                GetAndroidNativeBufferUsageParams *pParams = (GetAndroidNativeBufferUsageParams*)pStructure;
+                if(pParams->nPortIndex != 1)
+                    return OMX_ErrorUnsupportedIndex;
+                pParams->nUsage = nNativeBuffersUsage;
+            }
+            break;
+        case OMX_IndexParamStoreMetaDataInBuffers:
+            {
+                StoreMetaDataInBuffersParams *pParams = (StoreMetaDataInBuffersParams*)pStructure;
+                if(pParams->nPortIndex != 0)
+                    return OMX_ErrorUnsupportedIndex;
+                pParams->bStoreMetaData = bStoreMetaData;
+            }
+            break;
+#if (ANDROID_VERSION >= KITKAT_44)
+        case OMX_IndexParamVideoPortFormat:
+            {
+                ret = OMX_GetParameter(ComponentHandle, nParamIndex, pStructure);
+                OMX_VIDEO_PARAM_PORTFORMATTYPE *pParams = (OMX_VIDEO_PARAM_PORTFORMATTYPE *)pStructure;
+                if(pParams->eCompressionFormat == OMX_VIDEO_CodingVP8)
+                    pParams->eCompressionFormat = (OMX_VIDEO_CODINGTYPE)9;// defined in framework/native/include/media/openmax/OMX_Video.h
+            }
+            break;
+#endif
+        default:
+            ret = OMX_GetParameter(ComponentHandle, nParamIndex, pStructure);
+    };
+
+    return ret;
+}
+
+OMX_ERRORTYPE FSLOMXWrapper::SetParameter(
+        OMX_INDEXTYPE nParamIndex, 
+        OMX_PTR pStructure)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    if(pStructure == NULL)
+        return OMX_ErrorBadParameter;
+
+    switch((int)nParamIndex) {
+        case OMX_IndexParamEnableAndroidNativeBuffers:
+            {
+                EnableAndroidNativeBuffersParams *pParams = (EnableAndroidNativeBuffersParams*)pStructure;
+                if(pParams->nPortIndex != 1)
+                    return OMX_ErrorUnsupportedIndex;
+                bEnableNativeBuffers = pParams->enable;
+            }
+            break;
+        case OMX_IndexParamNativeBufferUsage:
+            {
+                GetAndroidNativeBufferUsageParams *pParams = (GetAndroidNativeBufferUsageParams*)pStructure;
+                if(pParams->nPortIndex != 1)
+                    return OMX_ErrorUnsupportedIndex;
+                nNativeBuffersUsage = pParams->nUsage;
+            }
+            break;
+        case OMX_IndexParamStoreMetaDataInBuffers:
+            {
+                StoreMetaDataInBuffersParams *pParams = (StoreMetaDataInBuffersParams*)pStructure;
+                if(pParams->nPortIndex != 0)
+                    return OMX_ErrorUnsupportedIndex;
+                bStoreMetaData = pParams->bStoreMetaData;
+
+                OMX_CONFIG_BOOLEANTYPE sStoreMetaData;
+                OMX_INIT_STRUCT(&sStoreMetaData, OMX_CONFIG_BOOLEANTYPE);
+                sStoreMetaData.bEnabled = bStoreMetaData;
+                ret = OMX_SetParameter(ComponentHandle, nParamIndex, &sStoreMetaData);
+
+                if (bStoreMetaData == OMX_TRUE) {
+                    OMX_PARAM_PORTDEFINITIONTYPE sPortDef;
+
+                    OMX_INIT_STRUCT(&sPortDef, OMX_PARAM_PORTDEFINITIONTYPE);
+                    sPortDef.nPortIndex = pParams->nPortIndex;
+                    OMX_GetParameter(ComponentHandle, OMX_IndexParamPortDefinition, &sPortDef);
+                    sPortDef.nBufferSize = 4 + sizeof(buffer_handle_t);
+                    OMX_SetParameter(ComponentHandle, OMX_IndexParamPortDefinition, &sPortDef);
+                    bSetGrallocBufferParameter = OMX_FALSE;
+                }
+            }
+            break;
+        case OMX_IndexParamUseAndroidNativeBuffer:
+            {
+                UseAndroidNativeBufferParams *pParams = (UseAndroidNativeBufferParams*)pStructure;
+                if(pParams->nPortIndex != 1)
+                    return OMX_ErrorUnsupportedIndex;
+                ret = DoUseNativeBuffer(pParams);
+            }
+            break;
+#if (ANDROID_VERSION >= JELLY_BEAN_42)
+        case OMX_IndexParamUseAndroidPrependSPSPPStoIDRFrames:
+            {
+                PrependSPSPPSToIDRFramesParams *pParams = (PrependSPSPPSToIDRFramesParams*)pStructure;
+                OMX_PARAM_PREPEND_SPSPPS_TO_IDR sPrependSPSPPSToIDR;
+                OMX_INIT_STRUCT(&sPrependSPSPPSToIDR, OMX_PARAM_PREPEND_SPSPPS_TO_IDR);
+                sPrependSPSPPSToIDR.bEnableSPSToIDR= pParams->bEnable;
+                ret = OMX_SetParameter(ComponentHandle, nParamIndex, &sPrependSPSPPSToIDR);
+            }
+            break;
+#endif
+#if (ANDROID_VERSION >= KITKAT_44)
+        case OMX_IndexParamVideoPortFormat:
+            {
+                OMX_VIDEO_PARAM_PORTFORMATTYPE *pParams = (OMX_VIDEO_PARAM_PORTFORMATTYPE*)pStructure;
+                if(pParams->eCompressionFormat == 9) // defined in framework/native/include/media/openmax/OMX_Video.h
+                    pParams->eCompressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP8;
+                ret = OMX_SetParameter(ComponentHandle, nParamIndex, pStructure);
+            }
+            break;
+        case OMX_IndexParamVideoDecReorderDisable:
+            {
+                DisableAVCReorderParams  *pParams = (DisableAVCReorderParams *)pStructure;
+                OMX_DECODER_REORDER sDecoderReorder;
+                OMX_INIT_STRUCT(&sDecoderReorder, OMX_DECODER_REORDER);
+                sDecoderReorder.bDisable= pParams->bDisable;
+                ret = OMX_SetParameter(ComponentHandle, nParamIndex, &sDecoderReorder);
+            }
+            break;
+#endif
+        default:
+            ret = OMX_SetParameter(ComponentHandle, nParamIndex, pStructure);
+    };
+
+    return ret;
+}
+
+OMX_ERRORTYPE FSLOMXWrapper::GetExtensionIndex(
+        OMX_STRING cParameterName, 
+        OMX_INDEXTYPE* pIndexType)
+{
+    if(!strcmp(cParameterName, "OMX.google.android.index.enableAndroidNativeBuffers"))
+        *pIndexType = OMX_IndexParamEnableAndroidNativeBuffers;
+    else if(!strcmp(cParameterName, "OMX.google.android.index.getAndroidNativeBufferUsage"))
+        *pIndexType = OMX_IndexParamNativeBufferUsage;
+    else if(!strcmp(cParameterName, "OMX.google.android.index.storeMetaDataInBuffers"))
+        *pIndexType = OMX_IndexParamStoreMetaDataInBuffers;
+    else if(!strcmp(cParameterName, "OMX.google.android.index.useAndroidNativeBuffer"))
+        *pIndexType = OMX_IndexParamUseAndroidNativeBuffer;
+    else if(!strcmp(cParameterName, "OMX.google.android.index.prependSPSPPSToIDRFrames"))
+        *pIndexType = OMX_IndexParamUseAndroidPrependSPSPPStoIDRFrames;
+    else if(!strcmp(cParameterName, "OMX.google.android.index.disableAVCReorder"))
+        *pIndexType = OMX_IndexParamVideoDecReorderDisable;
+    else
+        return OMX_GetExtensionIndex(ComponentHandle, cParameterName, pIndexType);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE FSLOMXWrapper::FreeBuffer(
+        OMX_U32 nPortIndex, 
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+    for(OMX_S32 i=0; i<MAX_BUFFER_CNT; i++) {
+        if(pBufferHdr == sBufferMapper[i].pBufferHdr) {
+            sBufferMapper[i].mGraphicBuffer->unlock();
+            RemoveHwBuffer(pBufferHdr->pBuffer);
+            sBufferMapper[i].mGraphicBuffer = NULL;
+            memset(&sBufferMapper[i], 0, sizeof(BufferMapper));
+            nBufferCnt--;
+            break;
+        }
+    }
+
+    OMX_FreeBuffer(ComponentHandle, nPortIndex, pBufferHdr);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE FSLOMXWrapper::DoUseNativeBuffer(
+        UseAndroidNativeBufferParams *pNativBufferParam)
+{
+    if(pNativBufferParam == NULL || pNativBufferParam->nativeBuffer == NULL
+            || pNativBufferParam->pAppPrivate == NULL)
+        return OMX_ErrorBadParameter;
+
+
+    GraphicBuffer *pGraphicBuffer = static_cast<GraphicBuffer*>(pNativBufferParam->nativeBuffer.get());
+    private_handle_t *prvHandle = (private_handle_t*)pGraphicBuffer->getNativeBuffer()->handle;
+
+    OMX_PTR vAddr = NULL;
+    pGraphicBuffer->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, &vAddr);
+    if(vAddr == NULL) {
+        LOGE("Failed to get native buffer virtual address.\n");
+        return OMX_ErrorUndefined;
+    }
+
+    LOGV("native buffer handle %p, phys %p, virs %p, size %d\n", prvHandle, (OMX_PTR)prvHandle->phys, vAddr, prvHandle->size);
+
+    AddHwBuffer((OMX_PTR)prvHandle->phys, vAddr);
+
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    ret = OMX_UseBuffer(ComponentHandle, pNativBufferParam->bufferHeader, 
+            pNativBufferParam->nPortIndex, pNativBufferParam->pAppPrivate, 
+            prvHandle->size, (OMX_U8*)vAddr);
+    if(ret != OMX_ErrorNone) {
+        RemoveHwBuffer(vAddr);
+        pGraphicBuffer->unlock();
+        LOGE("Failed to use native buffer.\n");
+        return ret;
+    }
+
+    sBufferMapper[nBufferCnt].pBufferHdr = *pNativBufferParam->bufferHeader;
+    sBufferMapper[nBufferCnt].mGraphicBuffer = pGraphicBuffer;
+    nBufferCnt ++;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE FSLOMXWrapper::EmptyThisBuffer(
+        OMX_BUFFERHEADERTYPE* pBufferHdr)
+{
+#if (ANDROID_VERSION >= JELLY_BEAN_42)
+    if (bStoreMetaData == OMX_TRUE && pBufferHdr->nFilledLen >= 8) {
+		OMX_U32 *pTempBuffer;
+		OMX_U32 nMetadataBufferType;
+
+		LOGV("Passing meta data to encoder");
+		pTempBuffer = (OMX_U32 *) (pBufferHdr->pBuffer);
+		nMetadataBufferType = *pTempBuffer;
+
+		if(nMetadataBufferType == kMetadataBufferTypeCameraSource) {
+			LOGV("MetadataBufferType is kMetadataBufferTypeCameraSource");
+		}
+		else if(nMetadataBufferType == kMetadataBufferTypeGrallocSource) {
+			LOGV("MetadataBufferType is kMetadataBufferTypeGrallocSource");
+        }
+
+        private_handle_t* pGrallocHandle;
+        buffer_handle_t  tBufHandle;
+
+        pTempBuffer++;
+        tBufHandle =  *((buffer_handle_t *)pTempBuffer);
+        pGrallocHandle = (private_handle_t*) tBufHandle;
+        LOGV("Grallloc buffer recieved in metadata buffer 0x%x",pGrallocHandle );
+
+        ((METADATA_BUFFER *)(pBufferHdr->pBuffer))->pPhysicAddress = \
+           (OMX_PTR) pGrallocHandle->phys;
+        LOGV("%s Gralloc=0x%x, phys = 0x%x", __FUNCTION__, pGrallocHandle,
+                pGrallocHandle->phys);
+
+        if (bSetGrallocBufferParameter == OMX_FALSE) {
+            GRALLOC_BUFFER_PARAMETER sGrallocBufferParam;
+
+            OMX_INIT_STRUCT(&sGrallocBufferParam, GRALLOC_BUFFER_PARAMETER);
+            sGrallocBufferParam.nPortIndex = 0;
+
+            sGrallocBufferParam.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+            switch(pGrallocHandle->format) {
+                case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+                    sGrallocBufferParam.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+                    break;
+                case HAL_PIXEL_FORMAT_YCbCr_420_P:
+                    sGrallocBufferParam.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+                    break;
+                case HAL_PIXEL_FORMAT_RGBA_8888:
+                    sGrallocBufferParam.eColorFormat = OMX_COLOR_Format32bitRGBA8888;
+                    break;
+                default:
+                    ALOGE("Not supported color format %d!", pGrallocHandle->format);
+                    break;
+            }
+
+            OMX_SetConfig(ComponentHandle, OMX_IndexConfigGrallocBufferParameter, &sGrallocBufferParam);
+            bSetGrallocBufferParameter = OMX_TRUE;
+        }
+
+    }
+#endif
+
+    return OMX_EmptyThisBuffer(ComponentHandle, pBufferHdr);
+}
+
+// FSLOMXPlugin class
+
+OMX_ERRORTYPE FSLOMXPlugin::makeComponentInstance(
+        const char *name,
+        const OMX_CALLBACKTYPE *callbacks,
+        OMX_PTR appData,
+        OMX_COMPONENTTYPE **component)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+
+    LOGV("makeComponentInstance, appData: %p", appData);
+
+    OMX_HANDLETYPE handle = NULL;
+    ret = OMX_GetHandle(&handle, (char*)name, appData, (OMX_CALLBACKTYPE*)callbacks);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    FSLOMXWrapper *pWrapper = new FSLOMXWrapper;
+    if(pWrapper == NULL)
+        return OMX_ErrorInsufficientResources;
+
+    *component = pWrapper->MakeWapper(handle);
+    if(*component == NULL)
+        return OMX_ErrorUndefined;
+
+    LOGV("makeComponentInstance done, instance is: %p", *component);
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE FSLOMXPlugin::destroyComponentInstance(
+            OMX_COMPONENTTYPE *component)
+{
+    LOGV("destroyComponentInstance, %p", component);
+
+    FSLOMXWrapper *pWrapper = (FSLOMXWrapper*)component->pComponentPrivate;
+    OMX_FreeHandle(pWrapper->GetComponentHandle());
+    delete pWrapper;
+
+    return OMX_ErrorNone;
+}
+
+OMX_ERRORTYPE FSLOMXPlugin::enumerateComponents(
+            OMX_STRING name,
+            size_t size,
+            OMX_U32 index)
+{
+    return OMX_ComponentNameEnum(name, size, index);
+}
+
+OMX_ERRORTYPE FSLOMXPlugin::getRolesOfComponent(
+            const char *name,
+            Vector<String8> *roles)
+{
+    OMX_ERRORTYPE ret = OMX_ErrorNone;
+    OMX_U32 numRoles;
+
+    LOGV("Call getRolesOfComponent.\n");
+
+    roles->clear();
+    ret = OMX_GetRolesOfComponent((char*)name, &numRoles, NULL);
+    if(ret != OMX_ErrorNone)
+        return ret;
+
+    if (numRoles > 0) {
+        OMX_U8 **array = new OMX_U8 *[numRoles];
+        OMX_S32 i;
+        for (i = 0; i   < (OMX_S32)numRoles;   ++i) {
+            array[i] = new OMX_U8[OMX_MAX_STRINGNAME_SIZE];
+        }
+
+        OMX_U32 numRoles2;
+        ret = OMX_GetRolesOfComponent((char*)name, &numRoles2, array);
+        if(ret != OMX_ErrorNone)
+            return ret;
+
+        for (i = 0; i < (OMX_S32)numRoles; ++i) {
+            String8 s((const char   *)array[i]);
+            roles->push(s);
+            delete[] array[i];
+            array[i] = NULL;
+        }
+
+        delete[] array;
+        array   =   NULL;
+    }
+
+    return OMX_ErrorNone;
+}
+
+OMXPluginBase* createOMXPlugin()
+{
+    LOGV("createOMXPlugin");
+    return (new FSLOMXPlugin());
+}
+
+}
diff --git a/utils/Android.mk b/utils/Android.mk
new file mode 100755
index 0000000..b252fff
--- /dev/null
+++ b/utils/Android.mk
@@ -0,0 +1,40 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+SOURCE_FILES = \
+	       Mem.cpp \
+	       Queue.cpp \
+	       RegistryAnalyser.cpp \
+	       RingBuffer.cpp \
+	       AudioTSManager.cpp \
+	       FadeInFadeOut.cpp \
+	       ShareLibarayMgr.cpp \
+	       mfw_gst_ts.c \
+	       Tsm_wrapper.c \
+			colorconvert/src/cczoomrotation16.cpp \
+			colorconvert/src/cczoomrotationbase.cpp \
+			audio_frame_parser/AudioFrameParser.c \
+			audio_frame_parser/AacFrameParser.c \
+			audio_frame_parser/Mp3FrameParser.c \
+			audio_frame_parser/Ac3FrameParser.c
+
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+ 
+LOCAL_C_INCLUDES += $(FSL_OMX_INCLUDES) \
+		    $(LOCAL_PATH)/colorconvert/include \
+			$(LOCAL_PATH)/audio_frame_parser
+
+LOCAL_SHARED_LIBRARIES := libdl lib_omx_osal_v2_arm11_elinux
+
+LOCAL_PRELINK_MODULE := false
+	
+LOCAL_MODULE:= lib_omx_utils_v2_arm11_elinux
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/utils/AudioTSManager.cpp b/utils/AudioTSManager.cpp
new file mode 100755
index 0000000..0ad68e5
--- /dev/null
+++ b/utils/AudioTSManager.cpp
@@ -0,0 +1,214 @@
+/**
+ *  Copyright (c) 2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include "Mem.h"
+#include "Log.h"
+#include "AudioTSManager.h"
+
+AudioTSManager::AudioTSManager()
+{
+	TS_Queue = NULL;
+	CurrentTS = 0;
+    PreTS = -1;
+    bHaveTS = E_FSL_OSAL_FALSE;
+	TotalConsumeLen = 0;
+	TotalReceivedLen = 0;
+    nOneByteTime = 0;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::Create()
+{
+    AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+
+	/** Create queue for TS. */
+	TS_Queue = FSL_NEW(Queue, ());
+	if (TS_Queue == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return AUDIO_TS_MANAGER_INSUFFICIENT_RESOURCES;
+	}
+
+	if (TS_Queue->Create(TS_QUEUE_SIZE, sizeof(TS_QUEUE), E_FSL_OSAL_FALSE) != QUEUE_SUCCESS)
+	{
+		FSL_DELETE(TS_Queue);
+		LOG_ERROR("Can't create audio ts queue.\n");
+		return AUDIO_TS_MANAGER_INSUFFICIENT_RESOURCES;
+	}
+
+	CurrentTS = 0;
+    PreTS = -1;
+	bHaveTS = E_FSL_OSAL_FALSE;
+	TotalConsumeLen = 0;
+	TotalReceivedLen = 0;
+
+    return ret;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::SetOneByteTime(fsl_osal_u32 OneByteTime)
+{
+	AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+
+    nOneByteTime = OneByteTime;
+
+	return ret;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::Reset()
+{
+	AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+
+	while (TS_Queue->Size() > 0)
+	{
+		TS_QUEUE TS_Item;
+
+		if (TS_Queue->Get(&TS_Item) != QUEUE_SUCCESS)
+		{
+			LOG_ERROR("Can't get audio TS item.\n");
+			return AUDIO_TS_MANAGER_FAILURE;
+		}
+	}
+
+	CurrentTS = 0;
+    PreTS = -1;
+	bHaveTS = E_FSL_OSAL_FALSE;
+	TotalConsumeLen = 0;
+	TotalReceivedLen = 0;
+
+	return ret;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::Free()
+{
+	AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+
+	LOG_DEBUG("TS queue free\n");
+	if(TS_Queue != NULL)
+		TS_Queue->Free();
+	LOG_DEBUG("TS queue delete\n");
+	FSL_DELETE(TS_Queue);
+
+	return ret;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::TS_Add(fsl_osal_s64 ts, fsl_osal_u32 BufferLen)
+{
+	AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+	TS_QUEUE TS_Item;
+
+    do {
+        // Core parser EOS.
+        // Core parser will output same audio time stamp if the audio data in 
+        // same trunk.
+        if (ts < 0 \
+                || (ts == 0 && BufferLen == 0) \
+                || ts == PreTS)
+            break;
+
+        TS_Item.ts = ts;
+        PreTS = ts;
+        /** Should add TS first after received buffer from input port */
+        TS_Item.AudioTSManagerBegin = TotalReceivedLen; 
+        LOG_LOG("TS: %lld\t AudioTSManagerBegin: %lld\n", TS_Item.ts, \
+                TS_Item.AudioTSManagerBegin);
+
+        if (TS_Queue->Add(&TS_Item) != QUEUE_SUCCESS) {
+            LOG_ERROR("Can't add TS item to audio ts queue. Queue size: %d, max queue size: %d \n", TS_Queue->Size(), TS_QUEUE_SIZE);
+            ret = AUDIO_TS_MANAGER_FAILURE;
+            break;
+        }
+    }while (0);
+
+	TotalReceivedLen += BufferLen;
+
+	return ret;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::TS_Get(fsl_osal_s64 *ts)
+{
+	AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+	*ts = CurrentTS;
+	LOG_DEBUG_INS("Get CurrentTS = %lld\n", CurrentTS);
+	return ret;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::TS_SetIncrease(fsl_osal_s64 ts)
+{
+    AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+	if (bHaveTS == E_FSL_OSAL_FALSE) {
+		CurrentTS += ts;
+	}
+	bHaveTS = E_FSL_OSAL_FALSE;
+	LOG_DEBUG_INS("Set CurrentTS = %lld\n", CurrentTS);
+	return ret;
+}
+
+fsl_osal_u32 AudioTSManager::GetFrameLen()
+{
+	TS_QUEUE TS_Item;
+	fsl_osal_u32 nFrameLen = 0;
+
+	if (TS_Queue->Access(&TS_Item, 1) != QUEUE_SUCCESS) {
+		LOG_WARNING("Can't get audio TS item.\n");
+		return TotalReceivedLen - TotalConsumeLen;
+	}
+
+	nFrameLen = TS_Item.AudioTSManagerBegin - TotalConsumeLen;
+	LOG_LOG("TS_Item.RingBufferBegin: %lld\n", TS_Item.AudioTSManagerBegin);
+	LOG_LOG("TotalConsumeLen: %lld\n", TotalConsumeLen);
+	LOG_LOG("Frame Len: %d\n", nFrameLen);
+
+	return nFrameLen;
+}
+
+AUDIO_TS_MANAGER_ERRORTYPE AudioTSManager::Consumered(fsl_osal_u32 ConsumeredLen)
+{
+    AUDIO_TS_MANAGER_ERRORTYPE ret = AUDIO_TS_MANAGER_SUCCESS;
+
+	if (TotalReceivedLen < TotalConsumeLen + ConsumeredLen) {
+		LOG_ERROR("audio ts manager consumer point set error.\n");
+		return AUDIO_TS_MANAGER_FAILURE;
+	}
+
+	TotalConsumeLen += ConsumeredLen;
+
+	if (TS_Queue->Size() < 1)
+		return ret;
+
+	/** Adjust current TS */
+	TS_QUEUE TS_Item;
+
+	while (1) {
+		if (TS_Queue->Access(&TS_Item, 1) != QUEUE_SUCCESS) {
+			LOG_DEBUG("Can't get audio TS item.\n");
+			return AUDIO_TS_MANAGER_SUCCESS;
+		}
+
+        if (TotalConsumeLen >= TS_Item.AudioTSManagerBegin) {
+            CurrentTS = TS_Item.ts;
+            if (nOneByteTime) {
+                CurrentTS += (TotalConsumeLen - TS_Item.AudioTSManagerBegin) \
+                             * nOneByteTime;
+            }
+            bHaveTS = E_FSL_OSAL_TRUE;
+
+            if (TS_Queue->Get(&TS_Item) != QUEUE_SUCCESS) {
+                LOG_ERROR("Can't get audio TS item.\n");
+                return AUDIO_TS_MANAGER_FAILURE;
+            }
+        }
+		else
+			break;
+	}
+
+	return ret;
+}
+
+/* File EOF */
diff --git a/utils/AudioTSManager.h b/utils/AudioTSManager.h
new file mode 100755
index 0000000..71aa770
--- /dev/null
+++ b/utils/AudioTSManager.h
@@ -0,0 +1,63 @@
+/**
+ *  Copyright (c) 2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file AudioTSManager.h
+ *  @brief Class definition of audio time stamp manager.
+ *  @ingroup AudioTSManager
+ */
+
+
+#ifndef AudioTSManager_h
+#define AudioTSManager_h
+
+#include "fsl_osal.h"
+#include "Queue.h"
+
+#define TS_QUEUE_SIZE (1024*20)
+
+typedef enum {
+    AUDIO_TS_MANAGER_SUCCESS,
+    AUDIO_TS_MANAGER_FAILURE,
+    AUDIO_TS_MANAGER_INSUFFICIENT_RESOURCES
+}AUDIO_TS_MANAGER_ERRORTYPE;
+
+typedef struct _TS_QUEUE{
+    fsl_osal_s64 ts;
+	fsl_osal_s64 AudioTSManagerBegin;
+}TS_QUEUE;
+
+class AudioTSManager {
+	public:
+		AudioTSManager();
+		AUDIO_TS_MANAGER_ERRORTYPE Create();
+        AUDIO_TS_MANAGER_ERRORTYPE SetOneByteTime(fsl_osal_u32 OneByteTime);
+        AUDIO_TS_MANAGER_ERRORTYPE Free();
+		AUDIO_TS_MANAGER_ERRORTYPE Reset();
+		AUDIO_TS_MANAGER_ERRORTYPE TS_Add(fsl_osal_s64 ts, fsl_osal_u32 BufferLen);
+		/** Set TS increase after decode one of audio data */
+		AUDIO_TS_MANAGER_ERRORTYPE TS_SetIncrease(fsl_osal_s64 ts); 
+		/** Get TS for output audio data of audio decoder. The output TS is calculated for 
+		 every frame of audio data */
+		AUDIO_TS_MANAGER_ERRORTYPE TS_Get(fsl_osal_s64 *ts); 
+		fsl_osal_u32 GetFrameLen();
+		/** Set consumered point for ring buffer. */
+		AUDIO_TS_MANAGER_ERRORTYPE Consumered(fsl_osal_u32 ConsumeredLen);
+	private:
+		Queue *TS_Queue;
+		fsl_osal_s64 CurrentTS;
+		fsl_osal_s64 PreTS;
+		efsl_osal_bool bHaveTS;
+		fsl_osal_s64 TotalConsumeLen;
+		fsl_osal_s64 TotalReceivedLen;
+        fsl_osal_u32 nOneByteTime;
+};
+
+#endif
+/* File EOF */
diff --git a/utils/FadeInFadeOut.cpp b/utils/FadeInFadeOut.cpp
new file mode 100755
index 0000000..e682ebf
--- /dev/null
+++ b/utils/FadeInFadeOut.cpp
@@ -0,0 +1,268 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Mem.h"
+#include "Log.h"
+#include "FadeInFadeOut.h"
+
+FADEINFADEOUT_ERRORTYPE FadeInFadeOut::Create(fsl_osal_u32 Channels, fsl_osal_u32 \
+		SamplingRate, fsl_osal_u32 BitsPerSample, fsl_osal_u32 ProcessLen, \
+		fsl_osal_u32 FadeScale)
+{
+	FADEINFADEOUT_ERRORTYPE ret = FADEINFADEOUT_SUCCESS;
+
+	if (FadeScale <= 1)
+	{
+		nFadeScale = FadeScale;
+	}
+	nFadeScaleStep = (fsl_osal_float)(1)/(ProcessLen/Channels/(BitsPerSample>>3));
+	eFadeMode = FADENONE;
+	nChannels = Channels;
+	nSamplingRate = SamplingRate;
+	nBitsPerSample = BitsPerSample;
+	nAudioDataLen = 0;
+	nProcessLen = ProcessLen;
+
+	return ret;
+}
+FADEINFADEOUT_ERRORTYPE FadeInFadeOut::SetMode(FADE_MODE FadeMode)
+{
+    FADEINFADEOUT_ERRORTYPE ret = FADEINFADEOUT_SUCCESS;
+
+	eFadeMode = FadeMode;
+
+	return ret;
+}
+
+FADEINFADEOUT_ERRORTYPE FadeInFadeOut::SetAudioDataLen(fsl_osal_u32 AudioDataLen)
+{
+    FADEINFADEOUT_ERRORTYPE ret = FADEINFADEOUT_SUCCESS;
+
+	nAudioDataLen = AudioDataLen;	
+
+	return ret;
+}
+
+FADEINFADEOUT_ERRORTYPE FadeInFadeOut::Process(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen)
+{
+    FADEINFADEOUT_ERRORTYPE ret = FADEINFADEOUT_SUCCESS;
+
+        if(nProcessLen == 0)
+            return FADEINFADEOUT_SUCCESS;
+
+	switch(eFadeMode)
+	{
+		case FADENONE:
+			break;
+		case FADEIN:
+			ret = FadeIn(pBuffer, BufferLen);
+			LOG_DEBUG("Fade in scale = %f\n", nFadeScale);
+			break;
+		case FADEOUT:
+			ret = FadeOut(pBuffer, BufferLen);
+			LOG_DEBUG("Fade out scale = %f\n", nFadeScale);
+			break;
+		case FADEOUTALL:
+			if (nAudioDataLen == 0)
+				return FADEINFADEOUT_FAILURE;
+
+			nAudioDataLen -= BufferLen;
+			if (nAudioDataLen < nProcessLen)
+			{
+				eFadeMode = FADEOUT;
+				ret = FadeOut(pBuffer + BufferLen - (nProcessLen - nAudioDataLen), \
+						nProcessLen - nAudioDataLen);
+				nAudioDataLen = 0;
+			}
+			break;
+		default:
+			break;
+	}
+
+	return ret;
+}
+
+FADEINFADEOUT_ERRORTYPE FadeInFadeOut::FadeIn(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen)
+{
+    FADEINFADEOUT_ERRORTYPE ret = FADEINFADEOUT_SUCCESS;
+	fsl_osal_u32 i, j, Len;
+	if (nBitsPerSample == 0 || nChannels == 0)
+		return FADEINFADEOUT_FAILURE;
+
+	if (nFadeScale >= 1) {
+		nFadeScale = 1;
+		eFadeMode = FADENONE;
+		return ret;
+	}
+
+	Len = BufferLen / (nBitsPerSample>>3) / nChannels;
+
+	switch(nBitsPerSample)
+	{
+		case 8:
+			{
+				fsl_osal_s8 *pSrc = (fsl_osal_s8 *)pBuffer, *pDst = (fsl_osal_s8 *)pBuffer;
+				fsl_osal_s8 Tmp;
+				for (i = 0; i < Len; i ++)
+				{
+					for (j = 0; j < nChannels; j ++)
+					{
+						Tmp = pSrc[i*nChannels+j];
+						Tmp = (fsl_osal_s8)(Tmp * nFadeScale);
+						pDst[i*nChannels+j] = Tmp;
+					}
+					nFadeScale += nFadeScaleStep;
+					if (nFadeScale > 1)
+					{
+						nFadeScale = 1;
+						eFadeMode = FADENONE;
+						break;
+					}
+				}
+			}
+			break;
+		case 16:
+			{
+				fsl_osal_s16 *pSrc = (fsl_osal_s16 *)pBuffer, *pDst = (fsl_osal_s16 *)pBuffer;
+				fsl_osal_s16 Tmp;
+				for (i = 0; i < Len; i ++)
+				{
+					for (j = 0; j < nChannels; j ++)
+					{
+						Tmp = pSrc[i*nChannels+j];
+						LOG_LOG("Fade in scale = %f\n", nFadeScale);
+						Tmp = (fsl_osal_s16)(Tmp * nFadeScale);
+						pDst[i*nChannels+j] = Tmp;
+					}
+					nFadeScale += nFadeScaleStep;
+					if (nFadeScale > 1)
+					{
+						nFadeScale = 1;
+						eFadeMode = FADENONE;
+						break;
+					}
+				}
+			}
+			break;
+		case 24:
+			{
+				fsl_osal_u8 *pSrc = (fsl_osal_u8 *)pBuffer, *pDst = (fsl_osal_u8 *)pBuffer;
+				fsl_osal_s32 Tmp;
+				for (i = 0; i < Len; i ++)
+				{
+					for (j = 0; j < nChannels; j ++)
+					{
+						Tmp = (((fsl_osal_u32)pSrc[(i*nChannels+j)*3]))|(((fsl_osal_u32)pSrc[(i*nChannels+j)*3+1])<<8)|(((fsl_osal_u32)pSrc[(i*nChannels+j)*3+2])<<16);
+						if (Tmp&0x800000) Tmp |= 0xff000000;
+						Tmp = (fsl_osal_s32)(Tmp * nFadeScale);
+						pDst[(i*nChannels+j)*3] = Tmp;
+						pDst[(i*nChannels+j)*3+1] = Tmp>>8;
+						pDst[(i*nChannels+j)*3+2] = Tmp>>16;
+					}
+					nFadeScale += nFadeScaleStep;
+					if (nFadeScale > 1)
+					{
+						nFadeScale = 1;
+						eFadeMode = FADENONE;
+						break;
+					}
+				}
+			}
+			break;
+	}
+
+	return ret;
+}
+
+FADEINFADEOUT_ERRORTYPE FadeInFadeOut::FadeOut(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen)
+{
+    FADEINFADEOUT_ERRORTYPE ret = FADEINFADEOUT_SUCCESS;
+	fsl_osal_u32 i, j, Len;
+	if (nBitsPerSample == 0 || nChannels == 0)
+		return FADEINFADEOUT_FAILURE;
+
+	Len = BufferLen / (nBitsPerSample>>3) / nChannels;
+
+	switch(nBitsPerSample)
+	{
+		case 8:
+			{
+				fsl_osal_s8 *pSrc = (fsl_osal_s8 *)pBuffer, *pDst = (fsl_osal_s8 *)pBuffer;
+				fsl_osal_s8 Tmp;
+				for (i = 0; i < Len; i ++)
+				{
+					for (j = 0; j < nChannels; j ++)
+					{
+						Tmp = pSrc[i*nChannels+j];
+						Tmp = (fsl_osal_s8)(Tmp * nFadeScale);
+						pDst[i*nChannels+j] = Tmp;
+					}
+					nFadeScale -= nFadeScaleStep;
+					if (nFadeScale < 0)
+					{
+						nFadeScale = 0;
+						eFadeMode = FADEIN;
+					}
+				}
+			}
+			break;
+		case 16:
+			{
+				fsl_osal_s16 *pSrc = (fsl_osal_s16 *)pBuffer, *pDst = (fsl_osal_s16 *)pBuffer;
+				fsl_osal_s16 Tmp;
+				for (i = 0; i < Len; i ++)
+				{
+					for (j = 0; j < nChannels; j ++)
+					{
+						Tmp = pSrc[i*nChannels+j];
+						LOG_LOG("Fade out scale = %f\n", nFadeScale);
+						LOG_LOG("Fade process len = %d\n", i);
+						Tmp = (fsl_osal_s16)(Tmp * nFadeScale);
+						pDst[i*nChannels+j] = Tmp;
+					}
+					nFadeScale -= nFadeScaleStep;
+					if (nFadeScale < 0)
+					{
+						nFadeScale = 0;
+						eFadeMode = FADEIN;
+					}
+				}
+			}
+			break;
+		case 24:
+			{
+				fsl_osal_u8 *pSrc = (fsl_osal_u8 *)pBuffer, *pDst = (fsl_osal_u8 *)pBuffer;
+				fsl_osal_s32 Tmp;
+				for (i = 0; i < Len; i ++)
+				{
+					for (j = 0; j < nChannels; j ++)
+					{
+						Tmp = (((fsl_osal_u32)pSrc[(i*nChannels+j)*3]))|(((fsl_osal_u32)pSrc[(i*nChannels+j)*3+1])<<8)|(((fsl_osal_u32)pSrc[(i*nChannels+j)*3+2])<<16);
+						if (Tmp&0x800000) Tmp |= 0xff000000;
+						Tmp = (fsl_osal_s32)(Tmp * nFadeScale);
+						pDst[(i*nChannels+j)*3] = Tmp;
+						pDst[(i*nChannels+j)*3+1] = Tmp>>8;
+						pDst[(i*nChannels+j)*3+2] = Tmp>>16;
+					}
+					nFadeScale -= nFadeScaleStep;
+					if (nFadeScale < 0)
+					{
+						nFadeScale = 0;
+						eFadeMode = FADEIN;
+					}
+				}
+			}
+			break;
+	}
+
+	return ret;
+}
+
+
+/* File EOF */
diff --git a/utils/FadeInFadeOut.h b/utils/FadeInFadeOut.h
new file mode 100755
index 0000000..47c9500
--- /dev/null
+++ b/utils/FadeInFadeOut.h
@@ -0,0 +1,56 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file FadeInFadeOut.h
+ *  @brief Class definition of fade in fade out.
+ *  @ingroup FadeInFadeOut
+ */
+
+
+#ifndef FadeInFadeOut_h
+#define FadeInFadeOut_h
+
+#include "fsl_osal.h"
+
+typedef enum {
+    FADEINFADEOUT_SUCCESS,
+    FADEINFADEOUT_FAILURE,
+    FADEINFADEOUT_INSUFFICIENT_RESOURCES
+}FADEINFADEOUT_ERRORTYPE;
+
+typedef enum {
+    FADENONE,
+    FADEIN,
+	FADEOUT,
+    FADEOUTALL
+}FADE_MODE;
+
+class FadeInFadeOut {
+	public:
+		FADEINFADEOUT_ERRORTYPE Create(fsl_osal_u32 Channels, fsl_osal_u32 SamplingRate, \
+				fsl_osal_u32 BitsPerSample, fsl_osal_u32 ProcessLen, fsl_osal_u32 FadeScale);
+		FADEINFADEOUT_ERRORTYPE SetMode(FADE_MODE FadeMode);
+		FADEINFADEOUT_ERRORTYPE SetAudioDataLen(fsl_osal_u32 AudioDataLen);
+		FADEINFADEOUT_ERRORTYPE Process(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen);
+		FADEINFADEOUT_ERRORTYPE FadeIn(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen);
+		FADEINFADEOUT_ERRORTYPE FadeOut(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen);
+	private:
+		fsl_osal_float nFadeScale;
+		fsl_osal_float nFadeScaleStep;
+		FADE_MODE eFadeMode;
+		fsl_osal_u32 nChannels;
+		fsl_osal_u32 nSamplingRate;
+		fsl_osal_u32 nBitsPerSample;
+		fsl_osal_u32 nAudioDataLen;
+		fsl_osal_u32 nProcessLen;
+};
+
+#endif
+/* File EOF */
diff --git a/utils/List.h b/utils/List.h
new file mode 100755
index 0000000..58bb7f6
--- /dev/null
+++ b/utils/List.h
@@ -0,0 +1,289 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file utils/List.h
+ *  @brief List template class.
+ *  @ingroup utils
+ */
+
+#ifndef List_h
+#define List_h
+
+#include "fsl_osal.h"
+#include "Log.h"
+#include "Mem.h"
+
+typedef enum LIST_RETURNTYPE {
+	LIST_SUCCESS = 0,
+    LIST_FAILURE
+} LSIT_RETURNTYPE; 
+ 
+template<class T> class List
+{
+	public:
+		List();
+		LSIT_RETURNTYPE Add(T *node, fsl_osal_u32 priority = 0); /**< Add node at the tail or based on priority*/
+		LSIT_RETURNTYPE Add(T *node, T *pUpNode); /**< Add node behind up node*/
+		LSIT_RETURNTYPE Remove(T *node); /**< Remove one node */
+		LSIT_RETURNTYPE Replace(T *node, T *nodeNew); /**< Replace one node with new node */
+		fsl_osal_u32 GetNodeCnt();
+		T *GetNode(fsl_osal_u32 index); /**< Get one node based on index, first index is 0 */
+		~List(); /**< Free all node */
+	private:
+		struct NODE{
+			NODE *pNext;
+			T *pT;
+			fsl_osal_u32 priority;
+		};
+		NODE *pFirst;
+		fsl_osal_u32 NodeCnt;
+};
+
+template<class T> List<T>::List()
+{
+	pFirst = NULL;
+	NodeCnt = 0;	
+}
+
+template<class T>
+LSIT_RETURNTYPE List<T>::Add(T *node, fsl_osal_u32 priority)
+{
+	NODE **ppTmp = &pFirst, **ppTmp2 = &pFirst, *pTmp3;
+
+	if (node == NULL)
+	{
+		LOG_ERROR("Add NULL to list.\n");
+		return LIST_FAILURE;
+	}
+
+	while (*ppTmp != NULL)
+	{
+		if (priority > (*ppTmp)->priority) 
+		{
+			break;
+		}
+		ppTmp2 = ppTmp;
+		ppTmp = &((*ppTmp)->pNext);
+	}
+
+	pTmp3 = FSL_NEW(NODE, ());
+	pTmp3->pT = node;
+	pTmp3->pNext = NULL;
+	pTmp3->priority = priority;
+	NodeCnt ++;
+
+	if (priority == 0)
+	{
+		*ppTmp = pTmp3;
+	}
+	else
+	{
+		if (*ppTmp == *ppTmp2)
+		{
+			/** Insert to begin. */
+			if (pFirst != NULL)
+			{
+				pTmp3->pNext = pFirst;
+			}
+			*ppTmp2 = pTmp3;
+		}
+		else if (*ppTmp == NULL)
+		{
+			/** Insert to the end */
+			*ppTmp = pTmp3;
+		}
+		else
+		{
+			/** Insert to the middle */
+			pTmp3->pNext = *ppTmp;
+			(*ppTmp2)->pNext = pTmp3;
+		}
+	}
+
+	return LIST_SUCCESS;
+}
+
+template<class T>
+LSIT_RETURNTYPE List<T>::Add(T *node, T *pUpNode)
+{
+	NODE **ppTmp = &pFirst, **ppTmp2 = &pFirst, *pTmp3;
+
+	if (node == NULL)
+	{
+		LOG_ERROR("Add NULL to list.\n");
+		return LIST_FAILURE;
+	}
+
+	while (*ppTmp != NULL)
+	{
+		if (pUpNode == (*ppTmp)->pT) 
+		{
+			ppTmp2 = ppTmp;
+			break;
+		}
+		ppTmp = &((*ppTmp)->pNext);
+	}
+
+	if (*ppTmp == NULL)
+	{
+		LOG_ERROR("Add NULL to list.\n");
+		return LIST_FAILURE;
+	}
+	ppTmp = &((*ppTmp)->pNext);
+
+	pTmp3 = FSL_NEW(NODE, ());
+	pTmp3->pT = node;
+	pTmp3->pNext = NULL;
+	pTmp3->priority = (*ppTmp2)->priority;
+	NodeCnt ++;
+
+	if (*ppTmp == *ppTmp2)
+	{
+		/** Insert to begin. */
+		if (pFirst != NULL)
+		{
+			pTmp3->pNext = pFirst;
+		}
+		*ppTmp2 = pTmp3;
+	}
+	else if (*ppTmp == NULL)
+	{
+		/** Insert to the end */
+		*ppTmp = pTmp3;
+	}
+	else
+	{
+		/** Insert to the middle */
+		pTmp3->pNext = *ppTmp;
+		(*ppTmp2)->pNext = pTmp3;
+	}
+
+	return LIST_SUCCESS;
+}
+
+
+template<class T>
+LSIT_RETURNTYPE List<T>::Remove(T *node)
+{
+	NODE *pTmp, *pTmp2;
+
+	if (node == NULL)
+	{
+		LOG_ERROR("Remove NULL from list.\n");
+		return LIST_FAILURE;
+	}
+
+	pTmp = pFirst;
+	pTmp2 = pFirst;
+	while (pTmp != NULL)
+	{
+		if (pTmp->pT == node)
+		{
+			LOG_LOG("Found the node in the list.\n");
+			if (pTmp == pFirst)
+			{
+				pFirst = pTmp->pNext;
+			}
+			else
+			{
+				pTmp2->pNext = pTmp->pNext;
+			}
+			FSL_DELETE(pTmp);
+			NodeCnt --;
+			if (NodeCnt == 0)
+			{
+				pFirst = NULL;
+			}
+
+			return LIST_SUCCESS;
+		}
+		pTmp2 = pTmp;
+		pTmp = pTmp->pNext;
+	}
+
+	LOG_ERROR("Can't find the node.\n");
+	return LIST_FAILURE;
+}
+
+template<class T>
+fsl_osal_u32 List<T>::GetNodeCnt()
+{
+	return NodeCnt;
+}
+
+template<class T>
+T *List<T>::GetNode(fsl_osal_u32 index)
+{
+	NODE *pTmp;
+	fsl_osal_u32 i;
+
+	if (NodeCnt == 0)
+	{
+		LOG_LOG("No node in the list.\n");
+		return NULL;
+	}
+
+	if (index > NodeCnt - 1)
+	{
+		LOG_LOG("No so many node in the list.\n");
+		return NULL;
+	}
+
+	pTmp = pFirst;
+	for (i = 0; i < index; i ++)
+	{
+		pTmp = pTmp->pNext;
+	}
+
+	return pTmp->pT;
+}
+
+template<class T>
+LSIT_RETURNTYPE List<T>::Replace(T *node, T *nodeNew)
+{
+	NODE *pTmp;
+
+	if (node == NULL)
+	{
+		LOG_ERROR("Remove NULL from list.\n");
+		return LIST_FAILURE;
+	}
+
+	pTmp = pFirst;
+	while (pTmp != NULL)
+	{
+		if (pTmp->pT == node)
+		{
+			pTmp->pT = nodeNew;
+			return LIST_SUCCESS;
+		}
+		pTmp = pTmp->pNext;
+	}
+
+	LOG_ERROR("Can't find the node.\n");
+	return LIST_FAILURE;
+}
+
+
+template<class T> List<T>::~List()
+{
+	NODE *pTmp = pFirst, *pTmp2 = pFirst;
+
+	while (pTmp != NULL)
+	{
+		pTmp2 = pTmp;
+		pTmp = pTmp->pNext;
+		FSL_DELETE(pTmp2);
+	}
+}
+
+
+#endif
+/* File EOF */
diff --git a/utils/Makefile b/utils/Makefile
new file mode 100755
index 0000000..3347986
--- /dev/null
+++ b/utils/Makefile
@@ -0,0 +1,67 @@
+#####################################################################################
+#
+#   Copyright (c) 2009, Freescale Semiconductors Inc.,
+#   All Rights Reserved.
+# 
+#   The following programs are the sole property of Freescale Semiconductors Inc.,
+#   and contain its proprietary and confidential information.
+# 
+####################################################################################### 
+#
+#   This file will compile all cpp file and build dynimic library. 
+#
+######################################################################################
+
+
+# Set the root directory
+OMX_ROOT_DIR=..
+
+# Set the BUILD information
+include $(OMX_ROOT_DIR)/Makefile.defines
+
+UTILS_SO_NAME= lib$(UTILS_LIB_NAME).so
+
+LFLAGS+= -l$(OSAL_LIB_NAME)
+
+SOURCE_FILES = $(SRC_DIR)/Mem.cpp \
+	$(SRC_DIR)/Queue.cpp \
+	$(SRC_DIR)/RegistryAnalyser.cpp \
+	$(SRC_DIR)/RingBuffer.cpp \
+	$(SRC_DIR)/FadeInFadeOut.cpp \
+	$(SRC_DIR)/ShareLibarayMgr.cpp \
+	$(SRC_DIR)/colorconvert/src/cczoomrotation16.cpp \
+	$(SRC_DIR)/colorconvert/src/cczoomrotationbase.cpp
+
+CSOURCE_FILES = $(SRC_DIR)/mfw_gst_ts.c \
+	              $(SRC_DIR)/audio_frame_parser/AudioFrameParser.c \
+	              $(SRC_DIR)/audio_frame_parser/AacFrameParser.c \
+	              $(SRC_DIR)/audio_frame_parser/Mp3FrameParser.c \
+	              $(SRC_DIR)/audio_frame_parser/Ac3FrameParser.c
+				  
+				  
+OBJECTS = $(SOURCE_FILES:.cpp=.o)
+OBJECTS += $(CSOURCE_FILES:.c=.o)
+
+CXXFLAGS += -I./colorconvert/include
+
+all: $(UTILS_SO_NAME)
+
+$(UTILS_SO_NAME):$(OBJECTS)
+	$(CXX) -shared -Wl,-soname,$(UTILS_SO_NAME) -o $(UTILS_SO_NAME) $(OBJECTS) $(LFLAGS) 
+
+	mv $(UTILS_SO_NAME) $(RELEASE_LIB_DIR)/$(UTILS_SO_NAME)
+	@echo "-----------------------------------------------------------------------------------"
+
+.cpp.o:
+	$(CXX) $(CXXFLAGS) -o $@ -c $<
+
+.c.o:
+	$(CC) $(CXXFLAGS) -o $@ -c $<	
+
+clean:
+	@echo "cleaning ..."
+	rm  -f $(SRC_DIR)/*.o $(SRC_DIR)/colorconvert/src/*.o
+	rm  -f $(RELEASE_LIB_DIR)/$(UTILS_SO_NAME)
+			
+
+
diff --git a/utils/Mem.cpp b/utils/Mem.cpp
new file mode 100755
index 0000000..d5eeaca
--- /dev/null
+++ b/utils/Mem.cpp
@@ -0,0 +1,348 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * @file Mem.cpp
+ *
+ * @brief memory utils
+ *
+ * @ingroup utils
+ */
+
+#include <stdio.h>
+#include "Mem.h"
+
+#include "Queue.h"
+
+#ifdef ANDROID_BUILD
+#include "Log.h"
+#define printf LogOutput
+#endif
+
+#ifdef OMX_MEM_CHECK
+
+#define DEFAULT_SHORT_NAME_OF_MM  "UM"
+#define STR_LEN 64
+
+#define MEM_CHECK_BOARDER
+#ifdef MEM_CHECK_BOARDER
+#define PRE_SIZE 64
+#define AFT_SIZE 64
+#define MAGICNUMBER 0xab
+#endif
+
+
+typedef struct _memdesc{
+    struct _memdesc * next;
+    fsl_osal_u32 size;
+    fsl_osal_ptr mem;
+    fsl_osal_char desstring[STR_LEN];
+    fsl_osal_s32 line;
+    fsl_osal_u32 age;
+}Mem_Desc;
+
+typedef struct _timestampmanager{
+    Mem_Desc * allocatedbuffer;
+    Mem_Desc * freelist;
+    Mem_Desc * head;
+    Mem_Desc * tail;
+    fsl_osal_u32 age;
+    fsl_osal_u32 size;
+    fsl_osal_u32 maxsize;
+    fsl_osal_u32 allocatednum; 
+    fsl_osal_char * shortname;
+}Mem_Mgr;
+
+#define COPYMEMORYDESC(des, src) \
+    do { \
+        des->size = src->size; \
+        des->mem = src->mem; \
+        des->line = src->line;\
+    }while(0)
+
+
+Mem_Mgr g_tm;
+Mem_Mgr *tm = &g_tm;
+
+
+fsl_osal_void init_memmanager(fsl_osal_char * shortname)
+{
+    fsl_osal_memset(tm, 0, sizeof(Mem_Mgr));
+    if (shortname){
+        tm->shortname = shortname;
+    }else{
+        tm->shortname = DEFAULT_SHORT_NAME_OF_MM;
+    }
+
+    tm->allocatednum = 5000;
+}
+
+static fsl_osal_void printandfree_allnonfreememory(Mem_Mgr *tm)
+{
+    Mem_Desc * bt = tm->head;
+    printf("%s: Non-freed memory list:\n", tm->shortname);
+    while(bt){
+        printf("\tmem %p\tsize = %ld\tage = %ld", bt->mem, bt->size, bt->age);
+        if (bt->desstring){
+            printf(" desc:  %s:%d\n",bt->desstring, bt->line);
+        }else{
+            printf("\n");
+        }
+        bt=bt->next;
+    }
+    printf("%s: End.\n", tm->shortname);
+}
+    
+fsl_osal_void deinit_memmanager()
+{
+    printandfree_allnonfreememory(tm);
+    if (tm->allocatedbuffer){
+        fsl_osal_dealloc(tm->allocatedbuffer);
+    }
+    fsl_osal_memset(tm, 0, sizeof(Mem_Mgr));
+}
+
+fsl_osal_void clear_memmanager()
+{
+    fsl_osal_u32 i;
+    Mem_Desc * bt = tm->allocatedbuffer;
+    tm->freelist = tm->head = tm->tail = NULL;
+    for (i=0;i<tm->allocatednum;i++){
+        bt->next = tm->freelist;
+        tm->freelist = bt;
+        bt++;
+    }
+}
+
+static Mem_Desc * new_Mem_Desc()
+{
+    Mem_Desc * newbuffer = NULL;
+    if (tm->freelist){
+        newbuffer = tm->freelist;
+        tm->freelist = newbuffer->next;
+        return newbuffer;
+    }
+    if (tm->allocatednum)
+        tm->allocatednum <<=1;
+    else
+        tm->allocatednum = 1000;
+    if ((newbuffer = (Mem_Desc *)fsl_osal_malloc_new(sizeof(Mem_Desc)*tm->allocatednum)) != NULL) {
+        Mem_Desc *oldhead, *nb;
+        fsl_osal_u32 i = 0;
+        
+        oldhead = tm->head;
+        nb = newbuffer;
+        tm->freelist = tm->head = tm->tail = NULL;
+        for (i=0;i<(tm->allocatednum-1);i++){
+            if (oldhead){
+                COPYMEMORYDESC(nb, oldhead);
+                nb->next = NULL;
+                if (tm->tail){
+                    (tm->tail)->next = nb;
+                    tm->tail = nb;
+                }else{
+                    tm->head = tm->tail = nb;
+                }
+                oldhead = oldhead->next;
+            }else{
+                nb->next = tm->freelist;
+                tm->freelist = nb;
+            }
+            nb++;
+        }
+        if (tm->allocatedbuffer){
+            fsl_osal_dealloc(tm->allocatedbuffer);
+        }
+        tm->allocatedbuffer = newbuffer;
+        return nb;
+    }else{
+        return newbuffer;
+    }
+}
+
+#ifdef MEM_CHECK_BOARDER
+fsl_osal_void check_mem_boarder(Mem_Desc *bt)
+{
+    fsl_osal_s32 i;
+    fsl_osal_char *buf = (fsl_osal_char *)(bt->mem);
+    fsl_osal_char *pre, *after;
+
+    pre = buf-PRE_SIZE;
+    for(i=0; i<PRE_SIZE; i++) {
+        if(pre[i] != MAGICNUMBER) {
+            printf("Memory up overflow from[%s:%d], age: %d\n",
+                    bt->desstring, bt->line, bt->age);
+            break;
+        }
+    }
+
+    after = pre + (bt->size - AFT_SIZE);
+    for(i=0; i<AFT_SIZE; i++) {
+        if(after[i] != MAGICNUMBER) {
+            printf("Memory down overflow from[%s:%d], age: %d\n",
+                    bt->desstring, bt->line, bt->age);
+            break;
+        }
+    }
+}
+#endif
+
+
+fsl_osal_ptr dbg_malloc(fsl_osal_u32 size, fsl_osal_char * desc, fsl_osal_s32 line)
+{
+    Mem_Desc * bt;
+    fsl_osal_ptr buf = NULL;
+
+#ifdef MEM_CHECK_BOARDER
+    fsl_osal_ptr ptr = NULL;
+    fsl_osal_s32 size1 = size;
+
+    size += PRE_SIZE + AFT_SIZE;
+#endif
+
+    if ((buf = fsl_osal_malloc_new(size)) && (bt = new_Mem_Desc())){
+        tm->age++;
+        tm->size+=size;
+        if (tm->size>tm->maxsize){
+            tm->maxsize = tm->size;
+            //printf("%s: mem exceed %ld bytes\n", tm->shortname, tm->maxsize);
+        }
+
+#ifdef MEM_CHECK_BOARDER
+        fsl_osal_memset(buf, MAGICNUMBER, PRE_SIZE);
+        ptr = (fsl_osal_ptr)((fsl_osal_u32)buf + PRE_SIZE + size1);
+        fsl_osal_memset(ptr, MAGICNUMBER, AFT_SIZE);
+        buf = (fsl_osal_ptr)((fsl_osal_u32)buf + PRE_SIZE);
+#endif
+        
+        bt->size = size;
+        bt->age = tm->age;
+        bt->mem = buf;
+		bt->line = line;
+        bt->next = NULL;
+
+        fsl_osal_memcpy(bt->desstring, desc, STR_LEN);
+        bt->desstring[STR_LEN-1] = '\0';
+        //printf("age: %d, in %s:%d allocate %p, size %d.\n",bt->age, desc, bt->line, (fsl_osal_s32)buf, size);
+		
+        if (tm->tail){
+            (tm->tail)->next = bt;
+            tm->tail = bt;
+        }else{
+            tm->head = tm->tail = bt;
+        }
+    }else{
+        if (buf){
+            fsl_osal_dealloc(buf);
+            buf = NULL;
+        }else{
+            printf("%s: FATAL ERROR - Can not allocate %ld bytes\n", tm->shortname, size);
+        }
+        printf("FATAL ERROR: Can not allocate memory for memmanager!!\n");
+    }
+
+    return buf;
+}
+
+
+fsl_osal_ptr dbg_realloc(fsl_osal_ptr ptr, fsl_osal_u32 size, fsl_osal_char * desc, fsl_osal_s32 line)
+{
+    Mem_Desc * bt = tm->head;
+    fsl_osal_ptr buf = NULL;
+
+    if(ptr == NULL)
+        return dbg_malloc(size, desc, line);
+
+    if(size == 0) {
+        dbg_free(ptr);
+        return NULL;
+    }
+
+    //find the mem descripter for ptr
+    while(bt) {
+        if (bt->mem==ptr)
+            break;
+        bt=bt->next;
+    }
+
+    buf = dbg_malloc(size, desc, line);
+    if(buf) {
+        fsl_osal_memcpy(buf, ptr, bt->size - (PRE_SIZE + AFT_SIZE));
+        dbg_free(ptr);
+    }
+    else
+        dbg_free(ptr); //FIXME
+
+    return buf;
+}
+
+fsl_osal_void dbg_free(fsl_osal_ptr mem)
+{
+    Mem_Desc * bt = tm->head, *btpr = NULL;
+    fsl_osal_ptr ptr = mem;
+    fsl_osal_s32 size = 0;
+    while(bt){
+        if (bt->mem==mem){
+            size = bt->size;
+#ifdef MEM_CHECK_BOARDER
+            check_mem_boarder(bt);
+            mem = (fsl_osal_ptr)((fsl_osal_u32)mem-PRE_SIZE);
+            size -= PRE_SIZE + AFT_SIZE;
+#endif
+            tm->size-=bt->size;
+            fsl_osal_memset(ptr, 0, size);
+            fsl_osal_dealloc(mem);
+            if (btpr){
+                btpr->next = bt->next;
+                if (tm->tail==bt){
+                    tm->tail = btpr;
+                }
+            }else{//head
+                tm->head = bt->next;
+                if (tm->head==NULL){
+                    tm->tail = NULL;
+                }
+            }
+            bt->next = tm->freelist;
+            tm->freelist = bt;
+            return;
+        }
+        btpr = bt;
+        bt=bt->next;
+    }
+    printf("%s Error memory freed pointer  = %p\n",tm->shortname, mem);
+}
+
+
+#ifdef __cplusplus
+void * operator new(unsigned int size, char* file, int line)
+{
+    return dbg_malloc(size, file, line);
+}
+
+void operator delete(fsl_osal_ptr ptr, char* file, int line)
+{
+    operator delete(ptr);
+}
+
+#if 0
+void * operator new(unsigned int size)
+{
+    return operator new(size, "Unknown", 0);
+}
+#endif
+
+void operator delete(fsl_osal_ptr ptr)
+{
+    dbg_free(ptr);
+}
+#endif
+
+#endif
+
diff --git a/utils/Mem.h b/utils/Mem.h
new file mode 100755
index 0000000..c552037
--- /dev/null
+++ b/utils/Mem.h
@@ -0,0 +1,60 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file Mem.h
+ *  @brief Memory utils
+ *  @ingroup Utils
+ */
+#ifndef Mem_h
+#define Mem_h
+
+
+#include "fsl_osal.h"
+
+#ifdef OMX_MEM_CHECK
+
+#define FSL_NEW(type, params) new(__FILE__, __LINE__) type params
+#define FSL_DELETE(ptr) { if(ptr) {delete(ptr); ptr=NULL;}}
+#define FSL_DELETE_THIS(ptr) { if(ptr) {delete(ptr);}}
+#define FSL_MALLOC(size) dbg_malloc(size, __FILE__, __LINE__)
+#define FSL_REALLOC(ptr, size) dbg_realloc(ptr, size, __FILE__, __LINE__)
+#define FSL_FREE(ptr) { if(ptr) {dbg_free(ptr); ptr=NULL;}}
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+fsl_osal_void init_memmanager(fsl_osal_char *shortname);
+fsl_osal_void deinit_memmanager();
+fsl_osal_void clear_memmanager();
+fsl_osal_ptr dbg_malloc(fsl_osal_u32 size, fsl_osal_char * desc,fsl_osal_s32 line);
+fsl_osal_ptr dbg_realloc(fsl_osal_ptr ptr, fsl_osal_u32 size, fsl_osal_char * desc,fsl_osal_s32 line);
+fsl_osal_void dbg_free(fsl_osal_ptr mem);
+#ifdef __cplusplus
+}
+
+void * operator new(unsigned int size, char* file, int line);
+void operator delete(fsl_osal_ptr ptr, char* file, int line);
+void * operator new(unsigned int size);
+void operator delete(fsl_osal_ptr ptr);
+#endif
+
+#else
+
+#define FSL_NEW(type, params) new type params
+#define FSL_DELETE(ptr) { if(ptr) {delete(ptr); ptr=NULL;}}
+#define FSL_DELETE_THIS(ptr) { if(ptr) {delete(ptr);}}
+#define FSL_MALLOC(size) fsl_osal_malloc_new(size)
+#define FSL_REALLOC(ptr, size) fsl_osal_realloc_new(ptr, size)
+#define FSL_FREE(ptr) { if(ptr) {fsl_osal_dealloc(ptr); ptr=NULL;}}
+
+#endif
+
+#endif
+/* File EOF */
diff --git a/utils/Queue.cpp b/utils/Queue.cpp
new file mode 100755
index 0000000..596e2ad
--- /dev/null
+++ b/utils/Queue.cpp
@@ -0,0 +1,327 @@
+/**
+ *  Copyright (c) 2009-2010, 2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Queue.h"
+#include "Mem.h"
+#include "Log.h"
+
+QUEUE_ERRORTYPE Queue::Create(
+        fsl_osal_u32 maxQSize, 
+        fsl_osal_u32 msgSize, 
+        efsl_osal_bool block)
+{
+    QUEUE_ERRORTYPE ret = QUEUE_SUCCESS;
+    fsl_osal_u32 i, aligned_msg_size;
+    fsl_osal_ptr ptr = NULL;
+    QNODE *pQNode = NULL;
+    fsl_osal_u8 *pMsg = NULL;
+
+    pQNodeMem = pQMsgMem = NULL;
+    pFreeNodes = pHead = pTail = NULL;
+    nQSize = 0;
+    lock = usedNodesSem = freeNodesSem = NULL;
+
+    nMaxQSize = maxQSize;
+    nMsgSize = msgSize;
+    bBlocking = block;
+
+    /* allocate for queue nodes */
+    ptr = FSL_MALLOC(sizeof(QNODE) * nMaxQSize);
+    if(ptr == NULL) {
+        LOG_ERROR("Failed to allocate memory for queue node.\n");
+        ret = QUEUE_INSUFFICIENT_RESOURCES;
+        goto err;
+    }
+    pQNodeMem = ptr;
+    pQNode = (QNODE*)ptr;
+
+    /* alloate for node messages */
+    aligned_msg_size = (nMsgSize + 3)/4*4;
+    ptr = FSL_MALLOC(nMaxQSize * aligned_msg_size);
+    if(ptr == NULL) {
+        LOG_ERROR("Failed to allocate memory for queue node message.\n");
+        ret = QUEUE_INSUFFICIENT_RESOURCES;
+        goto err;
+    }
+    pQMsgMem = ptr;
+    pMsg = (fsl_osal_u8*)ptr;
+
+    for(i=0; i<nMaxQSize-1; i++) {
+        pQNode[i].NextNode = &(pQNode[i+1]);
+        pQNode[i].pMsg = pMsg;
+        pMsg += aligned_msg_size;
+    }
+    pQNode[nMaxQSize-1].NextNode = NULL;
+    pQNode[nMaxQSize-1].pMsg = pMsg;
+    pFreeNodes = pQNode;
+
+    if(fsl_osal_mutex_init(&lock, fsl_osal_mutex_normal) != E_FSL_OSAL_SUCCESS) {
+        LOG_ERROR("Failed to create mutex for queue.\n");
+        ret = QUEUE_INSUFFICIENT_RESOURCES;
+        goto err;
+    }
+
+    if(fsl_osal_sem_init(&usedNodesSem, 0, 0) != E_FSL_OSAL_SUCCESS) {
+        LOG_ERROR("Failed to create mutex for used nodes.\n");
+        ret = QUEUE_INSUFFICIENT_RESOURCES;
+        goto err;
+    }
+
+    if(fsl_osal_sem_init(&freeNodesSem, 0, nMaxQSize) != E_FSL_OSAL_SUCCESS) {
+        LOG_ERROR("Failed to create mutex for free nodes.\n");
+        ret = QUEUE_INSUFFICIENT_RESOURCES;
+        goto err;
+    }
+
+    return ret;
+
+err:
+    Free();
+    return ret;
+}
+
+QUEUE_ERRORTYPE Queue::Free() 
+{
+    if(pQNodeMem != NULL)
+        FSL_FREE(pQNodeMem);
+    if(pQMsgMem != NULL)
+        FSL_FREE(pQMsgMem);
+    if(lock != NULL)
+        fsl_osal_mutex_destroy(lock);
+    if(usedNodesSem != NULL)
+        fsl_osal_sem_destroy(usedNodesSem);
+    if(freeNodesSem != NULL)
+        fsl_osal_sem_destroy(freeNodesSem);
+
+    return QUEUE_SUCCESS;
+}
+
+fsl_osal_u32 Queue::Size() 
+{
+    fsl_osal_u32 ret = 0;
+
+    fsl_osal_mutex_lock(lock);
+    ret = nQSize;
+    fsl_osal_mutex_unlock(lock);
+
+    return ret;
+}
+
+QUEUE_ERRORTYPE Queue::Add(fsl_osal_ptr pMsg) 
+{
+    QNODE *pQNode = NULL;
+
+    if(bBlocking == E_FSL_OSAL_TRUE)
+        fsl_osal_sem_wait(freeNodesSem);
+    else {
+        if(fsl_osal_sem_trywait(freeNodesSem) != E_FSL_OSAL_SUCCESS)
+            return QUEUE_NOT_READY;
+    }
+
+    fsl_osal_mutex_lock(lock);
+
+    if(pFreeNodes == NULL) {
+        fsl_osal_mutex_unlock(lock);
+        return QUEUE_OVERFLOW;
+    }
+
+    pQNode = pFreeNodes;
+    pFreeNodes = pFreeNodes->NextNode;
+    pQNode->NextNode = NULL;
+    fsl_osal_memcpy(pQNode->pMsg, pMsg, nMsgSize);
+    if(pHead == NULL && pTail == NULL) {
+        pHead = pQNode;
+        pTail = pQNode;
+    }
+    else {
+        pTail->NextNode = pQNode;
+        pTail = pQNode;
+    }
+    nQSize ++;
+    fsl_osal_sem_post(usedNodesSem);
+    fsl_osal_mutex_unlock(lock);
+
+    return QUEUE_SUCCESS;
+}
+
+QUEUE_ERRORTYPE Queue::Get(fsl_osal_ptr pMsg) 
+{
+    QNODE *pQNode = NULL;
+
+    if(bBlocking == E_FSL_OSAL_TRUE)
+        fsl_osal_sem_wait(usedNodesSem);
+    else {
+        if(fsl_osal_sem_trywait(usedNodesSem) != E_FSL_OSAL_SUCCESS)
+            return QUEUE_NOT_READY;
+    }
+
+    fsl_osal_mutex_lock(lock);
+
+    if(pHead == NULL) {
+        fsl_osal_mutex_unlock(lock);
+        return QUEUE_OVERFLOW;
+    }
+
+    pQNode = pHead;
+    pHead = pHead->NextNode;
+    fsl_osal_memcpy(pMsg, pQNode->pMsg, nMsgSize);
+    pQNode->NextNode = pFreeNodes;
+    pFreeNodes = pQNode;
+    nQSize --;
+    if(pHead == NULL)
+        pTail = NULL;
+
+    fsl_osal_sem_post(freeNodesSem);
+    fsl_osal_mutex_unlock(lock);
+
+    return QUEUE_SUCCESS;
+}
+
+QUEUE_ERRORTYPE Queue::Access(fsl_osal_ptr pMsg, fsl_osal_u32 nIndex)
+{
+    QNODE *pQNode = NULL;
+    fsl_osal_u32 i;
+
+    if(nIndex > nQSize) {
+        fsl_osal_memset(pMsg, 0, nMsgSize);
+        return QUEUE_FAILURE;
+    }
+
+    pQNode = pHead;
+
+    for(i=1; i<nIndex; i++)
+        pQNode = pQNode->NextNode;
+
+    fsl_osal_memcpy(pMsg, pQNode->pMsg, nMsgSize);
+
+    return QUEUE_SUCCESS;
+}
+
+QUEUE_ERRORTYPE Queue::Get(fsl_osal_ptr pMsg, fsl_osal_u32 nIndex) 
+{
+    QNODE *pQNode, *pQNodePrev = NULL;
+    fsl_osal_u32 i;
+
+    if(nIndex > nQSize) {
+        fsl_osal_memset(pMsg, 0, nMsgSize);
+        return QUEUE_FAILURE;
+    }
+
+    if(nIndex == 1)
+        return Get(pMsg);
+
+    if(bBlocking == E_FSL_OSAL_TRUE)
+        fsl_osal_sem_wait(usedNodesSem);
+    else {
+        if(fsl_osal_sem_trywait(usedNodesSem) != E_FSL_OSAL_SUCCESS)
+            return QUEUE_NOT_READY;
+    }
+
+    fsl_osal_mutex_lock(lock);
+
+    if(pHead == NULL) {
+        fsl_osal_mutex_unlock(lock);
+        return QUEUE_OVERFLOW;
+    }
+
+    pQNodePrev = pHead;
+    pQNode = pQNodePrev->NextNode;
+
+    for(i=2; i<nIndex; i++){
+        pQNodePrev = pQNodePrev->NextNode;
+        pQNode = pQNode->NextNode;
+    }
+
+    fsl_osal_memcpy(pMsg, pQNode->pMsg, nMsgSize);
+
+    pQNodePrev->NextNode = pQNode->NextNode;
+    pQNode->NextNode = pFreeNodes;
+    pFreeNodes = pQNode;
+    nQSize --;
+
+    if(pTail == pQNode)
+        pTail = pQNodePrev;
+
+    fsl_osal_sem_post(freeNodesSem);
+    fsl_osal_mutex_unlock(lock);
+
+    return QUEUE_SUCCESS;
+}
+
+
+/**< C type functions */
+
+QUEUE_ERRORTYPE CreateQueue(
+        fsl_osal_ptr *pQHandle,
+        fsl_osal_u32 nMaxQueueSize,
+        efsl_osal_bool bBlockingQueue,
+        fsl_osal_u32 nMessageSize)
+{
+    Queue *pQueue = NULL; 
+
+    pQueue = FSL_NEW(Queue, ());
+    if(pQueue == NULL)
+        return QUEUE_INSUFFICIENT_RESOURCES;
+    pQueue->Create(nMaxQueueSize, nMessageSize, bBlockingQueue);
+    *pQHandle = pQueue;
+
+    return QUEUE_SUCCESS;
+}
+
+QUEUE_ERRORTYPE EnQueue(
+        fsl_osal_ptr hQHandle, 
+        fsl_osal_ptr pMessage, 
+        efsl_osal_bool bMaxPriority)
+{
+    Queue *pQueue = NULL; 
+
+    pQueue = (Queue*) hQHandle;
+    pQueue->Add(pMessage);
+
+    return QUEUE_SUCCESS;
+}
+
+fsl_osal_u32 GetQueueSize(
+        fsl_osal_ptr hQHandle)
+{
+    Queue *pQueue = NULL; 
+
+    pQueue = (Queue*) hQHandle;
+    return pQueue->Size();
+}
+
+QUEUE_ERRORTYPE ReadQueue(
+        fsl_osal_ptr hQHandle, 
+        fsl_osal_ptr pMessage, 
+        efsl_osal_bool bDeQueue)
+{
+    Queue *pQueue = NULL; 
+
+    pQueue = (Queue*) hQHandle;
+    if(bDeQueue == E_FSL_OSAL_TRUE)
+        pQueue->Get(pMessage);
+    else
+        pQueue->Access(pMessage, 1);
+
+    return QUEUE_SUCCESS;
+}
+
+QUEUE_ERRORTYPE DeleteQueue(
+        fsl_osal_ptr hQHandle)
+{
+    Queue *pQueue = NULL; 
+
+    pQueue = (Queue*) hQHandle;
+    pQueue->Free();
+    FSL_DELETE(pQueue);
+
+    return QUEUE_SUCCESS;
+}
+
+/* File EOF */
diff --git a/utils/Queue.h b/utils/Queue.h
new file mode 100755
index 0000000..ef2da29
--- /dev/null
+++ b/utils/Queue.h
@@ -0,0 +1,93 @@
+/**
+ *  Copyright (c) 2009-2010, 2014, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file Queue.h
+ *  @brief Class definition of Queue
+ *  @ingroup State
+ */
+
+#ifndef Queue_h
+#define Queue_h
+
+#include "fsl_osal.h"
+
+typedef enum {
+    QUEUE_SUCCESS,
+    QUEUE_FAILURE,
+    QUEUE_NOT_READY,
+    QUEUE_OVERFLOW,
+    QUEUE_INSUFFICIENT_RESOURCES
+}QUEUE_ERRORTYPE;
+
+
+typedef struct _QNODE{
+    fsl_osal_ptr pMsg;
+    struct _QNODE *NextNode;
+}QNODE;
+
+
+class Queue {
+    public:
+        QUEUE_ERRORTYPE Create(
+                fsl_osal_u32 maxQSize, /**< total number of messages */
+                fsl_osal_u32 msgSize, /**< each message size */
+                efsl_osal_bool block); /**< if true, block call when add or get */
+        QUEUE_ERRORTYPE Free();
+        /**< Get current msg number in the queue*/
+        fsl_osal_u32 Size(); 
+        /**< Add a msg to the queue tail */
+        QUEUE_ERRORTYPE Add(fsl_osal_ptr pMsg); 
+        /**< Get a msg from the queue head, this function will remove the message from queue */
+        QUEUE_ERRORTYPE Get(fsl_osal_ptr pMsg); 
+        /**< Get the nIndex node from the queue , this function will remove the message from queue */
+        QUEUE_ERRORTYPE Get(fsl_osal_ptr pMsg, fsl_osal_u32 nIndex);
+        /**< Access the nIndex(start from 1) node message */
+        QUEUE_ERRORTYPE Access(fsl_osal_ptr pMsg, fsl_osal_u32 nIndex); 
+    private:
+        QNODE *pFreeNodes;
+        QNODE *pHead;
+        QNODE *pTail;
+        fsl_osal_ptr pQNodeMem;
+        fsl_osal_ptr pQMsgMem;
+        fsl_osal_u32 nQSize;
+        fsl_osal_u32 nMaxQSize;
+        fsl_osal_u32 nMsgSize;
+        efsl_osal_bool bBlocking;
+        fsl_osal_mutex lock;
+        fsl_osal_sem usedNodesSem;
+        fsl_osal_sem freeNodesSem;
+};
+
+extern "C" {
+    QUEUE_ERRORTYPE CreateQueue(
+            fsl_osal_ptr *pQHandle,
+            fsl_osal_u32 nMaxQueueSize,
+            efsl_osal_bool bBlockingQueue,
+            fsl_osal_u32 nMessageSize);
+
+    QUEUE_ERRORTYPE EnQueue(
+            fsl_osal_ptr hQHandle, 
+            fsl_osal_ptr pMessage, 
+            efsl_osal_bool bMaxPriority);
+
+    fsl_osal_u32 GetQueueSize(
+            fsl_osal_ptr hQHandle);
+
+    QUEUE_ERRORTYPE ReadQueue(
+            fsl_osal_ptr hQHandle, 
+            fsl_osal_ptr pMessage, 
+            efsl_osal_bool bDeQueue);
+
+    QUEUE_ERRORTYPE DeleteQueue(
+            fsl_osal_ptr hQHandle);
+}
+
+#endif
+/* File EOF */
diff --git a/utils/RegistryAnalyser.cpp b/utils/RegistryAnalyser.cpp
new file mode 100755
index 0000000..9d68b69
--- /dev/null
+++ b/utils/RegistryAnalyser.cpp
@@ -0,0 +1,177 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+#include "Log.h"
+#include "Mem.h"
+#include "RegistryAnalyser.h"
+
+RegistryAnalyser::RegistryAnalyser()
+{
+	pfile = NULL;
+	FileReadEnd = E_FSL_OSAL_FALSE;
+	BufferDataLen = 0;
+	UseOffset = 0;
+}
+
+RegistryAnalyser::~RegistryAnalyser()
+{
+}
+
+REG_ERRORTYPE RegistryAnalyser::Open(
+        fsl_osal_char *file_name) 
+{
+	efsl_osal_return_type_t ret;
+
+	if (file_name == NULL)
+	{
+		LOG_ERROR("Input file name is NULL.");
+		return REG_INVALID_REG;
+	}
+
+	ret = fsl_osal_fopen(file_name, "r", (fsl_osal_file *)&pfile);
+	if (ret != E_FSL_OSAL_SUCCESS)
+	{
+		LOG_ERROR("Can't open file: %s\n", file_name);
+		return REG_FAILURE;
+	}
+
+	return REG_SUCCESS;
+}
+
+REG_ERRORTYPE RegistryAnalyser::Close() 
+{
+	if (pfile == NULL)
+	{
+		LOG_ERROR("No file need close.\n");
+		return REG_FAILURE;
+	}
+
+	fsl_osal_fclose(pfile);
+
+	return REG_SUCCESS;
+}
+
+List<REG_ENTRY> *RegistryAnalyser::GetNextEntry()
+{
+	fsl_osal_char symbol;
+	efsl_osal_bool bSkip = E_FSL_OSAL_FALSE;
+	fsl_osal_char symbolBuffer[ITEM_VALUE_LEN] = {0}, *pStrSeg;
+	efsl_osal_bool EntryFounded = E_FSL_OSAL_FALSE;
+	fsl_osal_s32 symbolCnt = 0;
+	efsl_osal_return_type_t ret;
+	REG_ENTRY *pRegEntry;
+
+	if (pfile == NULL)
+	{
+		LOG_ERROR("No file to read.\n");
+		return &RegList;
+	}
+
+
+	/** Remove previous entry */
+	RemoveEntry();
+	
+	while (BufferDataLen - UseOffset > 0 || FileReadEnd == E_FSL_OSAL_FALSE)
+	{
+		if (BufferDataLen - UseOffset == 0)
+		{
+			ret = fsl_osal_fread(readBuffer, FILE_READ_SIZE, pfile, &BufferDataLen);
+			if (ret != E_FSL_OSAL_SUCCESS && ret != E_FSL_OSAL_EOF)
+			{
+				LOG_ERROR("file read error.");
+				return &RegList;
+			}
+
+			if (BufferDataLen < FILE_READ_SIZE)
+			{
+				FileReadEnd = E_FSL_OSAL_TRUE;
+			}
+
+			UseOffset = 0;
+		}
+		
+		symbol = readBuffer[UseOffset];
+		UseOffset ++;
+
+		if (bSkip == E_FSL_OSAL_TRUE)
+		{
+			if (symbol == '\n')
+			{
+				bSkip = E_FSL_OSAL_FALSE;
+			}
+		}
+		else
+		{
+			if (symbol == '#')
+			{
+				bSkip = E_FSL_OSAL_TRUE;
+			}
+			else if (symbol == '\t'
+					|| symbol == ' '
+					|| symbol == '\n'
+					|| symbol == '\r')
+			{
+			}
+			else if (symbol == '@')
+			{
+				EntryFounded = E_FSL_OSAL_TRUE;
+			}
+			else if (symbol == '$')
+			{
+				break;
+			}
+			else if (symbol == ';')
+			{
+				fsl_osal_char *pLast = NULL;
+				if (symbolCnt != 0 && ((pStrSeg = fsl_osal_strtok_r(symbolBuffer, "=", &pLast)) != NULL))
+				{
+					pRegEntry = FSL_NEW(REG_ENTRY, ());
+					fsl_osal_memset(pRegEntry, 0, sizeof(REG_ENTRY));
+					fsl_osal_strcpy(pRegEntry->name, pStrSeg);
+					pStrSeg = fsl_osal_strtok_r(NULL, "=", &pLast);
+					fsl_osal_strcpy(pRegEntry->value, pStrSeg);
+					fsl_osal_memset(symbolBuffer, 0, ITEM_VALUE_LEN);
+					symbolCnt = 0;
+					RegList.Add(pRegEntry);
+				}
+			}
+			else
+			{
+				if (EntryFounded == E_FSL_OSAL_TRUE)
+				{
+					symbolBuffer[symbolCnt] = symbol;
+					symbolCnt ++;
+				}
+			}
+		}
+	}
+	return &RegList;
+}
+
+REG_ERRORTYPE RegistryAnalyser::RemoveEntry() 
+{
+	fsl_osal_u32 NodeCnt = RegList.GetNodeCnt();
+	fsl_osal_s32 i;
+	REG_ENTRY *pRegEntry;
+
+	if (NodeCnt == 0)
+	{
+		return REG_SUCCESS;
+	}
+
+	for (i = NodeCnt - 1; i >= 0; i --)
+	{
+		pRegEntry = RegList.GetNode(i);
+		RegList.Remove(pRegEntry);
+		FSL_DELETE(pRegEntry);
+	}
+
+	return REG_SUCCESS;
+}
+
+/* File EOF */
diff --git a/utils/RegistryAnalyser.h b/utils/RegistryAnalyser.h
new file mode 100755
index 0000000..7c0e12a
--- /dev/null
+++ b/utils/RegistryAnalyser.h
@@ -0,0 +1,58 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file RegistryAnalyser.h
+ *  @brief Class definition of Regitsry file analyser
+ *  @ingroup RegistryAnalyser
+ */
+
+
+#ifndef RegistryAnalyser_h
+#define RegistryAnalyser_h
+
+#include "fsl_osal.h"
+#include "List.h"
+
+#define ITEM_NAME_LEN 32
+#define ITEM_VALUE_LEN 128
+#define FILE_READ_SIZE (1024*4)
+
+typedef enum {
+    REG_SUCCESS,
+    REG_FAILURE,
+    REG_INSUFFICIENT_RESOURCES,
+    REG_INVALID_REG
+}REG_ERRORTYPE;
+
+typedef struct _REG_ENTRY {
+    fsl_osal_char name[ITEM_NAME_LEN];
+    fsl_osal_char value[ITEM_VALUE_LEN];
+}REG_ENTRY;
+
+class RegistryAnalyser {
+	public:
+		RegistryAnalyser();
+		REG_ERRORTYPE Open(fsl_osal_char *file_name);
+		REG_ERRORTYPE Close();
+		List<REG_ENTRY> *GetNextEntry();
+		~RegistryAnalyser();
+	private:
+		FILE *pfile;
+		List<REG_ENTRY> RegList;
+		efsl_osal_bool FileReadEnd;
+		fsl_osal_s32 BufferDataLen;
+		fsl_osal_s32 UseOffset;
+		fsl_osal_char readBuffer[FILE_READ_SIZE];
+		REG_ERRORTYPE RemoveEntry(); 
+
+};
+
+#endif
+/* File EOF */
diff --git a/utils/RingBuffer.cpp b/utils/RingBuffer.cpp
new file mode 100755
index 0000000..bebcc04
--- /dev/null
+++ b/utils/RingBuffer.cpp
@@ -0,0 +1,220 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include "Mem.h"
+#include "Log.h"
+#include "RingBuffer.h"
+
+RingBuffer::RingBuffer()
+{
+	RingBufferPtr = NULL;
+	Reserved = NULL;
+	TotalConsumeLen = 0;
+	nPrevOffset = 0;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferCreate(fsl_osal_u32 nPushModeLen, fsl_osal_u32 nRingBufferScale)
+{
+    RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+
+	nPushModeInputLen = nPushModeLen;
+	nRingBufferLen = nPushModeInputLen * nRingBufferScale;
+
+	/** Create ring buffer for audio decoder input stream. */
+	LOG_DEBUG("Ring buffer len: %d\n", nRingBufferLen);
+	RingBufferPtr = (fsl_osal_u8 *)FSL_MALLOC(nRingBufferLen+8);
+	if (RingBufferPtr == NULL)
+	{
+		LOG_ERROR("Can't get memory.\n");
+		return RINGBUFFER_INSUFFICIENT_RESOURCES;
+	}
+
+	Reserved = (fsl_osal_u8 *)FSL_MALLOC(nPushModeInputLen);
+	if (Reserved == NULL)
+	{ 
+		FSL_FREE(RingBufferPtr);
+		LOG_ERROR("Can't get memory.\n");
+		return RINGBUFFER_INSUFFICIENT_RESOURCES;
+	}
+
+	TotalConsumeLen = 0;
+	ReservedLen = nPushModeInputLen;   
+	Begin = RingBufferPtr;
+	End = RingBufferPtr;
+	Consumered = RingBufferPtr;
+	nPrevOffset = 0;
+
+    return ret;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferReset()
+{
+	RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+
+	TotalConsumeLen = 0;
+	Begin = RingBufferPtr;
+	End = RingBufferPtr;
+	Consumered = RingBufferPtr;
+	nPrevOffset = 0;
+
+	return ret;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferFree()
+{
+	RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+
+	LOG_DEBUG("Free ring buffer\n");
+	FSL_FREE(RingBufferPtr);
+	LOG_DEBUG("Free reserved buffer\n");
+	FSL_FREE(Reserved);
+	LOG_DEBUG("Ring buffer free finished.\n");
+
+	return ret;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferAdd(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen, fsl_osal_u32 *pActualLen)
+{
+    RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+
+	fsl_osal_s32 DataLen = AudioDataLen();
+	fsl_osal_s32 FreeBufferLen = nRingBufferLen - DataLen - 1;
+	if (FreeBufferLen < (fsl_osal_s32)BufferLen)
+	{
+		*pActualLen = FreeBufferLen;
+	}
+	else
+	{
+		*pActualLen = BufferLen;
+	}
+
+	if (Begin + *pActualLen > RingBufferPtr + nRingBufferLen)
+	{
+		fsl_osal_u32 FirstSegmentLen = nRingBufferLen - (Begin - RingBufferPtr);
+		fsl_osal_memcpy(Begin, pBuffer, FirstSegmentLen);
+		fsl_osal_memcpy(RingBufferPtr, pBuffer + FirstSegmentLen, *pActualLen - FirstSegmentLen);
+		Begin = RingBufferPtr + *pActualLen - FirstSegmentLen;
+	}
+	else
+	{
+		fsl_osal_memcpy(Begin, pBuffer, *pActualLen);
+		Begin += *pActualLen;
+	}
+
+	LOG_LOG("nRingBufferLen = %d\t DataLen = %d\n", nRingBufferLen, DataLen);
+
+    return ret;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferAddZeros(fsl_osal_u32 BufferLen, fsl_osal_u32 *pActualLen)
+{
+    RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+
+	fsl_osal_u32 DataLen = AudioDataLen();
+	fsl_osal_u32 FreeBufferLen = nRingBufferLen - DataLen - 1;
+	if (FreeBufferLen < BufferLen)
+	{
+		*pActualLen = FreeBufferLen;
+	}
+	else
+	{
+		*pActualLen = BufferLen;
+	}
+
+	if (Begin + *pActualLen > RingBufferPtr + nRingBufferLen)
+	{
+		fsl_osal_u32 FirstSegmentLen = nRingBufferLen - (Begin - RingBufferPtr);
+		fsl_osal_memset(Begin, 0, FirstSegmentLen);
+		fsl_osal_memset(RingBufferPtr, 0, *pActualLen - FirstSegmentLen);
+		Begin = RingBufferPtr + *pActualLen - FirstSegmentLen;
+	}
+	else
+	{
+		fsl_osal_memset(Begin, 0, *pActualLen);
+		Begin += *pActualLen;
+	}
+
+	LOG_LOG("nRingBufferLen = %d\t DataLen = %d\n", nRingBufferLen, DataLen);
+
+    return ret;
+}
+
+
+fsl_osal_u32 RingBuffer::AudioDataLen()
+{
+	fsl_osal_s32 DataLen = Begin - End;
+	if (DataLen < 0)
+	{
+		DataLen = nRingBufferLen - (End - Begin);
+	}
+
+    return (fsl_osal_u32)DataLen;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferGet(fsl_osal_u8 **ppBuffer, fsl_osal_u32 BufferLen, fsl_osal_u32 *pActualLen)
+{
+    RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+	fsl_osal_s32 DataLen = AudioDataLen();
+	if (DataLen < (fsl_osal_s32)BufferLen)
+	{
+		*pActualLen = DataLen;
+	}
+	else
+	{
+		*pActualLen = BufferLen;
+	}
+	if (ReservedLen < *pActualLen)
+	{
+		LOG_WARNING("Reserved buffer is too short.\n");
+		*pActualLen = ReservedLen;
+	}
+
+	if (End + *pActualLen > RingBufferPtr + nRingBufferLen)
+	{
+		fsl_osal_u32 FirstSegmentLen = nRingBufferLen - (End - RingBufferPtr);
+		fsl_osal_memcpy(Reserved, End, FirstSegmentLen);
+		fsl_osal_memcpy(Reserved + FirstSegmentLen, RingBufferPtr, *pActualLen - FirstSegmentLen);
+		*ppBuffer = Reserved;
+	}
+	else
+	{
+		*ppBuffer = End;
+	}
+
+	LOG_LOG("nRingBufferLen = %d\t DataLen = %d\n", nRingBufferLen, DataLen);
+    return ret;
+}
+
+RINGBUFFER_ERRORTYPE RingBuffer::BufferConsumered(fsl_osal_u32 ConsumeredLen)
+{
+    RINGBUFFER_ERRORTYPE ret = RINGBUFFER_SUCCESS;
+	fsl_osal_s32 DataLen = AudioDataLen();
+	if (DataLen < (fsl_osal_s32)ConsumeredLen)
+	{
+		LOG_ERROR("Ring buffer consumer point set error.\n");
+		return RINGBUFFER_FAILURE;
+	}
+
+	if (End + ConsumeredLen > RingBufferPtr + nRingBufferLen)
+	{
+		End += ConsumeredLen - nRingBufferLen;
+	}
+	else
+	{
+		End += ConsumeredLen;
+	}
+
+	TotalConsumeLen += ConsumeredLen;
+	LOG_LOG("nRingBufferLen = %d\t DataLen = %d\n", nRingBufferLen, DataLen);
+	return ret;
+}
+
+/* File EOF */
diff --git a/utils/RingBuffer.h b/utils/RingBuffer.h
new file mode 100755
index 0000000..74eba2b
--- /dev/null
+++ b/utils/RingBuffer.h
@@ -0,0 +1,59 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file RingBuffer.h
+ *  @brief Class definition of ring buffer
+ *  @ingroup RingBuffer
+ */
+
+
+#ifndef RingBuffer_h
+#define RingBuffer_h
+
+#include "fsl_osal.h"
+#include "Queue.h"
+
+#define RING_BUFFER_SCALE 2
+
+typedef enum {
+    RINGBUFFER_SUCCESS,
+    RINGBUFFER_FAILURE,
+    RINGBUFFER_INSUFFICIENT_RESOURCES
+}RINGBUFFER_ERRORTYPE;
+
+class RingBuffer {
+	public:
+		RingBuffer();
+		RINGBUFFER_ERRORTYPE BufferCreate(fsl_osal_u32 nPushModeLen, fsl_osal_u32 nRingBufferScale = RING_BUFFER_SCALE);
+        RINGBUFFER_ERRORTYPE BufferFree();
+		RINGBUFFER_ERRORTYPE BufferReset();
+		RINGBUFFER_ERRORTYPE BufferAdd(fsl_osal_u8 *pBuffer, fsl_osal_u32 BufferLen, fsl_osal_u32 *pActualLen);
+		RINGBUFFER_ERRORTYPE BufferAddZeros(fsl_osal_u32 BufferLen, fsl_osal_u32 *pActualLen);
+		fsl_osal_u32 AudioDataLen();
+		RINGBUFFER_ERRORTYPE BufferGet(fsl_osal_u8 **ppBuffer, fsl_osal_u32 BufferLen, fsl_osal_u32 *pActualLen);
+		/** Set consumered point for ring buffer. */
+		RINGBUFFER_ERRORTYPE BufferConsumered(fsl_osal_u32 ConsumeredLen);
+		fsl_osal_u32 nPrevOffset;
+	private:
+		fsl_osal_u32 nPushModeInputLen;
+		fsl_osal_s64 TotalConsumeLen;
+        fsl_osal_u32 nOneByteTime;
+		fsl_osal_u8 *RingBufferPtr;
+		fsl_osal_u32 nRingBufferLen; /**< Should at least RING_BUFFER_SCALE * PUSH model input buffer length */
+		fsl_osal_u8 *Reserved;
+		fsl_osal_u32 ReservedLen;   /**< 1/RING_BUFFER_SCALE length of ring buffer length, 
+								 used for the end of ring buffer data */
+		fsl_osal_u8 *Begin;
+		fsl_osal_u8 *End;
+		fsl_osal_u8 *Consumered;
+};
+
+#endif
+/* File EOF */
diff --git a/utils/ShareLibarayMgr.cpp b/utils/ShareLibarayMgr.cpp
new file mode 100755
index 0000000..a8e69df
--- /dev/null
+++ b/utils/ShareLibarayMgr.cpp
@@ -0,0 +1,152 @@
+/**
+ *  Copyright (c) 2009-2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include "Mem.h"
+#include "Log.h"
+#include "ShareLibarayMgr.h"
+
+fsl_osal_ptr ShareLibarayMgr::load(fsl_osal_char *lib_name) 
+{
+	LIB_INFO *pLibInfo;
+
+	if (lib_name == NULL)
+	{
+		LOG_ERROR("Library name is NULL.\n");
+		return NULL;
+	}
+
+	/** Check if the library already loaded */
+	for (fsl_osal_s32 i = 0; ; i ++)
+	{
+		pLibInfo = lib_info.GetNode(i);
+		if(pLibInfo == NULL)
+		{
+			break;
+		}
+
+		if (!fsl_osal_strcmp(pLibInfo->lib_name, lib_name))
+		{
+			pLibInfo->refCount ++;
+			LOG_DEBUG("The reference times of the lib: %s is: %d\n", pLibInfo->lib_name, \
+					pLibInfo->refCount);
+			return pLibInfo->hlib;
+		}
+	}
+
+    const fsl_osal_char *cError;
+
+	fsl_osal_ptr pLibHandle = dlopen(lib_name, RTLD_NOW);
+	if (pLibHandle == NULL)
+	{
+		LOG_WARNING("Can't open library: %s\n", lib_name);
+		printf("Can't open library: %s\n", lib_name);
+        cError = dlerror();
+        LOG_WARNING("%s\n", cError);
+        printf("%s\n", cError);
+		return NULL;
+	}
+
+	pLibInfo = FSL_NEW(LIB_INFO, ());
+	if (pLibInfo == NULL)
+	{
+		LOG_ERROR("New LIB_INFO fail.\n");
+		return NULL;
+	}
+	
+	fsl_osal_strcpy(pLibInfo->lib_name, lib_name);
+	pLibInfo->hlib = pLibHandle;
+	pLibInfo->refCount = 1;
+
+	lib_info.Add(pLibInfo);
+
+	return pLibHandle;
+}
+
+fsl_osal_s32 ShareLibarayMgr::unload(fsl_osal_ptr hlib) 
+{
+	LIB_INFO *pLibInfo;
+
+	if (hlib == NULL)
+	{
+		LOG_ERROR("Library handle is NULL.\n");
+		return 0;
+	}
+
+	/** Check if the library already loaded */
+	for (fsl_osal_s32 i = 0; ; i ++)
+	{
+		pLibInfo = lib_info.GetNode(i);
+		if(pLibInfo == NULL)
+		{
+			break;
+		}
+
+		if (pLibInfo->hlib == hlib)
+		{
+			pLibInfo->refCount --;
+			LOG_DEBUG("The reference times of the library: %s is: %d\n", pLibInfo->lib_name, \
+					pLibInfo->refCount);
+			if (pLibInfo->refCount == 0)
+			{
+				LOG_DEBUG("Unload the librayr: %s\n", pLibInfo->lib_name);
+				dlclose(pLibInfo->hlib);
+				lib_info.Remove(pLibInfo);
+				FSL_DELETE(pLibInfo);
+				return 0;
+			}
+			return pLibInfo->refCount;
+		}
+	}
+	
+	return 0;
+}
+
+fsl_osal_ptr ShareLibarayMgr::getSymbol(fsl_osal_ptr hlib, fsl_osal_char *symbol) 
+{
+	LIB_INFO *pLibInfo;
+
+	if (hlib == NULL || symbol == NULL)
+	{
+		LOG_ERROR("Library handle or symbol is NULL.\n");
+		return NULL;
+	}
+
+	/** Check if the library already loaded */
+	for (fsl_osal_s32 i = 0; ; i ++)
+	{
+		pLibInfo = lib_info.GetNode(i);
+		if(pLibInfo == NULL)
+		{
+			break;
+		}
+
+		if (pLibInfo->hlib == hlib)
+		{
+			fsl_osal_ptr funcSymbol = dlsym(pLibInfo->hlib, symbol);
+			if (funcSymbol != NULL)
+			{
+				return funcSymbol;
+			}
+			else
+			{
+				const fsl_osal_char *cError;
+				cError = dlerror();
+				LOG_DEBUG("%s\n", cError);
+				break;
+			}
+		}
+	}
+
+	LOG_ERROR("Can't get symbol: %s in library: %s\n", symbol, pLibInfo->lib_name);
+	return NULL;
+}
+
+/* File EOF */
diff --git a/utils/ShareLibarayMgr.h b/utils/ShareLibarayMgr.h
new file mode 100755
index 0000000..57d6283
--- /dev/null
+++ b/utils/ShareLibarayMgr.h
@@ -0,0 +1,41 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file ShareLibarayMgr.h
+ *  @brief Class definition of shared library manager
+ *  @ingroup ShareLibarayMgr
+ */
+
+
+#ifndef ShareLibarayMgr_h
+#define ShareLibarayMgr_h
+
+#include "fsl_osal.h"
+#include "List.h"
+
+#define LIB_NAME_LEN 512
+
+typedef struct _LIB_INFO {
+    fsl_osal_char lib_name[LIB_NAME_LEN];
+    fsl_osal_ptr hlib;
+    fsl_osal_s32 refCount;
+}LIB_INFO;
+
+class ShareLibarayMgr {
+public:
+    fsl_osal_ptr load(fsl_osal_char *lib_name);
+    fsl_osal_s32 unload(fsl_osal_ptr hlib);
+    fsl_osal_ptr getSymbol(fsl_osal_ptr hlib, fsl_osal_char *symbol);
+private:
+    List<LIB_INFO> lib_info;
+};
+
+#endif
+/* File EOF */
diff --git a/utils/Tsm_wrapper.c b/utils/Tsm_wrapper.c
new file mode 100755
index 0000000..41e61dd
--- /dev/null
+++ b/utils/Tsm_wrapper.c
@@ -0,0 +1,536 @@
+/**
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+#include "Tsm_wrapper.h"
+
+//#define TS_DIS_ORI_TSMANAGER	//for debug: only use new ts mananger
+//#define TS_DIS_NEW_TSMANAGER	//for debug: only use original ts manager
+//#define TS_ENA_MULTI_STRATEGY	//for debug: run multi-strategy simultaneously
+#define TS_USE_QUERY_API		//the query value may be not matched with original method
+#define TS_LIST_LEN 128
+#define TS_LIST_FULL_THRESHOLD	(TS_LIST_LEN-5)
+#define TS_MAX_DIFF_US	90000
+#define TS_MAX_QUERY_DIFF_US	90000
+#define TS_INVALIDTS (-1)
+#define TS_SCALE	1000
+#define TS_ABS(t1,t2) (((t1)>=(t2))?((t1)-(t2)):((t2)-(t1)))
+#define TS_THRESHOLD_DURATION_INVALID (-1)
+#define TS_THRESHOLD_BLKCNT_INVALID (-1)
+
+#ifdef ANDROID_BUILD
+#include "Log.h"
+#define LOG_PRINTF LogOutput
+#else
+#define LOG_PRINTF printf
+#endif
+
+//#define TS_DEBUG_ON
+#ifdef TS_DEBUG_ON
+#define TS_API	LOG_PRINTF
+#define TS_DEBUG LOG_PRINTF
+#define TS_ERROR LOG_PRINTF
+#else
+#define TS_API(...) //LOG_PRINTF
+#define TS_DEBUG(...) //LOG_PRINTF
+#define TS_ERROR LOG_PRINTF
+#endif
+
+#define ts_memset memset//fsl_osal_memset
+#define ts_memcpy memcpy//fsl_osal_memcpy
+#define ts_malloc malloc//FSL_MALLOC
+#define ts_free free//FSL_FREE
+#define TS_TRUE 1
+#define TS_FALSE 0
+
+typedef struct{
+	//original object
+	void* pHandleOri;
+	int nInTsCntOri;
+	long long nInCurTsOri;
+
+	//new object
+	void* pHandle2;
+	int nInTsCnt2;
+	long long nInCurTs2;
+	int nIsActived2;	//accurate frame size is supported ?
+	signed long long nAccBlkOffset2;	//debug: accumulated bytes for blk
+	signed long long nAccFrmOffset2;	//debug: accumulated bytes for frame
+	long long nCurInputTs;     // input ts from parser(decode order)
+	long long nCurOutputTs;   // output ts from decoder(display order)
+
+	//global info
+	long long nLastTs;
+	long long nDeltaTs;
+
+	//data depth threshold: added for control the speed of feeding input, it is useful for rtsp/http application
+	long long nDurationMsThr;	/*threshold for timestamp duration cached in decoder:  <=0(default)-> no threshold*/
+	int nBlkCntThr;			/*threshold for blk(frame,field,...) count cached in decoder: <=0(default) -> no threshold*/
+}TSM_OBJ;
+
+static int DataDepthIsEnough(void* pHandle, void* pTsHandle)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	int nBlkCnt;
+	int isEnough;
+	int isDurationEnough=0;
+	int isBlkEnough=0;
+	if((pObj->nDurationMsThr>0)
+		&& (TS_INVALIDTS!=pObj->nCurInputTs)&&(TS_INVALIDTS!=pObj->nCurOutputTs)
+		&& (pObj->nCurInputTs > pObj->nCurOutputTs+pObj->nDurationMsThr*1000)){
+		TS_DEBUG("input ts(us): %lld, output ts(us): %lld, duration threshold(ms): %lld \r\n",pObj->nCurInputTs,pObj->nCurOutputTs,pObj->nDurationMsThr);
+		isDurationEnough=1;
+	}
+	nBlkCnt=getTSManagerPreBufferCnt(pTsHandle);
+	if((pObj->nBlkCntThr>0)&&(nBlkCnt>pObj->nBlkCntThr)){
+		TS_DEBUG("cached blk cnt: %d, blkcnt threshold: %d \r\n",nBlkCnt,pObj->nBlkCntThr);
+		isBlkEnough=1;
+	}
+	isEnough = isDurationEnough & isBlkEnough;
+	return isEnough;
+}
+
+void* tsmCreate()
+{
+	TSM_OBJ* pObj=NULL;
+	void* ptr=NULL;
+
+	//malloc memory for object
+	pObj=(TSM_OBJ*)ts_malloc(sizeof(TSM_OBJ));
+	if(pObj==NULL){
+		TS_ERROR("%s: error: malloc %d bytes fail \n",__FUNCTION__,sizeof(TSM_OBJ));
+		return NULL;
+	}
+	ts_memset((void*)pObj, 0, sizeof(TSM_OBJ));
+
+#ifndef TS_DIS_ORI_TSMANAGER
+	//create original ts manager
+	TS_API("ori:calling createTSManager(%d) \n",TS_LIST_LEN);
+	ptr=createTSManager(TS_LIST_LEN);
+	if(ptr){
+		pObj->pHandleOri=ptr;
+		pObj->nInTsCntOri=0;
+		pObj->nInCurTsOri=TS_INVALIDTS;
+	}
+	else	{
+		goto TSM_Create_Fail;
+	}
+#endif
+
+#ifndef TS_DIS_NEW_TSMANAGER
+	//create new ts manager
+	TS_API("new:calling createTSManager(%d) \n",TS_LIST_LEN);
+	ptr=createTSManager(TS_LIST_LEN);
+	if(ptr){
+		pObj->pHandle2=ptr;
+		pObj->nInTsCnt2=0;
+		pObj->nInCurTs2=TS_INVALIDTS;
+		pObj->nCurInputTs=TS_INVALIDTS;
+		pObj->nCurOutputTs=TS_INVALIDTS;
+	}
+	else	{
+		goto TSM_Create_Fail;
+	}
+#endif
+
+	//set default value
+	pObj->nLastTs=TS_INVALIDTS;
+	pObj->nDeltaTs=TS_INVALIDTS;
+	pObj->nDurationMsThr=TS_THRESHOLD_DURATION_INVALID;
+	pObj->nBlkCntThr=TS_THRESHOLD_BLKCNT_INVALID;
+	return (void*)pObj;
+
+TSM_Create_Fail:
+	if(pObj->pHandleOri){
+		TS_API("ori:calling destroyTSManager \n");
+		destroyTSManager(pObj->pHandleOri);
+		pObj->pHandleOri=NULL;
+	}
+	if(pObj->pHandle2){
+		TS_API("new:calling destroyTSManager \n");
+		destroyTSManager(pObj->pHandle2);
+		pObj->pHandle2=NULL;
+	}
+	if(pObj){
+		ts_free(pObj);
+	}
+	return NULL;
+}
+
+int tsmDestroy(void* pHandle)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	if(pObj->pHandleOri){
+		TS_API("ori:calling destroyTSManager \n");
+		destroyTSManager(pObj->pHandleOri);
+		pObj->pHandleOri=NULL;
+	}
+	if(pObj->pHandle2){
+		TS_API("new:calling destroyTSManager \n");
+		destroyTSManager(pObj->pHandle2);
+		pObj->pHandle2=NULL;
+	}
+	ts_free(pObj);
+	return 1;
+}
+
+int tsmSetFrmRate(void* pHandle,int nFsN, int nFsD)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	if(pObj->pHandleOri){
+		TS_API("ori:calling setTSManagerFrameRate: fps(%d/%d) \n",nFsN, nFsD);
+		setTSManagerFrameRate(pObj->pHandleOri, nFsN, nFsD);
+	}
+	if(pObj->pHandle2){
+		TS_API("new:calling setTSManagerFrameRate: fps(%d/%d) \n",nFsN, nFsD);
+		setTSManagerFrameRate(pObj->pHandle2, nFsN, nFsD);
+	}	
+	return 1;
+}
+
+
+int tsmSetBlkTs(void* pHandle,int nSize, TSM_TIMESTAMP Ts)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	TSM_TIMESTAMP ts=TS_INVALIDTS;
+	if(pObj->pHandleOri){
+		ts=Ts;
+		if(ts == TS_INVALIDTS){
+			ts = TSM_TIMESTAMP_NONE;
+		}
+		else{
+			ts*= TS_SCALE;
+		}
+		TS_API("ori:calling TSManagerReceive: ts(ns): %lld, total: %d\n", ts, (int)pObj->nInTsCntOri);
+		TSManagerReceive(pObj->pHandleOri, ts);		
+		pObj->nInTsCntOri++;
+	}
+	if(pObj->pHandle2){
+		ts=Ts;
+		if(ts == TS_INVALIDTS){
+			ts = TSM_TIMESTAMP_NONE;
+			//pObj->nCurInputTs=TS_INVALIDTS;
+		}
+		else{
+			pObj->nCurInputTs=ts;
+			ts*= TS_SCALE;
+		}
+		TS_API("new:calling TSManagerReceive2: [%lld(0x%llX)] ts(ns): %lld, size: %d, total: %d\n",pObj->nAccBlkOffset2,pObj->nAccBlkOffset2,ts, nSize,(int)pObj->nInTsCnt2);
+		TSManagerReceive2(pObj->pHandle2, ts,nSize);		
+		pObj->nInTsCnt2++;
+		pObj->nAccBlkOffset2+=nSize;
+	}	
+	return 1;
+}
+
+int tsmSetFrmBoundary(void* pHandle,int nStuffSize,int nFrmSize,void* pfrmHandle)
+{
+	/*pfrmHandle==NULL: the frame is skipped for skipmode/corrupt/... cases*/
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	if(pObj->pHandleOri){
+		//nothing
+	}
+	if(pObj->pHandle2){
+		if(pObj->nIsActived2==0){
+			pObj->nIsActived2=1;	//accurate frame size is reported by decoder
+		}
+		pObj->nAccFrmOffset2+=nStuffSize;
+#if 1	//consider special case: config data contain valid frames, as result, stuffsize < 0
+		if(pObj->nAccFrmOffset2+nFrmSize<=0)
+		{
+			TS_API("new:calling TSManagerValid2(0): [%lld(0x%llX)]: discarded frame size: %d \n",pObj->nAccFrmOffset2,pObj->nAccFrmOffset2,nFrmSize);
+			TSManagerValid2(pObj->pHandle2,0,pfrmHandle);
+		}
+		else if(pObj->nAccFrmOffset2<=0)
+		{
+			TS_API("new:calling TSManagerValid2(*): [%lld(0x%llX)]: discarded frame size: %d \n",pObj->nAccFrmOffset2,pObj->nAccFrmOffset2,nFrmSize);
+			TSManagerValid2(pObj->pHandle2,pObj->nAccFrmOffset2+nFrmSize,pfrmHandle);			
+		}
+		else
+#endif		
+		{
+			if(NULL==pfrmHandle){
+				TS_API("new:calling TSManagerValid2: [%lld(0x%llX)]: flush %d bytes, skipped frame size: %d \n",pObj->nAccFrmOffset2,pObj->nAccFrmOffset2,nStuffSize,nFrmSize);
+				TSManagerValid2(pObj->pHandle2,nStuffSize+nFrmSize,pfrmHandle);
+			}
+			else{
+				TS_API("new:calling TSManagerFlush2/TSManagerValid2: [%lld(0x%llX)]: flush %d bytes, frame size: %d, frm: 0x%X \n",pObj->nAccFrmOffset2,pObj->nAccFrmOffset2,nStuffSize,nFrmSize,pfrmHandle);
+				TSManagerFlush2(pObj->pHandle2,nStuffSize);
+				TSManagerValid2(pObj->pHandle2,nFrmSize,pfrmHandle);
+			}
+		}
+		//In fact, nInTsCnt2 may be changed after calling TSManagerValid2(), so nInTsCnt2 become unmeaningful
+		pObj->nAccFrmOffset2+=nFrmSize;
+#ifndef TS_ENA_MULTI_STRATEGY
+		//disable original method automatically, only one strategy is enabled
+		if(pObj->pHandleOri){
+			TS_DEBUG("new strategy is detected, original will be disabled automatically\n");
+			TS_API("ori: calling destroyTSManager\n");
+			destroyTSManager(pObj->pHandleOri);
+			pObj->pHandleOri=NULL;
+		}
+#endif
+	}
+	return 1;
+}
+
+
+TSM_TIMESTAMP tsmGetFrmTs(void* pHandle,void* pfrmHandle)
+{
+	/*nfrmHandle==NULL: 
+		(1) only need to pop one time stamp. (e.g. frame is not decoded at all by vpu for skipmode/corrupt/... cases); 
+		(2) mosaic frame which is dropped by vpu for non-gop case
+	*/
+	TSM_TIMESTAMP ts=TS_INVALIDTS;
+	TSM_TIMESTAMP tsOri=TS_INVALIDTS;
+	TSM_TIMESTAMP ts2=TS_INVALIDTS;
+	TSM_TIMESTAMP tsDiff;
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	if(pObj->pHandleOri){
+		if(pObj->nInCurTsOri != TS_INVALIDTS) {
+			tsOri = pObj->nInCurTsOri;
+			pObj->nInCurTsOri = TS_INVALIDTS;
+		}
+		else{
+			tsOri = TSManagerSend(pObj->pHandleOri);
+			TS_API("ori: calling TSManagerSend: returned ts(ns): %lld, total: %d \n",tsOri, (int)pObj->nInTsCntOri);
+			tsOri=(tsOri==TS_INVALIDTS)?tsOri:(tsOri/TS_SCALE);
+			pObj->nInTsCntOri--;
+		}
+		ts=tsOri;
+	}
+	if(pObj->pHandle2){
+		if(pObj->nIsActived2==0){
+			TS_DEBUG("new strategy isn't detected, it will be disabled automatically\n");
+			TS_API("new: calling destroyTSManager\n");
+			destroyTSManager(pObj->pHandle2);
+			pObj->pHandle2=NULL;
+		}
+		else{				
+			if(pObj->nInCurTs2 != TS_INVALIDTS) {
+				ts2 = pObj->nInCurTs2;
+				pObj->nInCurTs2 = TS_INVALIDTS;
+			}
+			else{
+				if(NULL==pfrmHandle){
+					ts2=TSManagerSend2(pObj->pHandle2, NULL);
+					TS_API("new: calling TSManagerSend2(NULL): returned ts(ns): %lld, total: %d \n",ts2, (int)pObj->nInTsCnt2);
+				}
+				else{
+					ts2=TSManagerSend2(pObj->pHandle2, pfrmHandle);
+					TS_API("new: calling TSManagerSend2: frm: 0x%X, returned ts(ns): %lld, total: %d \n",pfrmHandle,ts2, (int)pObj->nInTsCnt2);
+				}
+				ts2=(ts2==TS_INVALIDTS)?ts2:(ts2/TS_SCALE);
+				pObj->nInTsCnt2--;
+			}
+			//TS_DEBUG("new: get one ts: %lld, total: %d\n", ts2, (int)pObj->nInTsCnt2);
+			ts=ts2;
+			pObj->nCurOutputTs=ts;
+		}
+	}
+
+	//double check the ts for different schema
+	if(pObj->pHandleOri && pObj->pHandle2){
+		tsDiff=TS_ABS(tsOri,ts2);
+		if(tsDiff>=TS_MAX_DIFF_US){
+			TS_ERROR("LEVEL: 1 %s: the time stamp is conflict: ori ts(us): %lld, new ts(us): %lld, diff(us): %lld \n",__FUNCTION__,tsOri,ts2,tsDiff);
+		}
+	}
+
+	if(ts==TS_INVALIDTS){
+		TS_ERROR("%s: warning: can't get one valid ts \n",__FUNCTION__);
+	}
+#ifdef TS_DEBUG	
+	if(pObj->nLastTs!=TS_INVALIDTS){
+		pObj->nDeltaTs=ts-pObj->nLastTs;
+	}		
+	pObj->nLastTs=ts;
+	TS_DEBUG("%s: current ts(us): %lld, delta(us): %lld \n",__FUNCTION__,pObj->nLastTs,pObj->nDeltaTs);
+#endif	
+	return ts;
+}
+
+int tsmReSync(void* pHandle, TSM_TIMESTAMP synctime, TSMGR_MODE mode)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	TSM_TIMESTAMP ts;
+	if(pObj->pHandleOri){
+		ts=synctime*TS_SCALE;
+		TS_API("ori: calling resyncTSManager: synctime: %lld, mode: %d \n",ts,mode);
+		resyncTSManager(pObj->pHandleOri, ts, mode);
+	}
+	if(pObj->pHandle2){
+		ts=synctime*TS_SCALE;
+		TS_API("new: calling resyncTSManager: synctime: %lld, mode: %d \n",ts,mode);
+		resyncTSManager(pObj->pHandle2, ts, mode);
+	}
+	return 1;	
+}
+
+int tsmFlush(void* pHandle)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	if(pObj->pHandleOri){
+		pObj->nInTsCntOri=0;
+		pObj->nInCurTsOri=TS_INVALIDTS;
+	}
+	if(pObj->pHandle2){
+		pObj->nInTsCnt2=0;
+		pObj->nInCurTs2=TS_INVALIDTS;
+		pObj->nAccBlkOffset2=0;
+		pObj->nAccFrmOffset2=0;
+		pObj->nCurInputTs=TS_INVALIDTS;
+		pObj->nCurOutputTs=TS_INVALIDTS;        
+	}
+	pObj->nLastTs=TS_INVALIDTS;
+	pObj->nDeltaTs=TS_INVALIDTS;
+	return 1;	
+}
+
+int tsmHasEnoughSlot(void* pHandle)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	if(pObj->pHandleOri){
+		if(pObj->nInTsCntOri >= TS_LIST_FULL_THRESHOLD){
+			return TS_FALSE;
+		}
+		else{
+			return TS_TRUE;
+		}
+	}
+	if(pObj->pHandle2){
+		if(DataDepthIsEnough(pHandle,pObj->pHandle2))
+		{
+			return TS_FALSE;
+		}
+		else{
+			return TS_TRUE;
+		}
+	}
+	return TS_TRUE;
+}
+
+TSM_TIMESTAMP tsmQueryCurrTs(void* pHandle)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	TSM_TIMESTAMP ts=TS_INVALIDTS;
+	TSM_TIMESTAMP tsOri=TS_INVALIDTS;
+	TSM_TIMESTAMP ts2=TS_INVALIDTS;
+	TSM_TIMESTAMP tsDiff;
+	if(pObj->pHandleOri){
+		if(pObj->nInTsCntOri == 0){
+			tsOri=TS_INVALIDTS;
+		}
+		else if(pObj->nInCurTsOri != TS_INVALIDTS){
+			tsOri=pObj->nInCurTsOri;
+		}
+		else{
+			tsOri = TSManagerSend(pObj->pHandleOri);
+			TS_API("ori: calling TSManagerSend: returned(query) ts(ns): %lld \n",tsOri);
+			if(tsOri<0){
+				TS_ERROR("%s: error: one invalid ts(%lld) is queried: set it 0 manually\n",__FUNCTION__,tsOri);
+				//set one different value with TS_INVALIDTS to match the 'nInTsCntOri'
+				pObj->nInCurTsOri=TS_INVALIDTS+1;
+			}
+			else{
+				tsOri=(tsOri==TS_INVALIDTS)?tsOri:(tsOri/TS_SCALE);
+				pObj->nInCurTsOri = tsOri;
+			}
+			pObj->nInTsCntOri--;
+		}
+		ts=tsOri;
+		//TS_DEBUG("ori: query one ts: %lld \n",tsOri);
+	}
+	if(pObj->pHandle2){
+#ifdef TS_USE_QUERY_API
+		if(pObj->nIsActived2==0){
+			//hasn't been enabled
+			ts2=TS_INVALIDTS;
+		}
+		else{
+			//FIXME: the ts may be not matched
+			ts2=TSManagerQuery2(pObj->pHandle2,NULL);
+			TS_API("new: calling TSManagerQuery2(NULL): returned ts(ns): %lld \n",ts2);
+			ts2=(ts2==TS_INVALIDTS)?ts2:(ts2/TS_SCALE);
+		}
+#else
+		if(pObj->nInTsCnt2 == 0){
+			ts2=TS_INVALIDTS;
+		}
+		else if(pObj->nInCurTs2 != TS_INVALIDTS){
+			ts2=pObj->nInCurTs2;
+		}
+		else{
+			//FIXME: the ts may be not matched without calling TSManagerValid2()
+			ts2 = TSManagerSend2(pObj->pHandle2,NULL);
+			TS_API("new: calling TSManagerSend2(NULL): returned(query) ts(ns): %lld \n",ts2);
+			if(ts2<0){
+				TS_ERROR("%s: error: one invalid ts(%lld) is queried: set it 0 manually\n",__FUNCTION__,ts2);
+				//set one different value with TS_INVALIDTS to match the 'nInTsCntOri'
+				pObj->nInCurTs2=TS_INVALIDTS+1;
+			}
+			else{
+				ts2=(ts2==TS_INVALIDTS)?ts2:(ts2/TS_SCALE);
+				pObj->nInCurTs2 = ts2;
+			}
+			pObj->nInTsCnt2--;
+		}
+#endif		
+		ts=ts2;
+		//TS_DEBUG("new: query one ts: %lld \n",ts2);
+	}
+
+	//double check the ts for different schema
+	//if(pObj->pHandleOri && pObj->pHandle2){
+	if((tsOri!=TS_INVALIDTS)&&(ts2!=TS_INVALIDTS)){	
+		tsDiff=TS_ABS(tsOri,ts2);
+		if(tsDiff>=TS_MAX_QUERY_DIFF_US){
+			TS_ERROR("LEVEL: 1 %s: the time stamp is conflict: ori ts(us): %lld, new ts(us): %lld, diff(us): %lld \n",__FUNCTION__,tsOri,ts2,tsDiff);
+		}
+	}
+
+	return ts;
+}
+
+int tsmSetDataDepthThreshold(void* pHandle,int nDurationThr, int nBlkCntThr)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	pObj->nDurationMsThr=nDurationThr;
+	pObj->nBlkCntThr=nBlkCntThr;
+	return 1;
+}
+
+int tsmClearCachedFrameTs(void* pHandle)
+{
+	TSM_OBJ* pObj=(TSM_OBJ*)pHandle;
+	int nBlkCnt;
+	TSM_TIMESTAMP ts;
+	/*in this function, we only clear those frame be decoded already*/
+	if(pObj->pHandleOri){
+		/*in old design, all input ts will be inserted into ready list, no matter how it is decoded or not*/
+		TS_DEBUG("%s: unsupported by original ts manager! \r\n",__FUNCTION__);
+		return 0;
+	}
+	if(pObj->pHandle2){
+		/*in new design, only decoded frame is inserted the ready list, so we can clear them*/
+		nBlkCnt=getTSManagerPreBufferCnt(pObj->pHandle2);
+		TS_DEBUG("nBlkCnt: %d , nInTsCnt2: %d \r\n",nBlkCnt,pObj->nInTsCnt2);
+		while(nBlkCnt>0){
+			nBlkCnt--;
+			ts=TSManagerSend2(pObj->pHandle2, NULL);
+			TS_DEBUG("drop %lld \r\n",ts);
+			if(ts==TS_INVALIDTS){
+				break;
+			}
+		}
+	}
+	return 1;
+}
+
diff --git a/utils/Tsm_wrapper.h b/utils/Tsm_wrapper.h
new file mode 100755
index 0000000..07fee91
--- /dev/null
+++ b/utils/Tsm_wrapper.h
@@ -0,0 +1,36 @@
+/**
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef _TSM_WRAPPER_H_
+#define _TSM_WRAPPER_H_
+
+#include "mfw_gst_ts.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+void* tsmCreate();
+int tsmDestroy(void * pHandle);
+int tsmSetFrmRate(void * pHandle,int nFsN, int nFsD);
+int tsmSetBlkTs(void * pHandle,int nSize, TSM_TIMESTAMP Ts);
+int tsmSetFrmBoundary(void * pHandle,int nStuffSize,int nFrmSize,void * pfrmHandle);
+TSM_TIMESTAMP tsmGetFrmTs(void * pHandle,void * pfrmHandle);
+int tsmReSync(void * pHandle, TSM_TIMESTAMP synctime, TSMGR_MODE mode);
+int tsmFlush(void * pHandle);
+int tsmHasEnoughSlot(void * pHandle);
+TSM_TIMESTAMP tsmQueryCurrTs(void * pHandle);
+int tsmSetDataDepthThreshold(void* pHandle,int nDurationThr, int nBlkCntThr);
+int tsmClearCachedFrameTs(void* pHandle);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  //_TSM_WRAPPER_H_
+ 
diff --git a/utils/Utils.h b/utils/Utils.h
new file mode 100755
index 0000000..a79f3cf
--- /dev/null
+++ b/utils/Utils.h
@@ -0,0 +1,59 @@
+/**
+ *  Copyright (c) 2009-2010, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file Queue.h
+ *  @brief Class definition of Queue
+ *  @ingroup State
+ */
+
+#ifndef Utils_h
+#define Utils_h
+
+#include "fsl_osal.h"
+
+typedef enum {
+    QUEUE_SUCCESS,
+    QUEUE_FAILURE,
+    QUEUE_NOT_READY,
+    QUEUE_OVERFLOW,
+    QUEUE_INSUFFICIENT_RESOURCES
+}QUEUE_ERRORTYPE;
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+    QUEUE_ERRORTYPE CreateQueue(
+            fsl_osal_ptr *pQHandle,
+            fsl_osal_u32 nMaxQueueSize,
+            efsl_osal_bool bBlockingQueue,
+            fsl_osal_u32 nMessageSize);
+
+    QUEUE_ERRORTYPE EnQueue(
+            fsl_osal_ptr hQHandle, 
+            fsl_osal_ptr pMessage, 
+            efsl_osal_bool bMaxPriority);
+
+    fsl_osal_u32 GetQueueSize(
+            fsl_osal_ptr hQHandle);
+
+    QUEUE_ERRORTYPE ReadQueue(
+            fsl_osal_ptr hQHandle, 
+            fsl_osal_ptr pMessage, 
+            efsl_osal_bool bDeQueue);
+
+    QUEUE_ERRORTYPE DeleteQueue(
+            fsl_osal_ptr hQHandle);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
diff --git a/utils/audio_frame_parser/AacFrameParser.c b/utils/audio_frame_parser/AacFrameParser.c
new file mode 100755
index 0000000..e738a7b
--- /dev/null
+++ b/utils/audio_frame_parser/AacFrameParser.c
@@ -0,0 +1,96 @@
+/**
+ *  Copyright (c) 2010-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "AacFrameParser.h"
+
+static const fsl_osal_u32 aac_sampling_frequency[] = {96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000};
+#define AAC_SAMPLERATE_TABLE_SIZE (fsl_osal_u32)(sizeof(aac_sampling_frequency)/sizeof(aac_sampling_frequency[0]))
+#define AAC_FRAME_SIZE 1024
+static efsl_osal_bool IsADTSFrameHeader(fsl_osal_u8 * pHeader,FRAME_INFO * Info)
+{
+    fsl_osal_s32 id;
+    fsl_osal_s32 layer;
+    fsl_osal_s32 rotection_abs = 0;
+    fsl_osal_s32 profile;
+    fsl_osal_s32 sampling_freq_idx;
+    fsl_osal_s32 private_bit;
+    fsl_osal_s32 channel_config;
+    fsl_osal_s32 original_copy;
+    fsl_osal_s32 home;
+    fsl_osal_s32 copyright_id_bit;
+    fsl_osal_s32 copyright_id_start;
+    fsl_osal_s32 frame_length;
+    fsl_osal_s32 adts_buffer_fullness;
+    fsl_osal_s32 num_of_rdb;
+    fsl_osal_s32 protection_abs;
+
+    if(pHeader == NULL || Info == NULL)
+        return E_FSL_OSAL_FALSE;
+
+    if(pHeader[0] !=0xFF || (pHeader[1] & 0xF0) != 0xF0)
+        return E_FSL_OSAL_FALSE;
+
+    id = ((fsl_osal_s32)pHeader[1]&0x08)>>3;
+    layer = ((fsl_osal_s32)pHeader[1]&0x06)>>1;
+    protection_abs = (fsl_osal_s32)pHeader[1]&0x01;
+
+    if(layer != 0){
+        return E_FSL_OSAL_FALSE;
+    }
+
+    profile = ((fsl_osal_s32)pHeader[2]&0xC0) >> 6;
+    //do not check the profile level, decoder will check it.
+   // if(profile != 1){
+    //    return E_FSL_OSAL_FALSE;
+   // }
+
+    sampling_freq_idx = ((fsl_osal_s32)pHeader[2]&0x3C) >> 2;
+    if (sampling_freq_idx >= 0xc){
+        return E_FSL_OSAL_FALSE;
+    }
+
+    private_bit = ((fsl_osal_s32)pHeader[2]&0x02) >> 1;
+    channel_config = (((fsl_osal_s32)pHeader[2]&0x01) << 2) + (((fsl_osal_s32)pHeader[3]&0xC0) >> 6);
+    original_copy = ((fsl_osal_s32)pHeader[3]&0x20) >> 5;
+    home = ((fsl_osal_s32)pHeader[3]&0x10) >> 4;
+
+    copyright_id_bit = ((fsl_osal_s32)pHeader[3]&0x08) >> 3;
+    copyright_id_start = ((fsl_osal_s32)pHeader[3]&0x04) >> 2;
+    frame_length = (((fsl_osal_s32)pHeader[3]&0x03) << 11) + (((fsl_osal_s32)pHeader[4]) << 3) + (((fsl_osal_s32)pHeader[5]&0xE0) >> 5);
+
+    adts_buffer_fullness = (((fsl_osal_s32)pHeader[5]&0x1F) << 6) + (((fsl_osal_s32)pHeader[6]&0xFC) >> 2);
+    num_of_rdb = ((fsl_osal_s32)pHeader[6]&0x03);
+
+    Info->channels = channel_config;
+
+    //ref to 13818-7AAC (2).pdf, Table 42  Channel Configuration
+    if(Info->channels == 7)
+    {
+        Info->channels = 8;
+    }
+    else if(Info->channels == 0) //if 0, should parsed in raw block, so just set 1
+    {
+        Info->channels = 1;
+    }
+
+    if((fsl_osal_u32)sampling_freq_idx < AAC_SAMPLERATE_TABLE_SIZE)
+    {
+        Info->sampling_rate = aac_sampling_frequency[sampling_freq_idx];
+    }
+
+    Info->sample_per_fr = AAC_FRAME_SIZE;
+    Info->b_rate = (frame_length << 3) * Info->sampling_rate / Info->sample_per_fr; // / 1000;
+
+    Info->frm_size = frame_length;
+    return E_FSL_OSAL_TRUE;
+}
+AFP_RETURN AacCheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen)
+{
+    return CheckFrame(pFrameInfo,pBuffer,nBufferLen,AAC_FRAME_HEAD_SIZE,IsADTSFrameHeader);
+}
diff --git a/utils/audio_frame_parser/AacFrameParser.h b/utils/audio_frame_parser/AacFrameParser.h
new file mode 100755
index 0000000..cb0ce05
--- /dev/null
+++ b/utils/audio_frame_parser/AacFrameParser.h
@@ -0,0 +1,28 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductors Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef AacFrameParser_h
+#define AacFrameParser_h
+
+#include "AudioFrameParser.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define AAC_FRAME_HEAD_SIZE  7
+
+//check frame function
+AFP_RETURN AacCheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//AacFrameParser_h
diff --git a/utils/audio_frame_parser/Ac3FrameParser.c b/utils/audio_frame_parser/Ac3FrameParser.c
new file mode 100755
index 0000000..498e874
--- /dev/null
+++ b/utils/audio_frame_parser/Ac3FrameParser.c
@@ -0,0 +1,104 @@
+/**
+ *  Copyright (c) 2010-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Ac3FrameParser.h"
+#define NFSCOD      3   /* # defined sample rates */
+#define NDATARATE   38  /* # defined data rates */
+#define AC3D_FRAME_SIZE 1536
+//these tables got from http://rmworkshop.com/dvd_info/related_info/ac3hdr.html
+static const fsl_osal_s16 ac3_frame_size[NFSCOD][NDATARATE] =
+{   {   64, 64, 80, 80, 96, 96, 112, 112,
+    128, 128, 160, 160, 192, 192, 224, 224,
+    256, 256, 320, 320, 384, 384, 448, 448,
+    512, 512, 640, 640, 768, 768, 896, 896,
+    1024, 1024, 1152, 1152, 1280, 1280 },
+{   69, 70, 87, 88, 104, 105, 121, 122,
+    139, 140, 174, 175, 208, 209, 243, 244,
+    278, 279, 348, 349, 417, 418, 487, 488,
+    557, 558, 696, 697, 835, 836, 975, 976,
+    1114, 1115, 1253, 1254, 1393, 1394 },
+{   96, 96, 120, 120, 144, 144, 168, 168,
+    192, 192, 240, 240, 288, 288, 336, 336,
+    384, 384, 480, 480, 576, 576, 672, 672,
+    768, 768, 960, 960, 1152, 1152, 1344, 1344,
+    1536, 1536, 1728, 1728, 1920, 1920 }
+    };
+//these tables got from http://rmworkshop.com/dvd_info/related_info/ac3hdr.html
+static const fsl_osal_s32 ac3_sampling_rate[NFSCOD] = {48000,44100,32000};
+static const fsl_osal_s32 ac3_channel[] = {2,1,2,3,3,4,4,5};
+
+static efsl_osal_bool IsAC3FrameHeader(fsl_osal_u8 * pHeader,FRAME_INFO * Info)
+{
+    int fscod;
+    int frmsizecod;
+    int bsid;
+    int bsmode;
+    int acmod;
+    int lfeonOffset = 0;
+    int lfeon = 0;
+    int samplerate;
+    int framesize;
+    efsl_osal_bool bigEndian = E_FSL_OSAL_FALSE;
+
+    if(pHeader == NULL || Info == NULL)
+        return E_FSL_OSAL_FALSE;
+
+    if ((pHeader[0] == 0x0b && pHeader[1] == 0x77) || (pHeader[0] == 0x77 && pHeader[1] == 0x0b)){
+        ;
+    }else{
+        return E_FSL_OSAL_FALSE;
+    }
+
+    if(pHeader[0] == 0x0b && pHeader[1] == 0x77){
+        fscod = pHeader[4] >> 6;
+        frmsizecod = pHeader[4] & 0x3f;
+        acmod = pHeader[6] >> 5;
+        bigEndian = E_FSL_OSAL_TRUE;
+    }
+    else if(pHeader[0] == 0x77 && pHeader[1] == 0x0b){
+        fscod = pHeader[5] >> 6;
+        frmsizecod = pHeader[5] & 0x3f;
+        acmod = pHeader[7] >> 5;
+    }
+
+    if (fscod>=NFSCOD || frmsizecod>=NDATARATE){
+        return E_FSL_OSAL_FALSE;
+    }
+
+    samplerate = ac3_sampling_rate[fscod];
+    framesize = 2 * ac3_frame_size[fscod][frmsizecod];
+
+    if ((acmod & 0x1) && (acmod != 0x1)){
+        lfeonOffset += 2;
+    }
+    if (acmod & 0x4){
+        lfeonOffset += 2;
+    }
+    if (acmod == 0x2){
+        lfeonOffset += 2;
+    }
+
+    if(lfeonOffset <= 5){
+        lfeon = (pHeader[bigEndian?6:7] >> (4 - lfeonOffset)) & 0x01;
+    }else{
+        lfeon = (pHeader[bigEndian?7:6] >> 6)& 0x01;
+    }
+
+    Info->frm_size = framesize;
+    Info->sampling_rate = samplerate;
+    Info->b_rate = (framesize<<3)*samplerate/AC3D_FRAME_SIZE/1000;
+    Info->sample_per_fr = AC3D_FRAME_SIZE;
+    Info->channels = ac3_channel[acmod] + lfeon;
+    return E_FSL_OSAL_TRUE;
+}
+
+AFP_RETURN Ac3CheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen)
+{
+    return CheckFrame(pFrameInfo,pBuffer,nBufferLen,AC3_FRAME_HEAD_SIZE,IsAC3FrameHeader);
+}
diff --git a/utils/audio_frame_parser/Ac3FrameParser.h b/utils/audio_frame_parser/Ac3FrameParser.h
new file mode 100755
index 0000000..6054426
--- /dev/null
+++ b/utils/audio_frame_parser/Ac3FrameParser.h
@@ -0,0 +1,28 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductors Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef Ac3FrameParser_h
+#define Ac3FrameParser_h
+
+#include "AudioFrameParser.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define AC3_FRAME_HEAD_SIZE  8
+
+//check frame function
+AFP_RETURN Ac3CheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//Ac3FrameParser_h
diff --git a/utils/audio_frame_parser/AudioFrameParser.c b/utils/audio_frame_parser/AudioFrameParser.c
new file mode 100755
index 0000000..2ac59b1
--- /dev/null
+++ b/utils/audio_frame_parser/AudioFrameParser.c
@@ -0,0 +1,110 @@
+/**
+ *  Copyright (c) 2010-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "AudioFrameParser.h"
+#include "Mem.h"
+#include "Log.h"
+
+AFP_RETURN CheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen,fsl_osal_u32 nHeadSize,IsValidHeader fpIsValidHeader)
+{
+    AFP_RETURN ret = AFP_SUCCESS;
+
+    fsl_osal_u32 nOffset = 0;
+    fsl_osal_u32 nFrameOffset = 0;
+    fsl_osal_u32 nFirstFrameSize = 0;
+    fsl_osal_u32 nHeaderCount = 0;
+    FRAME_INFO Info;
+    fsl_osal_u8* pHeader = NULL;
+
+    if(!pFrameInfo || !pBuffer){
+        return AFP_FAILED;
+    }
+
+    fsl_osal_memset(pFrameInfo, 0, sizeof(pFrameInfo));
+
+    pFrameInfo->bGotOneFrame = E_FSL_OSAL_FALSE;
+    pFrameInfo->nHeaderCount = 0;
+    pFrameInfo->nConsumedOffset = 0;
+    pFrameInfo->nFrameSize = 0;
+    pFrameInfo->nBitRate = 0;
+    pFrameInfo->nSamplesPerFrame = 0;
+
+    fsl_osal_memset(&Info, 0x0, sizeof(FRAME_INFO));
+    LOG_LOG("CheckFrame start nBufferLen=%d",nBufferLen);
+
+    while(nOffset + nHeadSize <= nBufferLen){
+
+        pHeader = pBuffer + nOffset;
+
+        if(!fpIsValidHeader(pHeader,&Info)){
+            nOffset++;
+            continue;
+        }
+        //check the frame size
+        if(0 == Info.frm_size){
+            nOffset++;
+            continue;
+        }
+
+        nHeaderCount ++;
+        nFrameOffset = nOffset;
+        nFirstFrameSize = Info.frm_size;
+        LOG_LOG("CheckFrame nOffset=%d,frm_size=%d",nOffset,Info.frm_size);
+        if(Info.frm_size + nOffset + nHeadSize < nBufferLen){
+            nOffset += Info.frm_size;
+        }else{
+            nOffset++;
+            continue;
+        }
+
+        pHeader = pBuffer + nOffset;
+
+        if(fpIsValidHeader(pHeader,&Info)){
+            pFrameInfo->bGotOneFrame = E_FSL_OSAL_TRUE;
+            nHeaderCount ++;
+            break;
+        }else{
+            nHeaderCount --;
+            nOffset = nFrameOffset+1;
+            continue;
+        }
+    }
+
+    if(nFirstFrameSize > nHeadSize){
+        pFrameInfo->nFrameSize = nFirstFrameSize;
+    }else{
+        pFrameInfo->nFrameSize = 0;
+    }
+
+    if(nHeaderCount > 0){
+        pFrameInfo->nConsumedOffset = nFrameOffset;
+    }else{
+        pFrameInfo->nConsumedOffset = nBufferLen;
+        pFrameInfo->nFrameSize = 0;
+    }
+
+    pFrameInfo->nBitRate = Info.b_rate;
+    pFrameInfo->nSamplesPerFrame = Info.sample_per_fr;
+    pFrameInfo->nSamplingRate = Info.sampling_rate;
+    pFrameInfo->nChannels = Info.channels;
+    pFrameInfo->nHeaderCount = nHeaderCount;
+    LOG_DEBUG("CheckFrame parse one frame,bGotOneFrame=%d,nFrameCount=%d,nConsumedOffset=%d,nFrameSize=%d,\
+samplerate=%d,bitrate=%d,channel=%d,samplePerFrame=%d",
+        pFrameInfo->bGotOneFrame,
+        pFrameInfo->nHeaderCount,
+        pFrameInfo->nConsumedOffset,
+        pFrameInfo->nFrameSize,
+        pFrameInfo->nSamplingRate,
+        pFrameInfo->nBitRate,
+        pFrameInfo->nChannels,
+        pFrameInfo->nSamplesPerFrame
+    );
+
+    return ret;
+}
diff --git a/utils/audio_frame_parser/AudioFrameParser.h b/utils/audio_frame_parser/AudioFrameParser.h
new file mode 100755
index 0000000..eb8c4b8
--- /dev/null
+++ b/utils/audio_frame_parser/AudioFrameParser.h
@@ -0,0 +1,55 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductors Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef AudioFrameParser_h
+#define AudioFrameParser_h
+
+#include "fsl_osal.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//audio frame parser return value
+#define AFP_RETURN fsl_osal_s32
+#define AFP_SUCCESS 0
+#define AFP_FAILED  1
+
+//audio frame information
+typedef struct AUDIO_FRAME_INFO {
+    efsl_osal_bool bGotOneFrame;//true when get one frame and next frame's header
+    fsl_osal_u32 nHeaderCount;
+    fsl_osal_u32 nConsumedOffset;//frame header offset if get one frame
+    fsl_osal_u32 nFrameSize;//frame size
+    fsl_osal_u32 nBitRate;
+    fsl_osal_u32 nSamplesPerFrame;
+    fsl_osal_u32 nSamplingRate;
+    fsl_osal_u32 nChannels;
+} AUDIO_FRAME_INFO;
+
+typedef struct FRAME_INFO
+{
+    fsl_osal_u32 frm_size;
+    fsl_osal_u32 b_rate;
+    fsl_osal_u32 sampling_rate;
+    fsl_osal_u32 sample_per_fr;
+    fsl_osal_u32 layer;
+    fsl_osal_u32 version;
+    fsl_osal_u32 channels;
+}FRAME_INFO;
+
+typedef efsl_osal_bool (*IsValidHeader)(fsl_osal_u8 * pHeader,FRAME_INFO * Info);
+
+AFP_RETURN CheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen,fsl_osal_u32 nHeadSize,IsValidHeader fpIsValidHeader);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//AudioFrameParser_h
diff --git a/utils/audio_frame_parser/Mp3FrameParser.c b/utils/audio_frame_parser/Mp3FrameParser.c
new file mode 100755
index 0000000..51d6b11
--- /dev/null
+++ b/utils/audio_frame_parser/Mp3FrameParser.c
@@ -0,0 +1,142 @@
+/**
+ *  Copyright (c) 2010-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#include "Mp3FrameParser.h"
+//bit rate table
+fsl_osal_s16 mp3_bit_rate[16][6]= {
+    /* bitrate in Kbps
+    * MPEG-1 layer 1, 2, 3; MPEG-2 layer 1,2,3; MPEG-2.5 layer 1,2,3
+    */
+    {0,      0,	    0, 	    0,	    0,	    0},
+    {32,     32,	    32,	    32,	    8,	    8},
+    {64,	    48,	    40,	    48,	    16,	    16},
+    {96,	    56,	    48,	    56,	    24,	    24},
+    {128,    64,	    56,	    64,	    32,	    32},
+    {160,    80,	    64, 	80,	    40,	    40},
+    {192,	96,	    80, 	96,	    48,	    48},
+    {224,	112,	96,	    112,	56,	    56},
+    {256,	128,	112,	128,	64,	    64},
+    {288,	160,	128,	144,	80,	    80},
+    {320,	192,	160,	160,	96,	    96},
+    {352,	224,	192,	176,	112,	112},
+    {384,	256,	224,    192,	128,	128},
+    {416,	320,	256,    224,	144,	144},
+    {448,	384,	320,    256,	160,	160},
+    {999,	999,	999,    999,	999,	999}
+};
+
+//sampling rate table
+fsl_osal_u32 mp3_sampling_rate[4][3] = {
+    {44100, 22050, 11025},
+    {48000, 24000, 12000},
+    {32000, 16000, 8000},
+    {99999, 99999, 99999}
+};
+
+//sample per frame table
+fsl_osal_u32 mp3_sample_per_frame[3][3] = {
+    {384,   384,       84},
+    {1152,  1152,   1152},
+    {1152,  576,    576}
+};
+static efsl_osal_bool IsMP3FrameHeader(fsl_osal_u8 * pHeader,FRAME_INFO * Info)
+{
+    fsl_osal_s32 mpeg_version;
+    fsl_osal_s32 layer;
+    fsl_osal_s32 bit_rate_index;
+    fsl_osal_s32 bit_rate;
+    fsl_osal_s32 sampling_frequency;
+    fsl_osal_s32 sampling_frequency_index;
+    fsl_osal_s32 padding;
+    fsl_osal_s32 private_bit;
+    fsl_osal_s32 channel_mode;
+    fsl_osal_s32 frame_size;
+    fsl_osal_s32 channel_num;
+    fsl_osal_s32 has_crc = 0;
+
+    if(pHeader == NULL || Info == NULL)
+        return E_FSL_OSAL_FALSE;
+
+    if(pHeader[0] !=0xFF || (pHeader[1] & 0xE0) != 0xE0)
+        return E_FSL_OSAL_FALSE;
+
+    mpeg_version = ((fsl_osal_s32)pHeader[1]&0x18)>>3;
+
+    if(mpeg_version == 3){
+        mpeg_version = 0;  /* mpeg ver 1 */
+    }else if(mpeg_version == 2){
+        mpeg_version = 1;  /* mpeg ver 2 */
+    }
+    else if(mpeg_version == 0){
+        mpeg_version = 2;  /* mpeg ver 2.5 */
+    }
+
+    layer  = 4 - (((fsl_osal_s32)pHeader[1]&0x06)>>1);
+
+    if (( 3!= layer) && (2 != layer) && (1 != layer))  {
+        return E_FSL_OSAL_FALSE;
+    }
+
+    Info->version = mpeg_version;
+    Info->layer = layer;
+
+    /* has crc ? */
+    has_crc = !(((fsl_osal_u8) pHeader[1]) & 0x01);
+
+    bit_rate_index = ((fsl_osal_s32)pHeader[2]&0xF0)>>4;
+
+    if(mpeg_version == 0)
+        bit_rate = mp3_bit_rate[bit_rate_index][mpeg_version+layer-1];
+    else
+        bit_rate = mp3_bit_rate[bit_rate_index][3+layer-1];
+
+    Info->b_rate = bit_rate;
+
+    if (bit_rate > 448 || bit_rate == 0)
+    {
+        return E_FSL_OSAL_FALSE;
+    }
+
+    sampling_frequency_index =((fsl_osal_s32)pHeader[2]&0x0C)>>2;
+    sampling_frequency  = mp3_sampling_rate[sampling_frequency_index][mpeg_version];
+
+    Info->sampling_rate = sampling_frequency;
+    Info->sample_per_fr = mp3_sample_per_frame[layer-1][mpeg_version];
+
+    padding = ((fsl_osal_s32)pHeader[2]&0x02)>>1;
+
+    private_bit = ((fsl_osal_s32)pHeader[2]&0x01);
+
+    channel_mode = ((fsl_osal_s32)pHeader[3]&0xC0)>>6;
+
+    if(layer ==1)
+        frame_size = (fsl_osal_s32)((12*bit_rate*1000)/sampling_frequency+ padding)*4;
+    else
+        frame_size = (fsl_osal_s32)((Info->sample_per_fr/8*bit_rate*1000)/sampling_frequency)+ padding;
+
+    Info->frm_size = frame_size ;
+
+    if (3 == channel_mode)
+    {
+        channel_num = 1;
+    }
+    else
+    {
+        channel_num = 2;
+    }
+
+    Info->channels = channel_num;
+
+    return E_FSL_OSAL_TRUE;
+}
+
+AFP_RETURN Mp3CheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen)
+{
+    return CheckFrame(pFrameInfo,pBuffer,nBufferLen,MP3_FRAME_HEAD_SIZE,IsMP3FrameHeader);
+}
\ No newline at end of file
diff --git a/utils/audio_frame_parser/Mp3FrameParser.h b/utils/audio_frame_parser/Mp3FrameParser.h
new file mode 100755
index 0000000..9c2c177
--- /dev/null
+++ b/utils/audio_frame_parser/Mp3FrameParser.h
@@ -0,0 +1,28 @@
+/**
+ *  Copyright (c) 2009-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductors Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+#ifndef Mp3FrameParser_h
+#define Mp3FrameParser_h
+
+#include "AudioFrameParser.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MP3_FRAME_HEAD_SIZE  4
+
+//check frame function
+AFP_RETURN Mp3CheckFrame(AUDIO_FRAME_INFO *pFrameInfo, fsl_osal_u8 *pBuffer, fsl_osal_u32 nBufferLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif//AudioFrameParser_h
diff --git a/utils/colorconvert/include/cc16Wrapper.h b/utils/colorconvert/include/cc16Wrapper.h
new file mode 100755
index 0000000..c3b8f63
--- /dev/null
+++ b/utils/colorconvert/include/cc16Wrapper.h
@@ -0,0 +1,37 @@
+/**
+ *  Copyright (c) 2011, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/**
+ *  @file cc16Wrapper.h
+ *  @brief 
+ *  @ingroup 
+ */
+
+#ifndef CC16WRAPPER_h
+#define CC16WRAPPER_h
+
+#include "OMX_Types.h"
+#include "OMX_IVCommon.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+void * cc16WrapperCreate(void);
+OMX_S32 cc16WrapperInit(void * pWrapper, OMX_S32 Src_width, OMX_S32 Src_height, OMX_S32 Src_pitch, OMX_CONFIG_RECTTYPE *Src_crop, OMX_COLOR_FORMATTYPE Src_colorFormat, OMX_S32 Dst_width, OMX_S32 Dst_height, OMX_S32 Dst_pitch, OMX_S32 nRotation);
+OMX_S32 cc16WrapperSetMode(void *pWrapper, OMX_S32 nMode); //nMode : 0 Off, 1 On
+OMX_S32 cc16WrapperConvert(void *pWrapper, OMX_U8*srcBuf, OMX_U8 *destBuf);
+void cc16WrapperDelete(void **pWrapper);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/utils/colorconvert/include/cczoomrotation16.h b/utils/colorconvert/include/cczoomrotation16.h
new file mode 100755
index 0000000..1bcdb21
--- /dev/null
+++ b/utils/colorconvert/include/cczoomrotation16.h
@@ -0,0 +1,70 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+/* -------------------------------------------------------------------
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ * -------------------------------------------------------------------
+ */
+
+#ifndef CCZOOMROTATION16_H_INCLUDED
+#define CCZOOMROTATION16_H_INCLUDED
+
+#include "fsl_osal.h"
+
+#ifndef CCZOOMROTATIONBASE_H_INCLUDED
+#include "cczoomrotationbase.h"
+#endif
+
+/**
+*   This class is for 16 bit color conversion. The APIs usage is the same as
+*   ColorConvertBase. The output format for RGB is 5-6-5 bits.
+*/
+
+class ColorConvert16: public ColorConvertBase
+{
+    public:
+
+        static ColorConvertBase* NewL(void);
+        virtual ~ColorConvert16();
+        int32 Init(int32 Src_width, int32 Src_height, int32 Src_pitch, RECTTYPE *Src_crop, OMX_COLOR_FORMATTYPE srcColorFormat, int32 Dst_width, int32 Dst_height, int32 Dst_pitch, int32 nRotation = 0);
+        int32 SetYuvFullRange(bool range);
+        int32 SetMode(int32 nMode); //nMode : 0 Off, 1 On
+        int32 Convert(uint8 *srcBuf, uint8 *destBuf);
+        int32 Convert(uint8 **srcBuf, uint8 *destBuf);
+        int32 GetOutputBufferSize(void);
+        ColorConvert16();
+
+
+    private:
+
+        uint32 mCoefTbl32[516];
+        uint8 *mCoefTbl;
+        int32 get_frame16(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *COFF_TBL);
+
+        int32 cc16Rotate(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *COFF_TBL);
+        int32 cc16ZoomIn(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *COFF_TBL);
+        int32 cc16ZoomRotate(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *COFF_TBL);
+
+    private:
+        int32(ColorConvert16::*mPtrYUV2RGB)(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *COFF_TBL);
+};
+
+
+
+
+#endif // CCZOOMROTATION16_H_INCLUDED
diff --git a/utils/colorconvert/include/cczoomrotationbase.h b/utils/colorconvert/include/cczoomrotationbase.h
new file mode 100755
index 0000000..16833e5
--- /dev/null
+++ b/utils/colorconvert/include/cczoomrotationbase.h
@@ -0,0 +1,242 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+/* -------------------------------------------------------------------
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ * -------------------------------------------------------------------
+ */
+ 
+#ifndef CCZOOMROTATIONBASE_H_INCLUDED
+#define CCZOOMROTATIONBASE_H_INCLUDED
+
+#include "OMX_Types.h"
+#include "OMX_IVCommon.h"
+
+#ifndef int32
+#define  int32 OMX_S32
+#endif
+
+#ifndef int16
+#define  int16 OMX_S16 
+#endif
+
+#ifndef int8
+#define  int8 OMX_S8 
+#endif
+
+#ifndef uint16
+#define uint16 OMX_U16
+#endif
+
+#ifndef uint32
+#define uint32 OMX_U32
+#endif
+
+#ifndef uint8
+#define uint8 OMX_U8
+#endif
+
+
+#ifndef COLORCONV_CONFIG_H_INCLUDED
+#include "colorconv_config.h"
+#endif
+
+/* add capability support */
+#define  CCSUPPORT_ROTATION     0x1
+#define  CCSUPPORT_SCALING      0x2
+
+/* rotation orientation, values for nRotation */
+#define CCROTATE_NONE            0
+#define CCROTATE_CNTRCLKWISE     1
+#define CCROTATE_180             2
+#define CCROTATE_CLKWISE         3
+#define CCFLIP                   4
+#define CCBOTTOM_UP              8
+
+typedef struct _RECTTYPE {
+    int nLeft; 
+    int nTop;
+    int nWidth;
+    int nHeight;
+} RECTTYPE;
+
+/**
+*   Description - This is the base class of color converter classes.
+*   Each of the 3 libraries needs to include this class in the project.
+*
+*   ASSUMPTIONS:
+*   1. zoom ratio must be no greater than 3
+*   2. cannot do zoom in in one dimenstion and zoom out in another
+*   3. caller should take care of the aspect ratio control
+*   4. if there are margins, the caller should paint the background to the desired color
+*   5. all the starting address MUST be multiple of 4, which is normally the case.
+*   4. the dest pitch MUST be multiple of 4
+*
+*/
+// Definition of ColorConvertBase class
+
+class ColorConvertBase
+{
+    public:
+
+        //! Constructor
+        ColorConvertBase();
+
+        //! Destructor
+        virtual ~ColorConvertBase();
+
+        /**
+        *   @brief  This function returns a value indicate the capability of the library at run-time.
+        *   @return It returns one of or a union of CCSUPPORT_ROTATION and CCSUPPORT_SCALING
+        */
+        virtual int16 GetCapability(void);
+
+        /**
+        *   @brief The function initializes necessary lookup tables and verify the capability of the library before starting the operation.
+        *   @param Src_width specifies the width in pixel from the source to be color converted.
+        *   @param Src_height specifies the height in pixel from the source to be color converted.
+        *   @param Src_pitch is the actual memory width or stride of the source.
+        *   @param Dst_width specifies the width in pixel of the output.
+        *   @param Dst_height specifies the height in pixel of the output.
+        *   @param Dst_pitch is the stride size of the destination memory.
+        *   @param nRotation specifies whether rotation is to be applied. The value can be one of the followings
+        *   CCROTATE_NONE (0), CCROTATE_CNTRCLKWISE (1) or CCROTATE_CLKWISE (3).
+        *   When rotation is chosen, the Dst_width and Dst_height is still relative to the source coordinate,
+        *   i.e., to rotate a QCIF image, the output width will be 144 and height will be 176.
+        *   @return It returns 1 if success, 0 if fail, i.e., rotation or scaling not supported or
+        *   any of the above parameters is an odd number.
+        */
+
+        virtual int32 Init(int32 Src_width, int32 Src_height, int32 Src_pitch, RECTTYPE *Src_crop, OMX_COLOR_FORMATTYPE srcColorFormat, int32 Dst_width, int32 Dst_height, int32 Dst_pitch, int32 nRotation = 0);
+
+        /**
+        *   @brief This function specifies the height of the Y plane which may be larger
+        *   than the height of the displayed region. For example, the output from PVM4Vdec
+        *   always has width and height to be multiple of 16 pixels but the actual size may be not.
+        *   In this case, users will set the src_width and src_height to the actual size,
+        *   but set the src_pitch and SetMemHeight to the allocated Y plane size.
+        *   For WMV, the Y plane output from WMV decoder has the exact dimension (no padding
+        *   for multiple of 16).
+        */
+        virtual void SetMemHeight(int32 a_mHeight)
+        {
+            _mSrc_mheight = a_mHeight;
+        };
+
+        /**
+        *   @brief This function specifies whether the output will use the attribute specified
+        *   in the Init(.) function or perform regular color conversion without scaling or rotation.
+        *   @param nMode When set to 0, 1-to-1 color conversion only is done. When NMode is 1,
+        *   the output is be of the size and orientation specified in Init().
+        *   @return 0 if fails (capability not supported or not initialized), 1 if success.
+        */
+        virtual int32 SetMode(int32 nMode) = 0; //nMode : 0 Off, 1 On
+
+        /**
+        *   @brief These functions convert the input buffer data into the output format
+        *   and write the converted data to the output buffer.
+        *   @param srcBuf is a pointer to the Y plane assuming that the U and V planes are contiguous to the Y plane.
+        *   @param destBuf is a pointer to an output buffer.
+        *   @return This function return 1 if success, 0 if fail.in the case of the destBuf
+        *   and/or srcBuf address are not word-aligned (multiple of 4).
+        */
+
+        virtual int32 Convert(uint8 *srcBuf, uint8 *destBuf) = 0;
+
+        /**
+        *   @brief This function returns the size of output buffer that users need
+        *   to allocate and pass it in as an input argument to Convert() function.
+        *   Depending on the input argument to SetMode(), the buffer size can change.
+        *   Furthermore, the color conversion library MAY REQUIRE BUFFER TO BE LARGER
+        *   THAN what users EXPECT for extra processing space.
+        *   @return An integer specifying the size of the output buffer.
+        */
+        virtual int32 GetOutputBufferSize(void) = 0;
+
+        /**
+        *   @brief This function allows the destination pitch to be set at run-time,
+        *   e.g., switching between zoom & nonZoom mode.
+        *   @return 1.
+        */
+        int32 SetDstPitch(int32 iDstPitch)
+        {
+            _mDisp.dst_pitch = iDstPitch;
+            return 1;
+        };
+
+
+        /**
+        *   @brief This function specifies the range of the YCbCr input such that the
+        *   conversion to RGB is done accordingly (see ISO/IEC 14496-2:2004/FPDAM 3)..
+        *   @param range  a boolean, false or zero means the range of the Y is 16-235,
+        *   true or one means the full range of 0-255 is used. The default range is false.
+        */
+
+        virtual int32  SetYuvFullRange(bool range) = 0;
+
+    protected:
+
+        /** Internal structure for display property. This structure contains all configuration related
+        *   parameters thus unifying the interface to variations of color convert functions
+        */
+        typedef struct
+        {
+            /** @brief Pitch of the input buffer (in pixel) */
+            int32 src_pitch;
+            /** @brief Pitch of the output buffer (in pixel) */
+            int32 dst_pitch;
+            /** @brief Width of the content of the input (in pixel) */
+            int32 src_width;
+            /** @brief Height of the content of the input (in pixel) */
+            int32 src_height;
+            /** @brief Width of the desired output (in pixel) */
+            int32 dst_width;
+            /** @brief Height of the desired output (in pixel) */
+            int32 dst_height;
+            int32 src_crop_left;
+            int32 src_crop_top;
+            int32 src_crop_width;
+            int32 src_crop_height;
+        } DisplayProperties ;
+        DisplayProperties _mDisp;
+
+        uint32 _mSrc_width, _mSrc_height, _mSrc_mheight, _mSrc_pitch, _mDst_width, _mDst_height, _mDst_pitch, _mRotation;
+        int32 _mSrc_crop_left, _mSrc_crop_top, _mSrc_crop_width, _mSrc_crop_height;
+        uint8 *_mRowPix, *_mColPix;
+
+        bool _mInitialized; // initialized yet?
+        bool _mIsZoom;  //Is zoomable?
+        int32 _mState;  //Zoom? Rotation? etc
+        bool _mIsFlip;
+        bool _mYuvRange;
+        OMX_COLOR_FORMATTYPE _mColorFormat;
+
+    private:
+        /**
+        *   @brief This function calculates the number of repetitions for each input pixel to output
+        *   pixel such that the total output size is as specified. Users have to call this function
+        *   twice, one for horizontal scaling and one for vertical scaling.
+        *   @param  pLinePix is a pointer to an array of number of repetition (zero-order interpolation).
+        *   @param  iSrcLen is the input size.
+        *   @param  iDstLen is the output size.
+        */
+        void StretchLine(uint8 *pLinePix, int32 iSrcLen, int32 iDstLen);
+
+};
+#endif // CCZOOMROTATIONBASE_H_INCLUDED
+
diff --git a/utils/colorconvert/include/colorconv_config.h b/utils/colorconvert/include/colorconv_config.h
new file mode 100755
index 0000000..794b9bd
--- /dev/null
+++ b/utils/colorconvert/include/colorconv_config.h
@@ -0,0 +1,60 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+/* -------------------------------------------------------------------
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ * -------------------------------------------------------------------
+ */
+
+#ifndef COLORCONV_CONFIG_H_INCLUDED
+#define COLORCONV_CONFIG_H_INCLUDED
+
+/** For scaling support, define CCSCALING to 1, else set it to 0 */
+#define CCSCALING 1
+
+/** For rotation support, define CCROTATE to 1, else set it to 0  */
+#define CCROTATE 1
+
+/** To specify RGB format. define RGB_FORMAT to 1. For, BGR format, set it to 0 */
+#define RGB_FORMAT  0
+
+/********************************************************************************************
+ For YUV422 to YUV420 conversion, the Input YUV422 data can be in three forms:-
+    ENDIAN_1 :
+        Cb1 Y1 Cr1 Y2 Cb2 Y3 Cr2 Y4 .....
+
+    ENDIAN_2 :
+        Y2 Cr1 Y1 Cb1 Y4 Cr2 Y3 Cb2 ....
+
+    ENDIAN_3 :
+        Y1 Cr1 Y2 Cb1 Y3 Cr2 Y4 Cb2 ....
+
+*********************************************************************************************/
+/* Set one of the following to 1  depending on your requirement */
+#ifdef SHOLES_PROPERTY_OVERRIDES
+#define ENDIAN_1 1
+#define ENDIAN_2 0
+#else
+#define ENDIAN_1 0
+#define ENDIAN_2 1
+#endif
+#define ENDIAN_3 0
+
+#endif // COLORCONV_CONFIG_H_INCLUDED
+
+
diff --git a/utils/colorconvert/src/cczoomrotation16.cpp b/utils/colorconvert/src/cczoomrotation16.cpp
new file mode 100755
index 0000000..24fc4b9
--- /dev/null
+++ b/utils/colorconvert/src/cczoomrotation16.cpp
@@ -0,0 +1,6186 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+/* -------------------------------------------------------------------
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ * -------------------------------------------------------------------
+ */
+
+/** Class ColorConvert16, convert YUV to RGB16 in 5-6-5 format. */
+
+#include "Mem.h"
+#include "assert.h"
+#include "string.h"
+
+#include "colorconv_config.h"
+#include "cczoomrotation16.h"
+#include "cc16Wrapper.h"
+#include "Log.h"
+
+#define pvcc_abs(x) ((x)>0? (x): -(x))
+
+#define DITHER_ON
+#ifdef DITHER_ON
+
+#define OFFSET_5_0  2
+#define OFFSET_6_0  (1+1024)
+#define OFFSET_5_1  6
+#define OFFSET_6_1  (3+1024)
+
+#else  //for the rounding case (no dither)
+
+#define OFFSET_5_0  0 // Set to zero for performance4
+#define OFFSET_6_0  (0+1024) //(2+1024)
+#define OFFSET_5_1  0 //4
+#define OFFSET_6_1  (0+1024) //(2+1024)
+
+#endif
+
+ ColorConvertBase* ColorConvert16::NewL(void)
+{
+    ColorConvert16* self = FSL_NEW(ColorConvert16, ());
+    return (ColorConvertBase*) self;
+}
+
+
+ColorConvert16::ColorConvert16()
+{
+    mCoefTbl = (uint8*)mCoefTbl32;
+}
+
+
+ ColorConvert16::~ColorConvert16()
+{
+}
+
+
+int32 ColorConvert16::Init(int32 Src_width, int32 Src_height, int32 Src_pitch, RECTTYPE *Src_crop, OMX_COLOR_FORMATTYPE srcColorFormat, int32 Dst_width, int32 Dst_height, int32 Dst_pitch, int32 nRotation)
+{
+    //nRotation = 1;
+    //Dst_pitch = Dst_width = Src_height;
+    //Dst_height = Src_width;
+
+    LOG_DEBUG("ColorConvert16::Init() %d/%d/%d/%d = > %d/%d/%d/%d\n",
+            Src_width, Src_height, Src_pitch, srcColorFormat, Dst_width, Dst_height, Dst_pitch, nRotation);
+
+    if (ColorConvertBase::Init(Src_width, Src_height, Src_pitch, Src_crop, srcColorFormat, Dst_width, Dst_height, Dst_pitch, nRotation) == 0)
+    {
+        return 0;
+    }
+
+    _mInitialized = false;
+
+    if ((nRotation&1) == 0) // check for either shrinking or zooming both horz and vert. No combination..
+    {
+        if ((Src_width > Dst_width && Src_height < Dst_height) ||
+                (Src_width < Dst_width && Src_height > Dst_height))
+        {
+            return 0;
+        }
+    }
+    else
+    {
+        if ((Src_width > Dst_height && Src_height < Dst_width) ||
+                (Src_width < Dst_height && Src_height > Dst_width))
+        {
+            return 0;
+        }
+    }
+
+    _mInitialized = true;
+
+    // set default
+    SetYuvFullRange(false);
+    SetMode(0);
+
+    return 1;
+}
+
+
+int32  ColorConvert16::SetYuvFullRange(bool range)
+{
+    uint8 *clip;
+    int32 tmp, i;
+
+    assert(_mInitialized == true);
+
+    _mYuvRange = range;
+
+    //local init
+    if (_mYuvRange == false) // default Yuv range from 16-235, BT.709
+    {
+        *((uint32*)mCoefTbl) = 0x0000b2ce; //65536*0.813/1.164;  // 0.533
+        *((uint32*)(mCoefTbl + 4)) =  0x00015f03; //65536*1.596/1.164; // 1.793
+        *((uint32*)(mCoefTbl + 8)) =  0x000055fe; //65536*0.391/1.164; // 0.213
+        *((uint32*)(mCoefTbl + 12)) =  0x0001bbd2; //65536*2.018/1.164; // 2.112
+
+        clip = mCoefTbl + 400;
+        /* do 5 bit conversion */
+
+        memset(&clip[-384], 0, 401*sizeof(*clip));
+        memset(&clip[ 640], 0, 401*sizeof(*clip));
+
+        for (i = 17; i < 236; i++)
+        {                       // range of (x>>3) between -24 and 56
+            tmp = (int32)(1.164 * (i - 16));   // clip[1.164*((x>>3) - (16>>3))]
+            clip[i] = (uint8)(tmp >> 3);
+            clip[i+1024] = (uint8)(tmp >> 2);
+        }
+
+        memset(&clip[236], 31, 404*sizeof(*clip));
+        memset(&clip[1260], 63, 404*sizeof(*clip));
+
+    }
+    else  // full range 0-255
+    {
+        *((uint32*)mCoefTbl) = (int)(65536 * 0.4681); //0.714);
+        *((uint32*)(mCoefTbl + 4)) = (int)(65536 * 1.5748);//1.402);
+        *((uint32*)(mCoefTbl + 8)) = (int)(65536 * 0.1873);//0.344);
+        *((uint32*)(mCoefTbl + 12)) = (int)(65536 * 1.8556);//1.772);
+
+        clip = mCoefTbl + 400;
+        /* do 5 bit conversion */
+        memset(&clip[-384], 0, 385*sizeof(*clip));
+        memset(&clip[ 640], 0, 385*sizeof(*clip));
+
+        for (i = 1; i < 255; i++)   // range of (x>>3) between -24 and 56
+        {
+            clip[i] = i >> 3;
+            clip[i+1024] = i >> 2;
+        }
+        memset(&clip[255], 31, 385*sizeof(*clip));
+        memset(&clip[1279], 63, 385*sizeof(*clip));
+    }
+
+    return 1; // success
+}
+
+
+int32 ColorConvert16::SetMode(int32 nMode)  //nMode : 0 Off, 1 On
+{
+    assert(_mInitialized == true);
+
+    if (nMode == 0)
+    {
+        //      mPtrYUV2RGB = cc16Rotate;
+        //      _mState     = 1;
+        mPtrYUV2RGB =   &ColorConvert16::get_frame16;
+        _mState     =   0;
+        _mDisp.src_pitch = _mSrc_pitch  ;
+        _mDisp.dst_pitch = _mDst_pitch  ;
+        _mDisp.src_width = _mSrc_width  ;
+        _mDisp.src_height = _mSrc_height ;
+        _mDisp.dst_width = _mSrc_width  ;
+        _mDisp.dst_height = _mSrc_height ;
+    }
+    else
+    {
+        if (_mIsZoom)
+        {
+            if (_mRotation&0x1) /* zoom and rotate */
+            {
+                mPtrYUV2RGB = &ColorConvert16::cc16ZoomRotate;
+            }
+            else /* zoom only */
+            {
+                mPtrYUV2RGB =   &ColorConvert16::cc16ZoomIn;
+            }
+        }
+        else
+        {
+            if (_mRotation&0x1) /* rotate only*/
+            {
+                mPtrYUV2RGB = &ColorConvert16::cc16Rotate;
+            }
+            else /* no zoom, no rotate, SetMode(1) = SetMode(0) */
+            {
+                mPtrYUV2RGB =   &ColorConvert16::get_frame16;
+            }
+        }
+        _mState     =   nMode;
+        _mDisp.src_pitch = _mSrc_pitch  ;
+        _mDisp.dst_pitch = _mDst_pitch  ;
+        _mDisp.src_width = _mSrc_width  ;
+        _mDisp.src_height = _mSrc_height ;
+        _mDisp.dst_width = _mDst_width  ;
+        _mDisp.dst_height = _mDst_height ;
+    }
+
+    return 1;
+}
+
+
+int32 ColorConvert16::GetOutputBufferSize(void)
+{
+    assert(_mInitialized == true);
+
+    return  _mState ? (_mDst_height*_mDst_pitch*2) : (_mSrc_width*_mSrc_height*2);
+}
+
+
+int32 ColorConvert16::Convert(uint8 **yuvBuf, uint8 *rgbBuf)
+{
+    assert(_mInitialized == true);
+    assert(yuvBuf);
+    assert(yuvBuf[0]);
+    assert(yuvBuf[1]);
+    assert(yuvBuf[2]);
+    assert(rgbBuf);
+
+    if (((uint32)rgbBuf)&0x3 || ((uint32)yuvBuf[0])&0x3) /* address is not word align */
+    {
+        return 0;
+    }
+
+    (*this.*mPtrYUV2RGB)(yuvBuf, rgbBuf, &_mDisp, (uint8 *)mCoefTbl);
+
+    return 1;
+}
+
+
+int32 ColorConvert16::Convert(uint8 *yuvBuf, uint8 *rgbBuf)
+{
+    //this conversion will cause problems when do src clipping. However, if they want, they must give more info
+    uint8 *TmpYuvBuf[3];
+
+    assert(_mInitialized == true);
+    assert(yuvBuf);
+    assert(rgbBuf);
+
+    if (((uint32)rgbBuf)&0x3 || ((uint32)yuvBuf)&0x3) /* address is not word align */
+    {
+        return 0;
+    }
+
+    TmpYuvBuf[0]    =   yuvBuf;
+    TmpYuvBuf[1]    =   yuvBuf + (_mSrc_pitch) * (_mSrc_mheight);
+
+    if(_mColorFormat == OMX_COLOR_FormatYUV420Planar)
+        TmpYuvBuf[2]    =   TmpYuvBuf[1] + (_mSrc_pitch * _mSrc_mheight) / 4;
+    else if(_mColorFormat == OMX_COLOR_FormatYUV422Planar)
+        TmpYuvBuf[2]    =   TmpYuvBuf[1] + (_mSrc_pitch * _mSrc_mheight) / 2;
+    else if(_mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+        TmpYuvBuf[2] = TmpYuvBuf[1] + 1;
+    else if(_mColorFormat == OMX_COLOR_FormatYUV422SemiPlanar)
+        TmpYuvBuf[2] = TmpYuvBuf[1] + 1;
+
+    (*this.*mPtrYUV2RGB)(TmpYuvBuf, rgbBuf, &_mDisp, (uint8 *)mCoefTbl);
+
+    return 1;
+}
+
+
+int32 cc16(uint8 **src, uint8 *dst, int32 *disp_prop, uint8 *coeff_tbl, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16Reverse(uint8 **src, uint8 *dst, int32 *disp_prop, uint8 *coeff_tbl);
+
+int32 ColorConvert16::get_frame16(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *coff_tbl)
+{
+    int32 disp_prop[12];
+
+    disp_prop[0] = disp->src_pitch;
+    disp_prop[1] = disp->dst_pitch;
+    disp_prop[2] = disp->src_width;
+    disp_prop[3] = disp->src_height;
+    disp_prop[4] = disp->dst_width;
+    disp_prop[5] = disp->dst_height;
+    disp_prop[6] = (_mRotation > 0 ? 1 : 0);
+    disp_prop[7] = _mIsFlip;
+    disp_prop[8] = disp->src_crop_left;
+    disp_prop[9] = disp->src_crop_top;
+    disp_prop[10] = disp->src_crop_width;
+    disp_prop[11] = disp->src_crop_height;
+	
+
+    if (disp_prop[6] ^ disp_prop[7])    /* flip and rotate 180*/
+    {
+        return cc16Reverse(src, dst, disp_prop, coff_tbl);
+    }
+    else
+    {
+        return cc16(src, dst, disp_prop, coff_tbl, _mColorFormat);
+    }
+}
+
+int32 cc16(uint8 **src, uint8 *dst, int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat)
+{
+
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaDst, deltaCbCr;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+    int32 crop_left, crop_top, crop_width, crop_height;
+    int32 src_height;
+	
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+    src_height = disp[3];
+    crop_left = disp[8];
+    crop_top = disp[9];
+    crop_width = disp[10];
+    crop_height = disp[11];
+	
+
+    if (disp[6]) /* rotate 180 and flip */
+    {   /* move the starting point to the bottom-left corner of the picture */
+        deltaY = src_pitch * (disp[3] - 1);
+        pY = (uint16*)(src[0] + deltaY);
+        deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+        pCb = src[1] + deltaY;
+        pCr = src[2] + deltaY;
+        deltaY = -src_width - (src_pitch << 1);
+        deltaCbCr = -((src_width + src_pitch) >> 1);
+        src_pitch = -(src_pitch >> 1);
+    }
+    else
+    {
+		deltaY      = (src_pitch << 1) - crop_width;
+		if(colorFormat == OMX_COLOR_FormatYUV422Planar)
+			deltaCbCr = ((src_pitch << 1) - crop_width) >> 1;
+		else if(colorFormat == OMX_COLOR_FormatYUV422SemiPlanar) 
+			deltaCbCr   = (src_pitch << 1) - crop_width;
+		else if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar) 
+			deltaCbCr   = src_pitch - crop_width;
+		else
+			deltaCbCr   = (src_pitch - crop_width) >> 1;
+		pY = (uint16 *)(src[0] + crop_top * src_pitch);
+		pCb = src[1] + ((crop_top >> 1) * (src_pitch >> 1));
+		pCr = src[2] + ((crop_top >> 1) * (src_pitch >> 1));
+
+		pY += crop_left >> 1;
+		pCb += crop_left >> 1;
+		pCr += crop_left >> 1;
+		src_pitch >>= 1;
+    }
+
+    deltaDst    = (dst_pitch << 1) - crop_width;
+    pDst = (uint16 *)dst;
+
+    for (row = crop_height; row > 0; row -= 2)
+    {
+
+        for (col = crop_width - 1; col >= 0; col -= 2)
+        {
+			Cb = *pCb;
+			Cr = *pCr;
+
+			if(colorFormat == OMX_COLOR_FormatYUV420Planar || colorFormat == OMX_COLOR_FormatYUV422Planar){
+				pCb ++;
+				pCr ++;
+			}
+			else{
+				pCb +=  2;
+				pCr +=  2;
+			}
+
+            Y = pY[src_pitch];
+
+            Cb -= 128;
+            Cr -= 128;
+            Cg  =   Cr * cc1;
+            Cr  *= cc3;
+
+            Cg  +=  Cb * cc2;
+            Cb  *=  cc4;
+
+            tmp0    = (Y & 0xFF);   //Low endian    left pixel
+            tmp0    += OFFSET_5_0;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+
+            Y   = (Y >> 8) & 0xFF;
+
+            Y   += OFFSET_5_1;
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+
+            //RGB_565
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            rgb     |= (tmp0 << 16);
+
+            *((uint32*)(pDst + dst_pitch))  = rgb;
+
+            //load the top two pixels
+            Y = *pY++;
+
+            tmp0    = (Y & 0xFF);   //Low endian    left pixel
+            tmp0    += OFFSET_5_1;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+
+            Y   = (Y >> 8) & 0xFF;
+
+            Y   += OFFSET_5_0;
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+
+            //RGB_565
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            rgb     |= (tmp0 << 16);
+            *((uint32 *)pDst)   = rgb;
+            pDst += 2;
+
+        }//end of COL
+
+        pY  += (deltaY >> 1);
+        pCb +=  deltaCbCr;
+        pCr +=  deltaCbCr;
+        pDst += (deltaDst); //coz pDst defined as UINT *
+    }
+    return 1;
+}
+
+int32 cc16Reverse(uint8 **src, uint8 *dst, int32 *disp, uint8 *coff_tbl)
+{
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaDst, deltaCbCr;
+    int     row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    //  int32       mRotation;
+    int nextrow, mIsFlip;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+    mIsFlip     =   disp[7];
+
+    deltaDst    = (dst_pitch << 1) - src_width;
+
+    if (disp[6]) /* rotation, only */
+    {  /* move the starting point to the bottom-right corner of the picture */
+        nextrow = src_pitch * (disp[3] - 1);
+        pY = (uint16*)(src[0] + nextrow + src_width - 2);
+        nextrow = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+        pCb = src[1] + nextrow + (src_width >> 1) - 1;
+        pCr = src[2] + nextrow + (src_width >> 1) - 1;
+        nextrow = -(src_pitch >> 1);
+        deltaY      =   src_width - (src_pitch << 1);
+        deltaCbCr   = (src_width - src_pitch) >> 1;
+    }
+    else    /* flip only */
+    {   /* move the starting point to the top-right corner of the picture */
+        pY = (uint16 *)(src[0] + src_width - 2);
+        pCb = src[1] + (src_width >> 1) - 1;
+        pCr = src[2] + (src_width >> 1) - 1;
+        nextrow = src_pitch >> 1;
+        deltaY = src_width + (src_pitch << 1);
+        deltaCbCr = (src_width + src_pitch) >> 1;
+    }
+
+    pDst = (uint16 *)dst;
+
+    for (row = disp[3]; row > 0; row -= 2)
+    {
+
+        for (col = src_width - 1; col >= 0; col -= 2)
+        {
+
+            Cb = *pCb--;
+            Cr = *pCr--;
+            //load the bottom two pixels
+            //Y =   *(((uint16 *)pY)+src_pitch);
+            //Y =   *((uint16 *)(((uint16 *)pY) + src_pitch));
+            Y = pY[nextrow];
+
+            Cb -= 128;
+            Cr -= 128;
+            //Cg    =   Cr*JCoeff[0];//*((int32*)(clip - 40))
+            Cg  =   Cr * cc1;
+            Cr  *= cc3;
+
+            Cg  +=  Cb * cc2;
+            Cb  *=  cc4;
+
+            tmp0    = (Y & 0xFF);   //Low endian    left pixel
+            tmp0    += OFFSET_5_0;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+
+            Y   = (Y >> 8) & 0xFF;
+
+            Y   += OFFSET_5_1;
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            rgb = (rgb << 16) | tmp0;
+
+            *((uint32*)(pDst + dst_pitch))  = rgb;
+
+            //load the top two pixels
+            //Y =   *((uint16 *)pY)++;
+            Y = *pY--;
+
+            tmp0    = (Y & 0xFF);   //Low endian    left pixel
+            tmp0    += OFFSET_5_1;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+
+            Y   = (Y >> 8) & 0xFF;
+
+            Y   += OFFSET_5_0;
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            rgb  = (rgb << 16) | tmp0;
+
+            //          *( (unsigned int32 *)pDst)++    = rgb;
+            *((uint32 *)pDst)   = rgb;
+            pDst += 2;
+
+        }//end of COL
+
+        pY  += (deltaY >> 1);
+        pCb +=  deltaCbCr;
+        pCr +=  deltaCbCr;
+        pDst += (deltaDst); //coz pDst defined as UINT *
+    }
+    return 1;
+}
+
+
+int32 cc16rotate_P(uint8 **src, uint8 *dst, int32 src_pitch, int32 dst_pitch, int32 src_width, int32 src_height,
+                   int32 deltaY, int32 deltaCbCr, int32 deltaDst, uint8 *coeff_tbl);
+int32 cc16rotate_N(uint8 **src, uint8 *dst, int32 src_pitch, int32 dst_pitch, int32 src_width, int32 src_height,
+                   int32 deltaY, int32 deltaCbCr, int32 deltaDst, uint8 *coeff_tbl);
+
+int32 ColorConvert16::cc16Rotate(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *COFF_TBL)
+{
+    int32 src_pitch, dst_pitch, src_width, src_height;
+    int32 deltaY, deltaCbCr, deltaDst;
+
+    src_pitch   =   disp->src_pitch;
+    dst_pitch   =   disp->dst_pitch;
+    src_width   =   disp->src_width;
+    src_height  =   disp->src_height;
+
+    deltaY = (src_pitch << 1) - src_width;
+    deltaCbCr = (src_pitch - src_width) >> 1;
+
+    if (_mRotation == CCROTATE_CLKWISE)
+    {
+        if (!_mIsFlip)
+        {   // go from upper-right down and left
+            dst += ((src_height - 1) << 1);
+            deltaDst  =  -(dst_pitch * src_width) - 2;
+
+            return cc16rotate_N(src, dst, src_pitch, dst_pitch, src_width, src_height, deltaY,
+                                deltaCbCr, deltaDst, COFF_TBL);
+        }
+        else
+        {    // go from origin down and right
+            deltaDst  =  -(dst_pitch * src_width) + 2;
+            return cc16rotate_P(src, dst, src_pitch, dst_pitch, src_width, src_height, deltaY,
+                                deltaCbCr, deltaDst, COFF_TBL);
+        }
+
+    }
+    else  // rotate counterclockwise
+    {
+        if (!_mIsFlip)
+        {   // go from bottom-left to up right
+            dst += (((src_width - 1) * dst_pitch) << 1);
+            deltaDst = (dst_pitch * src_width + 2);
+            dst_pitch = -dst_pitch;
+
+            return cc16rotate_P(src, dst, src_pitch, dst_pitch, src_width, src_height, deltaY,
+                                deltaCbCr, deltaDst, COFF_TBL);
+        }
+        else
+        {   // go from bottom right to top and left
+            dst += (((src_height - 1) << 1) + (((src_width - 1) * dst_pitch) << 1));
+            deltaDst = (dst_pitch * src_width - 2);
+            dst_pitch = -dst_pitch;
+
+            return cc16rotate_N(src, dst, src_pitch, dst_pitch, src_width, src_height, deltaY,
+                                deltaCbCr, deltaDst, COFF_TBL);
+        }
+    }
+
+}
+
+int32 cc16rotate_P(uint8 **src, uint8 *dst, int32 src_pitch, int32 dst_pitch, int32 src_width, int32 src_height,
+                   int32 deltaY, int32 deltaCbCr, int32 deltaDst, uint8 *coeff_tbl)
+{
+#if CCROTATE
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       Y, Cb, Cr, Cg;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coeff_tbl + 400;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    pY = (uint16*) src[0];
+    src_pitch >>= 1;
+    pCb = src[1];
+    pCr = src[2];
+
+    pDst = (uint16 *)dst;
+
+    for (row = src_height; row > 0; row -= 2)
+    {
+
+        for (col = src_width - 1; col >= 0; col -= 2)
+        {
+
+            Cb = *pCb++;
+            Cr = *pCr++;
+            //load the bottom two pixels
+            Y = pY[src_pitch];
+
+            Cb -= 128;
+            Cr -= 128;
+            Cg  =   Cr * cc1;
+            Cr  *= cc3;
+
+            Cg  +=  Cb * cc2;
+            Cb  *=  cc4;
+
+            tmp0    = (Y & 0xFF);   //Low endian    left pixel
+            tmp0    += OFFSET_5_0;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+
+            *(pDst += 1) = rgb;
+
+            Y   = (Y >> 8);
+            Y   += OFFSET_5_1;
+
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            *(pDst += dst_pitch)    = tmp0;
+
+            //load the top two pixels
+            Y = *pY++;
+
+            tmp0    = (Y >> 8); //Low endian    right pixel
+            tmp0    += OFFSET_5_0;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+            *(pDst -= 1)   =   rgb;
+
+            tmp0   = Y & 0xFF;
+            tmp0    += OFFSET_5_1;
+
+            tmp1    = (tmp0) - (Cg >> 16);
+            tmp2    = (tmp0) + (Cb >> 16);
+            tmp0    = (tmp0) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            pDst[-dst_pitch] = tmp0;
+            pDst += dst_pitch;
+
+        }//end of COL
+
+        pY  += (deltaY >> 1);
+        pCb +=  deltaCbCr;
+        pCr +=  deltaCbCr;
+        pDst += (deltaDst); //coz pDst defined as UINT *
+    }
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(src_pitch);
+    OSCL_UNUSED_ARG(dst_pitch);
+    OSCL_UNUSED_ARG(src_width);
+    OSCL_UNUSED_ARG(src_height);
+    OSCL_UNUSED_ARG(deltaY);
+    OSCL_UNUSED_ARG(deltaCbCr);
+    OSCL_UNUSED_ARG(deltaDst);
+    OSCL_UNUSED_ARG(coeff_tbl);
+
+    return 0;
+#endif // CCROTATE
+}
+
+int32 cc16rotate_N(uint8 **src, uint8 *dst, int32 src_pitch, int32 dst_pitch, int32 src_width, int32 src_height,
+                   int32 deltaY, int32 deltaCbCr, int32 deltaDst, uint8 *coeff_tbl)
+{
+#if CCROTATE
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       Y, Cb, Cr, Cg;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coeff_tbl + 400;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    pY = (uint16*) src[0];
+    src_pitch >>= 1;
+    pCb = src[1];
+    pCr = src[2];
+
+    pDst = (uint16 *)dst;
+
+    for (row = src_height; row > 0; row -= 2)
+    {
+
+        for (col = src_width - 1; col >= 0; col -= 2)
+        {
+
+            Cb = *pCb++;
+            Cr = *pCr++;
+            //load the bottom two pixels
+            Y = pY[src_pitch];
+
+            Cb -= 128;
+            Cr -= 128;
+            Cg  =   Cr * cc1;
+            Cr  *= cc3;
+
+            Cg  +=  Cb * cc2;
+            Cb  *=  cc4;
+
+            tmp0    = (Y & 0xFF);   //Low endian    left pixel
+            tmp0    += OFFSET_5_0;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+
+            *(pDst -= 1) = rgb;
+
+            Y   = (Y >> 8) & 0xFF;
+
+            Y   += OFFSET_5_1;
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+            //RGB_565
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            *(pDst += dst_pitch)    = tmp0;
+
+            //load the top two pixels
+            Y = *pY++;
+
+            tmp0    = (Y >> 8) & 0xFF; //Low endian    right pixel
+            tmp0    += OFFSET_5_0;
+
+            tmp1    =   tmp0 - (Cg >> 16);
+            tmp2    =   tmp0 + (Cb >> 16);
+            tmp0    =   tmp0 + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+            tmp2    =   clip[tmp2];
+
+            rgb     =   tmp1 | (tmp0 << 6);
+            rgb     =   tmp2 | (rgb << 5);
+            *(pDst += 1)   =   rgb;
+
+            Y   = (Y & 0xFF);
+
+            Y   += OFFSET_5_1;
+            tmp1    = (Y) - (Cg >> 16);
+            tmp2    = (Y) + (Cb >> 16);
+            tmp0    = (Y) + (Cr >> 16);
+
+            tmp0    =   clip[tmp0];
+            tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+            tmp2    =   clip[tmp2];
+
+            tmp0    =   tmp1 | (tmp0 << 6);
+            tmp0    =   tmp2 | (tmp0 << 5);
+
+            pDst[-dst_pitch] = tmp0;
+            pDst += dst_pitch;
+
+        }//end of COL
+
+        pY  += (deltaY >> 1);
+        pCb +=  deltaCbCr;
+        pCr +=  deltaCbCr;
+        pDst += (deltaDst); //coz pDst defined as UINT *
+    }
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(src_pitch);
+    OSCL_UNUSED_ARG(dst_pitch);
+    OSCL_UNUSED_ARG(src_width);
+    OSCL_UNUSED_ARG(src_height);
+    OSCL_UNUSED_ARG(deltaY);
+    OSCL_UNUSED_ARG(deltaCbCr);
+    OSCL_UNUSED_ARG(deltaDst);
+    OSCL_UNUSED_ARG(coeff_tbl);
+
+    return 0;
+#endif // CCROTATE
+}
+
+
+
+int32 cc16scaledown(uint8 **src, uint8 *dst, int32 *disp,
+                    uint8 *coff_tbl, uint8 *_mRowPix, uint8 *_mColPix, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16scalingHalf(uint8 **src, uint8 *dst, int32 *disp,
+                      uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16scaling34(uint8 **src, uint8 *dst,
+                    int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16scaleup(uint8 **src, uint8 *dst, int32 *disp,
+                  uint8 *coff_tbl, uint8 *_mRowPix, uint8 *_mColPix, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16scaling54(uint8 **src, uint8 *dst,
+                    int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16scaling43(uint8 **src, uint8 *dst,
+                    int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat);
+int32 cc16scaling128x96(uint8 **src, uint8 *dst,
+                        int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat);
+
+// Note:: This zoom algorithm needs an extra line of RGB buffer. So, users
+// have to use GetOutputBufferSize API to get the size it needs. See GetOutputBufferSize().
+int32 ColorConvert16::cc16ZoomIn(uint8 **src, uint8 *dst, DisplayProperties *disp, uint8 *coff_tbl)
+{
+    int32 disp_prop[12];
+    int32 src_width, src_height, dst_width, dst_height;
+    int32 tempw, temph;
+
+    disp_prop[0] = disp->src_pitch;
+    disp_prop[1] = disp->dst_pitch;
+    disp_prop[2] = src_width = disp->src_width;
+    disp_prop[3] = src_height = disp->src_height;
+    disp_prop[4] = dst_width = disp->dst_width;
+    disp_prop[5] = dst_height = disp->dst_height;
+    disp_prop[6] = (_mRotation > 0 ? 1 : 0);
+    disp_prop[7] = _mIsFlip;
+    disp_prop[8] = disp->src_crop_left;
+    disp_prop[9] = disp->src_crop_top;
+    disp_prop[10] = disp->src_crop_width;
+    disp_prop[11] = disp->src_crop_height;
+
+    if (src_width > dst_width) /* scale down in width */
+    {
+        tempw = (3 * src_width) >> 2;
+        temph = (3 * src_height) >> 2;
+        /* check for special zoom-out case, 3:4 scaling down */
+        if (dst_width == tempw  &&  dst_height == temph && !(src_width&3))
+        {
+            return cc16scaling34(src, dst, disp_prop, coff_tbl, _mColorFormat);
+        }
+        else
+        {
+            if ((dst_width == (src_width >> 1)) && (dst_height == (src_height >> 1)))
+            {
+                return cc16scalingHalf(src, dst, disp_prop, coff_tbl, _mColorFormat);
+            }
+            else
+            {
+                return cc16scaledown(src, dst, disp_prop, coff_tbl, _mRowPix, _mColPix, _mColorFormat);
+            }
+        }
+    }
+    else
+    {
+        tempw = (5 * src_width) / 4;
+        temph = (5 * src_height) / 4;
+
+        /* check for special zoom-out case, 5:4 scaling up */
+        if (dst_width == tempw  &&  dst_height == temph && !(src_width&3))
+        {
+            return cc16scaling54(src, dst, disp_prop, coff_tbl, _mColorFormat);
+        }
+        else
+        {
+            tempw = (4 * src_width) / 3;
+            temph = (4 * src_height) / 3;
+            if (dst_width == tempw  &&  dst_height == temph && !(src_width&3))
+            {
+                return cc16scaling43(src, dst, disp_prop, coff_tbl, _mColorFormat);
+            }
+            else
+            {
+                tempw = (15 * src_width) / 8;
+                temph = (15 * src_height) / 8;
+#ifdef SPECIAL_SCALE_128x96
+                if (dst_width == tempw  &&  dst_height == temph && !(src_width&7))
+                {
+                    return cc16scaling128x96(src, dst, disp_prop, coff_tbl, _mColorFormat);
+                }
+                else
+#endif
+                {
+                    return cc16scaleup(src, dst, disp_prop, coff_tbl, _mRowPix, _mColPix, _mColorFormat);
+                }
+            }
+        }
+
+    }
+}
+
+#ifdef SPECIAL_SCALE_128x96
+int32 cc16scaling128x96(uint8 **src, uint8 *dst, int32 *disp, uint8 *coff_tbl)
+{
+#if CCSCALING
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width, nextrow;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaCbCr;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+#ifdef INTERPOLATE
+    int i, offset = 0;
+    uint16 *pI2, *pU2, *pIn, *pNext;
+    int32 tmp02, tmp01;
+#endif
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+
+    if (((disp[6] == 1) && (disp[7] == 1)) || ((disp[6] == 0) && (disp[7] == 0)))
+    {
+        if (disp[6])/* rotate 180 and flip */
+        {   /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+        else // no rotate,no flip
+        {
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            pY = (uint16 *) src[0];
+            src_pitch >>= 1;
+            pCb = src[1];
+            pCr = src[2];
+        }
+
+        pDst = (uint16 *)dst;
+
+        for (row = 0; row < disp[3] - 1; row += 2)
+        {
+            for (col = 0; col <= src_width - 1; col += 8)
+            {
+                Cb = *pCb++;
+                Cr = *pCr++;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifndef INTERPOLATE
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp02   =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp02;
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pI2 = ((pDst + (dst_pitch << 1) + 3));
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+                *(pDst + (dst_pitch << 1) + 3) = tmp0;
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifndef INTERPOLATE
+                *((pDst + 1)) = rgb;
+#endif
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp01   =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp01;
+                *((pDst + 1)) = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pU2 = (pDst + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp0;
+                *(pDst + 3) = tmp0;
+#endif
+                pDst += 4;
+
+                Cb = *pCb++;
+                Cr = *pCr++;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifdef INTERPOLATE
+                *pI2 = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp02   =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp02;
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pI2 = (pDst + (dst_pitch << 1) + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+                *(pDst + (dst_pitch << 1) + 3) = tmp0;
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifdef INTERPOLATE
+                *pU2 = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + 1)) = rgb;
+#endif
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp01   =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp01;
+                *((pDst + 1)) = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pU2 = (pDst + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp0;
+                *(pDst + 3) = tmp0;
+#endif
+                pDst += 4;
+
+                Cb = *pCb++;
+                Cr = *pCr++;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifdef INTERPOLATE
+                *pI2 = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp02   =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp02;
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pI2 = (pDst + (dst_pitch << 1) + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+                *(pDst + (dst_pitch << 1) + 3) = tmp0;
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifdef INTERPOLATE
+                *pU2 = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + 1)) = rgb;
+#endif
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp01   =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp01;
+                *((pDst + 1)) = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pU2 = (pDst + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp0;
+                *(pDst + 3) = tmp0;
+#endif
+                pDst += 4;
+
+                Cb = *pCb++;
+                Cr = *pCr++;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifdef INTERPOLATE
+                *pI2 = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+#ifdef INTERPOLATE
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    = (Y & 0xFF);   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifdef INTERPOLATE
+                *pU2 = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + 1)) = rgb;
+#endif
+                Y   = (Y >> 8) & 0xFF;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                *(pDst + 2) = tmp0;
+#ifdef INTERPOLATE
+                *((pDst + 1)) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                pDst += 3;
+
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            pDst -= (disp[4]);
+#ifdef INTERPOLATE
+            /* vertically - 1 1' 2 2' 3 3' 4 4' 5 5' 6 6' 7 7' 8 1 1'2 2'........*/
+            if ((row & 0x7))
+            {
+                pIn = pDst - dst_pitch;
+                pNext = pIn - dst_pitch;
+                for (i = 0; i < disp[4]; i++)
+                {
+                    int32 curr = pDst[i];
+                    int32 below = pNext[i];
+                    pIn[i] = (((((curr      & 0x1F)  + (below     & 0x1F)) / 2) & 0x1F)
+                              | ((((((curr >> 5) & 0x3F)  + ((below >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                              | ((((((curr >> 11) & 0x1F)  + ((below >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+                offset++;
+            }
+
+            pNext = pDst + (dst_pitch * 2);
+            pIn = pDst + dst_pitch;
+            for (i = 0; i < disp[4]; i++)
+            {
+                int32 curr = pDst[i];
+                int32 below = pNext[i];
+                pIn[i] = (((((curr      & 0x1F)  + (below     & 0x1F)) / 2) & 0x1F)
+                          | ((((((curr >> 5) & 0x3F)  + ((below >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                          | ((((((curr >> 11) & 0x1F)  + ((below >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+            }
+
+            if (offset == 3)
+            {
+                pDst = pNext + dst_pitch;
+                offset = 0;
+            }
+            else
+                pDst = pNext + dst_pitch * 2;
+#else
+            memcpy(pDst + dst_pitch, pDst, (disp[4] << 1));
+            pDst += (dst_pitch << 1);
+
+            if (row & 0x7)
+            {
+                memcpy(pDst + dst_pitch, pDst, (disp[4] << 1));
+                pDst += dst_pitch;  //coz pDst defined as UINT *
+            }
+            pDst += dst_pitch;
+#endif
+        }
+    }
+    else
+    {
+        if (disp[6])/* rotation 180 only */
+        {
+            /* move the starting point to the bottom-right corner of the picture */
+            nextrow = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + nextrow + src_width - 2);
+            nextrow = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + nextrow + (src_width >> 1) - 1;
+            pCr = src[2] + nextrow + (src_width >> 1) - 1;
+            nextrow = -(src_pitch >> 1);
+            deltaY      =   src_width - (src_pitch << 1);
+            deltaCbCr   = (src_width - src_pitch) >> 1;
+        }
+        else /* flip only */
+        {
+            /* move the starting point to the top-right corner of the picture */
+            pY = (uint16 *)(src[0] + src_width - 2);
+            pCb = src[1] + (src_width >> 1) - 1;
+            pCr = src[2] + (src_width >> 1) - 1;
+            nextrow = src_pitch >> 1;
+            deltaY = src_width + (src_pitch << 1);
+            deltaCbCr = (src_width + src_pitch) >> 1;
+        }
+        pDst = (uint16 *)dst;
+        for (row = 0; row < disp[3] - 1; row += 2)
+        {
+            for (col = 0; col <= src_width - 1; col += 8)
+            {
+                Cb = *pCb--;
+                Cr = *pCr--;
+                //load the bottom two pixels
+                Y = pY[nextrow];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifndef INTERPOLATE
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp02   =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp02;
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pI2 = ((pDst + (dst_pitch << 1) + 3));
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+                *(pDst + (dst_pitch << 1) + 3) = tmp0;
+#endif
+                //load the top two pixels
+                Y = *pY--;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                //tmp0  =   *pY++;
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifndef INTERPOLATE
+                *((pDst + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp01   =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp01;
+                *((pDst + 1)) = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pU2 = (pDst + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp0;
+                *(pDst + 3) = tmp0;
+#endif
+                pDst += 4;
+
+                Cb = *pCb--;
+                Cr = *pCr--;
+                //load the bottom two pixels
+                Y = pY[nextrow];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1- OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifdef INTERPOLATE
+                *pI2 = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp02   =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp02;
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pI2 = (pDst + (dst_pitch << 1) + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+                *(pDst + (dst_pitch << 1) + 3) = tmp0;
+#endif
+
+                //load the top two pixels
+                Y = *pY--;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                //tmp0  =   *pY++;
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifdef INTERPOLATE
+                *pU2 = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp01   =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp01;
+                *((pDst + 1)) = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pU2 = (pDst + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp0;
+                *(pDst + 3) = tmp0;
+#endif
+                pDst += 4;
+
+                Cb = *pCb--;
+                Cr = *pCr--;
+                //load the bottom two pixels
+                Y = pY[nextrow];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1- OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifdef INTERPOLATE
+                *pI2 = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp02   =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp02;
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pI2 = (pDst + (dst_pitch << 1) + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+                *(pDst + (dst_pitch << 1) + 3) = tmp0;
+#endif
+
+                //load the top two pixels
+                Y = *pY--;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                //tmp0  =   *pY++;
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifdef INTERPOLATE
+                *pU2 = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+#ifdef INTERPOLATE
+                tmp01   =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp01;
+                *((pDst + 1)) = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                pU2 = (pDst + 3);
+#else
+                tmp0    =   tmp2 | (tmp0 << 5);
+                *(pDst + 2) = tmp0;
+                *(pDst + 3) = tmp0;
+#endif
+                pDst += 4;
+
+                Cb = *pCb--;
+                Cr = *pCr--;
+                //load the bottom two pixels
+                Y = pY[nextrow];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1- OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *((pDst + (dst_pitch << 1))) = rgb;
+#ifdef INTERPOLATE
+                *pI2 = (((((tmp02      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp02 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp02 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + (dst_pitch << 1) + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                *(pDst + (dst_pitch << 1) + 2) = tmp0;
+#ifdef INTERPOLATE
+                *((pDst + (dst_pitch << 1) + 1)) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                                    | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                                    | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                //load the top two pixels
+                Y = *pY--;
+
+                tmp0    = (Y >> 8) & 0xFF;      //Low endian    left pixel
+                //tmp0  =   *pY++;
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *((pDst)) = rgb;
+#ifdef INTERPOLATE
+                *pU2 = (((((tmp01      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                        | ((((((tmp01 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                        | ((((((tmp01 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#else
+                *((pDst + 1)) = rgb;
+#endif
+
+                Y       =   Y & 0xFF;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                *(pDst + 2) = tmp0;
+#ifdef INTERPOLATE
+                *((pDst + 1)) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                pDst += 3;
+
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            pDst -= (disp[4]);
+#ifdef INTERPOLATE
+            /* vertically - 1 1' 2 2' 3 3' 4 4' 5 5' 6 6' 7 7' 8 1 1'2 2'........*/
+            if ((row & 0x7))
+            {
+                pIn = pDst - dst_pitch;
+                pNext = pIn - dst_pitch;
+                for (i = 0; i < disp[4]; i++)
+                {
+                    int32 curr = pDst[i];
+                    int32 below = pNext[i];
+                    pIn[i] = (((((curr      & 0x1F)  + (below     & 0x1F)) / 2) & 0x1F)
+                              | ((((((curr >> 5) & 0x3F)  + ((below >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                              | ((((((curr >> 11) & 0x1F)  + ((below >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+                offset++;
+            }
+
+            pNext = pDst + (dst_pitch * 2);
+            pIn = pDst + dst_pitch;
+            for (i = 0; i < disp[4]; i++)
+            {
+                int32 curr = pDst[i];
+                int32 below = pNext[i];
+                pIn[i] = (((((curr      & 0x1F)  + (below     & 0x1F)) / 2) & 0x1F)
+                          | ((((((curr >> 5) & 0x3F)  + ((below >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                          | ((((((curr >> 11) & 0x1F)  + ((below >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+            }
+
+            if (offset == 3)
+            {
+                pDst = pNext + dst_pitch;
+                offset = 0;
+            }
+            else
+                pDst = pNext + dst_pitch * 2;
+#else
+            memcpy(pDst + dst_pitch, pDst, (disp[4] << 1));
+            pDst += (dst_pitch << 1);
+
+            if (row & 0x7)
+            {
+                memcpy(pDst + dst_pitch, pDst, (disp[4] << 1));
+                pDst += dst_pitch;  //coz pDst defined as UINT *
+            }
+            pDst += dst_pitch;
+#endif
+        }
+    }
+
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coeff_tbl);
+    return 0;
+#endif // CCSCALING
+}
+#endif
+
+/* special function when scale down in width */
+int32 cc16scaledown(uint8 **src, uint8 *dst, int32 *disp,
+                    uint8 *coff_tbl, uint8 *_mRowPix, uint8 *_mColPix, OMX_COLOR_FORMATTYPE colorFormat)
+{
+#if CCSCALING
+    /*  1. move the dst pointer to the line above the border
+    2. do 2 line conversion
+    3. copy both up & down
+        */
+    uint8 *pCb, *pCr;
+    uint8   *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaCbCr, src_inc;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint8 *clip = coff_tbl + 400;
+    uint8 *rowpix, *colpix;
+    int32 crop_left, crop_top, crop_width, crop_height;
+    int32 src_height;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+    src_height = disp[3];
+    crop_left = disp[8];
+    crop_top = disp[9];
+    crop_width = disp[10];
+    crop_height = disp[11];
+
+    if (((disp[6] == 0) && (disp[7] == 1)) || ((disp[6] == 1) && (disp[7] == 0)))  // rotate 0 and flip || // rotate 180 and  no flip
+    {
+        if (disp[6])/* rotation 180 only */
+        {
+            /* move the starting point to the bottom-right corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (src[0] + deltaY + src_width - 2);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY + (src_width >> 1) - 1;
+            pCr = src[2] + deltaY + (src_width >> 1) - 1;
+            deltaY      =   src_width - (src_pitch << 1);
+            deltaCbCr   = (src_width - src_pitch) >> 1;
+            src_pitch = -src_pitch;
+        }
+        else /* flip only */
+        {
+            /* move the starting point to the top-right corner of the picture */
+            pY = (src[0] + src_width - 2);
+            pCb = src[1] + (src_width >> 1) - 1;
+            pCr = src[2] + (src_width >> 1) - 1;
+            deltaY = src_width + (src_pitch << 1);
+            deltaCbCr = (src_width + src_pitch) >> 1;
+        }
+
+        src_inc = -1;
+    }
+    else // rotate 180 and flip ||  no rotate, no flip
+    {
+        if (disp[6])    // rotate 180 and flip
+        {
+            /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = src[0] + deltaY;
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = - src_pitch;
+        }
+        else  // no rotate, no flip
+        {
+            deltaY      = (src_pitch << 1) - crop_width;
+            if(colorFormat == OMX_COLOR_FormatYUV422Planar)
+                deltaCbCr = ((src_pitch << 1) - crop_width) >> 1;
+            else if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar) 
+                deltaCbCr   = src_pitch - crop_width;
+            else
+                deltaCbCr   = (src_pitch - crop_width) >> 1;
+            pY = src[0] + crop_top * src_pitch;
+            pCb = src[1] + ((crop_top >> 1) * (src_pitch >> 1));
+            pCr = src[2] + ((crop_top >> 1) * (src_pitch >> 1));
+
+            pY += crop_left;
+            pCb += crop_left >> 1;
+            pCr += crop_left >> 1;
+
+        }
+
+        src_inc = 1;
+    }
+
+    pDst = (uint16 *)dst;
+
+    colpix = _mColPix + crop_height - 1;
+
+    for(row = crop_height - 1; row >= 0; row -= 2)
+    {/* decrement index, _mColPix[.] is
+        symmetric to increment index */
+
+        if (colpix[-1] + colpix[0] == 0)
+        {
+        
+            if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                pCb += (src_pitch >> 1);
+                pCr += (src_pitch >> 1);
+            }
+            else{
+                pCb += src_pitch ;
+                pCr += src_pitch ;
+            }           
+            pY += (src_pitch << 1);
+            colpix -= 2;
+            continue;
+        }
+
+        rowpix = _mRowPix + crop_width - 1;
+
+        if (colpix[-1] + colpix[0] == 1) // one line not skipped
+        {
+            for (col = crop_width - 2; col >= 0; col -= 2)
+            { /* decrement index, _mRowPix[.] is
+                symmetric to increment index */
+
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar ||colorFormat == OMX_COLOR_FormatYUV422Planar){
+                    (pCb += src_inc );
+                    (pCr += src_inc );
+                }
+                else{
+                    (pCb += src_inc * 2);
+                    (pCr += src_inc * 2);
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                if (*rowpix) /* compute this pixel */
+                {
+                    Y   =   *pY;
+                    (pY += src_inc);                        //upper left
+
+                    tmp1    =   Y - (Cg >> 16);
+                    tmp2    =   Y + (Cb >> 16);
+                    tmp0    =   Y + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + 1024];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst) = (uint16)tmp0;
+
+                }
+                else  /* if(_mRowPix[col]) */
+                {
+                    pY += src_inc;
+                }
+                pDst    += *rowpix--;
+
+                if (*rowpix) /* compute this pixel */
+                {
+                    Y   =   *pY;
+                    (pY += src_inc);                            //upper right
+
+                    tmp1    =   Y - (Cg >> 16);
+                    tmp2    =   Y + (Cb >> 16);
+                    tmp0    =   Y + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + 1024];
+                    tmp2    =   clip[tmp2];
+
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst) = (uint16)tmp0;
+                }
+                else  /* if(_mRowPix[col+1]) */
+                {
+                    pY += src_inc;
+                }
+
+                pDst    += *rowpix--;
+            }//end of COL
+
+        }  // one line not skipped
+
+        else  //both lines not skipped
+
+        {
+            for (col = crop_width - 2; col >= 0; col -= 2)
+            { /* decrement index, _mRowPix[.] is
+                symmetric to increment index */
+
+                Cb = *pCb;
+                Cr = *pCr;
+ 
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar ||colorFormat == OMX_COLOR_FormatYUV422Planar){
+                    (pCb += src_inc );
+                    (pCr += src_inc );
+                }
+                else{
+                    (pCb += src_inc * 2);
+                    (pCr += src_inc * 2);
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                if (*rowpix) /* compute this pixel */
+                {
+                    Y   =   pY[src_pitch];                      //lower left
+
+                    Y += OFFSET_5_1;
+                    tmp1    =   Y - (Cg >> 16);
+                    tmp2    =   Y + (Cb >> 16);
+                    tmp0    =   Y + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst + dst_pitch) = (uint16)tmp0;
+
+                    Y   =   *pY;
+                    (pY += src_inc);                        //upper left
+
+                    Y += OFFSET_5_0;
+                    tmp1    =   Y - (Cg >> 16);
+                    tmp2    =   Y + (Cb >> 16);
+                    tmp0    =   Y + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst) = (uint16)tmp0;
+
+                }
+                else  /* if(_mRowPix[col]) */
+                {
+                    pY += src_inc;
+                }
+                pDst    += *rowpix--;
+
+                if (*rowpix) /* compute this pixel */
+                {
+                    Y   =   pY[src_pitch];                      //lower left
+
+                    Y += OFFSET_5_0;
+                    tmp1    =   Y - (Cg >> 16);
+                    tmp2    =   Y + (Cb >> 16);
+                    tmp0    =   Y + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst + dst_pitch) = (uint16)tmp0;
+
+                    Y   =   *pY;
+                    (pY += src_inc);                            //upper right
+
+                    Y += OFFSET_5_1;
+                    tmp1    =   Y - (Cg >> 16);
+                    tmp2    =   Y + (Cb >> 16);
+                    tmp0    =   Y + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst) = (uint16)tmp0;
+                }
+                else  /* if(_mRowPix[col+1]) */
+                {
+                    pY += src_inc;
+                }
+
+                pDst    += *rowpix--;
+            }//end of COL
+
+            pDst += dst_pitch;
+
+        }
+
+        pY  += (deltaY);
+        pCb +=  deltaCbCr;
+        pCr +=  deltaCbCr;
+
+        pDst    +=  dst_pitch - disp[4];
+        colpix -= 2;
+
+    }
+
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+    OSCL_UNUSED_ARG(_mRowPix);
+    OSCL_UNUSED_ARG(_mColPix);
+    return 0;
+#endif // CCSCALING
+}
+
+/* special scaling by one-half */
+int32 cc16scalingHalf(uint8 **src, uint8 *dst, int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat)
+{
+#if CCSCALING
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width, nextrow;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaCbCr;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32 crop_left, crop_top, crop_width, crop_height;
+    int32 src_height;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+    src_height = disp[3];
+    crop_left = disp[8];
+    crop_top = disp[9];
+    crop_width = disp[10];
+    crop_height = disp[11];
+
+    if (((disp[6] == 1) && (disp[7] == 1)) || ((disp[6] == 0) && (disp[7] == 0)))
+    {
+        if (disp[6])/* rotate 180 and flip */
+        {   /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+        else // no rotate,no flip
+        {
+            if(colorFormat == OMX_COLOR_FormatYUV422Planar)
+                deltaCbCr = ((src_pitch << 1) - crop_width) >> 1;
+            else if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar) 
+                deltaCbCr   = src_pitch - crop_width;
+            else
+                deltaCbCr   = (src_pitch - crop_width) >> 1;
+
+            pCb = src[1] + ((crop_top >> 1) * (src_pitch >> 1));
+            pCr = src[2] + ((crop_top >> 1) * (src_pitch >> 1));
+
+            src_pitch >>= 1;
+            pY = (uint16 *)src[0] + crop_top * src_pitch;
+            deltaY      = (src_pitch << 1) - (crop_width >> 1);
+
+            pY += crop_left >> 1;
+            pCb += crop_left >> 1;
+            pCr += crop_left >> 1;
+
+        }
+
+        pDst = (uint16 *)dst;
+
+        for (row = 0; row < crop_height - 1; row += 2)
+        {
+            for (col = 0; col <= crop_width - 1; col += 2)
+            {
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar || colorFormat == OMX_COLOR_FormatYUV422Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Y = *pY++;
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + 1024];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *pDst++ = rgb;
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            pDst -= (disp[4]);
+            pDst += dst_pitch;
+        }
+    }
+    else
+    {
+        if (disp[6])/* rotation 180 only */
+        {
+            /* move the starting point to the bottom-right corner of the picture */
+            nextrow = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + nextrow + src_width - 2);
+            nextrow = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + nextrow + (src_width >> 1) - 1;
+            pCr = src[2] + nextrow + (src_width >> 1) - 1;
+            nextrow = -(src_pitch >> 1);
+            deltaY      =   src_width - (src_pitch << 1);
+            deltaCbCr   = (src_width - src_pitch) >> 1;
+        }
+        else /* flip only */
+        {
+            /* move the starting point to the top-right corner of the picture */
+            pY = (uint16 *)(src[0] + src_width - 2);
+            pCb = src[1] + (src_width >> 1) - 1;
+            pCr = src[2] + (src_width >> 1) - 1;
+            nextrow = src_pitch >> 1;
+            deltaY = src_width + (src_pitch << 1);
+            deltaCbCr = (src_width + src_pitch) >> 1;
+        }
+        pDst = (uint16 *)dst;
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+        
+        for (row = 0; row < disp[3] - 1; row += 2)
+        {
+            for (col = 0; col <= src_width - 1; col += 2)
+            {
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb --;
+                    pCr --;
+                }
+                else{
+                    pCb -=  2;
+                    pCr -=  2;
+                }
+
+                Y = *pY--;
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + 1024];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *pDst++ = rgb;
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            pDst -= (disp[4]);
+            pDst += dst_pitch;
+        }
+    }
+
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+    return 0;
+#endif // CCSCALING
+}
+
+
+/* special 3:4 scale-down color conversion */
+int32 cc16scaling34(uint8 **src, uint8 *dst,
+                    int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat)
+{
+#if CCSCALING
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaDst, deltaCbCr;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    int32 crop_left, crop_top, crop_width, crop_height;
+    int32 src_height;
+    uint8 *clip = coff_tbl + 400;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+    src_height = disp[3];
+    crop_left = disp[8];
+    crop_top = disp[9];
+    crop_width = disp[10];
+    crop_height = disp[11];
+
+    if (((disp[6] == 0) && (disp[7] == 1)) || ((disp[6] == 1) && (disp[7] == 0))) /* rotate 180 and  no flip, rotate 0 and  flip *///Ankur
+    {
+        if (disp[6] == 0)
+        {
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            pY = (uint16 *) src[0];
+            src_pitch >>= 1;
+            pCb = src[1];
+            pCr = src[2];
+        }
+        else
+        {
+            /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+
+        pDst = (uint16 *)dst + disp[4] - 1;
+        deltaDst    = (dst_pitch << 1) + disp[4];   /* disp[4] is dst_width */
+
+        for (row = disp[3]; row > 0; row -= 2)
+        {
+
+            for (col = src_width - 1; col >= 0; col -= 4)  /* do 8 pixels at a time, 4 ups 4 downs */
+            {
+
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                if (!(row&0x2)) /* do the bottom row every other times */
+                {
+                    //load the bottom two pixels
+                    Y = pY[src_pitch];
+
+                    tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                    tmp0    += OFFSET_5_0;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+                    //RGB_565
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+                    *(pDst + dst_pitch) = rgb;  /* save left pixel, have to save separately */
+
+                    Y   >>= 8;
+                    Y   += OFFSET_5_1;
+                    tmp1    = (Y) - (Cg >> 16);
+                    tmp2    = (Y) + (Cb >> 16);
+                    tmp0    = (Y) + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst + dst_pitch - 1) = tmp0; /* save right pixel */
+                }
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *pDst-- =   rgb;    /* save left pixel */
+
+                Y   >>= 8;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                *pDst-- = tmp0; /* save right pixel */
+
+                /* now do another 4 pixels but drop 2 pixels in the last column */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                //load the bottom two pixels
+                if (!(row&0x2)) /* do the bottom row every other times */
+                {
+                    Y = pY[src_pitch];
+
+                    tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                    tmp0    += OFFSET_5_0;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+                    //RGB_565
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+
+                    *(pDst + dst_pitch) = rgb;  /* save only one pixel, 2 bytes */
+                }
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *pDst   = rgb;
+                pDst--; /* save only one pixel, 2 bytes */
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            pDst += (deltaDst); //coz pDst defined as UINT *
+            if (row&0x2)
+            {
+                pDst -= dst_pitch;
+            }
+        }
+    }
+    else /* rotate 180 and flip || no rotation,no flip*/
+    {
+        if (disp[6]) /* rotate 180 and flip */
+        {
+            /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+        else // no rotation,no flip
+        {
+
+            if(colorFormat == OMX_COLOR_FormatYUV422Planar)
+                deltaCbCr = ((src_pitch << 1) - crop_width) >> 1;
+            else if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar) 
+                deltaCbCr   = src_pitch - crop_width;
+            else
+                deltaCbCr   = (src_pitch - crop_width) >> 1;
+            pCb = src[1] + ((crop_top >> 1) * (src_pitch >> 1));
+            pCr = src[2] + ((crop_top >> 1) * (src_pitch >> 1));
+
+            src_pitch >>= 1;
+
+            pY = (uint16 *)src[0] + crop_top * src_pitch;
+            deltaY      = (src_pitch << 1) - (crop_width >> 1);
+
+            pY += crop_left >> 1;
+            pCb += crop_left >> 1;
+            pCr += crop_left >> 1;
+
+            
+        }
+
+        deltaDst    = (dst_pitch << 1) - disp[4];   /* disp[4] is dst_width */
+        pDst = (uint16 *)dst;
+
+        for (row = disp[3]; row > 0; row -= 2)
+        {
+
+            for (col = src_width - 1; col >= 0; col -= 4)  /* do 8 pixels at a time, 4 ups 4 downs */
+            {
+
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar ||colorFormat == OMX_COLOR_FormatYUV422Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                if (!(row&0x2)) /* do the bottom row every other times */
+                {   //load the bottom two pixels
+                    Y = pY[src_pitch];
+
+                    tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                    tmp0    += OFFSET_5_0;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+                    //RGB_565
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+                    *(pDst + dst_pitch) = rgb;  /* save left pixel, have to save separately */
+
+                    Y   >>= 8;
+                    Y   += OFFSET_5_1;
+                    tmp1    = (Y) - (Cg >> 16);
+                    tmp2    = (Y) + (Cb >> 16);
+                    tmp0    = (Y) + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst + dst_pitch + 1) = tmp0; /* save right pixel */
+                }
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *pDst++ =   rgb;    /* save left pixel */
+
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                *pDst++ = tmp0; /* save right pixel */
+
+                /* now do another 4 pixels but drop 2 pixels in the last column */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar ||colorFormat == OMX_COLOR_FormatYUV422Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                //load the bottom two pixels
+                if (!(row&0x2)) /* do the bottom row every other times */
+                {
+                    Y = pY[src_pitch];
+
+                    tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                    tmp0    += OFFSET_5_0;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+                    //RGB_565
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+
+                    *(pDst + dst_pitch) = rgb;  /* save only one pixel, 2 bytes */
+                }
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *pDst   = rgb;
+                pDst++; /* save only one pixel, 2 bytes */
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            pDst += (deltaDst); //coz pDst defined as UINT *
+            if (row&0x2)
+            {
+                pDst -= dst_pitch;
+            }
+        }
+    }
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+    return 0;
+#endif // CCSCALING
+}
+
+
+int32 cc16scaleup(uint8 **src, uint8 *dst, int32 *disp,
+                  uint8 *coff_tbl, uint8 *_mRowPix, uint8 *_mColPix, OMX_COLOR_FORMATTYPE colorFormat)
+{
+#if CCSCALING
+    /*  1. move the dst pointer to the line above the border
+    2. do 2 line conversion
+    3. copy both up & down
+        */
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y,  Cb, Cr, Cg;
+    int32       deltaY, dst_width, deltaCbCr;
+    int32       row, col;
+    int32   tmp0, tmp1, tmp2, temp;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32       offset;
+    uint8 *rowpix, *colpix;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+
+#ifdef INTERPOLATE
+    int i;
+    uint32  copyline = 0;   //maru
+    uint16  *prev_pDst = 0; //maru
+    int32   prev_offset = 0;    //maru
+#endif
+
+    if (((disp[6] == 0) && (disp[7] == 1)) || ((disp[6] == 1) && (disp[7] == 0))) /* rotate 180 and  no flip || rotate 0 and  with flip */ //Ankur
+    {
+        if (disp[6] == 0) /*rotate 0 and  with flip */
+            pDst = (uint16 *)dst + disp[4] - 1;
+        else /* rotate 180 and  no flip */
+        {
+            pDst = ((uint16 *)dst) + disp[1] * (disp[5] - 1) + disp[4] - 1;
+            dst_pitch = -dst_pitch;
+        }
+
+        deltaY      = (src_pitch << 1) - src_width;
+        deltaCbCr   = (src_pitch - src_width) >> 1;
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+        dst_width   =   disp[4];
+        pY = (uint16*)src[0];
+        pCb = src[1];
+        pCr = src[2];
+        src_pitch >>= 1;
+        colpix = _mColPix + disp[3] - 1;
+
+        for (row = disp[3] - 1; row >= 0; row -= 2)
+        {/* decrement index, _mColPix[.] is
+            symmetric to increment index */
+            rowpix = _mRowPix + src_width - 1;
+
+            for (col = src_width - 2; col >= 0; col -= 2)
+            { /* decrement index, _mRowPix[.] is
+                symmetric to increment index */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Y = pY[src_pitch];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    =   Y & 0xFF;           //bottom left
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                //RGB_565
+
+                rgb =   tmp1 | (tmp0 << 6);
+                rgb =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;                      //bottom right
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                pDst += dst_pitch;
+                temp = rowpix[0] + rowpix[-1];
+                rowpix -= 2;
+                if (temp == 2)
+                {
+                    *pDst = rgb;
+                    *(pDst - 1) = tmp0;
+                }
+                else if (temp == 3)
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                    *(pDst - 2) = tmp0;
+                }
+                else if (temp == 4)
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = rgb;
+                    *(pDst - 2) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 2) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+                    *(pDst - 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F)) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+#endif
+                    *(pDst - 3) = tmp0;
+                }
+                else if (temp == 5)
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = rgb;
+                    *(pDst - 2) = tmp0;
+                    *(pDst - 3) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 3) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 3) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 3) / 4) & 0x1F) << 11));
+                    *(pDst - 2) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(pDst - 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F)) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F)) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F)) / 4) & 0x1F) << 11));
+#endif
+                    *(pDst - 4) = tmp0;
+                }
+                else /* temp ==6 */
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = rgb;
+                    *(pDst - 2) = rgb;
+                    *(pDst - 3) = tmp0;
+                    *(pDst - 4) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 4) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 4) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 4) / 5) & 0x1F) << 11));
+                    *(pDst - 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F) * 3) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F) * 3) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F) * 3) / 5) & 0x1F) << 11));
+                    *(pDst - 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F) * 2) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F) * 2) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F) * 2) / 5) & 0x1F) << 11));
+                    *(pDst - 4) = (((((tmp0      & 0x1F) * 4 + (rgb     & 0x1F)) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 4 + ((rgb >> 5) & 0x3F)) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 4 + ((rgb >> 11) & 0x1F)) / 5) & 0x1F) << 11));
+#endif
+                    *(pDst - 5) = tmp0;
+                }
+
+                pDst -= dst_pitch;
+
+                Y = *pY++;
+                tmp0    =       Y & 0xFF;       //top left
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb =   tmp1 | (tmp0 << 6);
+                rgb =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;                  //top right
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+                if (temp == 2)
+                {
+                    *pDst = rgb;
+                    *(pDst - 1) = tmp0;
+                }
+                else if (temp == 3)
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                    *(pDst - 2) = tmp0;
+                }
+                else if (temp == 4)
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = rgb;
+                    *(pDst - 2) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 2) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+                    *(pDst - 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F)) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+#endif
+                    *(pDst - 3) = tmp0;
+                }
+                else if (temp == 5)
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = rgb;
+                    *(pDst - 2) = tmp0;
+                    *(pDst - 3) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 3) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 3) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 3) / 4) & 0x1F) << 11));
+                    *(pDst - 2) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(pDst - 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F)) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F)) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F)) / 4) & 0x1F) << 11));
+#endif
+                    *(pDst - 4) = tmp0;
+                }
+                else /* temp ==6 */
+                {
+                    *pDst = rgb;
+#ifndef INTERPOLATE
+                    *(pDst - 1) = rgb;
+                    *(pDst - 2) = rgb;
+                    *(pDst - 3) = tmp0;
+                    *(pDst - 4) = tmp0;
+#else
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 4) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 4) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 4) / 5) & 0x1F) << 11));
+                    *(pDst - 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F) * 3) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F) * 3) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F) * 3) / 5) & 0x1F) << 11));
+                    *(pDst - 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F) * 2) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F) * 2) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F) * 2) / 5) & 0x1F) << 11));
+                    *(pDst - 4) = (((((tmp0      & 0x1F) * 4 + (rgb     & 0x1F)) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 4 + ((rgb >> 5) & 0x3F)) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 4 + ((rgb >> 11) & 0x1F)) / 5) & 0x1F) << 11));
+#endif
+                    *(pDst - 5) = tmp0;
+                }
+                pDst -= temp;
+
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            pDst++; // goes back to the beginning of the line
+
+#ifdef INTERPOLATE
+
+            if (copyline&0x1)   //Maruyama comment:BLACK line in SubQCIF.bmp
+            {
+                memcpy(prev_pDst + offset,             prev_pDst + dst_pitch, dst_width*2);
+            }
+            if (copyline&0x2)   //Maruyama comment:BLUE line in SubQCIF.bmp
+            {
+                for (i = 0 ; i < dst_width ; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + dst_pitch + i);
+                    //              int32 curtemp = *(pDst+dst_pitch+i);
+                    int32 curtemp = *(pDst + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + prev_offset + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+prev_offset+dst_pitch+i) = 0x1F;
+                }
+            }
+
+            if (copyline&0x4)
+            {
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + dst_pitch + i);
+                    //              int32 curtemp = *(pDst+dst_pitch+i);
+                    int32 curtemp = *(pDst + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + prev_offset + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+prev_offset+dst_pitch+i) = 0x3F<<5;
+                }
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + dst_pitch + i);
+                    int32 curtemp = *(pDst + dst_pitch + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + prev_offset + dst_pitch*2 + i) = (uint16)coltemp;
+                    //              *(prev_pDst+prev_offset+dst_pitch*2+i) = 0x1F<<11;
+                }
+            }
+
+            if (copyline&0x8)   //Maruyama comment:WHITE line in SubQCIF.bmp
+            {
+                for (i = 0 ; i < dst_width ; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *(pDst - dst_pitch + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+dst_pitch+i) = 0xFFFF;
+                }
+            }
+
+            if (copyline&0x10)
+            {
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    //              int32 curtemp = *(pDst+i);
+                    int32 curtemp = *(pDst - dst_pitch + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+dst_pitch+i) = 0x1F|(0x3F<<5);
+                }
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *(pDst + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch*2 + i) = (uint16)coltemp;
+                    //              *(prev_pDst+dst_pitch*2+i) = 0x1F|(0x1F<<11);
+                }
+            }
+#endif
+            //copy down
+            offset = (colpix[0] * dst_pitch);
+
+#ifdef INTERPOLATE
+            copyline = 0;   //maru
+            prev_pDst = pDst;   //maru
+            prev_offset = offset;   //maru
+#endif
+            if (colpix[-1] && colpix[0] != 1)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + offset,             pDst + dst_pitch, dst_width*2);
+#else
+                copyline |= 0x1;    //maru
+#endif
+            }
+            if (colpix[-1] == 2)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + offset + dst_pitch,   pDst + dst_pitch, dst_width*2);
+#else
+                copyline |= 0x2;    //maru
+#endif
+            }
+            else if (colpix[-1] == 3)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + offset + dst_pitch,   pDst + dst_pitch, dst_width*2);
+                memcpy(pDst + offset + dst_pitch*2, pDst + dst_pitch, dst_width*2);
+#else
+                copyline |= 0x4;    //maru
+#endif
+            }
+            //copy up
+            if (colpix[0] == 2)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + dst_pitch,          pDst,           dst_width*2);
+#else
+                copyline |= 0x8;    //maru
+#endif
+            }
+            else if (colpix[0] == 3)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + dst_pitch,          pDst,           dst_width*2);
+                memcpy(pDst + dst_pitch*2,        pDst,           dst_width*2);
+#else
+                copyline |= 0x10;   //maru
+#endif
+            }
+
+            pDst    +=  dst_pitch * (colpix[-1] + colpix[0]) + dst_width - 1;
+            colpix -= 2;
+        }//end of row
+
+#ifdef INTERPOLATE
+
+        if (copyline&0x1)   //Maruyama comment:BLACK line in SubQCIF.bmp
+        {
+            memcpy(prev_pDst + offset,             prev_pDst + dst_pitch, dst_width*2);
+        }
+        if (copyline&0x2)   //Maruyama comment:BLUE line in SubQCIF.bmp
+        {
+            memcpy(prev_pDst + offset + dst_pitch,   prev_pDst + dst_pitch, dst_width*2);
+        }
+
+        if (copyline&0x4)
+        {
+            memcpy(prev_pDst + offset + dst_pitch,   prev_pDst + dst_pitch, dst_width*2);
+            memcpy(prev_pDst + offset + dst_pitch*2, prev_pDst + dst_pitch, dst_width*2);
+        }
+#endif
+    }
+    else  /* rotate 180 and  with flip || no rotation ,no flip */
+    {
+        if (disp[6] == 1) /* rotate 180 and  with flip */ //Ankur
+        {
+            /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16 *)src[0] + (deltaY >> 1);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + (deltaY >> 0);
+            pCr = src[2] + (deltaY >> 0);
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            dst_width   =   disp[4];
+            src_pitch >>= 1;
+            src_pitch = -src_pitch;
+        }
+        else
+        {   // only scale up, no rotation ,no flip
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            dst_width   =   disp[4];
+            src_pitch >>= 1;
+            pY = (uint16*)src[0];
+            pCb = src[1];
+            pCr = src[2];
+        }
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+
+        pDst = (uint16 *)dst;
+        colpix = _mColPix + disp[3] - 1;
+
+        for (row = disp[3] - 1; row >= 0; row -= 2)
+        {/* decrement index, _mColPix[.] is
+            symmetric to increment index */
+            rowpix = _mRowPix + src_width - 1;
+
+            for (col = src_width - 2; col >= 0; col -= 2)
+            { /* decrement index, _mRowPix[.] is
+                symmetric to increment index */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Y = pY[src_pitch];
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                tmp0    =   Y & 0xFF;           //bottom left
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                //RGB_565
+
+                rgb =   tmp1 | (tmp0 << 6);
+                rgb =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;                      //bottom right
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                pDst += dst_pitch;
+                temp = rowpix[0] + rowpix[-1];
+                rowpix -= 2;
+                if (temp == 2)
+                {
+                    *pDst = (uint16)rgb;
+                    *(pDst + 1) = (uint16)tmp0;
+                }
+                else if (temp == 3)
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                    *(pDst + 2) = (uint16)tmp0;
+                }
+                else if (temp == 4)
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)rgb;
+                    *(pDst + 2) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 2) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+                    *(pDst + 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F)) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+#endif
+                    *(pDst + 3) = (uint16)tmp0;
+                }
+                else if (temp == 5)
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)rgb;
+                    *(pDst + 2) = (uint16)tmp0;
+                    *(pDst + 3) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 3) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 3) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 3) / 4) & 0x1F) << 11));
+                    *(pDst + 2) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(pDst + 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F)) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F)) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F)) / 4) & 0x1F) << 11));
+#endif
+                    *(pDst + 4) = (uint16)tmp0;
+                }
+                else /* temp ==6 */
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)rgb;
+                    *(pDst + 2) = (uint16)rgb;
+                    *(pDst + 3) = (uint16)tmp0;
+                    *(pDst + 4) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 4) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 4) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 4) / 5) & 0x1F) << 11));
+                    *(pDst + 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F) * 3) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F) * 3) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F) * 3) / 5) & 0x1F) << 11));
+                    *(pDst + 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F) * 2) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F) * 2) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F) * 2) / 5) & 0x1F) << 11));
+                    *(pDst + 4) = (((((tmp0      & 0x1F) * 4 + (rgb     & 0x1F)) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 4 + ((rgb >> 5) & 0x3F)) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 4 + ((rgb >> 11) & 0x1F)) / 5) & 0x1F) << 11));
+#endif
+                    *(pDst + 5) = (uint16)tmp0;
+                }
+
+                pDst -= dst_pitch;
+
+                Y = *pY++;
+                tmp0    =       Y & 0xFF;       //top left
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                rgb =   tmp1 | (tmp0 << 6);
+                rgb =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;                  //top right
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+                if (temp == 2)
+                {
+                    *pDst = (uint16)rgb;
+                    *(pDst + 1) = (uint16)tmp0;
+                }
+                else if (temp == 3)
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                    *(pDst + 2) = (uint16)tmp0;
+                }
+                else if (temp == 4)
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)rgb;
+                    *(pDst + 2) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 2) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+                    *(pDst + 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F)) / 3) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+#endif
+                    *(pDst + 3) = (uint16)tmp0;
+                }
+                else if (temp == 5)
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)rgb;
+                    *(pDst + 2) = (uint16)tmp0;
+                    *(pDst + 3) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 3) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 3) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 3) / 4) & 0x1F) << 11));
+                    *(pDst + 2) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(pDst + 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F)) / 4) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F)) / 4) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F)) / 4) & 0x1F) << 11));
+#endif
+                    *(pDst + 4) = (uint16)tmp0;
+                }
+                else /* temp ==6 */
+                {
+                    *pDst = (uint16)rgb;
+#ifndef INTERPOLATE
+                    *(pDst + 1) = (uint16)rgb;
+                    *(pDst + 2) = (uint16)rgb;
+                    *(pDst + 3) = (uint16)tmp0;
+                    *(pDst + 4) = (uint16)tmp0;
+#else
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F) * 4) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 4) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 4) / 5) & 0x1F) << 11));
+                    *(pDst + 2) = (((((tmp0      & 0x1F) * 2 + (rgb     & 0x1F) * 3) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F) * 3) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F) * 3) / 5) & 0x1F) << 11));
+                    *(pDst + 3) = (((((tmp0      & 0x1F) * 3 + (rgb     & 0x1F) * 2) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 3 + ((rgb >> 5) & 0x3F) * 2) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 3 + ((rgb >> 11) & 0x1F) * 2) / 5) & 0x1F) << 11));
+                    *(pDst + 4) = (((((tmp0      & 0x1F) * 4 + (rgb     & 0x1F)) / 5) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F) * 4 + ((rgb >> 5) & 0x3F)) / 5) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F) * 4 + ((rgb >> 11) & 0x1F)) / 5) & 0x1F) << 11));
+#endif
+                    *(pDst + 5) = (uint16)tmp0;
+                }
+                pDst += temp;
+
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            pDst -= (disp[4]);  //goes back to the beginning of the line;
+
+#ifdef INTERPOLATE
+
+            if (copyline&0x1)   //Maruyama comment:BLACK line in SubQCIF.bmp
+            {
+                memcpy(prev_pDst + offset,             prev_pDst + dst_pitch, dst_width*2);
+            }
+            if (copyline&0x2)   //Maruyama comment:BLUE line in SubQCIF.bmp
+            {
+                for (i = 0 ; i < dst_width ; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + dst_pitch + i);
+                    //              int32 curtemp = *(pDst+dst_pitch+i);
+                    int32 curtemp = *(pDst + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + prev_offset + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+prev_offset+dst_pitch+i) = 0x1F;
+                }
+            }
+
+            if (copyline&0x4)
+            {
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + dst_pitch + i);
+                    //              int32 curtemp = *(pDst+dst_pitch+i);
+                    int32 curtemp = *(pDst + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + prev_offset + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+prev_offset+dst_pitch+i) = 0x3F<<5;
+                }
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + dst_pitch + i);
+                    int32 curtemp = *(pDst + dst_pitch + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + prev_offset + dst_pitch*2 + i) = (uint16)coltemp;
+                    //              *(prev_pDst+prev_offset+dst_pitch*2+i) = 0x1F<<11;
+                }
+            }
+
+            if (copyline&0x8)   //Maruyama comment:WHITE line in SubQCIF.bmp
+            {
+                for (i = 0 ; i < dst_width ; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *(pDst - dst_pitch + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+dst_pitch+i) = 0xFFFF;
+                }
+            }
+
+            if (copyline&0x10)
+            {
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    //              int32 curtemp = *(pDst+i);
+                    int32 curtemp = *(pDst - dst_pitch + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                    //              *(prev_pDst+dst_pitch+i) = 0x1F|(0x3F<<5);
+                }
+                for (i = 0 ; i < dst_width ; i++)   //Maruyama comment:Not appeared in SubQCIF.bmp
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *(pDst + i);
+                    coltemp   = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch*2 + i) = (uint16)coltemp;
+                    //              *(prev_pDst+dst_pitch*2+i) = 0x1F|(0x1F<<11);
+                }
+            }
+#endif
+            //copy down
+            offset = (colpix[0] * dst_pitch);
+
+#ifdef INTERPOLATE
+            copyline = 0;   //maru
+            prev_pDst = pDst;   //maru
+            prev_offset = offset;   //maru
+#endif
+            if (colpix[-1] && colpix[0] != 1)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + offset, pDst + dst_pitch, dst_width*2);
+#else
+                copyline |= 0x1;    //maru
+#endif
+            }
+            if (colpix[-1] == 2)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + offset + dst_pitch, pDst + dst_pitch, dst_width*2);
+#else
+                copyline |= 0x2;    //maru
+#endif
+            }
+            else if (colpix[-1] == 3)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + offset + dst_pitch, pDst + dst_pitch, dst_width*2);
+                memcpy(pDst + offset + dst_pitch*2, pDst + dst_pitch, dst_width*2);
+#else
+                copyline |= 0x4;    //maru
+#endif
+            }
+
+            //copy up
+            if (colpix[0] == 2)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + dst_pitch, pDst, dst_width*2);
+#else
+                copyline |= 0x8;    //maru
+#endif
+            }
+            else if (colpix[0] == 3)
+            {
+#ifndef INTERPOLATE
+                memcpy(pDst + dst_pitch, pDst, dst_width*2);
+                memcpy(pDst + dst_pitch*2, pDst, dst_width*2);
+#else
+                copyline |= 0x10;   //maru
+#endif
+            }
+
+            pDst    +=  dst_pitch * (colpix[-1] + colpix[0]);
+            colpix -= 2;
+        }//end of row
+
+#ifdef INTERPOLATE
+        if (copyline&0x1)   //Maruyama comment:BLACK line in SubQCIF.bmp
+        {
+            memcpy(prev_pDst + offset,             prev_pDst + dst_pitch, dst_width*2);
+        }
+        if (copyline&0x2)   //Maruyama comment:BLUE line in SubQCIF.bmp
+        {
+            memcpy(prev_pDst + offset + dst_pitch, prev_pDst + dst_pitch, dst_width*2);
+        }
+
+        if (copyline&0x4)
+        {
+            memcpy(prev_pDst + offset + dst_pitch, prev_pDst + dst_pitch, dst_width*2);
+            memcpy(prev_pDst + offset + dst_pitch*2, prev_pDst + dst_pitch, dst_width*2);
+        }
+#endif
+    }
+
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+    OSCL_UNUSED_ARG(_mRowPix);
+    OSCL_UNUSED_ARG(_mColPix);
+
+    return 0;
+#endif // CCSCALING
+}
+
+/* special 5:4 scale-up color conversion */
+int32 cc16scaling54(uint8 **src, uint8 *dst,
+                    int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat)
+{
+#if CCSCALING
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaDst, deltaCbCr;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32 rgb1, rgb2;
+    int32  tmp01, tmp02;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+#ifdef INTERPOLATE
+    int copyline = 0, i;
+    uint16 *pFifth, *previous, *current;
+#endif
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+
+
+    if (((disp[6] == 1) && (disp[7] == 0)) || ((disp[6] == 0) && (disp[7] == 1))) /* rotate 180, no flip  || rotate 0 and flip */
+    {
+        if (disp[6])
+        {
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+        else
+        {
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            pY = (uint16 *) src[0];
+            src_pitch >>= 1;
+            pCb = src[1];
+            pCr = src[2];
+        }
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+
+        deltaDst    = (dst_pitch << 1) + disp[4] - 1;   /* disp[4] is dst_width */
+        pDst = (uint16 *)dst + disp[4] - 1;
+        for (row = disp[3]; row > 0; row -= 2)
+        {
+
+            for (col = src_width - 1; col >= 0; col -= 4)  /* do 8 pixels at a time, 4 ups 2 downs */
+            {
+
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *(pDst + dst_pitch) = rgb;  // i1 = p1;/* save left pixel, have to save separately */
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp02   =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *(pDst + dst_pitch - 1) = (((((tmp02 & 0x1F) * 3  + (rgb & 0x1F) + 2) / 4) & 0x1F)
+                                           | ((((((tmp02 >> 5) & 0x3F) * 3  + ((rgb >> 5) & 0x3F)  + 2) / 4) & 0x3F) << 5)
+                                           | ((((((tmp02 >> 11) & 0x1F) * 3  + ((rgb >> 11) & 0x1F)  + 2) / 4) & 0x1F) << 11));
+                //i2 = (p1 + 3*p2 + 2)>>2;
+#else
+                *(pDst + dst_pitch - 1) = tmp02; /* save right pixel */
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *pDst-- =   rgb; // i1 = p1;    /* save left pixel */
+
+                Y   >>= 8;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp01   =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *(pDst--) = (((((tmp01 & 0x1F) * 3  + (rgb & 0x1F) + 2) / 4) & 0x1F)
+                             | ((((((tmp01 >> 5) & 0x3F) * 3  + ((rgb >> 5) & 0x3F)  + 2) / 4) & 0x3F) << 5)
+                             | ((((((tmp01 >> 11) & 0x1F) * 3  + ((rgb >> 11) & 0x1F)  + 2) / 4) & 0x1F) << 11));
+                //i2 = (p1 + 3*p2 + 2)>>2;
+#else
+                *pDst-- = tmp01;    /* save right pixel */
+#endif
+                /* now do another 4 pixels add 1 pixels in the last column */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb2        =   tmp2 | (rgb << 5);
+
+#ifdef INTERPOLATE
+                // i3 = (p2 + p3 + 1)>>1;
+                *(pDst + dst_pitch) = (((((tmp02 & 0x1F)  + (rgb2 & 0x1F) + 1) / 2) & 0x1F)
+                                       | ((((((tmp02 >> 5) & 0x3F)  + ((rgb2 >> 5) & 0x3F)  + 1) / 2) & 0x3F) << 5)
+                                       | ((((((tmp02 >> 11) & 0x1F)  + ((rgb2 >> 11) & 0x1F)  + 1) / 2) & 0x1F) << 11));
+#else
+                *(pDst + dst_pitch) = rgb2;  /* save left pixel, have to save separately */
+#endif
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                //i4 = (3*p3 + p4 + 2)>>2;
+                *(pDst + dst_pitch - 1) = (((((tmp0 & 0x1F)  + (rgb2 & 0x1F) * 3 + 1) / 4) & 0x1F)
+                                           | ((((((tmp0 >> 5) & 0x3F)  + ((rgb2 >> 5) & 0x3F) * 3  + 1) / 4) & 0x3F) << 5)
+                                           | ((((((tmp0 >> 11) & 0x1F)  + ((rgb2 >> 11) & 0x1F) * 3  + 1) / 4) & 0x1F) << 11));
+#else
+                *(pDst + dst_pitch - 1) = tmp0; /* save right pixel */
+#endif
+                *(pDst + dst_pitch - 2) = tmp0; // i5 = p4; /* save right pixel */
+
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb1    =   tmp2 | (rgb << 5);
+
+#ifdef INTERPOLATE
+                *pDst-- = (((((tmp01 & 0x1F)  + (rgb1 & 0x1F) + 1) / 2) & 0x1F)
+                           | ((((((tmp01 >> 5) & 0x3F)  + ((rgb1 >> 5) & 0x3F)  + 1) / 2) & 0x3F) << 5)
+                           | ((((((tmp01 >> 11) & 0x1F)  + ((rgb1 >> 11) & 0x1F)  + 1) / 2) & 0x1F) << 11));
+#else
+                *pDst-- =   rgb1;   /* save left pixel */
+#endif
+
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *pDst-- = (((((tmp0 & 0x1F)  + (rgb1 & 0x1F) * 3 + 1) / 4) & 0x1F)
+                           | ((((((tmp0 >> 5) & 0x3F)  + ((rgb1 >> 5) & 0x3F) * 3  + 1) / 4) & 0x3F) << 5)
+                           | ((((((tmp0 >> 11) & 0x1F)  + ((rgb1 >> 11) & 0x1F) * 3  + 1) / 4) & 0x1F) << 11));
+#else
+                *pDst-- = tmp0; /* save right pixel */
+#endif
+                *pDst-- = tmp0; /* save right pixel */
+
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            pDst++; // go back to the beginning of the line
+            if (!(row&0x3))
+            {
+                memcpy(pDst + (dst_pitch << 1), pDst + dst_pitch, 2*disp[4]);
+                pDst += dst_pitch;
+#ifdef INTERPOLATE
+                previous = pDst - dst_pitch;
+
+                for (i = 0; i < disp[4]; i++)   // linear interpolation
+                {
+                    int32   last = previous[i];
+                    int32 curr = pDst[i];
+                    pDst[i] = (((((last      & 0x1F)  + (curr     & 0x1F)) / 2) & 0x1F)
+                               | ((((((last >> 5) & 0x3F)  + ((curr >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                               | ((((((last >> 11) & 0x1F)  + ((curr >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+#endif
+            }
+
+            pDst += (deltaDst); //coz pDst defined as UINT *
+        }
+    }
+    else
+    {
+        if (disp[6]) /* rotate 180 and flip */
+        {
+            /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+        else // no rotation,no flip,only scale
+        {
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            pY = (uint16 *) src[0];
+            src_pitch >>= 1;
+            pCb = src[1];
+            pCr = src[2];
+
+        }
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+
+        deltaDst    = (dst_pitch << 1) - disp[4];   /* disp[4] is dst_width */
+        pDst = (uint16 *)dst;
+
+        for (row = disp[3]; row > 0; row -= 2)
+        {
+
+            for (col = src_width - 1; col >= 0; col -= 4)  /* do 8 pixels at a time, 4 ups 2 downs */
+            {
+
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *(pDst + dst_pitch) = rgb;  /* save left pixel, have to save separately */
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp02   =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *(pDst + dst_pitch + 1) = (((((tmp02 & 0x1F) * 3  + (rgb & 0x1F) + 2) / 4) & 0x1F)
+                                           | ((((((tmp02 >> 5) & 0x3F) * 3  + ((rgb >> 5) & 0x3F)  + 2) / 4) & 0x3F) << 5)
+                                           | ((((((tmp02 >> 11) & 0x1F) * 3  + ((rgb >> 11) & 0x1F)  + 2) / 4) & 0x1F) << 11));
+                //i2 = (p1 + 3*p2 + 2)>>2;
+#else
+                *(pDst + dst_pitch + 1) = tmp02; /* save right pixel */
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *pDst++ =   rgb;    /* save left pixel */
+
+                Y   >>= 8;
+
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp01   =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *(pDst++) = (((((tmp01 & 0x1F) * 3  + (rgb & 0x1F) + 2) / 4) & 0x1F)
+                             | ((((((tmp01 >> 5) & 0x3F) * 3  + ((rgb >> 5) & 0x3F)  + 2) / 4) & 0x3F) << 5)
+                             | ((((((tmp01 >> 11) & 0x1F) * 3  + ((rgb >> 11) & 0x1F)  + 2) / 4) & 0x1F) << 11));
+                //i2 = (p1 + 3*p2 + 2)>>2;
+#else
+                *pDst++ = tmp01;    /* save right pixel */
+#endif
+                /* now do another 4 pixels add 1 pixels in the last column */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb2        =   tmp2 | (rgb << 5);
+#ifdef INTERPOLATE
+                // i3 = (p2 + p3 + 1)>>1;
+                *(pDst + dst_pitch) = (((((tmp02 & 0x1F)  + (rgb2 & 0x1F) + 1) / 2) & 0x1F)
+                                       | ((((((tmp02 >> 5) & 0x3F)  + ((rgb2 >> 5) & 0x3F)  + 1) / 2) & 0x3F) << 5)
+                                       | ((((((tmp02 >> 11) & 0x1F)  + ((rgb2 >> 11) & 0x1F)  + 1) / 2) & 0x1F) << 11));
+#else
+                *(pDst + dst_pitch) = rgb2;  /* save left pixel, have to save separately */
+#endif
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *(pDst + dst_pitch + 1) = (((((tmp0 & 0x1F)  + (rgb2 & 0x1F) * 3 + 1) / 4) & 0x1F)
+                                           | ((((((tmp0 >> 5) & 0x3F)  + ((rgb2 >> 5) & 0x3F) * 3  + 1) / 4) & 0x3F) << 5)
+                                           | ((((((tmp0 >> 11) & 0x1F)  + ((rgb2 >> 11) & 0x1F) * 3  + 1) / 4) & 0x1F) << 11));
+#else
+                *(pDst + dst_pitch + 1) = tmp0; /* save right pixel */
+#endif
+                *(pDst + dst_pitch + 2) = tmp0; /* save right pixel */ //Ankur
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb1        =   tmp2 | (rgb << 5);
+#ifdef INTERPOLATE
+                *pDst++ = (((((tmp01 & 0x1F)  + (rgb1 & 0x1F) + 1) / 2) & 0x1F)
+                           | ((((((tmp01 >> 5) & 0x3F)  + ((rgb1 >> 5) & 0x3F)  + 1) / 2) & 0x3F) << 5)
+                           | ((((((tmp01 >> 11) & 0x1F)  + ((rgb1 >> 11) & 0x1F)  + 1) / 2) & 0x1F) << 11));
+#else
+                *pDst++ =   rgb1;   /* save left pixel */
+#endif
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                *pDst++ = (((((tmp0 & 0x1F)  + (rgb1 & 0x1F) * 3 + 1) / 4) & 0x1F)
+                           | ((((((tmp0 >> 5) & 0x3F)  + ((rgb1 >> 5) & 0x3F) * 3  + 1) / 4) & 0x3F) << 5)
+                           | ((((((tmp0 >> 11) & 0x1F)  + ((rgb1 >> 11) & 0x1F) * 3  + 1) / 4) & 0x1F) << 11));
+#else
+                *pDst++ = tmp0; /* save right pixel */
+#endif
+                *pDst++ = tmp0; /* save right pixel */ // Ankur
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            pDst += (deltaDst); //coz pDst defined as UINT *
+
+            /************
+                interpolating 3rd row in between
+                row1
+                row2
+                inter1
+                row3
+                row4
+            **************/
+
+            if (!(row&0x3))
+            {
+#ifdef INTERPOLATE
+                pFifth = pDst; // interpolating 3rd line in between
+                copyline = 0;
+#else
+                memcpy(pDst, pDst - dst_pitch, 2*disp[4]);
+#endif
+                pDst += dst_pitch;
+            }
+#ifdef INTERPOLATE
+            if (copyline)
+            {
+                previous = pFifth - dst_pitch;
+                current = pDst - (dst_pitch * 2);
+
+                for (i = 0; i < disp[4]; i++)   // linear interpolation
+                {
+                    int32   last = previous[i];
+                    int32 curr = current[i];
+                    pFifth[i] = (((((last      & 0x1F)  + (curr     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((last >> 5) & 0x3F)  + ((curr >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((last >> 11) & 0x1F)  + ((curr >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+
+            }
+
+            copyline++;
+#endif
+        }
+    }
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+
+    return 0;
+#endif // CCSCALING
+}
+
+/* special 4:3 scale-up color conversion */
+int32 cc16scaling43(uint8 **src, uint8 *dst,
+                    int32 *disp, uint8 *coff_tbl, OMX_COLOR_FORMATTYPE colorFormat)
+{
+#if CCSCALING
+    uint8 *pCb, *pCr;
+    uint16  *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, deltaCbCr;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32 col3, row3;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+#ifdef INTERPOLATE
+    int i;
+    uint32  copyline = 0;   //maru
+    uint16  *prev_pDst = 0; //maru
+    int32   prev_offset = 0;    //maru
+#endif
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+
+    if (((disp[6] == 0 && disp[7] == 1)) || ((disp[6] == 1) && (disp[7] == 0)))  /* rotate 0 and flip // rotate 180, no flip*/
+    {
+        if (disp[6] == 0)
+        {
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            pY = (uint16 *) src[0];
+            src_pitch >>= 1;
+            pCb = src[1];
+            pCr = src[2];
+        }
+        else
+        {   /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+
+        pDst = ((uint16 *)dst) + disp[4] - 1;
+        row3 = 2;
+        for (row = disp[3]; row > 0; row -= 2)
+        {
+            col3 = 2;
+            if (row3 == 1)
+            {
+                dst_pitch <<= 1;
+            }
+
+            for (col = src_width - 1; col >= 0; col -= 4)
+            { /* do 8 pixels at a time, 2 ups 2 downs */
+                Cb = *pCb;
+                Cr = *pCr;
+
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *(pDst += dst_pitch) = rgb;  /* save left pixel, have to save separately */
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                if (col3 == 0)
+                {
+#ifndef INTERPOLATE
+                    //*(++pDst) = rgb; /* repeat this pixel */
+                    *(--pDst) = rgb; /* repeat this pixel */
+#else
+                    *(--pDst) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                }
+#ifndef INTERPOLATE
+                //*(pDst+1) = tmp0; /* save right pixel */Ankur
+                *(pDst - 1) = tmp0; /* save right pixel */
+                if (col3 == 1)
+                {
+                    //*(pDst+2) = tmp0; /* repeat this pixel */Ankur
+                    *(pDst - 2) = tmp0; /* repeat this pixel */
+                }
+#else
+                if (col3 != 1)
+                {
+                    *(pDst - 1) = tmp0;
+                }
+                else
+                {
+                    *(pDst - 2) = tmp0;
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+#endif
+
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifndef INTERPOLATE
+                *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                if (col3 == 0)
+                {
+                    pDst[1] = rgb; /* repeat this pixel */
+                }
+#else
+                if (col3 != 0)
+                {
+                    *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                }
+                else
+                {
+                    *(pDst -= dst_pitch) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                            | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                            | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    pDst[1] = rgb;
+                }
+#endif
+#ifndef INTERPOLATE
+                *(--pDst)   = tmp0; /* save right pixel */
+                if (col3 == 1)
+                {
+                    *(--pDst)   = tmp0; /* save right pixel */
+                }
+#else
+                if (col3 != 1)
+                {
+                    *(--pDst)   = tmp0; /* save right pixel */
+                }
+                else
+                {
+                    *(--pDst) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(--pDst) = tmp0;
+                }
+#endif
+
+                pDst--;
+
+                Cb = *pCb;
+                Cr = *pCr;
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *(pDst += dst_pitch) = rgb;  /* save left pixel, have to save separately */
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                if (col3 == 2)
+                {
+#ifndef INTERPOLATE
+                    *(--pDst) = rgb;
+#else
+                    *(--pDst) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                }
+
+#ifndef INTERPOLATE
+                *(pDst - 1) = tmp0; /* save right pixel */
+                if (col3 == 0)
+                {
+                    *(pDst - 2) = tmp0; /* repeat this pixel */
+                }
+#else
+                if (col3 != 0)
+                {
+                    *(pDst - 1) = tmp0; /* save right pixel */
+                }
+                else
+                {
+                    *(pDst - 2) = tmp0; /* save right pixel */
+                    *(pDst - 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+#endif
+
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+#ifndef INTERPOLATE
+                *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                if (col3 == 2)
+                {
+                    pDst[1] = rgb; /* repeat this pixel */
+                }
+#else
+                if (col3 != 2)
+                {
+                    *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                }
+                else
+                {
+                    *(pDst -= dst_pitch)    = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                               | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                               | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    pDst[1] = rgb;
+                }
+#endif
+
+#ifndef INTERPOLATE
+                *(--pDst)   = tmp0; /* save right pixel */
+                if (col3 == 0)
+                {
+                    *(--pDst)   = tmp0;
+                }
+#else
+                if (col3 != 0)
+                {
+                    *(--pDst)   = tmp0; /* save right pixel */
+                }
+                else
+                {
+                    *(--pDst)   = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(--pDst)   = tmp0; /* save right pixel */
+                }
+#endif
+
+                pDst--;
+
+                col3--;
+                if (col3 < 0)
+                {
+                    col3 = 2;
+                }
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            if (row3 == 1)
+            {
+                dst_pitch >>= 1;
+            }
+            dst += (dst_pitch << 2);
+
+            if (row3 == 1)
+            {
+#ifndef INTERPOLATE
+                memcpy(dst - (dst_pitch << 1), dst - (dst_pitch << 2), 2*disp[4]);
+#else
+                prev_pDst = (uint16*)(dst - (dst_pitch << 2));
+                for (i = 0; i < dst_pitch; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *((uint16*)dst + i);
+                    coltemp = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                               | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                               | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                }
+#endif
+                dst += (dst_pitch << 1);
+            }
+            else if (row3 == 0)
+            {
+                memcpy(dst, dst - (dst_pitch << 1), 2*disp[4]);
+#ifdef INTERPOLATE
+                prev_pDst = (uint16*)(dst - (dst_pitch << 2));
+                for (i = 0; i < dst_pitch; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *((uint16*)dst + i);
+                    coltemp = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                               | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                               | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                }
+#endif
+                dst += (dst_pitch << 1);
+            }
+            row3--;
+
+            if (row3 < 0)
+            {
+                row3 = 2;
+            }
+
+            pDst = ((uint16*)dst) + disp[4] - 1;
+        }
+    }
+    else  /* rotate 180 and flip || no rotation,no flip */
+    {
+        if (disp[6]) /* rotate 180 and flip */
+        {
+            /* move the starting point to the bottom-left corner of the picture */
+            deltaY = src_pitch * (disp[3] - 1);
+            pY = (uint16*)(src[0] + deltaY);
+            deltaY = (src_pitch >> 1) * ((disp[3] >> 1) - 1);
+            pCb = src[1] + deltaY;
+            pCr = src[2] + deltaY;
+            deltaY = -src_width - (src_pitch << 1);
+            deltaCbCr = -((src_width + src_pitch) >> 1);
+            src_pitch = -(src_pitch >> 1);
+        }
+        else // no rotation,no flip
+        {
+            deltaY      = (src_pitch << 1) - src_width;
+            deltaCbCr   = (src_pitch - src_width) >> 1;
+            pY = (uint16 *) src[0];
+            src_pitch >>= 1;
+            pCb = src[1];
+            pCr = src[2];
+        }
+
+        if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+            deltaCbCr *= 2;
+
+        pDst = (uint16 *)dst;
+        row3 = 2;
+
+        for (row = disp[3]; row > 0; row -= 2)
+        {
+            col3 = 2;
+
+            if (row3 == 1)
+            {
+                dst_pitch <<= 1;
+            }
+
+            for (col = src_width - 1; col >= 0; col -= 4)
+            { /* do 8 pixels at a time, 2 ups 2 downs */
+                Cb = *pCb;
+                Cr = *pCr;
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                *(pDst += dst_pitch) = rgb;  /* save left pixel, have to save separately */
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+                if (col3 == 0)
+                {
+#ifndef INTERPOLATE
+                    *(++pDst) = rgb; /* repeat this pixel */
+#else
+                    *(++pDst) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                }
+
+#ifndef INTERPOLATE
+                *(pDst + 1) = tmp0; /* save right pixel */
+                if (col3 == 1)
+                {
+                    *(pDst + 2) = tmp0; /* repeat this pixel */
+                }
+#else
+                if (col3 != 1)
+                {
+                    *(pDst + 1) = tmp0;
+                }
+                else
+                {
+                    *(pDst + 2) = tmp0;
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifndef INTERPOLATE
+                *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                if (col3 == 0)
+                {
+                    pDst[-1] = rgb; /* repeat this pixel */
+                }
+#else
+                if (col3 != 0)
+                {
+                    *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                }
+                else
+                {
+                    *(pDst -= dst_pitch) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                            | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                            | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    pDst[-1] = rgb;
+                }
+#endif
+
+#ifndef INTERPOLATE
+                *(++pDst)   = tmp0; /* save right pixel */
+                if (col3 == 1)
+                {
+                    *(++pDst)   = tmp0; /* save right pixel */
+                }
+#else
+                if (col3 != 1)
+                {
+                    *(++pDst)   = tmp0; /* save right pixel */
+                }
+                else
+                {
+                    *(++pDst) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(++pDst) = tmp0;
+                }
+#endif
+                pDst++;
+
+                Cb = *pCb;
+                Cr = *pCr;
+                if(colorFormat == OMX_COLOR_FormatYUV420Planar){
+                    pCb ++;
+                    pCr ++;
+                }
+                else{
+                    pCb +=  2;
+                    pCr +=  2;
+                }
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                //load the bottom two pixels
+                Y = pY[src_pitch];
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_0;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                //RGB_565
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                *(pDst += dst_pitch) = rgb;
+
+                Y   >>= 8;
+                Y   += OFFSET_5_1;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+                //RGB_565
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+                if (col3 == 2)
+                {
+#ifndef INTERPOLATE
+                    *(++pDst) = rgb; /* repeat this pixel */
+#else
+                    *(++pDst) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                 | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                 | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+#endif
+                }
+
+#ifndef INTERPOLATE
+                *(pDst + 1) = tmp0; /* save right pixel */
+                if (col3 == 0)
+                {
+                    *(pDst + 2) = tmp0; /* repeat this pixel */
+                }
+#else
+                if (col3 != 0)
+                {
+                    *(pDst + 1) = tmp0; /* save right pixel */
+                }
+                else
+                {
+                    *(pDst + 2) = tmp0; /* save right pixel */
+                    *(pDst + 1) = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                }
+#endif
+                //load the top two pixels
+                Y = *pY++;
+
+                tmp0    =   Y & 0xFF;   //Low endian    left pixel
+                tmp0    += OFFSET_5_1;
+
+                tmp1    =   tmp0 - (Cg >> 16);
+                tmp2    =   tmp0 + (Cb >> 16);
+                tmp0    =   tmp0 + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                tmp2    =   clip[tmp2];
+
+
+                rgb     =   tmp1 | (tmp0 << 6);
+                rgb     =   tmp2 | (rgb << 5);
+
+                Y   >>= 8;
+                Y   += OFFSET_5_0;
+                tmp1    = (Y) - (Cg >> 16);
+                tmp2    = (Y) + (Cb >> 16);
+                tmp0    = (Y) + (Cr >> 16);
+
+                tmp0    =   clip[tmp0];
+                tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                tmp2    =   clip[tmp2];
+
+                tmp0    =   tmp1 | (tmp0 << 6);
+                tmp0    =   tmp2 | (tmp0 << 5);
+#ifndef INTERPOLATE
+                *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                if (col3 == 2)
+                {
+                    pDst[-1] = rgb; /* repeat this pixel */
+                }
+#else
+                if (col3 != 2)
+                {
+                    *(pDst -= dst_pitch)    =   rgb;    /* save left pixel */
+                }
+                else
+                {
+                    *(pDst -= dst_pitch)    = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                               | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                               | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    pDst[-1] = rgb;
+                }
+#endif
+
+#ifndef INTERPOLATE
+                *(++pDst)   = tmp0; /* save right pixel */
+                if (col3 == 0)
+                {
+                    *(++pDst)   = tmp0; /* save right pixel */
+                }
+#else
+                if (col3 != 0)
+                {
+                    *(++pDst)   = tmp0; /* save right pixel */
+                }
+                else
+                {
+                    *(++pDst)   = (((((tmp0      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((tmp0 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((tmp0 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(++pDst)   = tmp0; /* save right pixel */
+                }
+#endif
+                pDst++;
+
+                col3--;
+                if (col3 < 0)
+                {
+                    col3 = 2;
+                }
+            }//end of COL
+
+            pY  += (deltaY >> 1);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+            if (row3 == 1)
+            {
+                dst_pitch >>= 1;
+            }
+            dst += (dst_pitch << 2);
+            if (row3 == 1)
+            {
+#ifndef INTERPOLATE
+                memcpy(dst - (dst_pitch << 1), dst - (dst_pitch << 2), 2*disp[4]);
+#else
+                prev_pDst = (uint16*)(dst - (dst_pitch << 2));
+                for (i = 0; i < dst_pitch; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *((uint16*)dst + i);
+                    coltemp = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                               | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                               | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                }
+#endif
+                dst += (dst_pitch << 1);
+            }
+            else if (row3 == 0)
+            {
+                memcpy(dst, dst - (dst_pitch << 1), 2*disp[4]);
+
+#ifdef INTERPOLATE
+                prev_pDst = (uint16*)(dst - (dst_pitch << 2));
+                for (i = 0; i < dst_pitch; i++)
+                {
+                    int32 coltemp;
+                    int32 pretemp = *(prev_pDst + i);
+                    int32 curtemp = *((uint16*)dst + i);
+                    coltemp = (((((pretemp      & 0x1F)  + (curtemp     & 0x1F)) / 2) & 0x1F)
+                               | ((((((pretemp >> 5) & 0x3F)  + ((curtemp >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                               | ((((((pretemp >> 11) & 0x1F)  + ((curtemp >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+                    *(prev_pDst + dst_pitch + i) = (uint16)coltemp;
+                }
+#endif
+                dst += (dst_pitch << 1);
+            }
+
+            row3--;
+            if (row3 < 0)
+            {
+                row3 = 2;
+            }
+
+            pDst = (uint16*)dst;
+        }
+    }
+
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+
+    return 0;
+#endif // CCSCALING
+}
+
+
+// platform specfic function in C
+int32 cc16sc_rotate(uint8 **src, uint8 *dst, int32 *disp,
+                    uint8 *coff_tbl, uint8 *_mRowPix,
+                    uint8 *_mColPix, bool _mIsRotateClkwise, int32 flip, OMX_COLOR_FORMATTYPE colorFormat); // ankur
+
+/////////////////////////////////////////////////////////////////////////////
+// Note:: This zoom algorithm needs an extra line of RGB buffer. So, users
+// have to use GetRGBBufferSize API to get the size it needs. See GetRGBBufferSize().
+int32 ColorConvert16::cc16ZoomRotate(uint8 **src, uint8 *dst,
+                                     DisplayProperties *disp, uint8 *coff_tbl)
+{
+    int32 disp_prop[6];
+    int32 flip; // ankur
+
+    disp_prop[0] = disp->src_pitch;
+    disp_prop[1] = disp->dst_pitch;
+    disp_prop[2] = disp->src_width;
+    disp_prop[3] = disp->src_height;
+    disp_prop[4] = disp->dst_width;
+    disp_prop[5] = disp->dst_height;
+
+    flip = _mIsFlip;
+    return cc16sc_rotate(src, dst, disp_prop, coff_tbl, _mRowPix, _mColPix, (_mRotation == CCROTATE_CLKWISE), flip, _mColorFormat);
+}
+
+int32 cc16sc_rotate(uint8 **src, uint8 *dst, int32 *disp,
+                    uint8 *coff_tbl, uint8 *_mRowPix,
+                    uint8 *_mColPix, bool _mIsRotateClkwise, int32 flip, OMX_COLOR_FORMATTYPE colorFormat) // ankur
+{
+#if (CCROTATE && CCSCALING)
+    /*  1. move the dst pointer to the line above the border
+    2. do 2 line conversion
+    3. copy both up & down
+        */
+    uint8 *pCb, *pCr;
+    uint8   *pY;
+    uint16  *pDst;
+    int32       src_pitch, dst_pitch, src_width;
+    int32       Y, Cb, Cr, Cg;
+    int32       deltaY, dst_width, deltaCbCr, dst_inc, dst_start_pos;
+    int32       row, col;
+    int32       tmp0, tmp1, tmp2;
+    uint32  rgb;
+    uint8 *clip = coff_tbl + 400;
+    int32       offset;
+    int32  cc1 = (*((int32*)(clip - 400)));
+    int32  cc3 = (*((int32*)(clip - 396)));
+    int32  cc2 = (*((int32*)(clip - 392)));
+    int32  cc4 = (*((int32*)(clip - 388)));
+
+    src_pitch   =   disp[0];
+    dst_pitch   =   disp[1];
+    src_width   =   disp[2];
+    dst_width   =  disp[4];
+
+#ifdef INTERPOLATE
+    int32 prgb1;
+    int32 prgb2;
+    int32 prgb3;
+    int32 prgb4;
+#endif
+
+    if (_mIsRotateClkwise)
+    {
+        deltaY      =  src_pitch * disp[3] + 2;
+        deltaCbCr   = ((src_pitch * disp[3]) >> 2) + 1;
+    }
+    else // rotate counterclockwise
+    {
+        deltaY      =  -(src_pitch * disp[3] + 2);
+        deltaCbCr   =  -(((src_pitch * disp[3]) >> 2) + 1);
+    }
+
+    if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar)
+        deltaCbCr *= 2;
+
+    // map origin of the destination to the source
+    if (_mIsRotateClkwise)
+    {
+        pY = src[0] + src_pitch * (disp[3] - 1);
+        pCb = src[1] + ((src_pitch >> 1) * ((disp[3] >> 1) - 1));
+        pCr = src[2] + ((src_pitch >> 1) * ((disp[3] >> 1) - 1));
+    }
+    else // rotate counterclockwise
+    {
+        pY = src[0] + src_width - 1;
+        pCb = src[1] + (src_width >> 1) - 1;
+        pCr = src[2] + (src_width >> 1) - 1;
+    }
+
+    int32 half_src_pitch, read_idx, tmp_src_pitch;
+    if (_mIsRotateClkwise)
+    {
+        half_src_pitch = -(src_pitch >> 1);
+        read_idx = 1;
+        tmp_src_pitch = -src_pitch;
+    }
+    else // rotate counterclockwise
+    {
+        half_src_pitch = (src_pitch >> 1);
+        read_idx = -1;
+        tmp_src_pitch = src_pitch;
+    }
+
+    if (flip == 0)
+    {
+        dst_start_pos = 0;
+        dst_inc = 1;
+    }
+    else
+    {
+        dst_start_pos = disp[4] - 1;
+        dst_inc = -1;
+    }
+
+    pDst = (uint16 *)dst + dst_start_pos;
+
+    for (row = src_width - 1; row > 0; row -= 2)
+    { /* decrement index, _mColPix[.] is symmetric to increment index */
+
+        if ((_mColPix[row-1] == 0) && (_mColPix[row] == 0))
+        {
+            if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar){
+                pCb += read_idx*2;
+                pCr += read_idx*2;
+            }
+            else{
+                pCb += read_idx;
+                pCr += read_idx;
+            }
+            pY += (read_idx * 2);
+            continue;
+        }
+
+        if (_mColPix[row-1] + _mColPix[row] == 1) // do only one row, scale down
+        {
+            for (col = disp[3] - 2; col >= 0; col -= 2)
+            {/* decrement index, _mRowPix[.] is symmetric to increment index */
+                Cb = *pCb;
+                Cr = *pCr;
+                if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar){
+                    pCb += half_src_pitch * 2;
+                    pCr += half_src_pitch * 2;
+                }
+                else
+                {
+                    pCb += half_src_pitch;
+                    pCr += half_src_pitch;
+                }
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                if (_mRowPix[col]) /* compute this pixel */
+                {
+                    tmp0    =   pY[read_idx];       //bottom left
+
+                    tmp0    += OFFSET_5_0;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+
+                    Y   =   *pY;
+                    pY += tmp_src_pitch;    //upper left
+
+                    Y   += OFFSET_5_1;
+                    tmp1    = (Y) - (Cg >> 16);
+                    tmp2    = (Y) + (Cb >> 16);
+                    tmp0    = (Y) + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst) = (uint16)tmp0;
+
+                } /*    if(_mRowPix[col])  */
+                else
+                {
+                    pY += tmp_src_pitch;
+                }
+
+                pDst    += (dst_inc > 0 ? _mRowPix[col] : -_mRowPix[col]);
+
+                if (_mRowPix[col+1]) /* compute this pixel */
+                {
+                    tmp0    =   pY[read_idx];           //bottom right
+
+                    tmp0    += OFFSET_5_1;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+
+                    Y   =   *pY;
+                    pY += tmp_src_pitch;        //upper right
+
+                    Y   += OFFSET_5_0;
+                    tmp1    = (Y) - (Cg >> 16);
+                    tmp2    = (Y) + (Cb >> 16);
+                    tmp0    = (Y) + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+                    *(pDst) = (uint16)tmp0;
+                }/* if(_mRowPix[col])  */
+                else
+                {
+                    pY += tmp_src_pitch;
+                }
+                pDst    += (dst_inc > 0 ? _mRowPix[col+1] : -_mRowPix[col+1]);
+            }//end of COL
+            //memcpy() both up & down
+
+            pY  += (deltaY);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            pDst += dst_pitch;
+
+            if (dst_inc > 0)
+            {
+                pDst -= dst_width; //goes back to the beginning of the line;
+            }
+            else
+            {
+                pDst += dst_width;
+            }
+        }
+        else   // do two rows at least, scale up or down
+        {
+
+#ifdef INTERPOLATE
+            prgb1 = 0;
+            prgb2 = 0;
+            prgb3 = 0;
+            prgb4 = 0;
+#endif
+            for (col = disp[3] - 2; col >= 0; col -= 2)
+            {/* decrement index, _mRowPix[.] is symmetric to increment index */
+                Cb = *pCb;
+                Cr = *pCr;
+                if(colorFormat == OMX_COLOR_FormatYUV420SemiPlanar){
+                    pCb += half_src_pitch * 2;
+                    pCr += half_src_pitch * 2;
+                }
+                else
+                {
+                    pCb += half_src_pitch;
+                    pCr += half_src_pitch;
+                }
+
+                Cb -= 128;
+                Cr -= 128;
+                Cg  =   Cr * cc1;
+                Cr  *= cc3;
+
+                Cg  +=  Cb * cc2;
+                Cb  *=  cc4;
+
+                if (_mRowPix[col]) /* compute this pixel */
+                {
+                    tmp0    =   pY[read_idx];       //bottom left
+
+                    tmp0    += OFFSET_5_0;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+
+                    Y   =   *pY;
+                    pY += tmp_src_pitch;    //upper left
+
+                    Y   += OFFSET_5_1;
+                    tmp1    = (Y) - (Cg >> 16);
+                    tmp2    = (Y) + (Cb >> 16);
+                    tmp0    = (Y) + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+
+                    //RGB_565
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                    prgb3 = rgb;
+                    prgb4 = tmp0;
+#endif
+
+                    if (_mRowPix[col] == 2)
+                    {
+#ifdef INTERPOLATE
+                        *(pDst + dst_pitch) = (((((prgb1      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                               | ((((((prgb1 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                               | ((((((prgb1 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+
+                        *(pDst + dst_pitch + dst_inc)   = (uint16)rgb;
+
+                        *(pDst) = (((((prgb2      & 0x1F)  + (tmp0     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((prgb2 >> 5) & 0x3F)  + ((tmp0 >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((prgb2 >> 11) & 0x1F)  + ((tmp0 >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+
+                        *(pDst + dst_inc)   = (uint16)tmp0;
+
+#else
+                        *(pDst + dst_pitch)         = (uint16)rgb;
+                        *(pDst + dst_pitch + dst_inc)   = (uint16)rgb;
+                        *(pDst)                     = (uint16)tmp0;
+                        *(pDst + dst_inc)               = (uint16)tmp0;
+#endif
+                    }
+                    else if (_mRowPix[col] == 3)
+                    {
+#ifdef INTERPOLATE
+                        *(pDst + dst_pitch) = (((((prgb1      & 0x1F)  + (rgb     & 0x1F) * 2) / 3) & 0x1F)
+                                               | ((((((prgb1 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                               | ((((((prgb1 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+
+                        *((pDst + dst_pitch + dst_inc)) = (((((prgb1      & 0x1F) * 2 + (rgb     & 0x1F)) / 3) & 0x1F)
+                                                           | ((((((prgb1 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                                           | ((((((prgb1 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+
+                        *((pDst + dst_pitch + (dst_inc << 1)))  = (uint16)rgb ;
+
+                        *(pDst) = (((((prgb2      & 0x1F)  + (tmp0     & 0x1F) * 2) / 3) & 0x1F)
+                                   | ((((((prgb2 >> 5) & 0x3F)  + ((tmp0 >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                   | ((((((prgb2 >> 11) & 0x1F)  + ((tmp0 >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+
+                        *((pDst + dst_inc)) = (((((prgb2      & 0x1F) * 2 + (tmp0     & 0x1F)) / 3) & 0x1F)
+                                               | ((((((prgb2 >> 5) & 0x3F) * 2 + ((tmp0 >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                               | ((((((prgb2 >> 11) & 0x1F) * 2 + ((tmp0 >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+
+                        *((pDst + (dst_inc << 1)))  = (uint16)tmp0;
+#else
+                        *(pDst + dst_pitch) = (uint16)rgb;
+                        *((pDst + dst_pitch + dst_inc)) = (uint16)rgb ;
+                        *((pDst + dst_pitch + (dst_inc << 1)))  = (uint16)rgb ;
+
+                        *(pDst) = (uint16)tmp0;
+                        *((pDst + dst_inc)) = (uint16)tmp0;
+                        *((pDst + (dst_inc << 1)))  = (uint16)tmp0;
+#endif
+                    }
+                    else
+                    {
+                        *(pDst + dst_pitch) = (uint16)rgb;
+                        *(pDst) = (uint16)tmp0;
+                    }
+
+                } /*    if(_mRowPix[col])  */
+                else
+                {
+                    pY += tmp_src_pitch;
+                }
+
+                pDst    += (dst_inc > 0 ? _mRowPix[col] : -_mRowPix[col]);
+
+                if (_mRowPix[col+1]) /* compute this pixel */
+                {
+                    tmp0    =   pY[read_idx];           //bottom right
+
+                    tmp0    += OFFSET_5_1;
+
+                    tmp1    =   tmp0 - (Cg >> 16);
+                    tmp2    =   tmp0 + (Cb >> 16);
+                    tmp0    =   tmp0 + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_1 - OFFSET_5_1];
+                    tmp2    =   clip[tmp2];
+
+
+                    rgb     =   tmp1 | (tmp0 << 6);
+                    rgb     =   tmp2 | (rgb << 5);
+
+                    Y   =   *pY;
+                    pY += tmp_src_pitch;        //upper right
+
+                    Y   += OFFSET_5_0;
+                    tmp1    = (Y) - (Cg >> 16);
+                    tmp2    = (Y) + (Cb >> 16);
+                    tmp0    = (Y) + (Cr >> 16);
+
+                    tmp0    =   clip[tmp0];
+                    tmp1    =   clip[tmp1 + OFFSET_6_0 - OFFSET_5_0];
+                    tmp2    =   clip[tmp2];
+
+                    tmp0    =   tmp1 | (tmp0 << 6);
+                    tmp0    =   tmp2 | (tmp0 << 5);
+
+#ifdef INTERPOLATE
+                    prgb1 = rgb;
+                    prgb2 = tmp0;
+#endif
+                    if (_mRowPix[col+1] == 2)
+                    {
+#ifdef INTERPOLATE
+                        *(pDst + dst_pitch) = (((((prgb3      & 0x1F)  + (rgb     & 0x1F)) / 2) & 0x1F)
+                                               | ((((((prgb3 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                               | ((((((prgb3 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+
+                        *(pDst + dst_pitch + dst_inc)   = (uint16)rgb;
+
+                        *(pDst) = (((((prgb4      & 0x1F)  + (tmp0     & 0x1F)) / 2) & 0x1F)
+                                   | ((((((prgb4 >> 5) & 0x3F)  + ((tmp0 >> 5) & 0x3F)) / 2) & 0x3F) << 5)
+                                   | ((((((prgb4 >> 11) & 0x1F)  + ((tmp0 >> 11) & 0x1F)) / 2) & 0x1F) << 11));
+
+                        *(pDst + dst_inc)   = (uint16)tmp0;
+
+#else
+                        *(pDst + dst_pitch)         = (uint16)rgb;
+                        *(pDst + dst_pitch + dst_inc)   = (uint16)rgb;
+                        *(pDst)                     = (uint16)tmp0;
+                        *(pDst + dst_inc)               = (uint16)tmp0;
+#endif
+                    }
+                    else if (_mRowPix[col+1] == 3)
+                    {
+#ifdef INTERPOLATE
+                        *(pDst + dst_pitch) = (((((prgb3      & 0x1F)  + (rgb     & 0x1F) * 2) / 3) & 0x1F)
+                                               | ((((((prgb3 >> 5) & 0x3F)  + ((rgb >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                               | ((((((prgb3 >> 11) & 0x1F)  + ((rgb >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+
+                        *((pDst + dst_pitch + dst_inc)) = (((((prgb3      & 0x1F) * 2 + (rgb     & 0x1F)) / 3) & 0x1F)
+                                                           | ((((((prgb3 >> 5) & 0x3F) * 2 + ((rgb >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                                           | ((((((prgb3 >> 11) & 0x1F) * 2 + ((rgb >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+
+                        *((pDst + dst_pitch + (dst_inc << 1)))  = (uint16)rgb ;
+
+                        *(pDst) = (((((prgb4      & 0x1F)  + (tmp0     & 0x1F) * 2) / 3) & 0x1F)
+                                   | ((((((prgb4 >> 5) & 0x3F)  + ((tmp0 >> 5) & 0x3F) * 2) / 3) & 0x3F) << 5)
+                                   | ((((((prgb4 >> 11) & 0x1F)  + ((tmp0 >> 11) & 0x1F) * 2) / 3) & 0x1F) << 11));
+
+                        *((pDst + dst_inc)) = (((((prgb4      & 0x1F) * 2 + (tmp0     & 0x1F)) / 3) & 0x1F)
+                                               | ((((((prgb4 >> 5) & 0x3F) * 2 + ((tmp0 >> 5) & 0x3F)) / 3) & 0x3F) << 5)
+                                               | ((((((prgb4 >> 11) & 0x1F) * 2 + ((tmp0 >> 11) & 0x1F)) / 3) & 0x1F) << 11));
+
+                        *((pDst + (dst_inc << 1)))  = (uint16)tmp0;
+#else
+                        *(pDst + dst_pitch) = (uint16)rgb;
+                        *((pDst + dst_pitch + dst_inc)) = (uint16)rgb ;
+                        *((pDst + dst_pitch + (dst_inc << 1)))  = (uint16)rgb ;
+
+                        *(pDst) = (uint16)tmp0;
+                        *((pDst + dst_inc)) = (uint16)tmp0;
+                        *((pDst + (dst_inc << 1)))  = (uint16)tmp0;
+#endif
+                    }
+                    else
+                    {
+                        *(pDst + dst_pitch) = (uint16)rgb;
+                        *(pDst) = (uint16)tmp0;
+                    }
+                }/* if(_mRowPix[col])  */
+                else
+                {
+                    pY += tmp_src_pitch;
+                }
+                pDst    += (dst_inc > 0 ? _mRowPix[col+1] : -_mRowPix[col+1]);
+            }//end of COL
+            //memcpy() both up & down
+
+            pY  += (deltaY);
+            pCb +=  deltaCbCr;
+            pCr +=  deltaCbCr;
+
+            if (dst_inc > 0)
+            {
+                pDst -= (dst_width); //goes back to the beginning of the line;
+            }
+            else
+            {
+                pDst += 1;
+            }
+
+            //copy down
+            offset = (_mColPix[row] * dst_pitch);
+
+            if (_mColPix[row-1] && _mColPix[row] != 1)
+            {
+                memcpy(pDst + offset, pDst + dst_pitch, dst_width*2);
+            }
+            if (_mColPix[row-1] == 2)
+            {
+                memcpy(pDst + offset + dst_pitch, pDst + dst_pitch, dst_width*2);
+            }
+            else if (_mColPix[row-1] == 3)
+            {
+                memcpy(pDst + offset + dst_pitch, pDst + dst_pitch, dst_width*2);
+                memcpy(pDst + offset + dst_pitch*2, pDst + dst_pitch, dst_width*2);
+            }
+
+            if (_mColPix[row] > 1)
+            {
+                memcpy(pDst + dst_pitch, pDst, dst_width*2);
+                if (_mColPix[row] > 2)
+                {
+                    memcpy(pDst + dst_pitch*2, pDst, dst_width*2);
+                }
+            }
+
+            pDst += dst_pitch * (_mColPix[row-1] + _mColPix[row]);
+            if (dst_inc < 0)
+            {
+                pDst += (dst_width - 1);
+            }
+        }
+    } // row
+
+    return 1;
+#else
+    OSCL_UNUSED_ARG(src);
+    OSCL_UNUSED_ARG(dst);
+    OSCL_UNUSED_ARG(disp);
+    OSCL_UNUSED_ARG(coff_tbl);
+    OSCL_UNUSED_ARG(_mRowPix);
+    OSCL_UNUSED_ARG(_mColPix);
+    OSCL_UNUSED_ARG(_mIsRotateClkwise);
+    OSCL_UNUSED_ARG(flip);
+
+    return 0;
+#endif // defined(CCROTATE) && defined(CCSCALING)
+}
+
+void * cc16WrapperCreate(void)
+{
+    ColorConvert16 * pcc16 = FSL_NEW(ColorConvert16, ());
+    return (void *) pcc16;
+}
+
+OMX_S32 cc16WrapperInit(void * p, OMX_S32 Src_width, OMX_S32 Src_height, OMX_S32 Src_pitch, OMX_CONFIG_RECTTYPE *Src_crop, OMX_COLOR_FORMATTYPE Src_colorFormat, OMX_S32 Dst_width, OMX_S32 Dst_height, OMX_S32 Dst_pitch, OMX_S32 nRotation)
+{
+    ColorConvert16 *pcc16 = (ColorConvert16 *)p;
+    RECTTYPE rect;
+    rect.nLeft = Src_crop->nLeft;
+    rect.nTop = Src_crop->nTop;
+    rect.nWidth = Src_crop->nWidth;
+    rect.nHeight = Src_crop->nHeight;
+    return pcc16->Init(Src_width, Src_height, Src_pitch, &rect, Src_colorFormat, Dst_width, Dst_height, Dst_pitch, nRotation);
+}
+
+OMX_S32 cc16WrapperSetMode(void *p, OMX_S32 nMode)
+{
+    ColorConvert16 *pcc16 = (ColorConvert16 *)p;
+    return pcc16->SetMode(nMode);
+}
+
+
+OMX_S32 cc16WrapperConvert(void *p, OMX_U8 *srcBuf, OMX_U8 *destBuf)
+{
+    ColorConvert16 *pcc16 = (ColorConvert16 *)p;
+    return pcc16->Convert(srcBuf, destBuf);
+}
+
+
+void cc16WrapperDelete(void ** p)
+{
+    ColorConvert16 **pcc16 = (ColorConvert16 **)p;
+    FSL_DELETE(*pcc16);
+}
+
+
diff --git a/utils/colorconvert/src/cczoomrotationbase.cpp b/utils/colorconvert/src/cczoomrotationbase.cpp
new file mode 100755
index 0000000..08a14c1
--- /dev/null
+++ b/utils/colorconvert/src/cczoomrotationbase.cpp
@@ -0,0 +1,356 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+/* -------------------------------------------------------------------
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ * -------------------------------------------------------------------
+ */
+
+#include "string.h"
+#include "Mem.h"
+
+#include "colorconv_config.h"
+#include "cczoomrotationbase.h"
+#include "Log.h"
+
+/**************************************************************
+ASSUMPTIONS:
+1. zoom ratio must be in range (1, 3]
+2. cannot do zoom in in one dimenstion and zoom out in another
+3. caller should take care of the aspect ratio control
+4. if there are margins, the caller should paint the background to the desired color
+5. all the starting address MUST be multiple of 4, which is normally the case.
+
+**************************************************************/
+
+
+#define OSCL_ARRAY_DELETE(ptr) FSL_FREE (ptr)
+#define OSCL_ARRAY_NEW(T, count) FSL_MALLOC (sizeof(T) * count)
+
+ColorConvertBase::ColorConvertBase(): _mRowPix(NULL), _mColPix(NULL), _mInitialized(false), _mState(0), _mYuvRange(false)
+{
+}
+
+
+ColorConvertBase::~ColorConvertBase()
+{
+    if (_mRowPix)
+    {
+        OSCL_ARRAY_DELETE(_mRowPix);
+    }
+    if (_mColPix)
+    {
+        OSCL_ARRAY_DELETE(_mColPix);
+    }
+}
+
+
+int16 ColorConvertBase::GetCapability(void)
+{
+    int16 cap = 0;
+#if CCROTATE
+    cap |= CCSUPPORT_ROTATION;
+#endif
+#if CCSCALING
+    cap |= CCSUPPORT_SCALING;
+#endif
+    return cap;
+}
+
+
+/**************************************************************
+nRotation : Rotation direction is defined at run time
+            0 -- No rotation
+            1 -- 90 degree counter clockwise (default)
+            2 -- 180 degree rotation (upside-down)
+            3 -- 90 degree clockwise
+            -1 -- flip left-right
+            -2 -- flip and rotate 90 degree cnt clk
+            -3 -- flip and rotate 180 degree
+            -4 -- flip and rotate 270 degree
+**************************************************************/
+int32 ColorConvertBase::Init(int32 Src_width, int32 Src_height, int32 Src_pitch,  RECTTYPE *Src_crop, OMX_COLOR_FORMATTYPE srcColorFormat, int32 Dst_width, int32 Dst_height, int32 Dst_pitch, int32 nRotation)
+{
+
+    /* check the followings, must be multiple of 2 */
+    if ((Src_pitch&1) || (Dst_pitch&1) || (Dst_height&1) || (Src_height&1) || (Src_width&1))
+    {
+        return 0;
+    }
+
+    _mInitialized = false;
+    _mSrc_mheight = Src_height;
+    _mRotation  =   nRotation;
+    _mDisp.src_pitch = _mSrc_pitch  =   Src_pitch;
+    _mDisp.dst_pitch = _mDst_pitch  =   Dst_pitch;
+    _mDisp.src_width = _mSrc_width  =   Src_width;
+    _mDisp.src_height = _mSrc_height =  Src_height;
+    _mDisp.src_crop_left = Src_crop->nLeft;
+    _mDisp.src_crop_top = Src_crop->nTop;    
+    _mDisp.src_crop_width = Src_crop->nWidth;    
+    _mDisp.src_crop_height = Src_crop->nHeight;    
+    _mDisp.dst_width = _mDst_width  =   Dst_width;
+    _mDisp.dst_height = _mDst_height =  Dst_height;
+    _mColorFormat = srcColorFormat;
+
+    if(_mColorFormat != OMX_COLOR_FormatYUV420Planar &&
+        _mColorFormat != OMX_COLOR_FormatYUV422Planar &&
+        _mColorFormat != OMX_COLOR_FormatYUV422SemiPlanar &&
+        _mColorFormat != OMX_COLOR_FormatYUV420SemiPlanar) 
+    {
+        return 0;
+    }
+
+    /* Check support for rotation */
+    if (_mRotation&0x1)
+    {
+        if (!(GetCapability()&CCSUPPORT_ROTATION))
+        {
+            return 0;
+        }
+    }
+
+    _mIsFlip = false;
+    if (_mRotation & 0x4)
+    {
+        _mIsFlip = true;
+        _mRotation -= 4;
+    }
+
+    //For now, we only support the zoom ratio <=3
+    if (_mRotation&0x1)
+    {
+        if (((Src_width*3) < Dst_height) || ((Src_height*3) < Dst_width))
+        {
+            return 0;
+        }
+    }
+    else
+    {
+        if (((Src_width*3) < Dst_width) || ((Src_height*3) < Dst_height))
+        {
+            return 0;
+        }
+    }
+
+    if (_mRowPix)
+    {
+        OSCL_ARRAY_DELETE(_mRowPix);
+    }
+    if (_mColPix)
+    {
+        OSCL_ARRAY_DELETE(_mColPix);
+    }
+    _mRowPix = NULL;
+    _mColPix = NULL;
+
+    if ((_mRotation&0x1) == 0)
+    { /* no rotation */
+        if ((_mDst_width != (uint32)_mDisp.src_crop_width) || (_mDst_height != (uint32)_mDisp.src_crop_height))
+        { /* scaling */
+            //calulate the Row
+            _mRowPix = (uint8 *) OSCL_ARRAY_NEW(uint8, _mDisp.src_crop_width);
+            if (_mRowPix == NULL)
+                return 0;
+
+            _mColPix = (uint8 *) OSCL_ARRAY_NEW(uint8, _mDisp.src_crop_height);
+
+            if (_mColPix == NULL){
+                if(_mRowPix != NULL){
+                    OSCL_ARRAY_DELETE(_mRowPix);
+                    _mRowPix = NULL;
+                }
+                return 0;
+            }
+
+            StretchLine(_mRowPix, _mDisp.src_crop_width, _mDst_width);
+            StretchLine(_mColPix, _mDisp.src_crop_height, _mDst_height);
+            _mIsZoom = true;
+        }
+        else
+        {
+            _mIsZoom = false;
+        }
+    }
+    else
+    { /* rotation,  */
+        if ((_mDst_height != _mSrc_width) || (_mDst_width != _mSrc_height))
+        { /* scaling */
+            //calulate the Row
+            _mRowPix = (uint8 *) OSCL_ARRAY_NEW(uint8, _mSrc_height);
+            if(_mRowPix == NULL)
+                return 0;
+            
+            _mColPix = (uint8 *) OSCL_ARRAY_NEW(uint8, _mSrc_width);
+            if(_mColPix == NULL){
+                OSCL_ARRAY_DELETE(_mRowPix);
+                _mRowPix = NULL;
+                return 0;
+            }
+
+            StretchLine(_mColPix, _mSrc_width, _mDst_height);
+            StretchLine(_mRowPix, _mSrc_height, _mDst_width);
+            _mIsZoom = true;
+        }
+        else
+        {
+            _mIsZoom = false;
+        }
+    }
+
+    // Check support to scaling
+    if (_mIsZoom)
+    {
+        if (!(GetCapability()&CCSUPPORT_SCALING))
+        {
+            return 0;
+        }
+    }
+
+    _mInitialized = true;
+
+    return 1;
+}
+
+void ColorConvertBase::StretchLine(uint8 *pLinePix, int32 iSrcLen, int32 iDstLen)
+{
+    // zoom ratio must be in range (1, 3]
+    int32 e, i, j = 0, d, i2SrcLen, i2DstLen;
+    bool bIsShrink = false;
+
+    if (iSrcLen > iDstLen)
+    {
+        bIsShrink = true;
+    }
+
+    if (3*iSrcLen == iDstLen || 3*iDstLen == iSrcLen)
+    {
+        j = 3;
+    }
+    if (2*iSrcLen == iDstLen || 2*iDstLen == iSrcLen)
+    {
+        j = 2;
+    }
+
+    if (j)
+    {
+        if (bIsShrink)
+        {
+            memset(pLinePix, 0, iSrcLen);
+            for (i = 0; i < iSrcLen; i += j)
+            {
+                pLinePix[i] = 1;
+            }
+        }
+        else
+        {
+            memset(pLinePix, j, iSrcLen);
+        }
+        return;
+    }
+
+    //int32 xd1=0 int32 xd2=iDstLen, int32 xs1=0, int32 xs2=iSrcLen
+    //int32 dx, dy2, e, d, dx2;
+    //dx = xd2 - xd1;
+    i2SrcLen = (iSrcLen - 1) << 1;//dy2 = (xs2 - xs1) << 1;
+    e = i2SrcLen - (iDstLen - 1);//e = dy2 - dx;
+    i2DstLen = (iDstLen - 1) << 1;//dx2 = dx << 1;
+    i = 0;
+    j = 0;
+    for (d = 0; d < iDstLen /*dx*/; d++)
+    {
+        if (i <= iSrcLen - 1)
+        {
+            *(pLinePix + i) =  j;
+        }
+        if (e >= 0)
+        {
+            i++;
+            e -= i2DstLen;
+        }
+        while (e >= 0)
+        {
+            if (i <= iSrcLen - 1)
+            {
+                *(pLinePix + i) =  j; /* zoom in case */
+            }
+            i++;
+            e -= i2DstLen;
+        }
+        j++;
+        e += i2SrcLen;
+    }
+
+    e = pLinePix[0];
+    for (i = 1; i < iSrcLen; i++)
+    {
+        d = pLinePix[i];
+        pLinePix[i] = (d - e); /* take difference between adjacent iRowPix[]. */
+        e = d;
+    }
+
+    // add some check here to make sure that sum_{i=0...iSrcLen-1} pLinePix[i] = iDstLen
+    e = 0;
+    for (i = 0; i < iSrcLen; i++)
+    {
+        e += pLinePix[i];
+    }
+
+    if (e != iDstLen)
+    {
+        j = 0;
+        while (e > iDstLen) /* sum greater than the destination */
+        {
+            while (pLinePix[j] == 0 && j < iSrcLen) /* find nonzero repetition pixel */
+            {
+                j++;
+            }
+
+            if (j < iSrcLen)
+            {
+                pLinePix[j]--;      /* remove pixel by one */
+                e--;
+                j++;                /* move to the next pixel */
+            }
+            else
+            {
+                j = 0;
+            }
+        }
+
+        j = 0;
+        while (e < iDstLen) /* sum less than the destination */
+        {
+            while (pLinePix[j] >= 3 && j < iSrcLen) /* find valid pixel */
+            {
+                j++;
+            }
+
+            if (j < iSrcLen)
+            {
+                pLinePix[j]++;  /* add pixel by one */
+                e++;
+                j++;            /* move to the next pixel */
+            }
+            else
+            {
+                j = 0;
+            }
+        }
+    }
+}
diff --git a/utils/id3_parser/Android.mk b/utils/id3_parser/Android.mk
new file mode 100755
index 0000000..83420c7
--- /dev/null
+++ b/utils/id3_parser/Android.mk
@@ -0,0 +1,21 @@
+ifeq ($(HAVE_FSL_IMX_CODEC),false)
+
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	ID3.cpp
+
+LOCAL_CFLAGS += $(FSL_OMX_CFLAGS)
+LOCAL_LDFLAGS += $(FSL_OMX_LDFLAGS)
+
+LOCAL_SHARED_LIBRARIES := libstagefright libstagefright_foundation libutils libc liblog
+
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE:= lib_id3_parser_arm11_elinux
+
+include $(BUILD_SHARED_LIBRARY)
+
+endif
diff --git a/utils/id3_parser/ID3.cpp b/utils/id3_parser/ID3.cpp
new file mode 100755
index 0000000..e2453e0
--- /dev/null
+++ b/utils/id3_parser/ID3.cpp
@@ -0,0 +1,789 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ *  Copyright (c) 2011-2013, Freescale Semiconductor Inc.,
+ */
+
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ID3"
+#include <utils/Log.h>
+
+#include "ID3.h"
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/Utils.h>
+#include <utils/String8.h>
+#include <byteswap.h>
+
+#if (ANDROID_VERSION >= JELLY_BEAN_42)
+#define LOGE ALOGE
+#define LOGV ALOGV
+#endif
+
+namespace android {
+
+static const size_t kMaxMetadataSize = 3 * 1024 * 1024;
+
+ID3::ID3()
+    : mIsValid(false),
+      mData(NULL),
+      mSize(0),
+      mFirstFrameOffset(0),
+      mVersion(ID3_UNKNOWN) {
+}
+
+ID3::~ID3() {
+    if (mData) {
+        free(mData);
+        mData = NULL;
+    }
+}
+
+bool ID3::isValid() const {
+    return mIsValid;
+}
+
+ID3::Version ID3::version() const {
+    return mVersion;
+}
+
+// static
+bool ID3::ParseSyncsafeInteger(const uint8_t encoded[4], size_t *x) {
+    *x = 0;
+    for (int32_t i = 0; i < 4; ++i) {
+        if (encoded[i] & 0x80) {
+            return false;
+        }
+
+        *x = ((*x) << 7) | encoded[i];
+    }
+
+    return true;
+}
+
+bool ID3::parseV2(const char *sourceBuf) {
+struct id3_header {
+    char id[3];
+    uint8_t version_major;
+    uint8_t version_minor;
+    uint8_t flags;
+    uint8_t enc_size[4];
+    };
+
+    id3_header header;
+	memcpy(&header, sourceBuf, sizeof(header));
+
+    if (memcmp(header.id, "ID3", 3)) {
+        return false;
+    }
+
+    if (header.version_major == 0xff || header.version_minor == 0xff) {
+        return false;
+    }
+
+    if (header.version_major == 2) {
+        if (header.flags & 0x3f) {
+            // We only support the 2 high bits, if any of the lower bits are
+            // set, we cannot guarantee to understand the tag format.
+            return false;
+        }
+
+        if (header.flags & 0x40) {
+            // No compression scheme has been decided yet, ignore the
+            // tag if compression is indicated.
+
+            return false;
+        }
+    } else if (header.version_major == 3) {
+        if (header.flags & 0x1f) {
+            // We only support the 3 high bits, if any of the lower bits are
+            // set, we cannot guarantee to understand the tag format.
+            return false;
+        }
+    } else if (header.version_major == 4) {
+        if (header.flags & 0x0f) {
+            // The lower 4 bits are undefined in this spec.
+            return false;
+        }
+    } else {
+        return false;
+    }
+
+    size_t size;
+    if (!ParseSyncsafeInteger(header.enc_size, &size)) {
+        return false;
+    }
+
+    if (size > kMaxMetadataSize) {
+        LOGE("skipping huge ID3 metadata of size %d", size);
+        return false;
+    }
+
+    mData = (uint8_t *)malloc(size);
+
+    if (mData == NULL) {
+        return false;
+    }
+
+    mSize = size;
+
+	memcpy(mData, sourceBuf+sizeof(header), mSize);
+
+    if (header.version_major == 4) {
+        if (!removeUnsynchronizationV2_4()) {
+            free(mData);
+            mData = NULL;
+
+            return false;
+        }
+    } else if (header.flags & 0x80) {
+        LOGV("removing unsynchronization");
+
+        removeUnsynchronization();
+    }
+
+    mFirstFrameOffset = 0;
+    if (header.version_major == 3 && (header.flags & 0x40)) {
+        // Version 2.3 has an optional extended header.
+
+        if (mSize < 4) {
+            free(mData);
+            mData = NULL;
+
+            return false;
+        }
+
+        size_t extendedHeaderSize = U32_AT(&mData[0]) + 4;
+
+        if (extendedHeaderSize > mSize) {
+            free(mData);
+            mData = NULL;
+
+            return false;
+        }
+
+        mFirstFrameOffset = extendedHeaderSize;
+
+        uint16_t extendedFlags = 0;
+        if (extendedHeaderSize >= 6) {
+            extendedFlags = U16_AT(&mData[4]);
+
+            if (extendedHeaderSize >= 10) {
+                size_t paddingSize = U32_AT(&mData[6]);
+
+                if (mFirstFrameOffset + paddingSize > mSize) {
+                    free(mData);
+                    mData = NULL;
+
+                    return false;
+                }
+
+                mSize -= paddingSize;
+            }
+
+            if (extendedFlags & 0x8000) {
+                LOGV("have crc");
+            }
+        }
+    } else if (header.version_major == 4 && (header.flags & 0x40)) {
+        // Version 2.4 has an optional extended header, that's different
+        // from Version 2.3's...
+
+        if (mSize < 4) {
+            free(mData);
+            mData = NULL;
+
+            return false;
+        }
+
+        size_t ext_size;
+        if (!ParseSyncsafeInteger(mData, &ext_size)) {
+            free(mData);
+            mData = NULL;
+
+            return false;
+        }
+
+        if (ext_size < 6 || ext_size > mSize) {
+            free(mData);
+            mData = NULL;
+
+            return false;
+        }
+
+        mFirstFrameOffset = ext_size;
+    }
+
+    if (header.version_major == 2) {
+        mVersion = ID3_V2_2;
+    } else if (header.version_major == 3) {
+        mVersion = ID3_V2_3;
+    } else {
+        CHECK_EQ(header.version_major, 4);
+        mVersion = ID3_V2_4;
+    }
+
+    return true;
+}
+
+void ID3::removeUnsynchronization() {
+    for (size_t i = 0; i + 1 < mSize; ++i) {
+        if (mData[i] == 0xff && mData[i + 1] == 0x00) {
+            memmove(&mData[i + 1], &mData[i + 2], mSize - i - 2);
+            --mSize;
+        }
+    }
+}
+
+static void WriteSyncsafeInteger(uint8_t *dst, size_t x) {
+    for (size_t i = 0; i < 4; ++i) {
+        dst[3 - i] = (x & 0x7f);
+        x >>= 7;
+    }
+}
+
+bool ID3::removeUnsynchronizationV2_4() {
+    size_t oldSize = mSize;
+
+    size_t offset = 0;
+    while (offset + 10 <= mSize) {
+        if (!memcmp(&mData[offset], "\0\0\0\0", 4)) {
+            break;
+        }
+
+        size_t dataSize;
+        if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
+            return false;
+        }
+
+        if (offset + dataSize + 10 > mSize) {
+            return false;
+        }
+
+        uint16_t flags = U16_AT(&mData[offset + 8]);
+        uint16_t prevFlags = flags;
+
+        if (flags & 1) {
+            // Strip data length indicator
+
+            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
+            mSize -= 4;
+            dataSize -= 4;
+
+            flags &= ~1;
+        }
+
+        if (flags & 2) {
+            // Unsynchronization added.
+
+            for (size_t i = 0; i + 1 < dataSize; ++i) {
+                if (mData[offset + 10 + i] == 0xff
+                        && mData[offset + 11 + i] == 0x00) {
+                    memmove(&mData[offset + 11 + i], &mData[offset + 12 + i],
+                            mSize - offset - 12 - i);
+                    --mSize;
+                    --dataSize;
+                }
+            }
+
+            flags &= ~2;
+        }
+
+        if (flags != prevFlags) {
+            WriteSyncsafeInteger(&mData[offset + 4], dataSize);
+            mData[offset + 8] = flags >> 8;
+            mData[offset + 9] = flags & 0xff;
+        }
+
+        offset += 10 + dataSize;
+    }
+
+    memset(&mData[mSize], 0, oldSize - mSize);
+
+    return true;
+}
+
+ID3::Iterator::Iterator(const ID3 &parent, const char *id)
+    : mParent(parent),
+      mID(NULL),
+      mOffset(mParent.mFirstFrameOffset),
+      mFrameData(NULL),
+      mFrameSize(0) {
+    if (id) {
+        mID = strdup(id);
+    }
+
+    findFrame();
+}
+
+ID3::Iterator::~Iterator() {
+    if (mID) {
+        free(mID);
+        mID = NULL;
+    }
+}
+
+bool ID3::Iterator::done() const {
+    return mFrameData == NULL;
+}
+
+void ID3::Iterator::next() {
+    if (mFrameData == NULL) {
+        return;
+    }
+
+    mOffset += mFrameSize;
+
+    findFrame();
+}
+
+void ID3::Iterator::getID(String8 *id) const {
+    id->setTo("");
+
+    if (mFrameData == NULL) {
+        return;
+    }
+
+    if (mParent.mVersion == ID3_V2_2) {
+        id->setTo((const char *)&mParent.mData[mOffset], 3);
+    } else if (mParent.mVersion == ID3_V2_3 || mParent.mVersion == ID3_V2_4) {
+        id->setTo((const char *)&mParent.mData[mOffset], 4);
+    } else {
+        CHECK(mParent.mVersion == ID3_V1 || mParent.mVersion == ID3_V1_1);
+
+        switch (mOffset) {
+            case 3:
+                id->setTo("TT2");
+                break;
+            case 33:
+                id->setTo("TP1");
+                break;
+            case 63:
+                id->setTo("TAL");
+                break;
+            case 93:
+                id->setTo("TYE");
+                break;
+            case 97:
+                id->setTo("COM");
+                break;
+            case 126:
+                id->setTo("TRK");
+                break;
+            case 127:
+                id->setTo("TCO");
+                break;
+            default:
+                CHECK(!"should not be here.");
+                break;
+        }
+    }
+}
+
+static void convertISO8859ToString8(
+        const uint8_t *data, size_t size,
+        String8 *s) {
+    size_t utf8len = 0;
+    for (size_t i = 0; i < size; ++i) {
+        if (data[i] == '\0') {
+            size = i;
+            break;
+        } else if (data[i] < 0x80) {
+            ++utf8len;
+        } else {
+            utf8len += 2;
+        }
+    }
+
+    if (utf8len == size) {
+        // Only ASCII characters present.
+
+        s->setTo((const char *)data, size);
+        return;
+    }
+
+    char *tmp = new char[utf8len];
+    char *ptr = tmp;
+    for (size_t i = 0; i < size; ++i) {
+        if (data[i] == '\0') {
+            break;
+        } else if (data[i] < 0x80) {
+            *ptr++ = data[i];
+        } else if (data[i] < 0xc0) {
+            *ptr++ = 0xc2;
+            *ptr++ = data[i];
+        } else {
+            *ptr++ = 0xc3;
+            *ptr++ = data[i] - 64;
+        }
+    }
+
+    s->setTo(tmp, utf8len);
+
+    delete[] tmp;
+    tmp = NULL;
+}
+
+void ID3::Iterator::getString(String8 *id) const {
+    id->setTo("");
+
+    if (mFrameData == NULL) {
+        return;
+    }
+
+    if (mParent.mVersion == ID3_V1 || mParent.mVersion == ID3_V1_1) {
+        if (mOffset == 126 || mOffset == 127) {
+            // Special treatment for the track number and genre.
+            char tmp[16];
+            sprintf(tmp, "%d", (int)*mFrameData);
+
+            id->setTo(tmp);
+            return;
+        }
+
+        convertISO8859ToString8(mFrameData, mFrameSize, id);
+        return;
+    }
+
+    size_t n = mFrameSize - getHeaderLength() - 1;
+
+    if (*mFrameData == 0x00) {
+        // ISO 8859-1
+        convertISO8859ToString8(mFrameData + 1, n, id);
+    } else if (*mFrameData == 0x03) {
+        // UTF-8
+        id->setTo((const char *)(mFrameData + 1), n);
+    } else if (*mFrameData == 0x02) {
+        // UTF-16 BE, no byte order mark.
+        // API wants number of characters, not number of bytes...
+        int len = n / 2;
+        const char16_t *framedata = (const char16_t *) (mFrameData + 1);
+        char16_t *framedatacopy = NULL;
+#if BYTE_ORDER == LITTLE_ENDIAN
+        framedatacopy = new char16_t[len];
+        for (int i = 0; i < len; i++) {
+            framedatacopy[i] = bswap_16(framedata[i]);
+        }
+        framedata = framedatacopy;
+#endif
+        id->setTo(framedata, len);
+        if (framedatacopy != NULL) {
+            delete[] framedatacopy;
+        }
+    } else {
+        // UCS-2
+        // API wants number of characters, not number of bytes...
+        int len = n / 2;
+        const char16_t *framedata = (const char16_t *) (mFrameData + 1);
+        char16_t *framedatacopy = NULL;
+        if (*framedata == 0xfffe) {
+            // endianness marker doesn't match host endianness, convert
+            framedatacopy = new char16_t[len];
+            for (int i = 0; i < len; i++) {
+                framedatacopy[i] = bswap_16(framedata[i]);
+            }
+            framedata = framedatacopy;
+        }
+        // If the string starts with an endianness marker, skip it
+        if (*framedata == 0xfeff) {
+            framedata++;
+            len--;
+        }
+        id->setTo(framedata, len);
+        if (framedatacopy != NULL) {
+            delete[] framedatacopy;
+        }
+    }
+}
+
+const uint8_t *ID3::Iterator::getData(size_t *length) const {
+    *length = 0;
+
+    if (mFrameData == NULL) {
+        return NULL;
+    }
+
+    *length = mFrameSize - getHeaderLength();
+
+    return mFrameData;
+}
+
+size_t ID3::Iterator::getHeaderLength() const {
+    if (mParent.mVersion == ID3_V2_2) {
+        return 6;
+    } else if (mParent.mVersion == ID3_V2_3 || mParent.mVersion == ID3_V2_4) {
+        return 10;
+    } else {
+        CHECK(mParent.mVersion == ID3_V1 || mParent.mVersion == ID3_V1_1);
+        return 0;
+    }
+}
+
+void ID3::Iterator::findFrame() {
+    for (;;) {
+        mFrameData = NULL;
+        mFrameSize = 0;
+
+        if (mParent.mVersion == ID3_V2_2) {
+            if (mOffset + 6 > mParent.mSize) {
+                return;
+            }
+
+            if (!memcmp(&mParent.mData[mOffset], "\0\0\0", 3)) {
+                return;
+            }
+
+            mFrameSize =
+                (mParent.mData[mOffset + 3] << 16)
+                | (mParent.mData[mOffset + 4] << 8)
+                | mParent.mData[mOffset + 5];
+
+            mFrameSize += 6;
+
+            if (mOffset + mFrameSize > mParent.mSize) {
+                LOGV("partial frame at offset %d (size = %d, bytes-remaining = %d)",
+                     mOffset, mFrameSize, mParent.mSize - mOffset - 6);
+                return;
+            }
+
+            mFrameData = &mParent.mData[mOffset + 6];
+
+            if (!mID) {
+                break;
+            }
+
+            char id[4];
+            memcpy(id, &mParent.mData[mOffset], 3);
+            id[3] = '\0';
+
+            if (!strcmp(id, mID)) {
+                break;
+            }
+        } else if (mParent.mVersion == ID3_V2_3
+                || mParent.mVersion == ID3_V2_4) {
+            if (mOffset + 10 > mParent.mSize) {
+                return;
+            }
+
+            if (!memcmp(&mParent.mData[mOffset], "\0\0\0\0", 4)) {
+                return;
+            }
+
+            size_t baseSize;
+            if (mParent.mVersion == ID3_V2_4) {
+                if (!ParseSyncsafeInteger(
+                            &mParent.mData[mOffset + 4], &baseSize)) {
+                    return;
+                }
+            } else {
+                baseSize = U32_AT(&mParent.mData[mOffset + 4]);
+            }
+
+            mFrameSize = 10 + baseSize;
+
+            if (mOffset + mFrameSize > mParent.mSize) {
+                LOGV("partial frame at offset %d (size = %d, bytes-remaining = %d)",
+                     mOffset, mFrameSize, mParent.mSize - mOffset - 10);
+                return;
+            }
+
+            uint16_t flags = U16_AT(&mParent.mData[mOffset + 8]);
+
+            if ((mParent.mVersion == ID3_V2_4 && (flags & 0x000c))
+                || (mParent.mVersion == ID3_V2_3 && (flags & 0x00c0))) {
+                // Compression or encryption are not supported at this time.
+                // Per-frame unsynchronization and data-length indicator
+                // have already been taken care of.
+
+                LOGV("Skipping unsupported frame (compression, encryption "
+                     "or per-frame unsynchronization flagged");
+
+                mOffset += mFrameSize;
+                continue;
+            }
+
+            mFrameData = &mParent.mData[mOffset + 10];
+
+            if (!mID) {
+                break;
+            }
+
+            char id[5];
+            memcpy(id, &mParent.mData[mOffset], 4);
+            id[4] = '\0';
+
+            if (!strcmp(id, mID)) {
+                break;
+            }
+        } else {
+            CHECK(mParent.mVersion == ID3_V1 || mParent.mVersion == ID3_V1_1);
+
+            if (mOffset >= mParent.mSize) {
+                return;
+            }
+
+            mFrameData = &mParent.mData[mOffset];
+
+            switch (mOffset) {
+                case 3:
+                case 33:
+                case 63:
+                    mFrameSize = 30;
+                    break;
+                case 93:
+                    mFrameSize = 4;
+                    break;
+                case 97:
+                    if (mParent.mVersion == ID3_V1) {
+                        mFrameSize = 30;
+                    } else {
+                        mFrameSize = 29;
+                    }
+                    break;
+                case 126:
+                    mFrameSize = 1;
+                    break;
+                case 127:
+                    mFrameSize = 1;
+                    break;
+                default:
+                    CHECK(!"Should not be here, invalid offset.");
+                    break;
+            }
+
+            if (!mID) {
+                break;
+            }
+
+            String8 id;
+            getID(&id);
+
+            if (id == mID) {
+                break;
+            }
+        }
+
+        mOffset += mFrameSize;
+    }
+}
+
+static size_t StringSize(const uint8_t *start, uint8_t encoding) {
+    if (encoding == 0x00 || encoding == 0x03) {
+        // ISO 8859-1 or UTF-8
+        return strlen((const char *)start) + 1;
+    }
+
+    // UCS-2
+    size_t n = 0;
+    while (start[n] != '\0' || start[n + 1] != '\0') {
+        n += 2;
+    }
+
+    return n + 2;
+}
+
+const void *
+ID3::getAlbumArt(size_t *length, String8 *mime) const {
+    *length = 0;
+    mime->setTo("");
+
+    Iterator it(
+            *this,
+            (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) ? "APIC" : "PIC");
+
+    while (!it.done()) {
+        size_t size;
+        const uint8_t *data = it.getData(&size);
+
+        if (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) {
+            uint8_t encoding = data[0];
+            mime->setTo((const char *)&data[1]);
+            size_t mimeLen = strlen((const char *)&data[1]) + 1;
+
+            uint8_t picType = data[1 + mimeLen];
+#if 0
+            if (picType != 0x03) {
+                // Front Cover Art
+                it.next();
+                continue;
+            }
+#endif
+
+            size_t descLen = StringSize(&data[2 + mimeLen], encoding);
+
+            *length = size - 2 - mimeLen - descLen;
+
+            return &data[2 + mimeLen + descLen];
+        } else {
+            uint8_t encoding = data[0];
+
+            if (!memcmp(&data[1], "PNG", 3)) {
+                mime->setTo("image/png");
+            } else if (!memcmp(&data[1], "JPG", 3)) {
+                mime->setTo("image/jpeg");
+            } else if (!memcmp(&data[1], "-->", 3)) {
+                mime->setTo("text/plain");
+            } else {
+                return NULL;
+            }
+
+#if 0
+            uint8_t picType = data[4];
+            if (picType != 0x03) {
+                // Front Cover Art
+                it.next();
+                continue;
+            }
+#endif
+
+            size_t descLen = StringSize(&data[5], encoding);
+
+            *length = size - 5 - descLen;
+
+            return &data[5 + descLen];
+        }
+    }
+
+    return NULL;
+}
+
+bool ID3::parseV1(const char *sourceBuf) {
+    const size_t V1_TAG_SIZE = 128;
+
+    mData = (uint8_t *)malloc(V1_TAG_SIZE);
+	memcpy(mData, sourceBuf, V1_TAG_SIZE);
+
+    if (memcmp("TAG", mData, 3)) {
+        free(mData);
+        mData = NULL;
+
+        return false;
+    }
+
+    mSize = V1_TAG_SIZE;
+    mFirstFrameOffset = 3;
+
+    if (mData[V1_TAG_SIZE - 3] != 0) {
+        mVersion = ID3_V1;
+    } else {
+        mVersion = ID3_V1_1;
+    }
+
+    return true;
+}
+
+}  // namespace android
diff --git a/utils/id3_parser/ID3.h b/utils/id3_parser/ID3.h
new file mode 100755
index 0000000..7426d00
--- /dev/null
+++ b/utils/id3_parser/ID3.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ *  Copyright (c) 2011-2012, Freescale Semiconductor Inc.,
+ */
+
+
+#ifndef ID3_H_
+
+#define ID3_H_
+
+#include <utils/RefBase.h>
+
+namespace android {
+
+struct String8;
+
+struct ID3 {
+    enum Version {
+        ID3_UNKNOWN,
+        ID3_V1,
+        ID3_V1_1,
+        ID3_V2_2,
+        ID3_V2_3,
+        ID3_V2_4,
+    };
+
+    ID3();
+    ~ID3();
+
+    bool parseV1(const char *sourceBuf);
+    bool parseV2(const char *sourceBuf);
+
+    bool isValid() const;
+
+    Version version() const;
+
+    const void *getAlbumArt(size_t *length, String8 *mime) const;
+
+    struct Iterator {
+        Iterator(const ID3 &parent, const char *id);
+        ~Iterator();
+
+        bool done() const;
+        void getID(String8 *id) const;
+        void getString(String8 *s) const;
+        const uint8_t *getData(size_t *length) const;
+        void next();
+
+    private:
+        const ID3 &mParent;
+        char *mID;
+        size_t mOffset;
+
+        const uint8_t *mFrameData;
+        size_t mFrameSize;
+
+        void findFrame();
+
+        size_t getHeaderLength() const;
+
+        Iterator(const Iterator &);
+        Iterator &operator=(const Iterator &);
+    };
+
+private:
+    bool mIsValid;
+    uint8_t *mData;
+    size_t mSize;
+    size_t mFirstFrameOffset;
+    Version mVersion;
+
+    void removeUnsynchronization();
+    bool removeUnsynchronizationV2_4();
+
+    static bool ParseSyncsafeInteger(const uint8_t encoded[4], size_t *x);
+
+    ID3(const ID3 &);
+    ID3 &operator=(const ID3 &);
+};
+
+}  // namespace android
+
+#endif  // ID3_H_
+
diff --git a/utils/mfw_gst_ts.c b/utils/mfw_gst_ts.c
new file mode 100755
index 0000000..7952972
--- /dev/null
+++ b/utils/mfw_gst_ts.c
@@ -0,0 +1,744 @@
+/**
+ *  Copyright (c) 2010-2013, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * Module Name:    TimeStamp.c
+ *
+ * Description:    include TimeStamp stratege for VPU / SW video decoder plugin
+ *
+ * Portability:    This code is written for Linux OS and Gstreamer
+ */
+
+/*
+ * Changelog:
+  11/2/2010        draft version       Lyon Wang
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "mfw_gst_ts.h"
+#include "Log.h"
+
+const char *debug_env = "ME_DEBUG";
+char *debug = NULL;
+int debug_level = 0;
+
+
+enum
+{
+  DEBUG_LEVEL_ERROR = 1,
+  DEBUG_LEVEL_WARNING,
+  DEBUG_LEVEL_LOG,
+  DEBUG_LEVEL_VERBOSE,
+};
+
+
+#define TSM_MESSAGE(level, fmt, ...)\
+  do{\
+    if (debug_level>=(level)){\
+      printf("TSM:"fmt, ##__VA_ARGS__);\
+    }\
+  }while(0)
+
+#define TSM_ERROR(...) TSM_MESSAGE(DEBUG_LEVEL_ERROR, ##__VA_ARGS__)
+#define TSM_WARNING(...) TSM_MESSAGE(DEBUG_LEVEL_WARNING, ##__VA_ARGS__)
+#define TSM_LOG(...) TSM_MESSAGE(DEBUG_LEVEL_LOG, ##__VA_ARGS__)
+#define TSM_VERBOSE(...) TSM_MESSAGE(DEBUG_LEVEL_VERBOSE, ##__VA_ARGS__)
+
+#define TSM_HISTORY_POWER 5
+#define TSM_HISTORY_SIZE (1<<TSM_HISTORY_POWER)
+#define TSM_ADAPTIVE_INTERVAL(tsm) \
+    (tsm->dur_history_total>>TSM_HISTORY_POWER)
+
+#define TSM_SECOND ((TSM_TIMESTAMP)1000000000)
+#define TSM_DEFAULT_INTERVAL (TSM_SECOND/30)
+#define TSM_DEFAULT_TS_BUFFER_SIZE (128)
+
+#define TSM_TS_IS_VALID(ts)	\
+    ((ts) != TSM_TIMESTAMP_NONE)
+
+#define TSM_KEY_IS_VALID(key) \
+    ((key) != TSM_KEY_NONE)
+
+#define TSM_DISTANCE(tsm)\
+    (((tsm->rx)>=(tsm->tx))?((tsm->rx)-(tsm->tx)):(tsm->ts_buf_size-(tsm->tx)+(tsm->rx)))
+
+#define TSM_PLUS_AGE(tsm)\
+    (TSM_DISTANCE(tsm)+tsm->invalid_ts_count+2)
+
+#define TSM_ABS(ts0, ts1)\
+    (((ts0)>(ts1))?((ts0)-(ts1)):((ts1)-(ts0)))
+
+#define TSM_TIME_FORMAT "u:%02u:%02u.%09u"
+
+#define TSM_TIME_ARGS(t) \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) (((TSM_TIMESTAMP)(t)) / (TSM_SECOND * 60 * 60)) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) ((((TSM_TIMESTAMP)(t)) / (TSM_SECOND * 60)) % 60) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) ((((TSM_TIMESTAMP)(t)) / TSM_SECOND) % 60) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) (((TSM_TIMESTAMP)(t)) % TSM_SECOND) : 999999999
+
+#define TSM_BUFFER_SET(buf, value, size) \
+    do {\
+        int i;\
+        for (i=0;i<(size);i++){\
+            (buf)[i] = (value);\
+        }\
+    }while(0)
+
+#define TSM_RECEIVED_NUNBER 512
+
+
+typedef struct
+{
+  TSM_TIMESTAMP ts;
+  unsigned long long age;
+  void *key;
+} TSMControl;
+
+typedef struct _TSMReceivedEntry
+{
+  TSM_TIMESTAMP ts;
+  struct _TSMReceivedEntry *next;
+  unsigned int used:1;
+  unsigned int subentry:1;
+  int size;
+} TSMReceivedEntry;
+
+typedef struct _TSMReceivedEntryMemory
+{
+  struct _TSMReceivedEntryMemory *next;
+  TSMReceivedEntry entrys[TSM_RECEIVED_NUNBER];
+} TSMReceivedEntryMemory;
+
+typedef struct
+{
+  TSMReceivedEntry *head;
+  TSMReceivedEntry *tail;
+  TSMReceivedEntry *free;
+  TSMReceivedEntryMemory *memory;
+  int cnt;
+} TSMRecivedCtl;
+
+typedef struct _TSManager
+{
+  int first_tx;
+  int first_rx;
+  int rx;                       //timestamps received
+  int tx;                       //timestamps transfered
+  TSM_TIMESTAMP last_ts_sent;   //last time stamp sent
+  TSM_TIMESTAMP last_ts_received;
+  TSM_TIMESTAMP suspicious_ts;
+
+  TSM_TIMESTAMP discont_threshold;
+
+  unsigned int invalid_ts_count;
+  TSMGR_MODE mode;
+  int ts_buf_size;
+  int dur_history_tx;
+  TSM_TIMESTAMP dur_history_total;
+  TSM_TIMESTAMP dur_history_buf[TSM_HISTORY_SIZE];
+  TSMControl *ts_buf;
+  unsigned long long age;
+  int tx_cnt;
+  int rx_cnt;
+  int cnt;
+  int valid_ts_received:1;
+  int big_cnt;
+
+  TSMRecivedCtl rctl;
+} TSManager;
+
+
+static void
+tsm_free_received_entry (TSMRecivedCtl * rctl, TSMReceivedEntry * entry)
+{
+  entry->next = rctl->free;
+  rctl->free = entry;
+}
+
+
+static TSMReceivedEntry *
+tsm_new_received_entry (TSMRecivedCtl * rctl)
+{
+  TSMReceivedEntry *ret = NULL;
+  if (rctl->free) {
+    ret = rctl->free;
+    rctl->free = ret->next;
+  } else {
+    TSMReceivedEntryMemory *p = malloc (sizeof (TSMReceivedEntryMemory));
+    if (p) {
+      int i;
+      for (i = 1; i < TSM_RECEIVED_NUNBER; i++) {
+        TSMReceivedEntry *e = &p->entrys[i];
+        tsm_free_received_entry (rctl, e);
+      };
+
+      p->next = rctl->memory;
+      rctl->memory = p;
+
+      ret = p->entrys;
+    }
+  }
+  return ret;
+}
+
+
+void
+TSManagerReceive2 (void *handle, TSM_TIMESTAMP timestamp, int size)
+{
+#define CLEAR_TSM_RENTRY(entry)\
+  do { \
+    (entry)->used = 0; \
+    (entry)->subentry = 0; \
+    (entry)->next = NULL; \
+  } while (0)
+  TSManager *tsm = (TSManager *) handle;
+
+  TSM_VERBOSE ("receive2 %" TSM_TIME_FORMAT " size %d\n",
+      TSM_TIME_ARGS (timestamp), size);
+
+  if (tsm) {
+    if (size > 0) {
+      TSMRecivedCtl *rctl = &tsm->rctl;
+      TSMReceivedEntry *e = tsm_new_received_entry (rctl);
+      if (e) {
+        CLEAR_TSM_RENTRY (e);
+        if ((rctl->tail) && (rctl->tail->ts == timestamp)) {
+          e->subentry = 1;
+        }
+        e->ts = timestamp;
+        e->size = size;
+        if (rctl->tail) {
+          rctl->tail->next = e;
+          rctl->tail = e;
+        } else {
+          rctl->head = rctl->tail = e;
+        }
+      }
+      rctl->cnt++;
+    } else {
+      TSManagerReceive (handle, timestamp);
+    }
+  }
+}
+
+
+static TSM_TIMESTAMP
+TSManagerGetLastTimeStamp (TSMRecivedCtl * rctl, int size, int use)
+{
+  TSM_TIMESTAMP ts = TSM_TIMESTAMP_NONE;
+  TSMReceivedEntry *e;
+  while ((size > 0) && (e = rctl->head)) {
+    ts = ((e->used) ? (TSM_TIMESTAMP_NONE) : (e->ts));
+    if (use)
+      e->used = 1;
+    if (size >= e->size) {
+      rctl->head = e->next;
+      if (rctl->head == NULL) {
+        rctl->tail = NULL;
+      } else {
+        if (rctl->head->subentry) {
+          rctl->head->used = e->used;
+        }
+      }
+      size -= e->size;
+      rctl->cnt--;
+      tsm_free_received_entry (rctl, e);
+    } else {
+      e->size -= size;
+      size = 0;
+    }
+  }
+  return ts;
+}
+
+
+void
+TSManagerFlush2 (void *handle, int size)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSManagerGetLastTimeStamp (&tsm->rctl, size, 0);
+  }
+
+}
+
+
+/*======================================================================================
+FUNCTION:           mfw_gst_receive_ts
+
+DESCRIPTION:        Check timestamp and do frame dropping if enabled
+
+ARGUMENTS PASSED:   pTimeStamp_Object  - TimeStamp Manager to handle related timestamp
+                    timestamp - time stamp of the input buffer which has video data.
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+static void
+_TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp, void *key)
+{
+  TSManager *tsm = (TSManager *) handle;
+
+  if (tsm) {
+    if (TSM_TS_IS_VALID (timestamp) && (tsm->rx_cnt))
+      tsm->valid_ts_received = 1;
+    tsm->rx_cnt++;
+    if (tsm->cnt < tsm->ts_buf_size - 1) {
+      tsm->cnt++;
+      if (tsm->mode == MODE_AI) {
+
+        if (TSM_TS_IS_VALID (timestamp)) {
+          if (tsm->first_rx) {
+            tsm->last_ts_received = timestamp;
+            tsm->first_rx = 0;
+          } else {
+            if (tsm->suspicious_ts) {
+              if (timestamp >= tsm->suspicious_ts) {
+                tsm->last_ts_received = timestamp;
+              }
+              tsm->suspicious_ts = 0;
+            }
+            if ((timestamp > tsm->last_ts_received)
+                && (timestamp - tsm->last_ts_received > tsm->discont_threshold)) {
+              tsm->suspicious_ts = timestamp;
+              timestamp = TSM_TIMESTAMP_NONE;
+            }
+          }
+        }
+
+        if (TSM_TS_IS_VALID (timestamp))        // && (TSM_ABS(timestamp, tsm->last_ts_sent)<TSM_SECOND*10))
+        {
+          tsm->ts_buf[tsm->rx].ts = timestamp;
+          tsm->ts_buf[tsm->rx].age = tsm->age + TSM_PLUS_AGE (tsm);
+          tsm->ts_buf[tsm->rx].key = key;
+          tsm->last_ts_received = timestamp;
+#ifdef DEBUG
+          //printf("age should %lld %lld\n", tsm->age, tsm->ts_buf[tsm->rx].age);
+          //printf("++++++ distance = %d  tx=%d, rx=%d, invalid count=%d\n", TSM_DISTANCE(tsm), tsm->tx, tsm->rx,tsm->invalid_ts_count);
+#endif
+          tsm->rx = ((tsm->rx + 1) % tsm->ts_buf_size);
+        } else {
+          tsm->invalid_ts_count++;
+        }
+      } else if (tsm->mode == MODE_FIFO) {
+        tsm->ts_buf[tsm->rx].ts = timestamp;
+        tsm->rx = ((tsm->rx + 1) % tsm->ts_buf_size);
+      }
+      TSM_LOG ("++Receive %d:%" TSM_TIME_FORMAT
+          ", invalid:%d, size:%d key %p\n", tsm->rx_cnt,
+          TSM_TIME_ARGS (timestamp), tsm->invalid_ts_count, tsm->cnt, key);
+    } else {
+      TSM_ERROR ("Too many timestamps recieved!! (cnt=%d)\n", tsm->cnt);
+    }
+  }
+}
+
+
+void
+TSManagerValid2 (void *handle, int size, void *key)
+{
+  TSManager *tsm = (TSManager *) handle;
+
+  TSM_VERBOSE ("valid2 size %d\n", size);
+
+  if (tsm) {
+    TSM_TIMESTAMP ts;
+    ts = TSManagerGetLastTimeStamp (&tsm->rctl, size, 1);
+    _TSManagerReceive (tsm, ts, key);
+  }
+}
+
+
+void
+TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp)
+{
+  _TSManagerReceive (handle, timestamp, TSM_KEY_NONE);
+}
+
+
+/*======================================================================================
+FUNCTION:           TSManagerSend
+
+DESCRIPTION:        Check timestamp and do frame dropping if enabled
+
+ARGUMENTS PASSED:   pTimeStamp_Object  - TimeStamp Manager to handle related timestamp
+                    ptimestamp - returned timestamp to use at render
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+static TSM_TIMESTAMP
+_TSManagerSend2 (void *handle, void *key, int send)
+{
+  TSManager *tsm = (TSManager *) handle;
+  int i = tsm->tx;
+  int index = -1;
+  int isValidTs=0;
+  TSM_TIMESTAMP ts0 = 0, tstmp = TSM_TIMESTAMP_NONE;
+  unsigned long long age = 0;
+  TSM_TIMESTAMP half_interval = TSM_ADAPTIVE_INTERVAL (tsm) >> 1;
+
+  if (tsm) {
+    if (send) {
+      tsm->tx_cnt++;
+    } else {
+      tsm->cnt++;
+      tsm->invalid_ts_count++;
+    }
+    if (tsm->cnt > 0) {
+      if (send) {
+        tsm->cnt--;
+      }
+      if (tsm->mode == MODE_AI) {
+
+        if (tsm->first_tx == 0) {
+          tstmp = tsm->last_ts_sent + TSM_ADAPTIVE_INTERVAL (tsm);
+        } else {
+          tstmp = tsm->last_ts_sent;
+        }
+
+        while (i != tsm->rx) {
+          if (index >= 0) {
+            if (tsm->ts_buf[i].ts < ts0) {
+              ts0 = tsm->ts_buf[i].ts;
+              age = tsm->ts_buf[i].age;
+              index = i;
+            }
+          } else {
+            ts0 = tsm->ts_buf[i].ts;
+            age = tsm->ts_buf[i].age;
+            index = i;
+          }
+          if ((TSM_KEY_IS_VALID (key)) && (key == tsm->ts_buf[i].key))
+            break;
+          i = ((i + 1) % tsm->ts_buf_size);
+        }
+        if (index >= 0) {
+          if ((tsm->invalid_ts_count) && (ts0 >= ((tstmp) + half_interval))
+              && (age > tsm->age)) {
+            /* use calculated ts0 */
+            if (send) {
+              tsm->invalid_ts_count--;
+            }
+          } else {
+
+            if (send) {
+              if (index != tsm->tx) {
+                tsm->ts_buf[index] = tsm->ts_buf[tsm->tx];
+              }
+              tsm->tx = ((tsm->tx + 1) % tsm->ts_buf_size);
+
+            }
+#if 0
+            if (ts0 >= ((tstmp) + half_interval))
+              tstmp = tstmp;
+            else
+              tstmp = ts0;
+#else
+            tstmp = ts0;
+#endif
+            isValidTs=1;
+          }
+
+        } else {
+          if (send) {
+            tsm->invalid_ts_count--;
+          }
+        }
+
+        if (tsm->first_tx == 0) {
+
+          if (tstmp > tsm->last_ts_sent) {
+            ts0 = (tstmp - tsm->last_ts_sent);
+          } else {
+            ts0 = 0;
+            tstmp = tsm->last_ts_sent;
+          }
+
+          if (ts0 > TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2) {
+            TSM_WARNING ("Jitter1:%" TSM_TIME_FORMAT " %" TSM_TIME_FORMAT "\n",
+                TSM_TIME_ARGS (ts0),
+                TSM_TIME_ARGS (TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2));
+          } else if (ts0 == 0) {
+            TSM_WARNING ("Jitter:%" TSM_TIME_FORMAT "\n", TSM_TIME_ARGS (ts0));
+          }
+
+          if (send) {
+            if(isValidTs && ts0 > TSM_ADAPTIVE_INTERVAL (tsm) * 2)
+                ts0 = TSM_ADAPTIVE_INTERVAL (tsm) * 2;
+            //printf("tstmp: %lld, ts0 %lld, interv %lld, big_cnt %d, is Valid %d\n", tstmp, ts0, TSM_ADAPTIVE_INTERVAL (tsm),tsm->big_cnt, isValidTs);
+            if ((ts0 <= TSM_ADAPTIVE_INTERVAL (tsm) * 2) || (tsm->big_cnt > 3)) {
+              tsm->big_cnt = 0;
+              tsm->dur_history_total -=
+                  tsm->dur_history_buf[tsm->dur_history_tx];
+              tsm->dur_history_buf[tsm->dur_history_tx] = ts0;
+              tsm->dur_history_tx =
+                  ((tsm->dur_history_tx + 1) % TSM_HISTORY_SIZE);
+              tsm->dur_history_total += ts0;
+            } else {
+              tsm->big_cnt++;
+            }
+          }
+        }
+
+        if (send) {
+          tsm->last_ts_sent = tstmp;
+          tsm->age++;
+          tsm->first_tx = 0;
+        }
+
+      } else if (tsm->mode == MODE_FIFO) {
+        tstmp = tsm->ts_buf[tsm->tx].ts;
+        if (send) {
+          tsm->tx = ((tsm->tx + 1) % tsm->ts_buf_size);
+        }
+        ts0 = tstmp - tsm->last_ts_sent;
+        if (send) {
+          tsm->last_ts_sent = tstmp;
+        }
+      }
+
+      if (send) {
+        TSM_LOG ("--Send %d:%" TSM_TIME_FORMAT ", int:%" TSM_TIME_FORMAT
+            ", avg:%" TSM_TIME_FORMAT " inkey %p\n", tsm->tx_cnt,
+            TSM_TIME_ARGS (tstmp), TSM_TIME_ARGS (ts0),
+            TSM_TIME_ARGS (TSM_ADAPTIVE_INTERVAL (tsm)), key);
+      }
+
+    } else {
+      if (tsm->valid_ts_received == 0) {
+        if (tsm->first_tx) {
+          tstmp = tsm->last_ts_sent;
+        } else {
+          tstmp = tsm->last_ts_sent + TSM_ADAPTIVE_INTERVAL (tsm);
+        }
+        if (send) {
+          tsm->first_tx = 0;
+          tsm->last_ts_sent = tstmp;
+        }
+      }
+      TSM_ERROR ("Too many timestamps send!!\n");
+    }
+
+    if (send == 0) {
+      tsm->cnt--;
+      tsm->invalid_ts_count--;
+    }
+
+  }
+
+  return tstmp;
+}
+
+
+TSM_TIMESTAMP
+TSManagerSend2 (void *handle, void *key)
+{
+  return _TSManagerSend2 (handle, key, 1);
+}
+
+
+TSM_TIMESTAMP
+TSManagerQuery2 (void *handle, void *key)
+{
+  return _TSManagerSend2 (handle, key, 0);
+}
+
+
+TSM_TIMESTAMP
+TSManagerSend (void *handle)
+{
+  return TSManagerSend2 (handle, TSM_KEY_NONE);
+}
+
+
+TSM_TIMESTAMP
+TSManagerQuery (void *handle)
+{
+  return TSManagerQuery2 (handle, TSM_KEY_NONE);
+}
+
+
+void
+resyncTSManager (void *handle, TSM_TIMESTAMP synctime, TSMGR_MODE mode)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSMRecivedCtl *rctl = &tsm->rctl;
+    TSMReceivedEntry *e = rctl->head;
+
+    while ((e = rctl->head)) {
+      rctl->head = e->next;
+      tsm_free_received_entry (rctl, e);
+    };
+    rctl->cnt = 0;
+
+    rctl->tail = NULL;
+
+    tsm->first_tx = 1;
+    tsm->first_rx = 1;
+    tsm->suspicious_ts = 0;
+
+    if (TSM_TS_IS_VALID (synctime))
+      tsm->last_ts_sent = synctime;
+
+    tsm->tx = tsm->rx = 0;
+    tsm->invalid_ts_count = 0;
+    tsm->mode = mode;
+    tsm->age = 0;
+    tsm->rx_cnt = tsm->tx_cnt = tsm->cnt = 0;
+    tsm->valid_ts_received = 0;
+
+    tsm->big_cnt = 0;
+  }
+}
+
+
+/*======================================================================================
+FUNCTION:           mfw_gst_init_ts
+
+DESCRIPTION:        malloc and initialize timestamp strcture
+
+ARGUMENTS PASSED:   ppTimeStamp_Object  - pointer of TimeStamp Manager to handle related timestamp
+
+RETURN VALUE:       TimeStamp structure pointer
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+void *
+createTSManager (int ts_buf_size)
+{
+  TSManager *tsm = (TSManager *) malloc (sizeof (TSManager));
+  debug = getenv (debug_env);
+  if (debug) {
+    debug_level = atoi (debug);
+  }
+  // printf("debug = %s \n ++++++++++++++++++++++++++++",debug);
+  if (tsm) {
+    memset (tsm, 0, sizeof (TSManager));
+    if (ts_buf_size <= 0) {
+      ts_buf_size = TSM_DEFAULT_TS_BUFFER_SIZE;
+    }
+    tsm->ts_buf_size = ts_buf_size;
+    tsm->ts_buf = malloc (sizeof (TSMControl) * ts_buf_size);
+
+    if (tsm->ts_buf == NULL) {
+      goto fail;
+    }
+
+    resyncTSManager (tsm, (TSM_TIMESTAMP) 0, MODE_AI);
+
+    tsm->dur_history_tx = 0;
+    TSM_BUFFER_SET (tsm->dur_history_buf, TSM_DEFAULT_INTERVAL,
+        TSM_HISTORY_SIZE);
+    tsm->dur_history_total = TSM_DEFAULT_INTERVAL << TSM_HISTORY_POWER;
+
+    tsm->discont_threshold = 10000000000LL;     // 10s
+  }
+  return tsm;
+fail:
+  if (tsm) {
+    if (tsm->ts_buf) {
+      free (tsm->ts_buf);
+    }
+    free (tsm);
+    tsm = NULL;
+  }
+  return tsm;
+}
+
+
+void
+destroyTSManager (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSMRecivedCtl *rctl = &tsm->rctl;
+    TSMReceivedEntryMemory *rmem;
+    if (tsm->ts_buf) {
+      free (tsm->ts_buf);
+    }
+
+    while ((rmem = rctl->memory)) {
+      rctl->memory = rmem->next;
+      free (rmem);
+    }
+    free (tsm);
+    tsm = NULL;
+  }
+}
+
+
+void
+setTSManagerFrameRate (void *handle, int fps_n, int fps_d)
+//void setTSManagerFrameRate(void * handle, float framerate)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts;
+  if ((fps_n > 0) && (fps_d > 0) && (fps_n / fps_d <= 80))
+    ts = TSM_SECOND * fps_d / fps_n;
+  else
+    ts = TSM_DEFAULT_INTERVAL;
+  // TSM_TIMESTAMP ts = TSM_SECOND / framerate;
+
+  if (tsm) {
+    TSM_BUFFER_SET (tsm->dur_history_buf, ts, TSM_HISTORY_SIZE);
+    tsm->dur_history_total = (ts << TSM_HISTORY_POWER);
+    if (debug)
+      TSM_LOG ("Set frame intrval:%" TSM_TIME_FORMAT "\n", TSM_TIME_ARGS (ts));
+  }
+}
+
+
+TSM_TIMESTAMP
+getTSManagerFrameInterval (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts = 0;
+  if (tsm) {
+    ts = TSM_ADAPTIVE_INTERVAL (tsm);
+  }
+  return ts;
+}
+
+
+TSM_TIMESTAMP
+getTSManagerPosition (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts = 0;
+  if (tsm) {
+    ts = tsm->last_ts_sent;
+  }
+  return ts;
+}
+
+
+int
+getTSManagerPreBufferCnt (void *handle)
+{
+  int i = 0;
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    i = tsm->rctl.cnt;
+  }
+  return i;
+}
diff --git a/utils/mfw_gst_ts.h b/utils/mfw_gst_ts.h
new file mode 100755
index 0000000..4bd7d81
--- /dev/null
+++ b/utils/mfw_gst_ts.h
@@ -0,0 +1,157 @@
+/**
+ *  Copyright (c) 2010-2012, Freescale Semiconductor Inc.,
+ *  All Rights Reserved.
+ *
+ *  The following programs are the sole property of Freescale Semiconductor Inc.,
+ *  and contain its proprietary and confidential information.
+ *
+ */
+
+/*
+ * Module Name:    TimeStamp.h
+ *
+ * Description:    include TimeStamp stratege for VPU / SW video decoder plugin
+ *
+ * Portability:    This code is written for Linux OS and Gstreamer
+ */
+
+/*
+ * Changelog:
+  11/2/2010        draft version       Lyon Wang
+ *
+ */
+
+#ifndef _TIMESTAMP_H_
+#define _TIMESTAMP_H_
+
+
+/**
+ * GST_CLOCK_TIME_NONE:
+ *
+ * Constant to define an undefined clock time.
+ */
+
+typedef long long TSM_TIMESTAMP;
+
+typedef enum
+{
+  MODE_AI,
+  MODE_FIFO,
+} TSMGR_MODE;
+
+#define TSM_TIMESTAMP_NONE ((long long)(-1))
+#define TSM_KEY_NONE ((void *)0)
+
+/**
+ * GST_CLOCK_TIME_IS_VALID:
+ * @time: clock time to validate
+ *
+ * Tests if a given #GstClockTime represents a valid defined time.
+ */
+
+#ifdef __cplusplus
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*!
+ * This function receive timestamp into timestamp manager.
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @param	timestamp	timestamp received
+ *
+ * @return	
+ */
+  EXTERN void TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp);
+
+  EXTERN void TSManagerReceive2 (void *handle, TSM_TIMESTAMP timestamp,
+      int size);
+
+  EXTERN void TSManagerFlush2 (void *handle, int size);
+
+  EXTERN void TSManagerValid2 (void *handle, int size, void *key);
+
+/*!
+ * This function send the timestamp for next output frame.
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @return	timestamp for next output frame.
+ */
+  EXTERN TSM_TIMESTAMP TSManagerSend (void *handle);
+
+  EXTERN TSM_TIMESTAMP TSManagerSend2 (void *handle, void *key);
+
+  EXTERN TSM_TIMESTAMP TSManagerQuery2 (void *handle, void *key);
+
+  EXTERN TSM_TIMESTAMP TSManagerQuery (void *handle);
+/*!
+ * This function resync timestamp handler when reset and seek
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @param	synctime    the postion time needed to set, if value invalid, position keeps original
+ * 
+ * @param	mode		playing mode (AI or FIFO)
+ *
+ * @return	
+ */
+  EXTERN void resyncTSManager (void *handle, TSM_TIMESTAMP synctime,
+      TSMGR_MODE mode);
+/*!
+ * This function create and reset timestamp handler
+ *
+ * @param	ts_buf_size	 time stamp queue buffer size 
+ * 
+ * @return	
+ */
+  EXTERN void *createTSManager (int ts_buf_size);
+/*!
+ * This function destory timestamp handler
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN void destroyTSManager (void *handle);
+/*!
+ * This function set  history buffer frame interval by fps_n and fps_d 
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @param	framerate       the framerate to be set
+ * 
+ * @return	
+ */
+  EXTERN void setTSManagerFrameRate (void *handle, int fps_n, int fps_d);
+//EXTERN void setTSManagerFrameRate(void * handle, float framerate);
+/*!
+ * This function set the current calculated Frame Interval
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN TSM_TIMESTAMP getTSManagerFrameInterval (void *handle);
+/*!
+ * This function get  the current time stamp postion
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN TSM_TIMESTAMP getTSManagerPosition (void *handle);
+  EXTERN int getTSManagerPreBufferCnt (void *handle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_TIMESTAMP_H_ */
-- 
1.8.0

